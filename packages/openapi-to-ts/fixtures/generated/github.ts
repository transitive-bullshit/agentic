/**
 * This file was auto-generated from an OpenAPI spec.
 */

import { z } from 'zod'

export namespace github {
  export const apiBaseUrl = 'https://api.github.com'

  // -----------------------------------------------------------------------------
  // Component schemas
  // -----------------------------------------------------------------------------

  export const RootSchema = z.object({
    current_user_url: z.string(),
    current_user_authorizations_html_url: z.string(),
    authorizations_url: z.string(),
    code_search_url: z.string(),
    commit_search_url: z.string(),
    emails_url: z.string(),
    emojis_url: z.string(),
    events_url: z.string(),
    feeds_url: z.string(),
    followers_url: z.string(),
    following_url: z.string(),
    gists_url: z.string(),
    hub_url: z.string().optional(),
    issue_search_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    label_search_url: z.string(),
    notifications_url: z.string(),
    organization_url: z.string(),
    organization_repositories_url: z.string(),
    organization_teams_url: z.string(),
    public_gists_url: z.string(),
    rate_limit_url: z.string(),
    repository_url: z.string(),
    repository_search_url: z.string(),
    current_user_repositories_url: z.string(),
    starred_url: z.string(),
    starred_gists_url: z.string(),
    topic_search_url: z.string().optional(),
    user_url: z.string(),
    user_organizations_url: z.string(),
    user_repositories_url: z.string(),
    user_search_url: z.string()
  })
  export type Root = z.infer<typeof RootSchema>

  export const SecurityAdvisoryEcosystemsSchema = z
    .enum([
      'rubygems',
      'npm',
      'pip',
      'maven',
      'nuget',
      'composer',
      'go',
      'rust',
      'erlang',
      'actions',
      'pub',
      'other',
      'swift'
    ])
    .describe("The package's language or package management ecosystem.")
  export type SecurityAdvisoryEcosystems = z.infer<
    typeof SecurityAdvisoryEcosystemsSchema
  >

  export const CvssSeveritiesSchema = z.object({
    cvss_v3: z
      .object({
        vector_string: z.string().describe('The CVSS 3 vector string.'),
        score: z
          .number()
          .gte(0)
          .lte(10)
          .describe('The CVSS 3 score.')
          .readonly()
      })
      .optional(),
    cvss_v4: z
      .object({
        vector_string: z.string().describe('The CVSS 4 vector string.'),
        score: z
          .number()
          .gte(0)
          .lte(10)
          .describe('The CVSS 4 score.')
          .readonly()
      })
      .optional()
  })
  export type CvssSeverities = z.infer<typeof CvssSeveritiesSchema>

  export const SecurityAdvisoryEpssSchema = z
    .object({
      percentage: z.number().gte(0).lte(100).optional(),
      percentile: z.number().gte(0).lte(100).optional()
    })
    .describe(
      'The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).'
    )
    .readonly()
  export type SecurityAdvisoryEpss = z.infer<typeof SecurityAdvisoryEpssSchema>

  export const SimpleUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('A GitHub user.')
  export type SimpleUser = z.infer<typeof SimpleUserSchema>

  export const SecurityAdvisoryCreditTypesSchema = z
    .enum([
      'analyst',
      'finder',
      'reporter',
      'coordinator',
      'remediation_developer',
      'remediation_reviewer',
      'remediation_verifier',
      'tool',
      'sponsor',
      'other'
    ])
    .describe('The type of credit the user is receiving.')
  export type SecurityAdvisoryCreditTypes = z.infer<
    typeof SecurityAdvisoryCreditTypesSchema
  >

  export const PaginationBeforeSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PaginationBefore = z.infer<typeof PaginationBeforeSchema>

  export const PaginationAfterSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PaginationAfter = z.infer<typeof PaginationAfterSchema>

  export const DirectionSchema = z
    .any()
    .describe('The direction to sort the results by.')
  export type Direction = z.infer<typeof DirectionSchema>

  export const GhsaIdSchema = z
    .any()
    .describe('The GHSA (GitHub Security Advisory) identifier of the advisory.')
  export type GhsaId = z.infer<typeof GhsaIdSchema>

  export const EnterpriseSchema = z
    .any()
    .describe(
      'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
    )
  export type Enterprise = z.infer<typeof EnterpriseSchema>

  export const WebhookConfigUrlSchema = z
    .string()
    .url()
    .describe('The URL to which the payloads will be delivered.')
  export type WebhookConfigUrl = z.infer<typeof WebhookConfigUrlSchema>

  export const WebhookConfigContentTypeSchema = z
    .string()
    .describe(
      'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.'
    )
  export type WebhookConfigContentType = z.infer<
    typeof WebhookConfigContentTypeSchema
  >

  export const WebhookConfigSecretSchema = z
    .string()
    .describe(
      'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).'
    )
  export type WebhookConfigSecret = z.infer<typeof WebhookConfigSecretSchema>

  export const WebhookConfigInsecureSslSchema = z.union([
    z
      .string()
      .describe(
        'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**'
      ),
    z.number()
  ])
  export type WebhookConfigInsecureSsl = z.infer<
    typeof WebhookConfigInsecureSslSchema
  >

  export const HookDeliveryItemSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the webhook delivery.'),
      guid: z
        .string()
        .describe(
          'Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).'
        ),
      delivered_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery occurred.'),
      redelivery: z
        .boolean()
        .describe('Whether the webhook delivery is a redelivery.'),
      duration: z.number().describe('Time spent delivering.'),
      status: z
        .string()
        .describe(
          'Describes the response returned after attempting the delivery.'
        ),
      status_code: z
        .number()
        .int()
        .describe('Status code received when delivery was made.'),
      event: z.string().describe('The event that triggered the delivery.'),
      action: z
        .string()
        .describe(
          'The type of activity for the event that triggered the delivery.'
        ),
      installation_id: z
        .number()
        .int()
        .describe(
          'The id of the GitHub App installation associated with this event.'
        ),
      repository_id: z
        .number()
        .int()
        .describe('The id of the repository associated with this event.'),
      throttled_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery was throttled.')
        .optional()
    })
    .describe(
      'Delivery made by a webhook, without request and response information.'
    )
  export type HookDeliveryItem = z.infer<typeof HookDeliveryItemSchema>

  export const PerPageSchema = z
    .any()
    .describe(
      'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PerPage = z.infer<typeof PerPageSchema>

  export const CursorSchema = z
    .any()
    .describe(
      'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
    )
  export type Cursor = z.infer<typeof CursorSchema>

  export const HookDeliverySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the delivery.'),
      guid: z
        .string()
        .describe(
          'Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).'
        ),
      delivered_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the delivery was delivered.'),
      redelivery: z.boolean().describe('Whether the delivery is a redelivery.'),
      duration: z.number().describe('Time spent delivering.'),
      status: z
        .string()
        .describe('Description of the status of the attempted delivery'),
      status_code: z
        .number()
        .int()
        .describe('Status code received when delivery was made.'),
      event: z.string().describe('The event that triggered the delivery.'),
      action: z
        .string()
        .describe(
          'The type of activity for the event that triggered the delivery.'
        ),
      installation_id: z
        .number()
        .int()
        .describe(
          'The id of the GitHub App installation associated with this event.'
        ),
      repository_id: z
        .number()
        .int()
        .describe('The id of the repository associated with this event.'),
      throttled_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery was throttled.')
        .optional(),
      url: z.string().describe('The URL target of the delivery.').optional(),
      request: z.object({
        headers: z
          .record(z.any())
          .describe('The request headers sent with the webhook delivery.'),
        payload: z.record(z.any()).describe('The webhook payload.')
      }),
      response: z.object({
        headers: z
          .record(z.any())
          .describe(
            'The response headers received when the delivery was made.'
          ),
        payload: z.string().describe('The response payload received.')
      })
    })
    .describe('Delivery made by a webhook.')
  export type HookDelivery = z.infer<typeof HookDeliverySchema>

  export const DeliveryIdSchema = z.any()
  export type DeliveryId = z.infer<typeof DeliveryIdSchema>

  export const PageSchema = z
    .object({
      url: z
        .string()
        .url()
        .describe('The API address for accessing this Page resource.'),
      status: z
        .enum(['built', 'building', 'errored'])
        .describe('The status of the most recent build of the Page.'),
      cname: z.string().describe("The Pages site's custom domain"),
      protected_domain_state: z
        .enum(['pending', 'verified', 'unverified'])
        .describe('The state if the domain is verified')
        .optional(),
      pending_domain_unverified_at: z
        .string()
        .datetime({ offset: true })
        .describe('The timestamp when a pending domain becomes unverified.')
        .optional(),
      custom_404: z
        .boolean()
        .describe('Whether the Page has a custom 404 page.')
        .default(false),
      html_url: z
        .string()
        .url()
        .describe('The web address the Page can be accessed from.')
        .optional(),
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe('The process in which the Page will be built.')
        .optional(),
      source: PagesSourceHashSchema.optional(),
      public: z
        .boolean()
        .describe(
          'Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.'
        ),
      https_certificate: PagesHttpsCertificateSchema.optional(),
      https_enforced: z
        .boolean()
        .describe('Whether https is enabled on the domain')
        .optional()
    })
    .describe('The configuration for GitHub Pages for a repository.')
  export type Page = z.infer<typeof PageSchema>

  export const AppPermissionsSchema = z
    .object({
      actions: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.'
        )
        .optional(),
      administration: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.'
        )
        .optional(),
      checks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for checks on code.'
        )
        .optional(),
      codespaces: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to create, edit, delete, and list Codespaces.'
        )
        .optional(),
      contents: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.'
        )
        .optional(),
      dependabot_secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage Dependabot secrets.'
        )
        .optional(),
      deployments: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for deployments and deployment statuses.'
        )
        .optional(),
      environments: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for managing repository environments.'
        )
        .optional(),
      issues: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.'
        )
        .optional(),
      metadata: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.'
        )
        .optional(),
      packages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for packages published to GitHub Packages.'
        )
        .optional(),
      pages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.'
        )
        .optional(),
      pull_requests: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.'
        )
        .optional(),
      repository_custom_properties: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and edit custom properties for a repository, when allowed by the property.'
        )
        .optional(),
      repository_hooks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the post-receive hooks for a repository.'
        )
        .optional(),
      repository_projects: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token to manage repository projects, columns, and cards.'
        )
        .optional(),
      secret_scanning_alerts: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage secret scanning alerts.'
        )
        .optional(),
      secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage repository secrets.'
        )
        .optional(),
      security_events: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage security events like code scanning alerts.'
        )
        .optional(),
      single_file: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage just a single file.'
        )
        .optional(),
      statuses: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for commit statuses.'
        )
        .optional(),
      vulnerability_alerts: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage Dependabot alerts.'
        )
        .optional(),
      workflows: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token to update GitHub Actions workflow files.'
        )
        .optional(),
      members: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for organization teams and members.'
        )
        .optional(),
      organization_administration: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage access to an organization.'
        )
        .optional(),
      organization_custom_roles: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for custom repository roles management.'
        )
        .optional(),
      organization_custom_org_roles: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for custom organization roles management.'
        )
        .optional(),
      organization_custom_properties: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token for custom property management.'
        )
        .optional(),
      organization_copilot_seat_management: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token for managing access to GitHub Copilot for members of an organization with a Copilot Business subscription. This property is in public preview and is subject to change.'
        )
        .optional(),
      organization_announcement_banners: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage announcement banners for an organization.'
        )
        .optional(),
      organization_events: z
        .literal('read')
        .describe(
          'The level of permission to grant the access token to view events triggered by an activity in an organization.'
        )
        .optional(),
      organization_hooks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the post-receive hooks for an organization.'
        )
        .optional(),
      organization_personal_access_tokens: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for viewing and managing fine-grained personal access token requests to an organization.'
        )
        .optional(),
      organization_personal_access_token_requests: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for viewing and managing fine-grained personal access tokens that have been approved by an organization.'
        )
        .optional(),
      organization_plan: z
        .literal('read')
        .describe(
          "The level of permission to grant the access token for viewing an organization's plan."
        )
        .optional(),
      organization_projects: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token to manage organization projects and projects public preview (where available).'
        )
        .optional(),
      organization_packages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for organization packages published to GitHub Packages.'
        )
        .optional(),
      organization_secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage organization secrets.'
        )
        .optional(),
      organization_self_hosted_runners: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.'
        )
        .optional(),
      organization_user_blocking: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage users blocked by the organization.'
        )
        .optional(),
      team_discussions: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage team discussions and related comments.'
        )
        .optional(),
      email_addresses: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the email addresses belonging to a user.'
        )
        .optional(),
      followers: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the followers belonging to a user.'
        )
        .optional(),
      git_ssh_keys: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage git SSH keys.'
        )
        .optional(),
      gpg_keys: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage GPG keys belonging to a user.'
        )
        .optional(),
      interaction_limits: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage interaction limits on a repository.'
        )
        .optional(),
      profile: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token to manage the profile settings belonging to a user.'
        )
        .optional(),
      starring: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to list and manage repositories a user is starring.'
        )
        .optional()
    })
    .describe('The permissions granted to the user access token.')
  export type AppPermissions = z.infer<typeof AppPermissionsSchema>

  export const NullableSimpleUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('A GitHub user.')
  export type NullableSimpleUser = z.infer<typeof NullableSimpleUserSchema>

  export const SinceSchema = z
    .any()
    .describe(
      'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type Since = z.infer<typeof SinceSchema>

  export const InstallationIdSchema = z
    .any()
    .describe('The unique identifier of the installation.')
  export type InstallationId = z.infer<typeof InstallationIdSchema>

  export const NullableLicenseSimpleSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      spdx_id: z.string(),
      node_id: z.string(),
      html_url: z.string().url().optional()
    })
    .describe('License Simple')
  export type NullableLicenseSimple = z.infer<
    typeof NullableLicenseSimpleSchema
  >

  export const ClientIdSchema = z
    .any()
    .describe('The client ID of the GitHub app.')
  export type ClientId = z.infer<typeof ClientIdSchema>

  export const AppSlugSchema = z.any()
  export type AppSlug = z.infer<typeof AppSlugSchema>

  export const SimpleClassroomRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique name of the repository.'),
      html_url: z
        .string()
        .url()
        .describe('The URL to view the repository on GitHub.com.'),
      node_id: z.string().describe('The GraphQL identifier of the repository.'),
      private: z.boolean().describe('Whether the repository is private.'),
      default_branch: z
        .string()
        .describe('The default branch for the repository.')
    })
    .describe('A GitHub repository view for Classroom')
  export type SimpleClassroomRepository = z.infer<
    typeof SimpleClassroomRepositorySchema
  >

  export const SimpleClassroomOrganizationSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      node_id: z.string(),
      html_url: z.string().url(),
      name: z.string(),
      avatar_url: z.string()
    })
    .describe('A GitHub organization.')
  export type SimpleClassroomOrganization = z.infer<
    typeof SimpleClassroomOrganizationSchema
  >

  export const AssignmentIdSchema = z
    .any()
    .describe('The unique identifier of the classroom assignment.')
  export type AssignmentId = z.infer<typeof AssignmentIdSchema>

  export const SimpleClassroomUserSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      avatar_url: z.string().url(),
      html_url: z.string().url()
    })
    .describe('A GitHub user simplified for Classroom.')
  export type SimpleClassroomUser = z.infer<typeof SimpleClassroomUserSchema>

  export const SimpleClassroomSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the classroom.'),
      name: z.string().describe('The name of the classroom.'),
      archived: z
        .boolean()
        .describe('Returns whether classroom is archived or not.'),
      url: z.string().describe('The url of the classroom on GitHub Classroom.')
    })
    .describe('A GitHub Classroom classroom')
  export type SimpleClassroom = z.infer<typeof SimpleClassroomSchema>

  export const ClassroomAssignmentGradeSchema = z
    .object({
      assignment_name: z.string().describe('Name of the assignment'),
      assignment_url: z.string().describe('URL of the assignment'),
      starter_code_url: z
        .string()
        .describe('URL of the starter code for the assignment'),
      github_username: z.string().describe('GitHub username of the student'),
      roster_identifier: z
        .string()
        .describe('Roster identifier of the student'),
      student_repository_name: z
        .string()
        .describe("Name of the student's assignment repository"),
      student_repository_url: z
        .string()
        .describe("URL of the student's assignment repository"),
      submission_timestamp: z
        .string()
        .describe("Timestamp of the student's assignment submission"),
      points_awarded: z
        .number()
        .int()
        .describe('Number of points awarded to the student'),
      points_available: z
        .number()
        .int()
        .describe('Number of points available for the assignment'),
      group_name: z
        .string()
        .describe('If a group assignment, name of the group the student is in')
        .optional()
    })
    .describe('Grade for a student or groups GitHub Classroom assignment')
  export type ClassroomAssignmentGrade = z.infer<
    typeof ClassroomAssignmentGradeSchema
  >

  export const ClassroomIdSchema = z
    .any()
    .describe('The unique identifier of the classroom.')
  export type ClassroomId = z.infer<typeof ClassroomIdSchema>

  export const CodeOfConductSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      body: z.string().optional(),
      html_url: z.string().url()
    })
    .describe('Code Of Conduct')
  export type CodeOfConduct = z.infer<typeof CodeOfConductSchema>

  export const CodeSecurityConfigurationSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The ID of the code security configuration')
        .optional(),
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique within the organization.'
        )
        .optional(),
      target_type: z
        .enum(['global', 'organization', 'enterprise'])
        .describe('The type of the code security configuration.')
        .optional(),
      description: z
        .string()
        .describe('A description of the code security configuration')
        .optional(),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe('The enablement status of GitHub Advanced Security')
        .optional(),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .optional(),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .optional(),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .optional()
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .optional(),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .optional(),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .optional(),
      code_scanning_default_setup_options: z
        .object({
          runner_type: z
            .enum(['standard', 'labeled', 'not_set'])
            .describe(
              'Whether to use labeled runners or standard GitHub runners.'
            )
            .optional(),
          runner_label: z
            .string()
            .describe(
              "The label of the runner to use for code scanning when runner_type is 'labeled'."
            )
            .optional()
        })
        .describe('Feature options for code scanning default setup')
        .optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .optional(),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .optional(),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .optional(),
      secret_scanning_delegated_bypass: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning delegated bypass')
        .optional(),
      secret_scanning_delegated_bypass_options: z
        .object({
          reviewers: z
            .array(
              z.object({
                reviewer_id: z
                  .number()
                  .int()
                  .describe(
                    'The ID of the team or role selected as a bypass reviewer'
                  ),
                reviewer_type: z
                  .enum(['TEAM', 'ROLE'])
                  .describe('The type of the bypass reviewer')
              })
            )
            .describe(
              'The bypass reviewers for secret scanning delegated bypass'
            )
            .optional()
        })
        .describe('Feature options for secret scanning delegated bypass')
        .optional(),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .optional(),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non-provider patterns'
        )
        .optional(),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .optional(),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .optional(),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .optional(),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .optional(),
      url: z.string().url().describe('The URL of the configuration').optional(),
      html_url: z
        .string()
        .url()
        .describe('The URL of the configuration')
        .optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A code security configuration')
  export type CodeSecurityConfiguration = z.infer<
    typeof CodeSecurityConfigurationSchema
  >

  export const CodeScanningDefaultSetupOptionsSchema = z
    .object({
      runner_type: z
        .enum(['standard', 'labeled', 'not_set'])
        .describe('Whether to use labeled runners or standard GitHub runners.')
        .optional(),
      runner_label: z
        .string()
        .describe(
          "The label of the runner to use for code scanning default setup when runner_type is 'labeled'."
        )
        .optional()
    })
    .describe('Feature options for code scanning default setup')
  export type CodeScanningDefaultSetupOptions = z.infer<
    typeof CodeScanningDefaultSetupOptionsSchema
  >

  export const ConfigurationIdSchema = z
    .any()
    .describe('The unique identifier of the code security configuration.')
  export type ConfigurationId = z.infer<typeof ConfigurationIdSchema>

  export const AlertNumberSchema = z
    .any()
    .describe(
      'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
    )
  export type AlertNumber = z.infer<typeof AlertNumberSchema>

  export const DependabotAlertPackageSchema = z
    .object({
      ecosystem: z
        .string()
        .describe("The package's language or package management ecosystem.")
        .readonly(),
      name: z
        .string()
        .describe('The unique package name within its ecosystem.')
        .readonly()
    })
    .strict()
    .describe('Details for the vulnerable package.')
    .readonly()
  export type DependabotAlertPackage = z.infer<
    typeof DependabotAlertPackageSchema
  >

  export const AlertUrlSchema = z
    .string()
    .url()
    .describe('The REST API URL of the alert resource.')
    .readonly()
  export type AlertUrl = z.infer<typeof AlertUrlSchema>

  export const AlertHtmlUrlSchema = z
    .string()
    .url()
    .describe('The GitHub URL of the alert resource.')
    .readonly()
  export type AlertHtmlUrl = z.infer<typeof AlertHtmlUrlSchema>

  export const AlertCreatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertCreatedAt = z.infer<typeof AlertCreatedAtSchema>

  export const AlertUpdatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertUpdatedAt = z.infer<typeof AlertUpdatedAtSchema>

  export const AlertDismissedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertDismissedAt = z.infer<typeof AlertDismissedAtSchema>

  export const AlertFixedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertFixedAt = z.infer<typeof AlertFixedAtSchema>

  export const AlertAutoDismissedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertAutoDismissedAt = z.infer<typeof AlertAutoDismissedAtSchema>

  export const DependabotAlertCommaSeparatedStatesSchema = z
    .any()
    .describe(
      'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
    )
  export type DependabotAlertCommaSeparatedStates = z.infer<
    typeof DependabotAlertCommaSeparatedStatesSchema
  >

  export const DependabotAlertCommaSeparatedSeveritiesSchema = z
    .any()
    .describe(
      'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
    )
  export type DependabotAlertCommaSeparatedSeverities = z.infer<
    typeof DependabotAlertCommaSeparatedSeveritiesSchema
  >

  export const DependabotAlertCommaSeparatedEcosystemsSchema = z
    .any()
    .describe(
      'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
    )
  export type DependabotAlertCommaSeparatedEcosystems = z.infer<
    typeof DependabotAlertCommaSeparatedEcosystemsSchema
  >

  export const DependabotAlertCommaSeparatedPackagesSchema = z
    .any()
    .describe(
      'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
    )
  export type DependabotAlertCommaSeparatedPackages = z.infer<
    typeof DependabotAlertCommaSeparatedPackagesSchema
  >

  export const DependabotAlertCommaSeparatedEpssSchema = z
    .any()
    .describe(
      'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
    )
  export type DependabotAlertCommaSeparatedEpss = z.infer<
    typeof DependabotAlertCommaSeparatedEpssSchema
  >

  export const DependabotAlertScopeSchema = z
    .any()
    .describe(
      'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
    )
  export type DependabotAlertScope = z.infer<typeof DependabotAlertScopeSchema>

  export const DependabotAlertSortSchema = z
    .any()
    .describe(
      "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
    )
  export type DependabotAlertSort = z.infer<typeof DependabotAlertSortSchema>

  export const PaginationFirstSchema = z
    .any()
    .describe(
      '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
    )
  export type PaginationFirst = z.infer<typeof PaginationFirstSchema>

  export const PaginationLastSchema = z
    .any()
    .describe(
      '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
    )
  export type PaginationLast = z.infer<typeof PaginationLastSchema>

  export const NullableAlertUpdatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type NullableAlertUpdatedAt = z.infer<
    typeof NullableAlertUpdatedAtSchema
  >

  export const SecretScanningAlertStateSchema = z
    .any()
    .describe(
      'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
    )
  export type SecretScanningAlertState = z.infer<
    typeof SecretScanningAlertStateSchema
  >

  export const SecretScanningAlertResolutionSchema = z
    .any()
    .describe(
      'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
    )
  export type SecretScanningAlertResolution = z.infer<
    typeof SecretScanningAlertResolutionSchema
  >

  export const SecretScanningAlertSecretTypeSchema = z
    .any()
    .describe(
      'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
    )
  export type SecretScanningAlertSecretType = z.infer<
    typeof SecretScanningAlertSecretTypeSchema
  >

  export const SecretScanningAlertSortSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
    )
  export type SecretScanningAlertSort = z.infer<
    typeof SecretScanningAlertSortSchema
  >

  export const SecretScanningAlertValiditySchema = z
    .any()
    .describe(
      'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
    )
  export type SecretScanningAlertValidity = z.infer<
    typeof SecretScanningAlertValiditySchema
  >

  export const SecretScanningAlertPubliclyLeakedSchema = z
    .any()
    .describe(
      'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
    )
  export type SecretScanningAlertPubliclyLeaked = z.infer<
    typeof SecretScanningAlertPubliclyLeakedSchema
  >

  export const SecretScanningAlertMultiRepoSchema = z
    .any()
    .describe(
      'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
    )
  export type SecretScanningAlertMultiRepo = z.infer<
    typeof SecretScanningAlertMultiRepoSchema
  >

  export const ActorSchema = z
    .any()
    .describe(
      "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
    )
  export type Actor = z.infer<typeof ActorSchema>

  export const IssueTypeSchema = z
    .object({
      id: z.number().int().describe('The unique identifier of the issue type.'),
      node_id: z.string().describe('The node identifier of the issue type.'),
      name: z.string().describe('The name of the issue type.'),
      description: z.string().describe('The description of the issue type.'),
      color: z
        .enum([
          'gray',
          'blue',
          'green',
          'yellow',
          'orange',
          'red',
          'pink',
          'purple'
        ])
        .describe('The color of the issue type.')
        .optional(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time the issue type created.')
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time the issue type last updated.')
        .optional(),
      is_enabled: z
        .boolean()
        .describe('The enabled state of the issue type.')
        .optional()
    })
    .describe('The type of issue.')
  export type IssueType = z.infer<typeof IssueTypeSchema>

  export const AuthorAssociationSchema = z
    .enum([
      'COLLABORATOR',
      'CONTRIBUTOR',
      'FIRST_TIMER',
      'FIRST_TIME_CONTRIBUTOR',
      'MANNEQUIN',
      'MEMBER',
      'NONE',
      'OWNER'
    ])
    .describe('How the author is associated with the repository.')
  export type AuthorAssociation = z.infer<typeof AuthorAssociationSchema>

  export const ReactionRollupSchema = z.object({
    url: z.string().url(),
    total_count: z.number().int(),
    '+1': z.number().int(),
    '-1': z.number().int(),
    laugh: z.number().int(),
    confused: z.number().int(),
    heart: z.number().int(),
    hooray: z.number().int(),
    eyes: z.number().int(),
    rocket: z.number().int()
  })
  export type ReactionRollup = z.infer<typeof ReactionRollupSchema>

  export const SubIssuesSummarySchema = z.object({
    total: z.number().int(),
    completed: z.number().int(),
    percent_completed: z.number().int()
  })
  export type SubIssuesSummary = z.infer<typeof SubIssuesSummarySchema>

  export const LinkWithTypeSchema = z
    .object({ href: z.string(), type: z.string() })
    .describe('Hypermedia Link with Type')
  export type LinkWithType = z.infer<typeof LinkWithTypeSchema>

  export const PublicUserSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      user_view_type: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      name: z.string(),
      company: z.string(),
      blog: z.string(),
      location: z.string(),
      email: z.string().email(),
      notification_email: z.string().email().optional(),
      hireable: z.boolean(),
      bio: z.string(),
      twitter_username: z.string().optional(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      plan: z
        .object({
          collaborators: z.number().int(),
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int()
        })
        .optional(),
      private_gists: z.number().int().optional(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z.number().int().optional()
    })
    .strict()
    .describe('Public User')
  export type PublicUser = z.infer<typeof PublicUserSchema>

  export const GistIdSchema = z
    .any()
    .describe('The unique identifier of the gist.')
  export type GistId = z.infer<typeof GistIdSchema>

  export const CommentIdSchema = z
    .any()
    .describe('The unique identifier of the comment.')
  export type CommentId = z.infer<typeof CommentIdSchema>

  export const GitignoreTemplateSchema = z
    .object({ name: z.string(), source: z.string() })
    .describe('Gitignore Template')
  export type GitignoreTemplate = z.infer<typeof GitignoreTemplateSchema>

  export const LabelsSchema = z
    .any()
    .describe('A list of comma separated label names. Example: `bug,ui,@high`')
  export type Labels = z.infer<typeof LabelsSchema>

  export const LicenseSimpleSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      spdx_id: z.string(),
      node_id: z.string(),
      html_url: z.string().url().optional()
    })
    .describe('License Simple')
  export type LicenseSimple = z.infer<typeof LicenseSimpleSchema>

  export const LicenseSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      spdx_id: z.string(),
      url: z.string().url(),
      node_id: z.string(),
      html_url: z.string().url(),
      description: z.string(),
      implementation: z.string(),
      permissions: z.array(z.string()),
      conditions: z.array(z.string()),
      limitations: z.array(z.string()),
      body: z.string(),
      featured: z.boolean()
    })
    .describe('License')
  export type License = z.infer<typeof LicenseSchema>

  export const MarketplaceListingPlanSchema = z
    .object({
      url: z.string().url(),
      accounts_url: z.string().url(),
      id: z.number().int(),
      number: z.number().int(),
      name: z.string(),
      description: z.string(),
      monthly_price_in_cents: z.number().int(),
      yearly_price_in_cents: z.number().int(),
      price_model: z.enum(['FREE', 'FLAT_RATE', 'PER_UNIT']),
      has_free_trial: z.boolean(),
      unit_name: z.string(),
      state: z.string(),
      bullets: z.array(z.string())
    })
    .describe('Marketplace Listing Plan')
  export type MarketplaceListingPlan = z.infer<
    typeof MarketplaceListingPlanSchema
  >

  export const AccountIdSchema = z.any().describe('account_id parameter')
  export type AccountId = z.infer<typeof AccountIdSchema>

  export const PlanIdSchema = z
    .any()
    .describe('The unique identifier of the plan.')
  export type PlanId = z.infer<typeof PlanIdSchema>

  export const SortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type Sort = z.infer<typeof SortSchema>

  export const ApiOverviewSchema = z
    .object({
      verifiable_password_authentication: z.boolean(),
      ssh_key_fingerprints: z
        .object({
          SHA256_RSA: z.string().optional(),
          SHA256_DSA: z.string().optional(),
          SHA256_ECDSA: z.string().optional(),
          SHA256_ED25519: z.string().optional()
        })
        .optional(),
      ssh_keys: z.array(z.string()).optional(),
      hooks: z.array(z.string()).optional(),
      github_enterprise_importer: z.array(z.string()).optional(),
      web: z.array(z.string()).optional(),
      api: z.array(z.string()).optional(),
      git: z.array(z.string()).optional(),
      packages: z.array(z.string()).optional(),
      pages: z.array(z.string()).optional(),
      importer: z.array(z.string()).optional(),
      actions: z.array(z.string()).optional(),
      actions_macos: z.array(z.string()).optional(),
      codespaces: z.array(z.string()).optional(),
      dependabot: z.array(z.string()).optional(),
      copilot: z.array(z.string()).optional(),
      domains: z
        .object({
          website: z.array(z.string()).optional(),
          codespaces: z.array(z.string()).optional(),
          copilot: z.array(z.string()).optional(),
          packages: z.array(z.string()).optional(),
          actions: z.array(z.string()).optional(),
          actions_inbound: z
            .object({
              full_domains: z.array(z.string()).optional(),
              wildcard_domains: z.array(z.string()).optional()
            })
            .optional(),
          artifact_attestations: z
            .object({
              trust_domain: z.string().optional(),
              services: z.array(z.string()).optional()
            })
            .optional()
        })
        .optional()
    })
    .describe('Api Overview')
  export type ApiOverview = z.infer<typeof ApiOverviewSchema>

  export const OwnerSchema = z
    .any()
    .describe(
      'The account owner of the repository. The name is not case sensitive.'
    )
  export type Owner = z.infer<typeof OwnerSchema>

  export const RepoSchema = z
    .any()
    .describe(
      'The name of the repository without the `.git` extension. The name is not case sensitive.'
    )
  export type Repo = z.infer<typeof RepoSchema>

  export const SecurityAndAnalysisSchema = z.object({
    advanced_security: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    dependabot_security_updates: z
      .object({
        status: z
          .enum(['enabled', 'disabled'])
          .describe(
            'The enablement status of Dependabot security updates for the repository.'
          )
          .optional()
      })
      .describe(
        'Enable or disable Dependabot security updates for the repository.'
      )
      .optional(),
    secret_scanning: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_push_protection: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_non_provider_patterns: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_ai_detection: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional()
  })
  export type SecurityAndAnalysis = z.infer<typeof SecurityAndAnalysisSchema>

  export const AllSchema = z
    .any()
    .describe('If `true`, show notifications marked as read.')
  export type All = z.infer<typeof AllSchema>

  export const ParticipatingSchema = z
    .any()
    .describe(
      'If `true`, only shows notifications in which the user is directly participating or mentioned.'
    )
  export type Participating = z.infer<typeof ParticipatingSchema>

  export const BeforeSchema = z
    .any()
    .describe(
      'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type Before = z.infer<typeof BeforeSchema>

  export const ThreadIdSchema = z
    .any()
    .describe(
      'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
    )
  export type ThreadId = z.infer<typeof ThreadIdSchema>

  export const ThreadSubscriptionSchema = z
    .object({
      subscribed: z.boolean(),
      ignored: z.boolean(),
      reason: z.string(),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      thread_url: z.string().url().optional(),
      repository_url: z.string().url().optional()
    })
    .describe('Thread Subscription')
  export type ThreadSubscription = z.infer<typeof ThreadSubscriptionSchema>

  export const OrganizationSimpleSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string()
    })
    .describe('A GitHub organization.')
  export type OrganizationSimple = z.infer<typeof OrganizationSimpleSchema>

  export const SinceOrgSchema = z
    .any()
    .describe(
      'An organization ID. Only return organizations with an ID greater than this ID.'
    )
  export type SinceOrg = z.infer<typeof SinceOrgSchema>

  export const BillingUsageReportSchema = z.object({
    usageItems: z
      .array(
        z.object({
          date: z.string().describe('Date of the usage line item.'),
          product: z.string().describe('Product name.'),
          sku: z.string().describe('SKU name.'),
          quantity: z
            .number()
            .int()
            .describe('Quantity of the usage line item.'),
          unitType: z.string().describe('Unit type of the usage line item.'),
          pricePerUnit: z
            .number()
            .describe('Price per unit of the usage line item.'),
          grossAmount: z
            .number()
            .describe('Gross amount of the usage line item.'),
          discountAmount: z
            .number()
            .describe('Discount amount of the usage line item.'),
          netAmount: z.number().describe('Net amount of the usage line item.'),
          organizationName: z.string().describe('Name of the organization.'),
          repositoryName: z
            .string()
            .describe('Name of the repository.')
            .optional()
        })
      )
      .optional()
  })
  export type BillingUsageReport = z.infer<typeof BillingUsageReportSchema>

  export const OrgSchema = z
    .any()
    .describe('The organization name. The name is not case sensitive.')
  export type Org = z.infer<typeof OrgSchema>

  export const BillingUsageReportYearSchema = z
    .any()
    .describe(
      'If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.'
    )
  export type BillingUsageReportYear = z.infer<
    typeof BillingUsageReportYearSchema
  >

  export const BillingUsageReportMonthSchema = z
    .any()
    .describe(
      'If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.'
    )
  export type BillingUsageReportMonth = z.infer<
    typeof BillingUsageReportMonthSchema
  >

  export const BillingUsageReportDaySchema = z
    .any()
    .describe(
      'If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.'
    )
  export type BillingUsageReportDay = z.infer<
    typeof BillingUsageReportDaySchema
  >

  export const BillingUsageReportHourSchema = z
    .any()
    .describe(
      'If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.'
    )
  export type BillingUsageReportHour = z.infer<
    typeof BillingUsageReportHourSchema
  >

  export const OrganizationFullSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string(),
      name: z.string().optional(),
      company: z.string().optional(),
      blog: z.string().url().optional(),
      location: z.string().optional(),
      email: z.string().email().optional(),
      twitter_username: z.string().optional(),
      is_verified: z.boolean().optional(),
      has_organization_projects: z.boolean(),
      has_repository_projects: z.boolean(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      html_url: z.string().url(),
      type: z.string(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      private_gists: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z
        .number()
        .int()
        .describe(
          'The number of collaborators on private repositories.\n\nThis field may be null if the number of private repositories is over 50,000.'
        )
        .optional(),
      billing_email: z.string().email().optional(),
      plan: z
        .object({
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int(),
          filled_seats: z.number().int().optional(),
          seats: z.number().int().optional()
        })
        .optional(),
      default_repository_permission: z.string().optional(),
      members_can_create_repositories: z.boolean().optional(),
      two_factor_requirement_enabled: z.boolean().optional(),
      members_allowed_repository_creation_type: z.string().optional(),
      members_can_create_public_repositories: z.boolean().optional(),
      members_can_create_private_repositories: z.boolean().optional(),
      members_can_create_internal_repositories: z.boolean().optional(),
      members_can_create_pages: z.boolean().optional(),
      members_can_create_public_pages: z.boolean().optional(),
      members_can_create_private_pages: z.boolean().optional(),
      members_can_fork_private_repositories: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      advanced_security_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependabot_alerts_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependabot_security_updates_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependency_graph_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_push_protection_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_push_protection_custom_link_enabled: z
        .boolean()
        .describe(
          'Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.'
        )
        .optional(),
      secret_scanning_push_protection_custom_link: z
        .string()
        .describe(
          'An optional URL string to display to contributors who are blocked from pushing a secret.'
        )
        .optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      archived_at: z.string().datetime({ offset: true }),
      deploy_keys_enabled_for_repositories: z
        .boolean()
        .describe(
          'Controls whether or not deploy keys may be added and used for repositories in the organization.'
        )
        .optional()
    })
    .describe('Organization Full')
  export type OrganizationFull = z.infer<typeof OrganizationFullSchema>

  export const ActionsCacheUsageOrgEnterpriseSchema = z.object({
    total_active_caches_count: z
      .number()
      .int()
      .describe(
        'The count of active caches across all repositories of an enterprise or an organization.'
      ),
    total_active_caches_size_in_bytes: z
      .number()
      .int()
      .describe(
        'The total size in bytes of all active cache items across all repositories of an enterprise or an organization.'
      )
  })
  export type ActionsCacheUsageOrgEnterprise = z.infer<
    typeof ActionsCacheUsageOrgEnterpriseSchema
  >

  export const ActionsCacheUsageByRepositorySchema = z
    .object({
      full_name: z
        .string()
        .describe(
          'The repository owner and name for the cache usage being shown.'
        ),
      active_caches_size_in_bytes: z
        .number()
        .int()
        .describe(
          'The sum of the size in bytes of all the active cache items in the repository.'
        ),
      active_caches_count: z
        .number()
        .int()
        .describe('The number of active caches in the repository.')
    })
    .describe('GitHub Actions Cache Usage by repository.')
  export type ActionsCacheUsageByRepository = z.infer<
    typeof ActionsCacheUsageByRepositorySchema
  >

  export const NullableActionsHostedRunnerPoolImageSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.'
        ),
      size_gb: z.number().int().describe('Image size in GB.'),
      display_name: z.string().describe('Display name for this image.'),
      source: z
        .enum(['github', 'partner', 'custom'])
        .describe('The image provider.')
    })
    .describe('Provides details of a hosted runner image')
  export type NullableActionsHostedRunnerPoolImage = z.infer<
    typeof NullableActionsHostedRunnerPoolImageSchema
  >

  export const ActionsHostedRunnerMachineSpecSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID used for the `size` parameter when creating a new runner.'
        ),
      cpu_cores: z.number().int().describe('The number of cores.'),
      memory_gb: z
        .number()
        .int()
        .describe('The available RAM for the machine spec.'),
      storage_gb: z
        .number()
        .int()
        .describe('The available SSD storage for the machine spec.')
    })
    .describe('Provides details of a particular machine spec.')
  export type ActionsHostedRunnerMachineSpec = z.infer<
    typeof ActionsHostedRunnerMachineSpecSchema
  >

  export const PublicIpSchema = z
    .object({
      enabled: z.boolean().describe('Whether public IP is enabled.').optional(),
      prefix: z.string().describe('The prefix for the public IP.').optional(),
      length: z
        .number()
        .int()
        .describe('The length of the IP prefix.')
        .optional()
    })
    .describe(
      'Provides details of Public IP for a GitHub-hosted larger runners'
    )
  export type PublicIp = z.infer<typeof PublicIpSchema>

  export const ActionsHostedRunnerImageSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.'
        ),
      platform: z.string().describe('The operating system of the image.'),
      size_gb: z.number().int().describe('Image size in GB.'),
      display_name: z.string().describe('Display name for this image.'),
      source: z
        .enum(['github', 'partner', 'custom'])
        .describe('The image provider.')
    })
    .describe('Provides details of a hosted runner image')
  export type ActionsHostedRunnerImage = z.infer<
    typeof ActionsHostedRunnerImageSchema
  >

  export const ActionsHostedRunnerLimitsSchema = z.object({
    public_ips: z
      .object({
        maximum: z
          .number()
          .int()
          .describe(
            'The maximum number of static public IP addresses that can be used for Hosted Runners.'
          ),
        current_usage: z
          .number()
          .int()
          .describe(
            'The current number of static public IP addresses in use by Hosted Runners.'
          )
      })
      .describe(
        'Provides details of static public IP limits for GitHub-hosted Hosted Runners'
      )
  })
  export type ActionsHostedRunnerLimits = z.infer<
    typeof ActionsHostedRunnerLimitsSchema
  >

  export const HostedRunnerIdSchema = z
    .any()
    .describe('Unique identifier of the GitHub-hosted runner.')
  export type HostedRunnerId = z.infer<typeof HostedRunnerIdSchema>

  export const OidcCustomSubSchema = z
    .object({
      include_claim_keys: z
        .array(z.string())
        .describe(
          'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
        )
    })
    .describe('Actions OIDC Subject customization')
  export type OidcCustomSub = z.infer<typeof OidcCustomSubSchema>

  export const EmptyObjectSchema = z
    .object({})
    .strict()
    .describe('An object without any properties.')
  export type EmptyObject = z.infer<typeof EmptyObjectSchema>

  export const EnabledRepositoriesSchema = z
    .enum(['all', 'none', 'selected'])
    .describe(
      'The policy that controls the repositories in the organization that are allowed to run GitHub Actions.'
    )
  export type EnabledRepositories = z.infer<typeof EnabledRepositoriesSchema>

  export const AllowedActionsSchema = z
    .enum(['all', 'local_only', 'selected'])
    .describe(
      'The permissions policy that controls the actions and reusable workflows that are allowed to run.'
    )
  export type AllowedActions = z.infer<typeof AllowedActionsSchema>

  export const SelectedActionsUrlSchema = z
    .string()
    .describe(
      'The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.'
    )
  export type SelectedActionsUrl = z.infer<typeof SelectedActionsUrlSchema>

  export const RepositoryIdSchema = z
    .any()
    .describe('The unique identifier of the repository.')
  export type RepositoryId = z.infer<typeof RepositoryIdSchema>

  export const SelectedActionsSchema = z.object({
    github_owned_allowed: z
      .boolean()
      .describe(
        'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
      )
      .optional(),
    verified_allowed: z
      .boolean()
      .describe(
        'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
      )
      .optional(),
    patterns_allowed: z
      .array(z.string())
      .describe(
        'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\n\n> [!NOTE]\n> The `patterns_allowed` setting only applies to public repositories.'
      )
      .optional()
  })
  export type SelectedActions = z.infer<typeof SelectedActionsSchema>

  export const ActionsDefaultWorkflowPermissionsSchema = z
    .enum(['read', 'write'])
    .describe(
      'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.'
    )
  export type ActionsDefaultWorkflowPermissions = z.infer<
    typeof ActionsDefaultWorkflowPermissionsSchema
  >

  export const ActionsCanApprovePullRequestReviewsSchema = z
    .boolean()
    .describe(
      'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.'
    )
  export type ActionsCanApprovePullRequestReviews = z.infer<
    typeof ActionsCanApprovePullRequestReviewsSchema
  >

  export const RunnerGroupsOrgSchema = z.object({
    id: z.number(),
    name: z.string(),
    visibility: z.string(),
    default: z.boolean(),
    selected_repositories_url: z
      .string()
      .describe(
        'Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`'
      )
      .optional(),
    runners_url: z.string(),
    hosted_runners_url: z.string().optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    inherited: z.boolean(),
    inherited_allows_public_repositories: z.boolean().optional(),
    allows_public_repositories: z.boolean(),
    workflow_restrictions_read_only: z
      .boolean()
      .describe(
        'If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional()
  })
  export type RunnerGroupsOrg = z.infer<typeof RunnerGroupsOrgSchema>

  export const VisibleToRepositorySchema = z
    .any()
    .describe(
      'Only return runner groups that are allowed to be used by this repository.'
    )
  export type VisibleToRepository = z.infer<typeof VisibleToRepositorySchema>

  export const RunnerGroupIdSchema = z
    .any()
    .describe('Unique identifier of the self-hosted runner group.')
  export type RunnerGroupId = z.infer<typeof RunnerGroupIdSchema>

  export const RunnerLabelSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the label.')
        .optional(),
      name: z.string().describe('Name of the label.'),
      type: z
        .enum(['read-only', 'custom'])
        .describe(
          'The type of label. Read-only labels are applied automatically when the runner is configured.'
        )
        .optional()
    })
    .describe('A label for a self hosted runner')
  export type RunnerLabel = z.infer<typeof RunnerLabelSchema>

  export const RunnerIdSchema = z
    .any()
    .describe('Unique identifier of the self-hosted runner.')
  export type RunnerId = z.infer<typeof RunnerIdSchema>

  export const RunnerApplicationSchema = z
    .object({
      os: z.string(),
      architecture: z.string(),
      download_url: z.string(),
      filename: z.string(),
      temp_download_token: z
        .string()
        .describe(
          'A short lived bearer token used to download the runner, if needed.'
        )
        .optional(),
      sha256_checksum: z.string().optional()
    })
    .describe('Runner Application')
  export type RunnerApplication = z.infer<typeof RunnerApplicationSchema>

  export const RunnerLabelNameSchema = z
    .any()
    .describe("The name of a self-hosted runner's custom label.")
  export type RunnerLabelName = z.infer<typeof RunnerLabelNameSchema>

  export const OrganizationActionsSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a secret'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Secrets for GitHub Actions for an organization.')
  export type OrganizationActionsSecret = z.infer<
    typeof OrganizationActionsSecretSchema
  >

  export const ActionsPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.'),
      id: z.number().int().optional(),
      url: z.string().optional(),
      title: z.string().optional(),
      created_at: z.string().optional()
    })
    .describe('The public key used for setting Actions Secrets.')
  export type ActionsPublicKey = z.infer<typeof ActionsPublicKeySchema>

  export const SecretNameSchema = z.any().describe('The name of the secret.')
  export type SecretName = z.infer<typeof SecretNameSchema>

  export const OrganizationActionsVariableSchema = z
    .object({
      name: z.string().describe('The name of the variable.'),
      value: z.string().describe('The value of the variable.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a variable'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Organization variable for GitHub Actions.')
  export type OrganizationActionsVariable = z.infer<
    typeof OrganizationActionsVariableSchema
  >

  export const VariablesPerPageSchema = z
    .any()
    .describe(
      'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type VariablesPerPage = z.infer<typeof VariablesPerPageSchema>

  export const VariableNameSchema = z
    .any()
    .describe('The name of the variable.')
  export type VariableName = z.infer<typeof VariableNameSchema>

  export const UsernameSchema = z
    .any()
    .describe('The handle for the GitHub user account.')
  export type Username = z.infer<typeof UsernameSchema>

  export const AlertInstancesUrlSchema = z
    .string()
    .url()
    .describe(
      'The REST API URL for fetching the list of instances for an alert.'
    )
    .readonly()
  export type AlertInstancesUrl = z.infer<typeof AlertInstancesUrlSchema>

  export const CodeScanningAlertStateSchema = z
    .enum(['open', 'dismissed', 'fixed'])
    .describe('State of a code scanning alert.')
  export type CodeScanningAlertState = z.infer<
    typeof CodeScanningAlertStateSchema
  >

  export const CodeScanningAlertDismissedReasonSchema = z
    .enum(['false positive', "won't fix", 'used in tests'])
    .describe(
      '**Required when the state is dismissed.** The reason for dismissing or closing the alert.'
    )
  export type CodeScanningAlertDismissedReason = z.infer<
    typeof CodeScanningAlertDismissedReasonSchema
  >

  export const CodeScanningAlertDismissedCommentSchema = z
    .string()
    .max(280)
    .describe(
      'The dismissal comment associated with the dismissal of the alert.'
    )
  export type CodeScanningAlertDismissedComment = z.infer<
    typeof CodeScanningAlertDismissedCommentSchema
  >

  export const CodeScanningAlertRuleSummarySchema = z.object({
    id: z
      .string()
      .describe('A unique identifier for the rule used to detect the alert.')
      .optional(),
    name: z
      .string()
      .describe('The name of the rule used to detect the alert.')
      .optional(),
    severity: z
      .enum(['none', 'note', 'warning', 'error'])
      .describe('The severity of the alert.')
      .optional(),
    security_severity_level: z
      .enum(['low', 'medium', 'high', 'critical'])
      .describe('The security severity of the alert.')
      .optional(),
    description: z
      .string()
      .describe('A short description of the rule used to detect the alert.')
      .optional(),
    full_description: z
      .string()
      .describe('A description of the rule used to detect the alert.')
      .optional(),
    tags: z
      .array(z.string())
      .describe('A set of tags applicable for the rule.')
      .optional(),
    help: z
      .string()
      .describe(
        'Detailed documentation for the rule as GitHub Flavored Markdown.'
      )
      .optional(),
    help_uri: z
      .string()
      .describe(
        'A link to the documentation for the rule used to detect the alert.'
      )
      .optional()
  })
  export type CodeScanningAlertRuleSummary = z.infer<
    typeof CodeScanningAlertRuleSummarySchema
  >

  export const CodeScanningAnalysisToolNameSchema = z
    .string()
    .describe(
      'The name of the tool used to generate the code scanning analysis.'
    )
  export type CodeScanningAnalysisToolName = z.infer<
    typeof CodeScanningAnalysisToolNameSchema
  >

  export const CodeScanningAnalysisToolVersionSchema = z
    .string()
    .describe(
      'The version of the tool used to generate the code scanning analysis.'
    )
  export type CodeScanningAnalysisToolVersion = z.infer<
    typeof CodeScanningAnalysisToolVersionSchema
  >

  export const CodeScanningAnalysisToolGuidSchema = z
    .string()
    .describe(
      'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.'
    )
  export type CodeScanningAnalysisToolGuid = z.infer<
    typeof CodeScanningAnalysisToolGuidSchema
  >

  export const CodeScanningRefSchema = z
    .string()
    .describe(
      'The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.'
    )
  export type CodeScanningRef = z.infer<typeof CodeScanningRefSchema>

  export const CodeScanningAnalysisAnalysisKeySchema = z
    .string()
    .describe(
      'Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.'
    )
  export type CodeScanningAnalysisAnalysisKey = z.infer<
    typeof CodeScanningAnalysisAnalysisKeySchema
  >

  export const CodeScanningAlertEnvironmentSchema = z
    .string()
    .describe(
      'Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.'
    )
  export type CodeScanningAlertEnvironment = z.infer<
    typeof CodeScanningAlertEnvironmentSchema
  >

  export const CodeScanningAnalysisCategorySchema = z
    .string()
    .describe(
      'Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.'
    )
  export type CodeScanningAnalysisCategory = z.infer<
    typeof CodeScanningAnalysisCategorySchema
  >

  export const CodeScanningAlertLocationSchema = z
    .object({
      path: z.string().optional(),
      start_line: z.number().int().optional(),
      end_line: z.number().int().optional(),
      start_column: z.number().int().optional(),
      end_column: z.number().int().optional()
    })
    .describe('Describe a region within a file for the alert.')
  export type CodeScanningAlertLocation = z.infer<
    typeof CodeScanningAlertLocationSchema
  >

  export const CodeScanningAlertClassificationSchema = z
    .enum(['source', 'generated', 'test', 'library'])
    .describe(
      'A classification of the file. For example to identify it as generated.'
    )
  export type CodeScanningAlertClassification = z.infer<
    typeof CodeScanningAlertClassificationSchema
  >

  export const NullableCodespaceMachineSchema = z
    .object({
      name: z.string().describe('The name of the machine.'),
      display_name: z
        .string()
        .describe(
          'The display name of the machine includes cores, memory, and storage.'
        ),
      operating_system: z
        .string()
        .describe('The operating system of the machine.'),
      storage_in_bytes: z
        .number()
        .int()
        .describe('How much storage is available to the codespace.'),
      memory_in_bytes: z
        .number()
        .int()
        .describe('How much memory is available to the codespace.'),
      cpus: z
        .number()
        .int()
        .describe('How many cores are available to the codespace.'),
      prebuild_availability: z
        .enum(['none', 'ready', 'in_progress'])
        .describe(
          'Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.'
        )
    })
    .describe('A description of the machine powering a codespace.')
  export type NullableCodespaceMachine = z.infer<
    typeof NullableCodespaceMachineSchema
  >

  export const CodespacesOrgSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'The type of repositories in the organization that the secret is visible to'
        ),
      selected_repositories_url: z
        .string()
        .url()
        .describe(
          'The API URL at which the list of repositories this secret is visible to can be retrieved'
        )
        .optional()
    })
    .describe('Secrets for a GitHub Codespace.')
  export type CodespacesOrgSecret = z.infer<typeof CodespacesOrgSecretSchema>

  export const CodespacesPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.'),
      id: z.number().int().optional(),
      url: z.string().optional(),
      title: z.string().optional(),
      created_at: z.string().optional()
    })
    .describe('The public key used for setting Codespaces secrets.')
  export type CodespacesPublicKey = z.infer<typeof CodespacesPublicKeySchema>

  export const CopilotOrganizationSeatBreakdownSchema = z
    .object({
      total: z
        .number()
        .int()
        .describe(
          'The total number of seats being billed for the organization as of the current billing cycle.'
        )
        .optional(),
      added_this_cycle: z
        .number()
        .int()
        .describe('Seats added during the current billing cycle.')
        .optional(),
      pending_cancellation: z
        .number()
        .int()
        .describe(
          'The number of seats that are pending cancellation at the end of the current billing cycle.'
        )
        .optional(),
      pending_invitation: z
        .number()
        .int()
        .describe(
          'The number of users who have been invited to receive a Copilot seat through this organization.'
        )
        .optional(),
      active_this_cycle: z
        .number()
        .int()
        .describe(
          'The number of seats that have used Copilot during the current billing cycle.'
        )
        .optional(),
      inactive_this_cycle: z
        .number()
        .int()
        .describe(
          'The number of seats that have not used Copilot during the current billing cycle.'
        )
        .optional()
    })
    .describe('The breakdown of Copilot Business seats for the organization.')
  export type CopilotOrganizationSeatBreakdown = z.infer<
    typeof CopilotOrganizationSeatBreakdownSchema
  >

  export const NullableOrganizationSimpleSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string()
    })
    .describe('A GitHub organization.')
  export type NullableOrganizationSimple = z.infer<
    typeof NullableOrganizationSimpleSchema
  >

  export const NullableTeamSimpleSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      members_url: z.string(),
      name: z.string().describe('Name of the team'),
      description: z.string().describe('Description of the team'),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      privacy: z
        .string()
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .string()
        .describe('The notification setting the team has set')
        .optional(),
      html_url: z.string().url(),
      repositories_url: z.string().url(),
      slug: z.string(),
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type NullableTeamSimple = z.infer<typeof NullableTeamSimpleSchema>

  export const EnterpriseTeamSchema = z
    .object({
      id: z.number().int(),
      name: z.string(),
      slug: z.string(),
      url: z.string().url(),
      sync_to_organizations: z.string(),
      group_id: z.string().optional(),
      group_name: z.string().optional(),
      html_url: z.string().url(),
      members_url: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Group of enterprise owners and/or members')
  export type EnterpriseTeam = z.infer<typeof EnterpriseTeamSchema>

  export const CopilotIdeCodeCompletionsSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'Number of users who accepted at least one Copilot code suggestion, across all active editors. Includes both full and partial acceptances.'
        )
        .optional(),
      languages: z
        .array(
          z
            .object({
              name: z
                .string()
                .describe(
                  'Name of the language used for Copilot code completion suggestions.'
                )
                .optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'Number of users who accepted at least one Copilot code completion suggestion for the given language. Includes both full and partial acceptances.'
                )
                .optional()
            })
            .describe(
              'Usage metrics for a given language for the given editor for Copilot code completions.'
            )
        )
        .describe('Code completion metrics for active languages.')
        .optional(),
      editors: z
        .array(
          z
            .object({
              name: z.string().describe('Name of the given editor.').optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'Number of users who accepted at least one Copilot code completion suggestion for the given editor. Includes both full and partial acceptances.'
                )
                .optional(),
              models: z
                .array(
                  z.object({
                    name: z
                      .string()
                      .describe(
                        "Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'."
                      )
                      .optional(),
                    is_custom_model: z
                      .boolean()
                      .describe(
                        'Indicates whether a model is custom or default.'
                      )
                      .optional(),
                    custom_model_training_date: z
                      .string()
                      .describe('The training date for the custom model.')
                      .optional(),
                    total_engaged_users: z
                      .number()
                      .int()
                      .describe(
                        'Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language and model. Includes both full and partial acceptances.'
                      )
                      .optional(),
                    languages: z
                      .array(
                        z
                          .object({
                            name: z
                              .string()
                              .describe(
                                'Name of the language used for Copilot code completion suggestions, for the given editor.'
                              )
                              .optional(),
                            total_engaged_users: z
                              .number()
                              .int()
                              .describe(
                                'Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language. Includes both full and partial acceptances.'
                              )
                              .optional(),
                            total_code_suggestions: z
                              .number()
                              .int()
                              .describe(
                                'The number of Copilot code suggestions generated for the given editor, for the given language.'
                              )
                              .optional(),
                            total_code_acceptances: z
                              .number()
                              .int()
                              .describe(
                                'The number of Copilot code suggestions accepted for the given editor, for the given language. Includes both full and partial acceptances.'
                              )
                              .optional(),
                            total_code_lines_suggested: z
                              .number()
                              .int()
                              .describe(
                                'The number of lines of code suggested by Copilot code completions for the given editor, for the given language.'
                              )
                              .optional(),
                            total_code_lines_accepted: z
                              .number()
                              .int()
                              .describe(
                                'The number of lines of code accepted from Copilot code suggestions for the given editor, for the given language.'
                              )
                              .optional()
                          })
                          .describe(
                            'Usage metrics for a given language for the given editor for Copilot code completions.'
                          )
                      )
                      .describe(
                        'Code completion metrics for active languages, for the given editor.'
                      )
                      .optional()
                  })
                )
                .describe(
                  'List of model metrics for custom models and the default model.'
                )
                .optional()
            })
            .catchall(z.any())
            .describe('Copilot code completion metrics for active editors.')
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot editor code completions in the IDE.')
  export type CopilotIdeCodeCompletions = z.infer<
    typeof CopilotIdeCodeCompletionsSchema
  >

  export const CopilotIdeChatSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe('Total number of users who prompted Copilot Chat in the IDE.')
        .optional(),
      editors: z
        .array(
          z
            .object({
              name: z.string().describe('Name of the given editor.').optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'The number of users who prompted Copilot Chat in the specified editor.'
                )
                .optional(),
              models: z
                .array(
                  z.object({
                    name: z
                      .string()
                      .describe(
                        "Name of the model used for Copilot Chat. If the default model is used will appear as 'default'."
                      )
                      .optional(),
                    is_custom_model: z
                      .boolean()
                      .describe(
                        'Indicates whether a model is custom or default.'
                      )
                      .optional(),
                    custom_model_training_date: z
                      .string()
                      .describe('The training date for the custom model.')
                      .optional(),
                    total_engaged_users: z
                      .number()
                      .int()
                      .describe(
                        'The number of users who prompted Copilot Chat in the given editor and model.'
                      )
                      .optional(),
                    total_chats: z
                      .number()
                      .int()
                      .describe(
                        'The total number of chats initiated by users in the given editor and model.'
                      )
                      .optional(),
                    total_chat_insertion_events: z
                      .number()
                      .int()
                      .describe(
                        "The number of times users accepted a code suggestion from Copilot Chat using the 'Insert Code' UI element, for the given editor."
                      )
                      .optional(),
                    total_chat_copy_events: z
                      .number()
                      .int()
                      .describe(
                        "The number of times users copied a code suggestion from Copilot Chat using the keyboard, or the 'Copy' UI element, for the given editor."
                      )
                      .optional()
                  })
                )
                .describe(
                  'List of model metrics for custom models and the default model.'
                )
                .optional()
            })
            .describe('Copilot Chat metrics, for active editors.')
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot Chat in the IDE.')
  export type CopilotIdeChat = z.infer<typeof CopilotIdeChatSchema>

  export const CopilotDotcomChatSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'Total number of users who prompted Copilot Chat on github.com at least once.'
        )
        .optional(),
      models: z
        .array(
          z.object({
            name: z
              .string()
              .describe(
                "Name of the model used for Copilot Chat. If the default model is used will appear as 'default'."
              )
              .optional(),
            is_custom_model: z
              .boolean()
              .describe('Indicates whether a model is custom or default.')
              .optional(),
            custom_model_training_date: z
              .string()
              .describe(
                'The training date for the custom model (if applicable).'
              )
              .optional(),
            total_engaged_users: z
              .number()
              .int()
              .describe(
                'Total number of users who prompted Copilot Chat on github.com at least once for each model.'
              )
              .optional(),
            total_chats: z
              .number()
              .int()
              .describe(
                'Total number of chats initiated by users on github.com.'
              )
              .optional()
          })
        )
        .describe(
          'List of model metrics for a custom models and the default model.'
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot Chat in GitHub.com')
  export type CopilotDotcomChat = z.infer<typeof CopilotDotcomChatSchema>

  export const CopilotDotcomPullRequestsSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'The number of users who used Copilot for Pull Requests on github.com to generate a pull request summary at least once.'
        )
        .optional(),
      repositories: z
        .array(
          z.object({
            name: z.string().describe('Repository name').optional(),
            total_engaged_users: z
              .number()
              .int()
              .describe(
                'The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository.'
              )
              .optional(),
            models: z
              .array(
                z.object({
                  name: z
                    .string()
                    .describe(
                      "Name of the model used for Copilot pull request summaries. If the default model is used will appear as 'default'."
                    )
                    .optional(),
                  is_custom_model: z
                    .boolean()
                    .describe('Indicates whether a model is custom or default.')
                    .optional(),
                  custom_model_training_date: z
                    .string()
                    .describe('The training date for the custom model.')
                    .optional(),
                  total_pr_summaries_created: z
                    .number()
                    .int()
                    .describe(
                      'The number of pull request summaries generated using Copilot for Pull Requests in the given repository.'
                    )
                    .optional(),
                  total_engaged_users: z
                    .number()
                    .int()
                    .describe(
                      'The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository and model.'
                    )
                    .optional()
                })
              )
              .describe(
                'List of model metrics for custom models and the default model.'
              )
              .optional()
          })
        )
        .describe(
          'Repositories in which users used Copilot for Pull Requests to generate pull request summaries'
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot for pull requests.')
  export type CopilotDotcomPullRequests = z.infer<
    typeof CopilotDotcomPullRequestsSchema
  >

  export const CopilotUsageMetricsSchema = z
    .object({
      day: z
        .string()
        .date()
        .describe(
          'The date for which the usage metrics are reported, in `YYYY-MM-DD` format.'
        ),
      total_suggestions_count: z
        .number()
        .int()
        .describe(
          'The total number of Copilot code completion suggestions shown to users.'
        )
        .optional(),
      total_acceptances_count: z
        .number()
        .int()
        .describe(
          'The total number of Copilot code completion suggestions accepted by users.'
        )
        .optional(),
      total_lines_suggested: z
        .number()
        .int()
        .describe(
          'The total number of lines of code completions suggested by Copilot.'
        )
        .optional(),
      total_lines_accepted: z
        .number()
        .int()
        .describe(
          'The total number of lines of code completions accepted by users.'
        )
        .optional(),
      total_active_users: z
        .number()
        .int()
        .describe(
          'The total number of users who were shown Copilot code completion suggestions during the day specified.'
        )
        .optional(),
      total_chat_acceptances: z
        .number()
        .int()
        .describe(
          'The total instances of users who accepted code suggested by Copilot Chat in the IDE (panel and inline).'
        )
        .optional(),
      total_chat_turns: z
        .number()
        .int()
        .describe(
          'The total number of chat turns (prompt and response pairs) sent between users and Copilot Chat in the IDE.'
        )
        .optional(),
      total_active_chat_users: z
        .number()
        .int()
        .describe(
          'The total number of users who interacted with Copilot Chat in the IDE during the day specified.'
        )
        .optional(),
      breakdown: z
        .array(
          z
            .object({
              language: z
                .string()
                .describe(
                  'The language in which Copilot suggestions were shown to users in the specified editor.'
                )
                .optional(),
              editor: z
                .string()
                .describe(
                  'The editor in which Copilot suggestions were shown to users for the specified language.'
                )
                .optional(),
              suggestions_count: z
                .number()
                .int()
                .describe(
                  'The number of Copilot suggestions shown to users in the editor specified during the day specified.'
                )
                .optional(),
              acceptances_count: z
                .number()
                .int()
                .describe(
                  'The number of Copilot suggestions accepted by users in the editor specified during the day specified.'
                )
                .optional(),
              lines_suggested: z
                .number()
                .int()
                .describe(
                  'The number of lines of code suggested by Copilot in the editor specified during the day specified.'
                )
                .optional(),
              lines_accepted: z
                .number()
                .int()
                .describe(
                  'The number of lines of code accepted by users in the editor specified during the day specified.'
                )
                .optional(),
              active_users: z
                .number()
                .int()
                .describe(
                  'The number of users who were shown Copilot completion suggestions in the editor specified during the day specified.'
                )
                .optional()
            })
            .catchall(z.any())
            .describe('Breakdown of Copilot usage by editor for this language')
        )
        .describe(
          'Breakdown of Copilot code completions usage by language and editor'
        )
    })
    .strict()
    .describe('Summary of Copilot usage.')
  export type CopilotUsageMetrics = z.infer<typeof CopilotUsageMetricsSchema>

  export const OrganizationDependabotSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a secret'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Secrets for GitHub Dependabot for an organization.')
  export type OrganizationDependabotSecret = z.infer<
    typeof OrganizationDependabotSecretSchema
  >

  export const DependabotPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.')
    })
    .describe('The public key used for setting Dependabot Secrets.')
  export type DependabotPublicKey = z.infer<typeof DependabotPublicKeySchema>

  export const OrgHookSchema = z
    .object({
      id: z.number().int(),
      url: z.string().url(),
      ping_url: z.string().url(),
      deliveries_url: z.string().url().optional(),
      name: z.string(),
      events: z.array(z.string()),
      active: z.boolean(),
      config: z.object({
        url: z.string().optional(),
        insecure_ssl: z.string().optional(),
        content_type: z.string().optional(),
        secret: z.string().optional()
      }),
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      type: z.string()
    })
    .describe('Org Hook')
  export type OrgHook = z.infer<typeof OrgHookSchema>

  export const HookIdSchema = z
    .any()
    .describe(
      'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
    )
  export type HookId = z.infer<typeof HookIdSchema>

  export const ApiInsightsRouteStatsSchema = z
    .array(
      z.object({
        http_method: z.string().describe('The HTTP method').optional(),
        api_route: z
          .string()
          .describe("The API path's route template")
          .optional(),
        total_request_count: z
          .number()
          .int()
          .describe(
            'The total number of requests within the queried time period'
          )
          .optional(),
        rate_limited_request_count: z
          .number()
          .int()
          .describe(
            'The total number of requests that were rate limited within the queried time period'
          )
          .optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage route stats for an actor')
  export type ApiInsightsRouteStats = z.infer<
    typeof ApiInsightsRouteStatsSchema
  >

  export const ApiInsightsActorTypeSchema = z
    .any()
    .describe('The type of the actor')
  export type ApiInsightsActorType = z.infer<typeof ApiInsightsActorTypeSchema>

  export const ApiInsightsActorIdSchema = z
    .any()
    .describe('The ID of the actor')
  export type ApiInsightsActorId = z.infer<typeof ApiInsightsActorIdSchema>

  export const ApiInsightsMinTimestampSchema = z
    .any()
    .describe(
      'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type ApiInsightsMinTimestamp = z.infer<
    typeof ApiInsightsMinTimestampSchema
  >

  export const ApiInsightsMaxTimestampSchema = z
    .any()
    .describe(
      'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type ApiInsightsMaxTimestamp = z.infer<
    typeof ApiInsightsMaxTimestampSchema
  >

  export const ApiInsightsRouteStatsSortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type ApiInsightsRouteStatsSort = z.infer<
    typeof ApiInsightsRouteStatsSortSchema
  >

  export const ApiInsightsApiRouteSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsApiRouteSubstring = z.infer<
    typeof ApiInsightsApiRouteSubstringSchema
  >

  export const ApiInsightsSubjectStatsSchema = z
    .array(
      z.object({
        subject_type: z.string().optional(),
        subject_name: z.string().optional(),
        subject_id: z.number().int().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage subject stats for an organization')
  export type ApiInsightsSubjectStats = z.infer<
    typeof ApiInsightsSubjectStatsSchema
  >

  export const ApiInsightsSortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type ApiInsightsSort = z.infer<typeof ApiInsightsSortSchema>

  export const ApiInsightsSubjectNameSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsSubjectNameSubstring = z.infer<
    typeof ApiInsightsSubjectNameSubstringSchema
  >

  export const ApiInsightsSummaryStatsSchema = z
    .object({
      total_request_count: z
        .number()
        .int()
        .describe('The total number of requests within the queried time period')
        .optional(),
      rate_limited_request_count: z
        .number()
        .int()
        .describe(
          'The total number of requests that were rate limited within the queried time period'
        )
        .optional()
    })
    .describe('API Insights usage summary stats for an organization')
  export type ApiInsightsSummaryStats = z.infer<
    typeof ApiInsightsSummaryStatsSchema
  >

  export const ApiInsightsUserIdSchema = z
    .any()
    .describe('The ID of the user to query for stats')
  export type ApiInsightsUserId = z.infer<typeof ApiInsightsUserIdSchema>

  export const ApiInsightsTimeStatsSchema = z
    .array(
      z.object({
        timestamp: z.string().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional()
      })
    )
    .describe('API Insights usage time stats for an organization')
  export type ApiInsightsTimeStats = z.infer<typeof ApiInsightsTimeStatsSchema>

  export const ApiInsightsTimestampIncrementSchema = z
    .any()
    .describe(
      'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
    )
  export type ApiInsightsTimestampIncrement = z.infer<
    typeof ApiInsightsTimestampIncrementSchema
  >

  export const ApiInsightsUserStatsSchema = z
    .array(
      z.object({
        actor_type: z.string().optional(),
        actor_name: z.string().optional(),
        actor_id: z.number().int().optional(),
        integration_id: z.number().int().optional(),
        oauth_application_id: z.number().int().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage stats for a user')
  export type ApiInsightsUserStats = z.infer<typeof ApiInsightsUserStatsSchema>

  export const ApiInsightsActorNameSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsActorNameSubstring = z.infer<
    typeof ApiInsightsActorNameSubstringSchema
  >

  export const InteractionGroupSchema = z
    .enum(['existing_users', 'contributors_only', 'collaborators_only'])
    .describe(
      'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.'
    )
  export type InteractionGroup = z.infer<typeof InteractionGroupSchema>

  export const InteractionExpirySchema = z
    .enum(['one_day', 'three_days', 'one_week', 'one_month', 'six_months'])
    .describe(
      'The duration of the interaction restriction. Default: `one_day`.'
    )
  export type InteractionExpiry = z.infer<typeof InteractionExpirySchema>

  export const InvitationIdSchema = z
    .any()
    .describe('The unique identifier of the invitation.')
  export type InvitationId = z.infer<typeof InvitationIdSchema>

  export const OrganizationCreateIssueTypeSchema = z.object({
    name: z.string().describe('Name of the issue type.'),
    is_enabled: z
      .boolean()
      .describe(
        'Whether or not the issue type is enabled at the organization level.'
      ),
    is_private: z
      .boolean()
      .describe(
        'Whether or not the issue type is restricted to issues in private repositories.'
      )
      .optional(),
    description: z
      .string()
      .describe('Description of the issue type.')
      .optional(),
    color: z
      .enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
      ])
      .describe('Color for the issue type.')
      .optional()
  })
  export type OrganizationCreateIssueType = z.infer<
    typeof OrganizationCreateIssueTypeSchema
  >

  export const OrganizationUpdateIssueTypeSchema = z.object({
    name: z.string().describe('Name of the issue type.'),
    is_enabled: z
      .boolean()
      .describe(
        'Whether or not the issue type is enabled at the organization level.'
      ),
    is_private: z
      .boolean()
      .describe(
        'Whether or not the issue type is restricted to issues in private repositories.'
      )
      .optional(),
    description: z
      .string()
      .describe('Description of the issue type.')
      .optional(),
    color: z
      .enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
      ])
      .describe('Color for the issue type.')
      .optional()
  })
  export type OrganizationUpdateIssueType = z.infer<
    typeof OrganizationUpdateIssueTypeSchema
  >

  export const IssueTypeIdSchema = z
    .any()
    .describe('The unique identifier of the issue type.')
  export type IssueTypeId = z.infer<typeof IssueTypeIdSchema>

  export const CodespaceNameSchema = z
    .any()
    .describe('The name of the codespace.')
  export type CodespaceName = z.infer<typeof CodespaceNameSchema>

  export const MigrationIdSchema = z
    .any()
    .describe('The unique identifier of the migration.')
  export type MigrationId = z.infer<typeof MigrationIdSchema>

  export const RepoNameSchema = z.any().describe('repo_name parameter')
  export type RepoName = z.infer<typeof RepoNameSchema>

  export const TeamSlugSchema = z.any().describe('The slug of the team name.')
  export type TeamSlug = z.infer<typeof TeamSlugSchema>

  export const RoleIdSchema = z
    .any()
    .describe('The unique identifier of the role.')
  export type RoleId = z.infer<typeof RoleIdSchema>

  export const TeamSimpleSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      members_url: z.string(),
      name: z.string().describe('Name of the team'),
      description: z.string().describe('Description of the team'),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      privacy: z
        .string()
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .string()
        .describe('The notification setting the team has set')
        .optional(),
      html_url: z.string().url(),
      repositories_url: z.string().url(),
      slug: z.string(),
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type TeamSimple = z.infer<typeof TeamSimpleSchema>

  export const PackageVisibilitySchema = z
    .any()
    .describe(
      'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
    )
  export type PackageVisibility = z.infer<typeof PackageVisibilitySchema>

  export const PackageTypeSchema = z
    .any()
    .describe(
      "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
    )
  export type PackageType = z.infer<typeof PackageTypeSchema>

  export const PackageNameSchema = z.any().describe('The name of the package.')
  export type PackageName = z.infer<typeof PackageNameSchema>

  export const PackageVersionSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.'),
      name: z.string().describe('The name of the package version.'),
      url: z.string(),
      package_html_url: z.string(),
      html_url: z.string().optional(),
      license: z.string().optional(),
      description: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      deleted_at: z.string().datetime({ offset: true }).optional(),
      metadata: z
        .object({
          package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
          ]),
          container: z.object({ tags: z.array(z.string()) }).optional(),
          docker: z.object({ tag: z.array(z.string()).optional() }).optional()
        })
        .optional()
    })
    .describe('A version of a software package')
  export type PackageVersion = z.infer<typeof PackageVersionSchema>

  export const PackageVersionIdSchema = z
    .any()
    .describe('Unique identifier of the package version.')
  export type PackageVersionId = z.infer<typeof PackageVersionIdSchema>

  export const PersonalAccessTokenSortSchema = z
    .any()
    .describe('The property by which to sort the results.')
  export type PersonalAccessTokenSort = z.infer<
    typeof PersonalAccessTokenSortSchema
  >

  export const PersonalAccessTokenOwnerSchema = z
    .any()
    .describe('A list of owner usernames to use to filter the results.')
  export type PersonalAccessTokenOwner = z.infer<
    typeof PersonalAccessTokenOwnerSchema
  >

  export const PersonalAccessTokenRepositorySchema = z
    .any()
    .describe('The name of the repository to use to filter the results.')
  export type PersonalAccessTokenRepository = z.infer<
    typeof PersonalAccessTokenRepositorySchema
  >

  export const PersonalAccessTokenPermissionSchema = z
    .any()
    .describe('The permission to use to filter the results.')
  export type PersonalAccessTokenPermission = z.infer<
    typeof PersonalAccessTokenPermissionSchema
  >

  export const PersonalAccessTokenBeforeSchema = z
    .any()
    .describe(
      'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type PersonalAccessTokenBefore = z.infer<
    typeof PersonalAccessTokenBeforeSchema
  >

  export const PersonalAccessTokenAfterSchema = z
    .any()
    .describe(
      'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type PersonalAccessTokenAfter = z.infer<
    typeof PersonalAccessTokenAfterSchema
  >

  export const PersonalAccessTokenTokenIdSchema = z
    .any()
    .describe('The ID of the token')
  export type PersonalAccessTokenTokenId = z.infer<
    typeof PersonalAccessTokenTokenIdSchema
  >

  export const FineGrainedPersonalAccessTokenIdSchema = z
    .any()
    .describe(
      'The unique identifier of the fine-grained personal access token.'
    )
  export type FineGrainedPersonalAccessTokenId = z.infer<
    typeof FineGrainedPersonalAccessTokenIdSchema
  >

  export const OrgPrivateRegistryConfigurationSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the private registry configuration.'),
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry.'
        )
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry.'
        ),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Private registry configuration for an organization')
  export type OrgPrivateRegistryConfiguration = z.infer<
    typeof OrgPrivateRegistryConfigurationSchema
  >

  export const OrgPrivateRegistryConfigurationWithSelectedRepositoriesSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the private registry configuration.'),
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry.'
        )
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        ),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry when `visibility` is set to `selected`.'
        )
        .optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Private registry configuration for an organization')
  export type OrgPrivateRegistryConfigurationWithSelectedRepositories = z.infer<
    typeof OrgPrivateRegistryConfigurationWithSelectedRepositoriesSchema
  >

  export const CustomPropertySchema = z
    .object({
      property_name: z.string().describe('The name of the property'),
      url: z
        .string()
        .url()
        .describe(
          'The URL that can be used to fetch, update, or delete info about this property via the API.'
        )
        .optional(),
      source_type: z
        .enum(['organization', 'enterprise'])
        .describe('The source type of the property')
        .optional(),
      value_type: z
        .enum(['string', 'single_select', 'multi_select', 'true_false'])
        .describe('The type of the value for the property'),
      required: z
        .boolean()
        .describe('Whether the property is required.')
        .optional(),
      default_value: z
        .union([z.string(), z.array(z.string())])
        .describe('Default value of the property')
        .optional(),
      description: z
        .string()
        .describe('Short description of the property')
        .optional(),
      allowed_values: z
        .array(z.string().max(75))
        .max(200)
        .describe(
          'An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.'
        )
        .optional(),
      values_editable_by: z
        .enum(['org_actors', 'org_and_repo_actors'])
        .describe('Who can edit the values of the property')
        .optional()
    })
    .describe('Custom property defined on an organization')
  export type CustomProperty = z.infer<typeof CustomPropertySchema>

  export const CustomPropertyNameSchema = z
    .any()
    .describe('The custom property name')
  export type CustomPropertyName = z.infer<typeof CustomPropertyNameSchema>

  export const CustomPropertySetPayloadSchema = z
    .object({
      value_type: z
        .enum(['string', 'single_select', 'multi_select', 'true_false'])
        .describe('The type of the value for the property'),
      required: z
        .boolean()
        .describe('Whether the property is required.')
        .optional(),
      default_value: z
        .union([z.string(), z.array(z.string())])
        .describe('Default value of the property')
        .optional(),
      description: z
        .string()
        .describe('Short description of the property')
        .optional(),
      allowed_values: z
        .array(z.string().max(75))
        .max(200)
        .describe(
          'An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.'
        )
        .optional(),
      values_editable_by: z
        .enum(['org_actors', 'org_and_repo_actors'])
        .describe('Who can edit the values of the property')
        .optional()
    })
    .describe('Custom property set payload')
  export type CustomPropertySetPayload = z.infer<
    typeof CustomPropertySetPayloadSchema
  >

  export const CustomPropertyValueSchema = z
    .object({
      property_name: z.string().describe('The name of the property'),
      value: z
        .union([z.string(), z.array(z.string())])
        .describe('The value assigned to the property')
    })
    .describe('Custom property name and associated value')
  export type CustomPropertyValue = z.infer<typeof CustomPropertyValueSchema>

  export const CodeOfConductSimpleSchema = z
    .object({
      url: z.string().url(),
      key: z.string(),
      name: z.string(),
      html_url: z.string().url()
    })
    .describe('Code of Conduct Simple')
  export type CodeOfConductSimple = z.infer<typeof CodeOfConductSimpleSchema>

  export const RepositoryRuleEnforcementSchema = z
    .enum(['disabled', 'active', 'evaluate'])
    .describe(
      'The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).'
    )
  export type RepositoryRuleEnforcement = z.infer<
    typeof RepositoryRuleEnforcementSchema
  >

  export const RepositoryRulesetBypassActorSchema = z
    .object({
      actor_id: z
        .number()
        .int()
        .describe(
          'The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.'
        )
        .optional(),
      actor_type: z
        .enum([
          'Integration',
          'OrganizationAdmin',
          'RepositoryRole',
          'Team',
          'DeployKey'
        ])
        .describe('The type of actor that can bypass a ruleset.'),
      bypass_mode: z
        .enum(['always', 'pull_request'])
        .describe(
          'When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.'
        )
        .default('always')
    })
    .describe('An actor that can bypass rules in a ruleset')
  export type RepositoryRulesetBypassActor = z.infer<
    typeof RepositoryRulesetBypassActorSchema
  >

  export const RepositoryRulesetConditionsSchema = z
    .object({
      ref_name: z
        .object({
          include: z
            .array(z.string())
            .describe(
              'Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.'
            )
            .optional(),
          exclude: z
            .array(z.string())
            .describe(
              'Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.'
            )
            .optional()
        })
        .optional()
    })
    .describe('Parameters for a repository ruleset ref name condition')
  export type RepositoryRulesetConditions = z.infer<
    typeof RepositoryRulesetConditionsSchema
  >

  export const RepositoryRulesetConditionsRepositoryNameTargetSchema = z
    .object({
      repository_name: z.object({
        include: z
          .array(z.string())
          .describe(
            'Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.'
          )
          .optional(),
        exclude: z
          .array(z.string())
          .describe(
            'Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.'
          )
          .optional(),
        protected: z
          .boolean()
          .describe('Whether renaming of target repositories is prevented.')
          .optional()
      })
    })
    .describe('Parameters for a repository name condition')
  export type RepositoryRulesetConditionsRepositoryNameTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryNameTargetSchema
  >

  export const RepositoryRulesetConditionsRepositoryIdTargetSchema = z
    .object({
      repository_id: z.object({
        repository_ids: z
          .array(z.number().int())
          .describe(
            'The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.'
          )
          .optional()
      })
    })
    .describe('Parameters for a repository ID condition')
  export type RepositoryRulesetConditionsRepositoryIdTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryIdTargetSchema
  >

  export const RepositoryRulesetConditionsRepositoryPropertySpecSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the repository property to target'),
      property_values: z
        .array(z.string())
        .describe('The values to match for the repository property'),
      source: z
        .enum(['custom', 'system'])
        .describe(
          "The source of the repository property. Defaults to 'custom' if not specified."
        )
        .optional()
    })
    .describe('Parameters for a targeting a repository property')
  export type RepositoryRulesetConditionsRepositoryPropertySpec = z.infer<
    typeof RepositoryRulesetConditionsRepositoryPropertySpecSchema
  >

  export const RepositoryRuleCreationSchema = z
    .object({ type: z.literal('creation') })
    .describe(
      'Only allow users with bypass permission to create matching refs.'
    )
  export type RepositoryRuleCreation = z.infer<
    typeof RepositoryRuleCreationSchema
  >

  export const RepositoryRuleUpdateSchema = z
    .object({
      type: z.literal('update'),
      parameters: z
        .object({
          update_allows_fetch_and_merge: z
            .boolean()
            .describe('Branch can pull changes from its upstream repository')
        })
        .optional()
    })
    .describe(
      'Only allow users with bypass permission to update matching refs.'
    )
  export type RepositoryRuleUpdate = z.infer<typeof RepositoryRuleUpdateSchema>

  export const RepositoryRuleDeletionSchema = z
    .object({ type: z.literal('deletion') })
    .describe(
      'Only allow users with bypass permissions to delete matching refs.'
    )
  export type RepositoryRuleDeletion = z.infer<
    typeof RepositoryRuleDeletionSchema
  >

  export const RepositoryRuleRequiredLinearHistorySchema = z
    .object({ type: z.literal('required_linear_history') })
    .describe('Prevent merge commits from being pushed to matching refs.')
  export type RepositoryRuleRequiredLinearHistory = z.infer<
    typeof RepositoryRuleRequiredLinearHistorySchema
  >

  export const RepositoryRuleMergeQueueSchema = z
    .object({
      type: z.literal('merge_queue'),
      parameters: z
        .object({
          check_response_timeout_minutes: z
            .number()
            .int()
            .gte(1)
            .lte(360)
            .describe(
              'Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed'
            ),
          grouping_strategy: z
            .enum(['ALLGREEN', 'HEADGREEN'])
            .describe(
              'When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.'
            ),
          max_entries_to_build: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'Limit the number of queued pull requests requesting checks and workflow runs at the same time.'
            ),
          max_entries_to_merge: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'The maximum number of PRs that will be merged together in a group.'
            ),
          merge_method: z
            .enum(['MERGE', 'SQUASH', 'REBASE'])
            .describe(
              'Method to use when merging changes from queued pull requests.'
            ),
          min_entries_to_merge: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'The minimum number of PRs that will be merged together in a group.'
            ),
          min_entries_to_merge_wait_minutes: z
            .number()
            .int()
            .gte(0)
            .lte(360)
            .describe(
              'The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.'
            )
        })
        .optional()
    })
    .describe('Merges must be performed via a merge queue.')
  export type RepositoryRuleMergeQueue = z.infer<
    typeof RepositoryRuleMergeQueueSchema
  >

  export const RepositoryRuleRequiredDeploymentsSchema = z
    .object({
      type: z.literal('required_deployments'),
      parameters: z
        .object({
          required_deployment_environments: z
            .array(z.string())
            .describe(
              'The environments that must be successfully deployed to before branches can be merged.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.'
    )
  export type RepositoryRuleRequiredDeployments = z.infer<
    typeof RepositoryRuleRequiredDeploymentsSchema
  >

  export const RepositoryRuleRequiredSignaturesSchema = z
    .object({ type: z.literal('required_signatures') })
    .describe('Commits pushed to matching refs must have verified signatures.')
  export type RepositoryRuleRequiredSignatures = z.infer<
    typeof RepositoryRuleRequiredSignaturesSchema
  >

  export const RepositoryRulePullRequestSchema = z
    .object({
      type: z.literal('pull_request'),
      parameters: z
        .object({
          allowed_merge_methods: z
            .array(z.enum(['merge', 'squash', 'rebase']))
            .describe(
              'Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.'
            )
            .optional(),
          automatic_copilot_code_review_enabled: z
            .boolean()
            .describe(
              '> [!NOTE]\n> `automatic_copilot_code_review_enabled` is in beta and subject to change.\n\nAutomatically request review from Copilot for new pull requests, if the author has access to Copilot code review.'
            )
            .optional(),
          dismiss_stale_reviews_on_push: z
            .boolean()
            .describe(
              'New, reviewable commits pushed will dismiss previous pull request review approvals.'
            ),
          require_code_owner_review: z
            .boolean()
            .describe(
              'Require an approving review in pull requests that modify files that have a designated code owner.'
            ),
          require_last_push_approval: z
            .boolean()
            .describe(
              'Whether the most recent reviewable push must be approved by someone other than the person who pushed it.'
            ),
          required_approving_review_count: z
            .number()
            .int()
            .gte(0)
            .lte(10)
            .describe(
              'The number of approving reviews that are required before a pull request can be merged.'
            ),
          required_review_thread_resolution: z
            .boolean()
            .describe(
              'All conversations on code must be resolved before a pull request can be merged.'
            )
        })
        .optional()
    })
    .describe(
      'Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.'
    )
  export type RepositoryRulePullRequest = z.infer<
    typeof RepositoryRulePullRequestSchema
  >

  export const RepositoryRuleParamsStatusCheckConfigurationSchema = z
    .object({
      context: z
        .string()
        .describe(
          'The status check context name that must be present on the commit.'
        ),
      integration_id: z
        .number()
        .int()
        .describe(
          'The optional integration ID that this status check must originate from.'
        )
        .optional()
    })
    .describe('Required status check')
  export type RepositoryRuleParamsStatusCheckConfiguration = z.infer<
    typeof RepositoryRuleParamsStatusCheckConfigurationSchema
  >

  export const RepositoryRuleNonFastForwardSchema = z
    .object({ type: z.literal('non_fast_forward') })
    .describe('Prevent users with push access from force pushing to refs.')
  export type RepositoryRuleNonFastForward = z.infer<
    typeof RepositoryRuleNonFastForwardSchema
  >

  export const RepositoryRuleCommitMessagePatternSchema = z
    .object({
      type: z.literal('commit_message_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the commit_message_pattern rule')
  export type RepositoryRuleCommitMessagePattern = z.infer<
    typeof RepositoryRuleCommitMessagePatternSchema
  >

  export const RepositoryRuleCommitAuthorEmailPatternSchema = z
    .object({
      type: z.literal('commit_author_email_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the commit_author_email_pattern rule')
  export type RepositoryRuleCommitAuthorEmailPattern = z.infer<
    typeof RepositoryRuleCommitAuthorEmailPatternSchema
  >

  export const RepositoryRuleCommitterEmailPatternSchema = z
    .object({
      type: z.literal('committer_email_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the committer_email_pattern rule')
  export type RepositoryRuleCommitterEmailPattern = z.infer<
    typeof RepositoryRuleCommitterEmailPatternSchema
  >

  export const RepositoryRuleBranchNamePatternSchema = z
    .object({
      type: z.literal('branch_name_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the branch_name_pattern rule')
  export type RepositoryRuleBranchNamePattern = z.infer<
    typeof RepositoryRuleBranchNamePatternSchema
  >

  export const RepositoryRuleTagNamePatternSchema = z
    .object({
      type: z.literal('tag_name_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the tag_name_pattern rule')
  export type RepositoryRuleTagNamePattern = z.infer<
    typeof RepositoryRuleTagNamePatternSchema
  >

  export const RepositoryRuleFilePathRestrictionSchema = z
    .object({
      type: z.literal('file_path_restriction'),
      parameters: z
        .object({
          restricted_file_paths: z
            .array(z.string())
            .describe(
              'The file paths that are restricted from being pushed to the commit graph.'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.'
    )
  export type RepositoryRuleFilePathRestriction = z.infer<
    typeof RepositoryRuleFilePathRestrictionSchema
  >

  export const RepositoryRuleMaxFilePathLengthSchema = z
    .object({
      type: z.literal('max_file_path_length'),
      parameters: z
        .object({
          max_file_path_length: z
            .number()
            .int()
            .gte(1)
            .lte(256)
            .describe('The maximum amount of characters allowed in file paths.')
        })
        .optional()
    })
    .describe(
      'Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.'
    )
  export type RepositoryRuleMaxFilePathLength = z.infer<
    typeof RepositoryRuleMaxFilePathLengthSchema
  >

  export const RepositoryRuleFileExtensionRestrictionSchema = z
    .object({
      type: z.literal('file_extension_restriction'),
      parameters: z
        .object({
          restricted_file_extensions: z
            .array(z.string())
            .describe(
              'The file extensions that are restricted from being pushed to the commit graph.'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits that include files with specified file extensions from being pushed to the commit graph.'
    )
  export type RepositoryRuleFileExtensionRestriction = z.infer<
    typeof RepositoryRuleFileExtensionRestrictionSchema
  >

  export const RepositoryRuleMaxFileSizeSchema = z
    .object({
      type: z.literal('max_file_size'),
      parameters: z
        .object({
          max_file_size: z
            .number()
            .int()
            .gte(1)
            .lte(100)
            .describe(
              'The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.'
    )
  export type RepositoryRuleMaxFileSize = z.infer<
    typeof RepositoryRuleMaxFileSizeSchema
  >

  export const RepositoryRuleParamsWorkflowFileReferenceSchema = z
    .object({
      path: z.string().describe('The path to the workflow file'),
      ref: z
        .string()
        .describe('The ref (branch or tag) of the workflow file to use')
        .optional(),
      repository_id: z
        .number()
        .int()
        .describe('The ID of the repository where the workflow is defined'),
      sha: z
        .string()
        .describe('The commit SHA of the workflow file to use')
        .optional()
    })
    .describe('A workflow that must run for this rule to pass')
  export type RepositoryRuleParamsWorkflowFileReference = z.infer<
    typeof RepositoryRuleParamsWorkflowFileReferenceSchema
  >

  export const RepositoryRuleParamsCodeScanningToolSchema = z
    .object({
      alerts_threshold: z
        .enum(['none', 'errors', 'errors_and_warnings', 'all'])
        .describe(
          'The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."'
        ),
      security_alerts_threshold: z
        .enum(['none', 'critical', 'high_or_higher', 'medium_or_higher', 'all'])
        .describe(
          'The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."'
        ),
      tool: z.string().describe('The name of a code scanning tool')
    })
    .describe(
      'A tool that must provide code scanning results for this rule to pass.'
    )
  export type RepositoryRuleParamsCodeScanningTool = z.infer<
    typeof RepositoryRuleParamsCodeScanningToolSchema
  >

  export const RulesetTargetsSchema = z
    .any()
    .describe(
      'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
    )
  export type RulesetTargets = z.infer<typeof RulesetTargetsSchema>

  export const RuleSuitesSchema = z
    .array(
      z.object({
        id: z
          .number()
          .int()
          .describe('The unique identifier of the rule insight.')
          .optional(),
        actor_id: z
          .number()
          .int()
          .describe('The number that identifies the user.')
          .optional(),
        actor_name: z
          .string()
          .describe('The handle for the GitHub user account.')
          .optional(),
        before_sha: z
          .string()
          .describe('The first commit sha before the push evaluation.')
          .optional(),
        after_sha: z
          .string()
          .describe('The last commit sha in the push evaluation.')
          .optional(),
        ref: z
          .string()
          .describe('The ref name that the evaluation ran on.')
          .optional(),
        repository_id: z
          .number()
          .int()
          .describe(
            'The ID of the repository associated with the rule evaluation.'
          )
          .optional(),
        repository_name: z
          .string()
          .describe('The name of the repository without the `.git` extension.')
          .optional(),
        pushed_at: z.string().datetime({ offset: true }).optional(),
        result: z
          .enum(['pass', 'fail', 'bypass'])
          .describe(
            'The result of the rule evaluations for rules with the `active` enforcement status.'
          )
          .optional(),
        evaluation_result: z
          .enum(['pass', 'fail', 'bypass'])
          .describe(
            'The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.'
          )
          .optional()
      })
    )
    .describe('Response')
  export type RuleSuites = z.infer<typeof RuleSuitesSchema>

  export const RefInQuerySchema = z
    .any()
    .describe(
      'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
    )
  export type RefInQuery = z.infer<typeof RefInQuerySchema>

  export const RepositoryNameInQuerySchema = z
    .any()
    .describe('The name of the repository to filter on.')
  export type RepositoryNameInQuery = z.infer<
    typeof RepositoryNameInQuerySchema
  >

  export const TimePeriodSchema = z
    .any()
    .describe(
      'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
    )
  export type TimePeriod = z.infer<typeof TimePeriodSchema>

  export const ActorNameInQuerySchema = z
    .any()
    .describe(
      'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
    )
  export type ActorNameInQuery = z.infer<typeof ActorNameInQuerySchema>

  export const RuleSuiteResultSchema = z
    .any()
    .describe(
      'The rule results to filter on. When specified, only suites with this result will be returned.'
    )
  export type RuleSuiteResult = z.infer<typeof RuleSuiteResultSchema>

  export const RuleSuiteSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the rule insight.')
        .optional(),
      actor_id: z
        .number()
        .int()
        .describe('The number that identifies the user.')
        .optional(),
      actor_name: z
        .string()
        .describe('The handle for the GitHub user account.')
        .optional(),
      before_sha: z
        .string()
        .describe('The first commit sha before the push evaluation.')
        .optional(),
      after_sha: z
        .string()
        .describe('The last commit sha in the push evaluation.')
        .optional(),
      ref: z
        .string()
        .describe('The ref name that the evaluation ran on.')
        .optional(),
      repository_id: z
        .number()
        .int()
        .describe(
          'The ID of the repository associated with the rule evaluation.'
        )
        .optional(),
      repository_name: z
        .string()
        .describe('The name of the repository without the `.git` extension.')
        .optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      result: z
        .enum(['pass', 'fail', 'bypass'])
        .describe(
          'The result of the rule evaluations for rules with the `active` enforcement status.'
        )
        .optional(),
      evaluation_result: z
        .enum(['pass', 'fail', 'bypass'])
        .describe(
          'The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.'
        )
        .optional(),
      rule_evaluations: z
        .array(
          z.object({
            rule_source: z
              .object({
                type: z
                  .string()
                  .describe('The type of rule source.')
                  .optional(),
                id: z
                  .number()
                  .int()
                  .describe('The ID of the rule source.')
                  .optional(),
                name: z
                  .string()
                  .describe('The name of the rule source.')
                  .optional()
              })
              .optional(),
            enforcement: z
              .enum(['active', 'evaluate', 'deleted ruleset'])
              .describe('The enforcement level of this rule source.')
              .optional(),
            result: z
              .enum(['pass', 'fail'])
              .describe('The result of the evaluation of the individual rule.')
              .optional(),
            rule_type: z.string().describe('The type of rule.').optional(),
            details: z
              .string()
              .describe(
                'The detailed failure message for the rule. Null if the rule passed.'
              )
              .optional()
          })
        )
        .describe('Details on the evaluated rules.')
        .optional()
    })
    .describe('Response')
  export type RuleSuite = z.infer<typeof RuleSuiteSchema>

  export const RuleSuiteIdSchema = z
    .any()
    .describe(
      'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
    )
  export type RuleSuiteId = z.infer<typeof RuleSuiteIdSchema>

  export const RulesetVersionSchema = z
    .object({
      version_id: z
        .number()
        .int()
        .describe('The ID of the previous version of the ruleset'),
      actor: z
        .object({
          id: z.number().int().optional(),
          type: z.string().optional()
        })
        .describe('The actor who updated the ruleset'),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('The historical version of a ruleset')
  export type RulesetVersion = z.infer<typeof RulesetVersionSchema>

  export const SecretScanningPaginationBeforeOrgRepoSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
    )
  export type SecretScanningPaginationBeforeOrgRepo = z.infer<
    typeof SecretScanningPaginationBeforeOrgRepoSchema
  >

  export const SecretScanningPaginationAfterOrgRepoSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
    )
  export type SecretScanningPaginationAfterOrgRepo = z.infer<
    typeof SecretScanningPaginationAfterOrgRepoSchema
  >

  export const ActionsBillingUsageSchema = z.object({
    total_minutes_used: z
      .number()
      .int()
      .describe('The sum of the free and paid GitHub Actions minutes used.'),
    total_paid_minutes_used: z
      .number()
      .int()
      .describe('The total paid GitHub Actions minutes used.'),
    included_minutes: z
      .number()
      .int()
      .describe('The amount of free GitHub Actions minutes available.'),
    minutes_used_breakdown: z.object({
      UBUNTU: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu runner machines.')
        .optional(),
      MACOS: z
        .number()
        .int()
        .describe('Total minutes used on macOS runner machines.')
        .optional(),
      WINDOWS: z
        .number()
        .int()
        .describe('Total minutes used on Windows runner machines.')
        .optional(),
      ubuntu_4_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 4 core runner machines.')
        .optional(),
      ubuntu_8_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 8 core runner machines.')
        .optional(),
      ubuntu_16_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 16 core runner machines.')
        .optional(),
      ubuntu_32_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 32 core runner machines.')
        .optional(),
      ubuntu_64_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 64 core runner machines.')
        .optional(),
      windows_4_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 4 core runner machines.')
        .optional(),
      windows_8_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 8 core runner machines.')
        .optional(),
      windows_16_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 16 core runner machines.')
        .optional(),
      windows_32_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 32 core runner machines.')
        .optional(),
      windows_64_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 64 core runner machines.')
        .optional(),
      macos_12_core: z
        .number()
        .int()
        .describe('Total minutes used on macOS 12 core runner machines.')
        .optional(),
      total: z
        .number()
        .int()
        .describe('Total minutes used on all runner machines.')
        .optional()
    })
  })
  export type ActionsBillingUsage = z.infer<typeof ActionsBillingUsageSchema>

  export const PackagesBillingUsageSchema = z.object({
    total_gigabytes_bandwidth_used: z
      .number()
      .int()
      .describe(
        'Sum of the free and paid storage space (GB) for GitHuub Packages.'
      ),
    total_paid_gigabytes_bandwidth_used: z
      .number()
      .int()
      .describe('Total paid storage space (GB) for GitHuub Packages.'),
    included_gigabytes_bandwidth: z
      .number()
      .int()
      .describe('Free storage space (GB) for GitHub Packages.')
  })
  export type PackagesBillingUsage = z.infer<typeof PackagesBillingUsageSchema>

  export const CombinedBillingUsageSchema = z.object({
    days_left_in_billing_cycle: z
      .number()
      .int()
      .describe('Numbers of days left in billing cycle.'),
    estimated_paid_storage_for_month: z
      .number()
      .int()
      .describe('Estimated storage space (GB) used in billing cycle.'),
    estimated_storage_for_month: z
      .number()
      .int()
      .describe(
        'Estimated sum of free and paid storage space (GB) used in billing cycle.'
      )
  })
  export type CombinedBillingUsage = z.infer<typeof CombinedBillingUsageSchema>

  export const NetworkConfigurationSchema = z
    .object({
      id: z
        .string()
        .describe('The unique identifier of the network configuration.'),
      name: z.string().describe('The name of the network configuration.'),
      compute_service: z
        .enum(['none', 'actions', 'codespaces'])
        .describe(
          'The hosted compute service the network configuration supports.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .describe(
          'The unique identifier of each network settings in the configuration.'
        )
        .optional(),
      created_on: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time at which the network configuration was created, in ISO 8601 format.'
        )
    })
    .describe('A hosted compute network configuration.')
  export type NetworkConfiguration = z.infer<typeof NetworkConfigurationSchema>

  export const NetworkConfigurationIdSchema = z
    .any()
    .describe('Unique identifier of the hosted compute network configuration.')
  export type NetworkConfigurationId = z.infer<
    typeof NetworkConfigurationIdSchema
  >

  export const NetworkSettingsSchema = z
    .object({
      id: z
        .string()
        .describe('The unique identifier of the network settings resource.'),
      network_configuration_id: z
        .string()
        .describe(
          'The identifier of the network configuration that is using this settings resource.'
        )
        .optional(),
      name: z.string().describe('The name of the network settings resource.'),
      subnet_id: z
        .string()
        .describe(
          'The subnet this network settings resource is configured for.'
        ),
      region: z
        .string()
        .describe(
          'The location of the subnet this network settings resource is configured for.'
        )
    })
    .describe('A hosted compute network settings resource.')
  export type NetworkSettings = z.infer<typeof NetworkSettingsSchema>

  export const NetworkSettingsIdSchema = z
    .any()
    .describe('Unique identifier of the hosted compute network settings.')
  export type NetworkSettingsId = z.infer<typeof NetworkSettingsIdSchema>

  export const TeamOrganizationSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string(),
      name: z.string().optional(),
      company: z.string().optional(),
      blog: z.string().url().optional(),
      location: z.string().optional(),
      email: z.string().email().optional(),
      twitter_username: z.string().optional(),
      is_verified: z.boolean().optional(),
      has_organization_projects: z.boolean(),
      has_repository_projects: z.boolean(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      type: z.string(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      private_gists: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z.number().int().optional(),
      billing_email: z.string().email().optional(),
      plan: z
        .object({
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int(),
          filled_seats: z.number().int().optional(),
          seats: z.number().int().optional()
        })
        .optional(),
      default_repository_permission: z.string().optional(),
      members_can_create_repositories: z.boolean().optional(),
      two_factor_requirement_enabled: z.boolean().optional(),
      members_allowed_repository_creation_type: z.string().optional(),
      members_can_create_public_repositories: z.boolean().optional(),
      members_can_create_private_repositories: z.boolean().optional(),
      members_can_create_internal_repositories: z.boolean().optional(),
      members_can_create_pages: z.boolean().optional(),
      members_can_create_public_pages: z.boolean().optional(),
      members_can_create_private_pages: z.boolean().optional(),
      members_can_fork_private_repositories: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      updated_at: z.string().datetime({ offset: true }),
      archived_at: z.string().datetime({ offset: true })
    })
    .describe('Team Organization')
  export type TeamOrganization = z.infer<typeof TeamOrganizationSchema>

  export const DiscussionNumberSchema = z
    .any()
    .describe('The number that identifies the discussion.')
  export type DiscussionNumber = z.infer<typeof DiscussionNumberSchema>

  export const CommentNumberSchema = z
    .any()
    .describe('The number that identifies the comment.')
  export type CommentNumber = z.infer<typeof CommentNumberSchema>

  export const ReactionIdSchema = z
    .any()
    .describe('The unique identifier of the reaction.')
  export type ReactionId = z.infer<typeof ReactionIdSchema>

  export const TeamMembershipSchema = z
    .object({
      url: z.string().url(),
      role: z
        .enum(['member', 'maintainer'])
        .describe('The role of the user in the team.')
        .default('member'),
      state: z
        .enum(['active', 'pending'])
        .describe("The state of the user's membership in the team.")
    })
    .describe('Team Membership')
  export type TeamMembership = z.infer<typeof TeamMembershipSchema>

  export const ProjectIdSchema = z
    .any()
    .describe('The unique identifier of the project.')
  export type ProjectId = z.infer<typeof ProjectIdSchema>

  export const SecurityProductSchema = z
    .any()
    .describe('The security feature to enable or disable.')
  export type SecurityProduct = z.infer<typeof SecurityProductSchema>

  export const OrgSecurityProductEnablementSchema = z
    .any()
    .describe(
      'The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.'
    )
  export type OrgSecurityProductEnablement = z.infer<
    typeof OrgSecurityProductEnablementSchema
  >

  export const CardIdSchema = z
    .any()
    .describe('The unique identifier of the card.')
  export type CardId = z.infer<typeof CardIdSchema>

  export const ProjectColumnSchema = z
    .object({
      url: z.string().url(),
      project_url: z.string().url(),
      cards_url: z.string().url(),
      id: z
        .number()
        .int()
        .describe('The unique identifier of the project column'),
      node_id: z.string(),
      name: z.string().describe('Name of the project column'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Project columns contain cards of work.')
  export type ProjectColumn = z.infer<typeof ProjectColumnSchema>

  export const ColumnIdSchema = z
    .any()
    .describe('The unique identifier of the column.')
  export type ColumnId = z.infer<typeof ColumnIdSchema>

  export const RateLimitSchema = z.object({
    limit: z.number().int(),
    remaining: z.number().int(),
    reset: z.number().int(),
    used: z.number().int()
  })
  export type RateLimit = z.infer<typeof RateLimitSchema>

  export const ArtifactSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('The name of the artifact.'),
      size_in_bytes: z
        .number()
        .int()
        .describe('The size in bytes of the artifact.'),
      url: z.string(),
      archive_download_url: z.string(),
      expired: z.boolean().describe('Whether or not the artifact has expired.'),
      created_at: z.string().datetime({ offset: true }),
      expires_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      digest: z
        .string()
        .describe(
          'The SHA256 digest of the artifact. This field will only be populated on artifacts uploaded with upload-artifact v4 or newer. For older versions, this field will be null.'
        )
        .optional(),
      workflow_run: z
        .object({
          id: z.number().int().optional(),
          repository_id: z.number().int().optional(),
          head_repository_id: z.number().int().optional(),
          head_branch: z.string().optional(),
          head_sha: z.string().optional()
        })
        .optional()
    })
    .describe('An artifact')
  export type Artifact = z.infer<typeof ArtifactSchema>

  export const ArtifactNameSchema = z
    .any()
    .describe(
      'The name field of an artifact. When specified, only artifacts with this name will be returned.'
    )
  export type ArtifactName = z.infer<typeof ArtifactNameSchema>

  export const ArtifactIdSchema = z
    .any()
    .describe('The unique identifier of the artifact.')
  export type ArtifactId = z.infer<typeof ArtifactIdSchema>

  export const ActionsCacheListSchema = z
    .object({
      total_count: z.number().int().describe('Total number of caches'),
      actions_caches: z
        .array(
          z.object({
            id: z.number().int().optional(),
            ref: z.string().optional(),
            key: z.string().optional(),
            version: z.string().optional(),
            last_accessed_at: z.string().datetime({ offset: true }).optional(),
            created_at: z.string().datetime({ offset: true }).optional(),
            size_in_bytes: z.number().int().optional()
          })
        )
        .describe('Array of caches')
    })
    .describe('Repository actions caches')
  export type ActionsCacheList = z.infer<typeof ActionsCacheListSchema>

  export const ActionsCacheGitRefFullSchema = z
    .any()
    .describe(
      'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
    )
  export type ActionsCacheGitRefFull = z.infer<
    typeof ActionsCacheGitRefFullSchema
  >

  export const ActionsCacheKeySchema = z
    .any()
    .describe('An explicit key or prefix for identifying the cache')
  export type ActionsCacheKey = z.infer<typeof ActionsCacheKeySchema>

  export const ActionsCacheListSortSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.'
    )
  export type ActionsCacheListSort = z.infer<typeof ActionsCacheListSortSchema>

  export const ActionsCacheKeyRequiredSchema = z
    .any()
    .describe('A key for identifying the cache.')
  export type ActionsCacheKeyRequired = z.infer<
    typeof ActionsCacheKeyRequiredSchema
  >

  export const CacheIdSchema = z
    .any()
    .describe('The unique identifier of the GitHub Actions cache.')
  export type CacheId = z.infer<typeof CacheIdSchema>

  export const JobSchema = z
    .object({
      id: z.number().int().describe('The id of the job.'),
      run_id: z
        .number()
        .int()
        .describe('The id of the associated workflow run.'),
      run_url: z.string(),
      run_attempt: z
        .number()
        .int()
        .describe(
          'Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.'
        )
        .optional(),
      node_id: z.string(),
      head_sha: z.string().describe('The SHA of the commit that is being run.'),
      url: z.string(),
      html_url: z.string(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe('The phase of the lifecycle that the job is currently in.'),
      conclusion: z
        .enum([
          'success',
          'failure',
          'neutral',
          'cancelled',
          'skipped',
          'timed_out',
          'action_required'
        ])
        .describe('The outcome of the job.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job created, in ISO 8601 format.'),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job started, in ISO 8601 format.'),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job finished, in ISO 8601 format.'),
      name: z.string().describe('The name of the job.'),
      steps: z
        .array(
          z.object({
            status: z
              .enum(['queued', 'in_progress', 'completed'])
              .describe(
                'The phase of the lifecycle that the job is currently in.'
              ),
            conclusion: z.string().describe('The outcome of the job.'),
            name: z.string().describe('The name of the job.'),
            number: z.number().int(),
            started_at: z
              .string()
              .datetime({ offset: true })
              .describe('The time that the step started, in ISO 8601 format.')
              .optional(),
            completed_at: z
              .string()
              .datetime({ offset: true })
              .describe('The time that the job finished, in ISO 8601 format.')
              .optional()
          })
        )
        .describe('Steps in this job.')
        .optional(),
      check_run_url: z.string(),
      labels: z
        .array(z.string())
        .describe(
          'Labels for the workflow job. Specified by the "runs_on" attribute in the action\'s workflow file.'
        ),
      runner_id: z
        .number()
        .int()
        .describe(
          "The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_name: z
        .string()
        .describe(
          "The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_group_id: z
        .number()
        .int()
        .describe(
          "The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_group_name: z
        .string()
        .describe(
          "The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      workflow_name: z.string().describe('The name of the workflow.'),
      head_branch: z.string().describe('The name of the current branch.')
    })
    .describe('Information of a job execution in a workflow run')
  export type Job = z.infer<typeof JobSchema>

  export const JobIdSchema = z
    .any()
    .describe('The unique identifier of the job.')
  export type JobId = z.infer<typeof JobIdSchema>

  export const OidcCustomSubRepoSchema = z
    .object({
      use_default: z
        .boolean()
        .describe(
          'Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.'
        ),
      include_claim_keys: z
        .array(z.string())
        .describe(
          'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
        )
        .optional()
    })
    .describe('Actions OIDC subject customization for a repository')
  export type OidcCustomSubRepo = z.infer<typeof OidcCustomSubRepoSchema>

  export const ActionsSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set secrets for GitHub Actions.')
  export type ActionsSecret = z.infer<typeof ActionsSecretSchema>

  export const ActionsVariableSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    created_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        "The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
      ),
    updated_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        "The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
      )
  })
  export type ActionsVariable = z.infer<typeof ActionsVariableSchema>

  export const ActionsEnabledSchema = z
    .boolean()
    .describe('Whether GitHub Actions is enabled on the repository.')
  export type ActionsEnabled = z.infer<typeof ActionsEnabledSchema>

  export const ActionsWorkflowAccessToRepositorySchema = z.object({
    access_level: z
      .enum(['none', 'user', 'organization'])
      .describe(
        'Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository.\n\n`none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.'
      )
  })
  export type ActionsWorkflowAccessToRepository = z.infer<
    typeof ActionsWorkflowAccessToRepositorySchema
  >

  export const ReferencedWorkflowSchema = z
    .object({ path: z.string(), sha: z.string(), ref: z.string().optional() })
    .describe('A workflow referenced/reused by the initial caller workflow')
  export type ReferencedWorkflow = z.infer<typeof ReferencedWorkflowSchema>

  export const PullRequestMinimalSchema = z.object({
    id: z.number().int(),
    number: z.number().int(),
    url: z.string(),
    head: z.object({
      ref: z.string(),
      sha: z.string(),
      repo: z.object({
        id: z.number().int(),
        url: z.string(),
        name: z.string()
      })
    }),
    base: z.object({
      ref: z.string(),
      sha: z.string(),
      repo: z.object({
        id: z.number().int(),
        url: z.string(),
        name: z.string()
      })
    })
  })
  export type PullRequestMinimal = z.infer<typeof PullRequestMinimalSchema>

  export const NullableSimpleCommitSchema = z
    .object({
      id: z.string().describe('SHA for the commit'),
      tree_id: z.string().describe("SHA for the commit's tree"),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of the commit'),
      author: z
        .object({
          name: z.string().describe("Name of the commit's author"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's author")
        })
        .describe('Information about the Git author'),
      committer: z
        .object({
          name: z.string().describe("Name of the commit's committer"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's committer")
        })
        .describe('Information about the Git committer')
    })
    .describe('A commit.')
  export type NullableSimpleCommit = z.infer<typeof NullableSimpleCommitSchema>

  export const WorkflowRunBranchSchema = z
    .any()
    .describe(
      'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
    )
  export type WorkflowRunBranch = z.infer<typeof WorkflowRunBranchSchema>

  export const EventSchema = z
    .object({
      id: z.string(),
      type: z.string(),
      actor: ActorSchema,
      repo: z.object({
        id: z.number().int(),
        name: z.string(),
        url: z.string().url()
      }),
      org: ActorSchema.optional(),
      payload: z.object({
        action: z.string().optional(),
        issue: IssueSchema.optional(),
        comment: IssueCommentSchema.optional(),
        pages: z
          .array(
            z.object({
              page_name: z.string().optional(),
              title: z.string().optional(),
              summary: z.string().optional(),
              action: z.string().optional(),
              sha: z.string().optional(),
              html_url: z.string().optional()
            })
          )
          .optional()
      }),
      public: z.boolean(),
      created_at: z.string().datetime({ offset: true })
    })
    .describe('Event')
  export type Event = z.infer<typeof EventSchema>

  export const WorkflowRunStatusSchema = z
    .any()
    .describe(
      'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
    )
  export type WorkflowRunStatus = z.infer<typeof WorkflowRunStatusSchema>

  export const CreatedSchema = z
    .any()
    .describe(
      'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
    )
  export type Created = z.infer<typeof CreatedSchema>

  export const ExcludePullRequestsSchema = z
    .any()
    .describe(
      'If `true` pull requests are omitted from the response (empty array).'
    )
  export type ExcludePullRequests = z.infer<typeof ExcludePullRequestsSchema>

  export const WorkflowRunCheckSuiteIdSchema = z
    .any()
    .describe(
      'Returns workflow runs with the `check_suite_id` that you specify.'
    )
  export type WorkflowRunCheckSuiteId = z.infer<
    typeof WorkflowRunCheckSuiteIdSchema
  >

  export const WorkflowRunHeadShaSchema = z
    .any()
    .describe(
      'Only returns workflow runs that are associated with the specified `head_sha`.'
    )
  export type WorkflowRunHeadSha = z.infer<typeof WorkflowRunHeadShaSchema>

  export const RunIdSchema = z
    .any()
    .describe('The unique identifier of the workflow run.')
  export type RunId = z.infer<typeof RunIdSchema>

  export const AttemptNumberSchema = z
    .any()
    .describe('The attempt number of the workflow run.')
  export type AttemptNumber = z.infer<typeof AttemptNumberSchema>

  export const ReviewCustomGatesCommentRequiredSchema = z.object({
    environment_name: z
      .string()
      .describe('The name of the environment to approve or reject.'),
    comment: z
      .string()
      .describe(
        'Comment associated with the pending deployment protection rule. **Required when state is not provided.**'
      )
  })
  export type ReviewCustomGatesCommentRequired = z.infer<
    typeof ReviewCustomGatesCommentRequiredSchema
  >

  export const ReviewCustomGatesStateRequiredSchema = z.object({
    environment_name: z
      .string()
      .describe('The name of the environment to approve or reject.'),
    state: z
      .enum(['approved', 'rejected'])
      .describe(
        'Whether to approve or reject deployment to the specified environments.'
      ),
    comment: z
      .string()
      .describe('Optional comment to include with the review.')
      .optional()
  })
  export type ReviewCustomGatesStateRequired = z.infer<
    typeof ReviewCustomGatesStateRequiredSchema
  >

  export const DeploymentReviewerTypeSchema = z
    .enum(['User', 'Team'])
    .describe('The type of reviewer.')
  export type DeploymentReviewerType = z.infer<
    typeof DeploymentReviewerTypeSchema
  >

  export const WorkflowRunUsageSchema = z
    .object({
      billable: z.object({
        UBUNTU: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional(),
        MACOS: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional(),
        WINDOWS: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional()
      }),
      run_duration_ms: z.number().int().optional()
    })
    .describe('Workflow Run Usage')
  export type WorkflowRunUsage = z.infer<typeof WorkflowRunUsageSchema>

  export const WorkflowSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      path: z.string(),
      state: z.enum([
        'active',
        'deleted',
        'disabled_fork',
        'disabled_inactivity',
        'disabled_manually'
      ]),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string(),
      html_url: z.string(),
      badge_url: z.string(),
      deleted_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A GitHub Actions workflow')
  export type Workflow = z.infer<typeof WorkflowSchema>

  export const WorkflowIdSchema = z
    .any()
    .describe(
      'The ID of the workflow. You can also pass the workflow file name as a string.'
    )
  export type WorkflowId = z.infer<typeof WorkflowIdSchema>

  export const WorkflowUsageSchema = z
    .object({
      billable: z.object({
        UBUNTU: z.object({ total_ms: z.number().int().optional() }).optional(),
        MACOS: z.object({ total_ms: z.number().int().optional() }).optional(),
        WINDOWS: z.object({ total_ms: z.number().int().optional() }).optional()
      })
    })
    .describe('Workflow Usage')
  export type WorkflowUsage = z.infer<typeof WorkflowUsageSchema>

  export const AutolinkSchema = z
    .object({
      id: z.number().int(),
      key_prefix: z.string().describe('The prefix of a key that is linkified.'),
      url_template: z
        .string()
        .describe(
          'A template for the target URL that is generated if a key was found.'
        ),
      is_alphanumeric: z
        .boolean()
        .describe(
          'Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.'
        )
    })
    .describe('An autolink reference.')
  export type Autolink = z.infer<typeof AutolinkSchema>

  export const AutolinkIdSchema = z
    .any()
    .describe('The unique identifier of the autolink.')
  export type AutolinkId = z.infer<typeof AutolinkIdSchema>

  export const CheckAutomatedSecurityFixesSchema = z
    .object({
      enabled: z
        .boolean()
        .describe(
          'Whether Dependabot security updates are enabled for the repository.'
        ),
      paused: z
        .boolean()
        .describe(
          'Whether Dependabot security updates are paused for the repository.'
        )
    })
    .describe('Check Dependabot security updates')
  export type CheckAutomatedSecurityFixes = z.infer<
    typeof CheckAutomatedSecurityFixesSchema
  >

  export const ProtectedBranchRequiredStatusCheckSchema = z
    .object({
      url: z.string().optional(),
      enforcement_level: z.string().optional(),
      contexts: z.array(z.string()),
      checks: z.array(
        z.object({ context: z.string(), app_id: z.number().int() })
      ),
      contexts_url: z.string().optional(),
      strict: z.boolean().optional()
    })
    .describe('Protected Branch Required Status Check')
  export type ProtectedBranchRequiredStatusCheck = z.infer<
    typeof ProtectedBranchRequiredStatusCheckSchema
  >

  export const ProtectedBranchAdminEnforcedSchema = z
    .object({ url: z.string().url(), enabled: z.boolean() })
    .describe('Protected Branch Admin Enforced')
  export type ProtectedBranchAdminEnforced = z.infer<
    typeof ProtectedBranchAdminEnforcedSchema
  >

  export const BranchRestrictionPolicySchema = z
    .object({
      url: z.string().url(),
      users_url: z.string().url(),
      teams_url: z.string().url(),
      apps_url: z.string().url(),
      users: z.array(
        z.object({
          login: z.string().optional(),
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          avatar_url: z.string().optional(),
          gravatar_id: z.string().optional(),
          url: z.string().optional(),
          html_url: z.string().optional(),
          followers_url: z.string().optional(),
          following_url: z.string().optional(),
          gists_url: z.string().optional(),
          starred_url: z.string().optional(),
          subscriptions_url: z.string().optional(),
          organizations_url: z.string().optional(),
          repos_url: z.string().optional(),
          events_url: z.string().optional(),
          received_events_url: z.string().optional(),
          type: z.string().optional(),
          site_admin: z.boolean().optional(),
          user_view_type: z.string().optional()
        })
      ),
      teams: z.array(
        z.object({
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          html_url: z.string().optional(),
          name: z.string().optional(),
          slug: z.string().optional(),
          description: z.string().optional(),
          privacy: z.string().optional(),
          notification_setting: z.string().optional(),
          permission: z.string().optional(),
          members_url: z.string().optional(),
          repositories_url: z.string().optional(),
          parent: z.string().optional()
        })
      ),
      apps: z.array(
        z.object({
          id: z.number().int().optional(),
          slug: z.string().optional(),
          node_id: z.string().optional(),
          owner: z
            .object({
              login: z.string().optional(),
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().optional(),
              repos_url: z.string().optional(),
              events_url: z.string().optional(),
              hooks_url: z.string().optional(),
              issues_url: z.string().optional(),
              members_url: z.string().optional(),
              public_members_url: z.string().optional(),
              avatar_url: z.string().optional(),
              description: z.string().optional(),
              gravatar_id: z.string().optional(),
              html_url: z.string().optional(),
              followers_url: z.string().optional(),
              following_url: z.string().optional(),
              gists_url: z.string().optional(),
              starred_url: z.string().optional(),
              subscriptions_url: z.string().optional(),
              organizations_url: z.string().optional(),
              received_events_url: z.string().optional(),
              type: z.string().optional(),
              site_admin: z.boolean().optional(),
              user_view_type: z.string().optional()
            })
            .optional(),
          name: z.string().optional(),
          client_id: z.string().optional(),
          description: z.string().optional(),
          external_url: z.string().optional(),
          html_url: z.string().optional(),
          created_at: z.string().optional(),
          updated_at: z.string().optional(),
          permissions: z
            .object({
              metadata: z.string().optional(),
              contents: z.string().optional(),
              issues: z.string().optional(),
              single_file: z.string().optional()
            })
            .optional(),
          events: z.array(z.string()).optional()
        })
      )
    })
    .describe('Branch Restriction Policy')
  export type BranchRestrictionPolicy = z.infer<
    typeof BranchRestrictionPolicySchema
  >

  export const NullableGitUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      date: z.string().optional()
    })
    .describe('Metaproperties for Git author/committer information.')
  export type NullableGitUser = z.infer<typeof NullableGitUserSchema>

  export const VerificationSchema = z.object({
    verified: z.boolean(),
    reason: z.string(),
    payload: z.string(),
    signature: z.string(),
    verified_at: z.string()
  })
  export type Verification = z.infer<typeof VerificationSchema>

  export const DiffEntrySchema = z
    .object({
      sha: z.string(),
      filename: z.string(),
      status: z.enum([
        'added',
        'removed',
        'modified',
        'renamed',
        'copied',
        'changed',
        'unchanged'
      ]),
      additions: z.number().int(),
      deletions: z.number().int(),
      changes: z.number().int(),
      blob_url: z.string().url(),
      raw_url: z.string().url(),
      contents_url: z.string().url(),
      patch: z.string().optional(),
      previous_filename: z.string().optional()
    })
    .describe('Diff Entry')
  export type DiffEntry = z.infer<typeof DiffEntrySchema>

  export const BranchSchema = z
    .any()
    .describe(
      'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
    )
  export type Branch = z.infer<typeof BranchSchema>

  export const StatusCheckPolicySchema = z
    .object({
      url: z.string().url(),
      strict: z.boolean(),
      contexts: z.array(z.string()),
      checks: z.array(
        z.object({ context: z.string(), app_id: z.number().int() })
      ),
      contexts_url: z.string().url()
    })
    .describe('Status Check Policy')
  export type StatusCheckPolicy = z.infer<typeof StatusCheckPolicySchema>

  export const CheckRunIdSchema = z
    .any()
    .describe('The unique identifier of the check run.')
  export type CheckRunId = z.infer<typeof CheckRunIdSchema>

  export const CheckAnnotationSchema = z
    .object({
      path: z.string(),
      start_line: z.number().int(),
      end_line: z.number().int(),
      start_column: z.number().int(),
      end_column: z.number().int(),
      annotation_level: z.string(),
      title: z.string(),
      message: z.string(),
      raw_details: z.string(),
      blob_href: z.string()
    })
    .describe('Check Annotation')
  export type CheckAnnotation = z.infer<typeof CheckAnnotationSchema>

  export const SimpleCommitSchema = z
    .object({
      id: z.string().describe('SHA for the commit'),
      tree_id: z.string().describe("SHA for the commit's tree"),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of the commit'),
      author: z
        .object({
          name: z.string().describe("Name of the commit's author"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's author")
        })
        .describe('Information about the Git author'),
      committer: z
        .object({
          name: z.string().describe("Name of the commit's committer"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's committer")
        })
        .describe('Information about the Git committer')
    })
    .describe('A commit.')
  export type SimpleCommit = z.infer<typeof SimpleCommitSchema>

  export const CheckSuiteIdSchema = z
    .any()
    .describe('The unique identifier of the check suite.')
  export type CheckSuiteId = z.infer<typeof CheckSuiteIdSchema>

  export const CheckNameSchema = z
    .any()
    .describe('Returns check runs with the specified `name`.')
  export type CheckName = z.infer<typeof CheckNameSchema>

  export const StatusSchema = z
    .object({
      url: z.string(),
      avatar_url: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      state: z.string(),
      description: z.string(),
      target_url: z.string(),
      context: z.string(),
      created_at: z.string(),
      updated_at: z.string(),
      creator: NullableSimpleUserSchema
    })
    .describe('The status of a commit.')
  export type Status = z.infer<typeof StatusSchema>

  export const PrAliasSchema = z
    .any()
    .describe(
      'The number of the pull request for the results you want to list.'
    )
  export type PrAlias = z.infer<typeof PrAliasSchema>

  export const CodeScanningAlertRuleSchema = z.object({
    id: z
      .string()
      .describe('A unique identifier for the rule used to detect the alert.')
      .optional(),
    name: z
      .string()
      .describe('The name of the rule used to detect the alert.')
      .optional(),
    severity: z
      .enum(['none', 'note', 'warning', 'error'])
      .describe('The severity of the alert.')
      .optional(),
    security_severity_level: z
      .enum(['low', 'medium', 'high', 'critical'])
      .describe('The security severity of the alert.')
      .optional(),
    description: z
      .string()
      .describe('A short description of the rule used to detect the alert.')
      .optional(),
    full_description: z
      .string()
      .describe('A description of the rule used to detect the alert.')
      .optional(),
    tags: z
      .array(z.string())
      .describe('A set of tags applicable for the rule.')
      .optional(),
    help: z
      .string()
      .describe(
        'Detailed documentation for the rule as GitHub Flavored Markdown.'
      )
      .optional(),
    help_uri: z
      .string()
      .describe(
        'A link to the documentation for the rule used to detect the alert.'
      )
      .optional()
  })
  export type CodeScanningAlertRule = z.infer<
    typeof CodeScanningAlertRuleSchema
  >

  export const CodeScanningAlertSetStateSchema = z
    .enum(['open', 'dismissed'])
    .describe(
      'Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.'
    )
  export type CodeScanningAlertSetState = z.infer<
    typeof CodeScanningAlertSetStateSchema
  >

  export const CodeScanningAlertCreateRequestSchema = z
    .boolean()
    .describe('If `true`, attempt to create an alert dismissal request.')
  export type CodeScanningAlertCreateRequest = z.infer<
    typeof CodeScanningAlertCreateRequestSchema
  >

  export const CodeScanningAutofixStatusSchema = z
    .enum(['pending', 'error', 'success', 'outdated'])
    .describe('The status of an autofix.')
  export type CodeScanningAutofixStatus = z.infer<
    typeof CodeScanningAutofixStatusSchema
  >

  export const CodeScanningAutofixDescriptionSchema = z
    .string()
    .describe('The description of an autofix.')
  export type CodeScanningAutofixDescription = z.infer<
    typeof CodeScanningAutofixDescriptionSchema
  >

  export const CodeScanningAutofixStartedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type CodeScanningAutofixStartedAt = z.infer<
    typeof CodeScanningAutofixStartedAtSchema
  >

  export const CodeScanningAutofixCommitsSchema = z
    .object({
      target_ref: z
        .string()
        .describe(
          'The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
        )
        .optional(),
      message: z.string().describe('Commit message to be used.').optional()
    })
    .describe('Commit an autofix for a code scanning alert')
  export type CodeScanningAutofixCommits = z.infer<
    typeof CodeScanningAutofixCommitsSchema
  >

  export const CodeScanningAutofixCommitsResponseSchema = z.object({
    target_ref: z
      .string()
      .describe(
        'The Git reference of target branch for the commit. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
      .optional(),
    sha: z.string().describe('SHA of commit with autofix.').optional()
  })
  export type CodeScanningAutofixCommitsResponse = z.infer<
    typeof CodeScanningAutofixCommitsResponseSchema
  >

  export const CodeScanningAnalysisCommitShaSchema = z
    .string()
    .regex(new RegExp('^[0-9a-fA-F]+$'))
    .min(40)
    .max(40)
    .describe(
      'The SHA of the commit to which the analysis you are uploading relates.'
    )
  export type CodeScanningAnalysisCommitSha = z.infer<
    typeof CodeScanningAnalysisCommitShaSchema
  >

  export const CodeScanningAnalysisEnvironmentSchema = z
    .string()
    .describe(
      'Identifies the variable values associated with the environment in which this analysis was performed.'
    )
  export type CodeScanningAnalysisEnvironment = z.infer<
    typeof CodeScanningAnalysisEnvironmentSchema
  >

  export const CodeScanningAnalysisCreatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type CodeScanningAnalysisCreatedAt = z.infer<
    typeof CodeScanningAnalysisCreatedAtSchema
  >

  export const CodeScanningAnalysisUrlSchema = z
    .string()
    .url()
    .describe('The REST API URL of the analysis resource.')
    .readonly()
  export type CodeScanningAnalysisUrl = z.infer<
    typeof CodeScanningAnalysisUrlSchema
  >

  export const CodeScanningAnalysisSarifIdSchema = z
    .string()
    .describe('An identifier for the upload.')
  export type CodeScanningAnalysisSarifId = z.infer<
    typeof CodeScanningAnalysisSarifIdSchema
  >

  export const CodeScanningAnalysisDeletionSchema = z
    .object({
      next_analysis_url: z
        .string()
        .url()
        .describe(
          'Next deletable analysis in chain, without last analysis deletion confirmation'
        )
        .readonly(),
      confirm_delete_url: z
        .string()
        .url()
        .describe(
          'Next deletable analysis in chain, with last analysis deletion confirmation'
        )
        .readonly()
    })
    .describe('Successful deletion of a code scanning analysis')
  export type CodeScanningAnalysisDeletion = z.infer<
    typeof CodeScanningAnalysisDeletionSchema
  >

  export const CodeScanningVariantAnalysisLanguageSchema = z
    .enum([
      'cpp',
      'csharp',
      'go',
      'java',
      'javascript',
      'python',
      'ruby',
      'swift'
    ])
    .describe('The language targeted by the CodeQL query')
  export type CodeScanningVariantAnalysisLanguage = z.infer<
    typeof CodeScanningVariantAnalysisLanguageSchema
  >

  export const CodeScanningVariantAnalysisRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      name: z.string().describe('The name of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique, name of the repository.'),
      private: z.boolean().describe('Whether the repository is private.'),
      stargazers_count: z.number().int(),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Repository Identifier')
  export type CodeScanningVariantAnalysisRepository = z.infer<
    typeof CodeScanningVariantAnalysisRepositorySchema
  >

  export const CodeScanningVariantAnalysisStatusSchema = z
    .enum([
      'pending',
      'in_progress',
      'succeeded',
      'failed',
      'canceled',
      'timed_out'
    ])
    .describe('The new status of the CodeQL variant analysis repository task.')
  export type CodeScanningVariantAnalysisStatus = z.infer<
    typeof CodeScanningVariantAnalysisStatusSchema
  >

  export const CodeScanningDefaultSetupSchema = z
    .object({
      state: z
        .enum(['configured', 'not-configured'])
        .describe('Code scanning default setup has been configured or not.')
        .optional(),
      languages: z
        .array(
          z.enum([
            'actions',
            'c-cpp',
            'csharp',
            'go',
            'java-kotlin',
            'javascript-typescript',
            'javascript',
            'python',
            'ruby',
            'typescript',
            'swift'
          ])
        )
        .describe('Languages to be analyzed.')
        .optional(),
      runner_type: z
        .enum(['standard', 'labeled'])
        .describe('Runner type to be used.')
        .optional(),
      runner_label: z
        .string()
        .describe('Runner label to be used if the runner type is labeled.')
        .optional(),
      query_suite: z
        .enum(['default', 'extended'])
        .describe('CodeQL query suite to be used.')
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of latest configuration update.')
        .optional(),
      schedule: z
        .literal('weekly')
        .describe('The frequency of the periodic analysis.')
        .optional()
    })
    .describe('Configuration for code scanning default setup.')
  export type CodeScanningDefaultSetup = z.infer<
    typeof CodeScanningDefaultSetupSchema
  >

  export const CodeScanningDefaultSetupUpdateSchema = z
    .object({
      state: z
        .enum(['configured', 'not-configured'])
        .describe('The desired state of code scanning default setup.')
        .optional(),
      runner_type: z
        .enum(['standard', 'labeled'])
        .describe('Runner type to be used.')
        .optional(),
      runner_label: z
        .string()
        .describe('Runner label to be used if the runner type is labeled.')
        .optional(),
      query_suite: z
        .enum(['default', 'extended'])
        .describe('CodeQL query suite to be used.')
        .optional(),
      languages: z
        .array(
          z.enum([
            'actions',
            'c-cpp',
            'csharp',
            'go',
            'java-kotlin',
            'javascript-typescript',
            'python',
            'ruby',
            'swift'
          ])
        )
        .describe('CodeQL languages to be analyzed.')
        .optional()
    })
    .strict()
    .describe('Configuration for code scanning default setup.')
  export type CodeScanningDefaultSetupUpdate = z.infer<
    typeof CodeScanningDefaultSetupUpdateSchema
  >

  export const CodeScanningRefFullSchema = z
    .string()
    .regex(new RegExp('^refs/(heads|tags|pull)/.*$'))
    .describe(
      'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.'
    )
  export type CodeScanningRefFull = z.infer<typeof CodeScanningRefFullSchema>

  export const CodeScanningAnalysisSarifFileSchema = z
    .string()
    .describe(
      'A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."'
    )
  export type CodeScanningAnalysisSarifFile = z.infer<
    typeof CodeScanningAnalysisSarifFileSchema
  >

  export const CodeScanningSarifsStatusSchema = z.object({
    processing_status: z
      .enum(['pending', 'complete', 'failed'])
      .describe(
        '`pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.'
      )
      .optional(),
    analyses_url: z
      .string()
      .url()
      .describe(
        'The REST API URL for getting the analyses associated with the upload.'
      )
      .readonly()
      .optional(),
    errors: z
      .array(z.string())
      .describe('Any errors that ocurred during processing of the delivery.')
      .readonly()
      .optional()
  })
  export type CodeScanningSarifsStatus = z.infer<
    typeof CodeScanningSarifsStatusSchema
  >

  export const CodeownersErrorsSchema = z
    .object({
      errors: z.array(
        z.object({
          line: z
            .number()
            .int()
            .describe('The line number where this errors occurs.'),
          column: z
            .number()
            .int()
            .describe('The column number where this errors occurs.'),
          source: z
            .string()
            .describe('The contents of the line where the error occurs.')
            .optional(),
          kind: z.string().describe('The type of error.'),
          suggestion: z
            .string()
            .describe(
              'Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.'
            )
            .optional(),
          message: z
            .string()
            .describe(
              'A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).'
            ),
          path: z
            .string()
            .describe('The path of the file where the error occured.')
        })
      )
    })
    .describe("A list of errors found in a repo's CODEOWNERS file")
  export type CodeownersErrors = z.infer<typeof CodeownersErrorsSchema>

  export const CodespaceMachineSchema = z
    .object({
      name: z.string().describe('The name of the machine.'),
      display_name: z
        .string()
        .describe(
          'The display name of the machine includes cores, memory, and storage.'
        ),
      operating_system: z
        .string()
        .describe('The operating system of the machine.'),
      storage_in_bytes: z
        .number()
        .int()
        .describe('How much storage is available to the codespace.'),
      memory_in_bytes: z
        .number()
        .int()
        .describe('How much memory is available to the codespace.'),
      cpus: z
        .number()
        .int()
        .describe('How many cores are available to the codespace.'),
      prebuild_availability: z
        .enum(['none', 'ready', 'in_progress'])
        .describe(
          'Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.'
        )
    })
    .describe('A description of the machine powering a codespace.')
  export type CodespaceMachine = z.infer<typeof CodespaceMachineSchema>

  export const CodespacesPermissionsCheckForDevcontainerSchema = z
    .object({
      accepted: z
        .boolean()
        .describe(
          'Whether the user has accepted the permissions defined by the devcontainer config'
        )
    })
    .describe('Permission check result for a given devcontainer config.')
  export type CodespacesPermissionsCheckForDevcontainer = z.infer<
    typeof CodespacesPermissionsCheckForDevcontainerSchema
  >

  export const RepoCodespacesSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set repository secrets for GitHub Codespaces.')
  export type RepoCodespacesSecret = z.infer<typeof RepoCodespacesSecretSchema>

  export const CollaboratorSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional(),
          admin: z.boolean()
        })
        .optional(),
      role_name: z.string(),
      user_view_type: z.string().optional()
    })
    .describe('Collaborator')
  export type Collaborator = z.infer<typeof CollaboratorSchema>

  export const NullableCollaboratorSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional(),
          admin: z.boolean()
        })
        .optional(),
      role_name: z.string(),
      user_view_type: z.string().optional()
    })
    .describe('Collaborator')
  export type NullableCollaborator = z.infer<typeof NullableCollaboratorSchema>

  export const BranchShortSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string() }),
      protected: z.boolean()
    })
    .describe('Branch Short')
  export type BranchShort = z.infer<typeof BranchShortSchema>

  export const CommitShaSchema = z.any().describe('The SHA of the commit.')
  export type CommitSha = z.infer<typeof CommitShaSchema>

  export const LinkSchema = z
    .object({ href: z.string() })
    .describe('Hypermedia Link')
  export type Link = z.infer<typeof LinkSchema>

  export const CommitRefSchema = z
    .any()
    .describe(
      'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
    )
  export type CommitRef = z.infer<typeof CommitRefSchema>

  export const SimpleCommitStatusSchema = z.object({
    description: z.string(),
    id: z.number().int(),
    node_id: z.string(),
    state: z.string(),
    context: z.string(),
    target_url: z.string().url(),
    required: z.boolean().optional(),
    avatar_url: z.string().url(),
    url: z.string().url(),
    created_at: z.string().datetime({ offset: true }),
    updated_at: z.string().datetime({ offset: true })
  })
  export type SimpleCommitStatus = z.infer<typeof SimpleCommitStatusSchema>

  export const NullableCodeOfConductSimpleSchema = z
    .object({
      url: z.string().url(),
      key: z.string(),
      name: z.string(),
      html_url: z.string().url()
    })
    .describe('Code of Conduct Simple')
  export type NullableCodeOfConductSimple = z.infer<
    typeof NullableCodeOfConductSimpleSchema
  >

  export const NullableCommunityHealthFileSchema = z.object({
    url: z.string().url(),
    html_url: z.string().url()
  })
  export type NullableCommunityHealthFile = z.infer<
    typeof NullableCommunityHealthFileSchema
  >

  export const ContentDirectorySchema = z
    .array(
      z.object({
        type: z.enum(['dir', 'file', 'submodule', 'symlink']),
        size: z.number().int(),
        name: z.string(),
        path: z.string(),
        content: z.string().optional(),
        sha: z.string(),
        url: z.string().url(),
        git_url: z.string().url(),
        html_url: z.string().url(),
        download_url: z.string().url(),
        _links: z.object({
          git: z.string().url(),
          html: z.string().url(),
          self: z.string().url()
        })
      })
    )
    .describe('A list of directory items')
  export type ContentDirectory = z.infer<typeof ContentDirectorySchema>

  export const ContentFileSchema = z
    .object({
      type: z.literal('file'),
      encoding: z.string(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      content: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      }),
      target: z.string().optional(),
      submodule_git_url: z.string().optional()
    })
    .describe('Content File')
  export type ContentFile = z.infer<typeof ContentFileSchema>

  export const ContentSymlinkSchema = z
    .object({
      type: z.literal('symlink'),
      target: z.string(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      })
    })
    .describe('An object describing a symlink')
  export type ContentSymlink = z.infer<typeof ContentSymlinkSchema>

  export const ContentSubmoduleSchema = z
    .object({
      type: z.literal('submodule'),
      submodule_git_url: z.string().url(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      })
    })
    .describe('An object describing a submodule')
  export type ContentSubmodule = z.infer<typeof ContentSubmoduleSchema>

  export const FileCommitSchema = z
    .object({
      content: z.object({
        name: z.string().optional(),
        path: z.string().optional(),
        sha: z.string().optional(),
        size: z.number().int().optional(),
        url: z.string().optional(),
        html_url: z.string().optional(),
        git_url: z.string().optional(),
        download_url: z.string().optional(),
        type: z.string().optional(),
        _links: z
          .object({
            self: z.string().optional(),
            git: z.string().optional(),
            html: z.string().optional()
          })
          .optional()
      }),
      commit: z.object({
        sha: z.string().optional(),
        node_id: z.string().optional(),
        url: z.string().optional(),
        html_url: z.string().optional(),
        author: z
          .object({
            date: z.string().optional(),
            name: z.string().optional(),
            email: z.string().optional()
          })
          .optional(),
        committer: z
          .object({
            date: z.string().optional(),
            name: z.string().optional(),
            email: z.string().optional()
          })
          .optional(),
        message: z.string().optional(),
        tree: z
          .object({ url: z.string().optional(), sha: z.string().optional() })
          .optional(),
        parents: z
          .array(
            z.object({
              url: z.string().optional(),
              html_url: z.string().optional(),
              sha: z.string().optional()
            })
          )
          .optional(),
        verification: z
          .object({
            verified: z.boolean().optional(),
            reason: z.string().optional(),
            signature: z.string().optional(),
            payload: z.string().optional(),
            verified_at: z.string().optional()
          })
          .optional()
      })
    })
    .describe('File Commit')
  export type FileCommit = z.infer<typeof FileCommitSchema>

  export const ContributorSchema = z
    .object({
      login: z.string().optional(),
      id: z.number().int().optional(),
      node_id: z.string().optional(),
      avatar_url: z.string().url().optional(),
      gravatar_id: z.string().optional(),
      url: z.string().url().optional(),
      html_url: z.string().url().optional(),
      followers_url: z.string().url().optional(),
      following_url: z.string().optional(),
      gists_url: z.string().optional(),
      starred_url: z.string().optional(),
      subscriptions_url: z.string().url().optional(),
      organizations_url: z.string().url().optional(),
      repos_url: z.string().url().optional(),
      events_url: z.string().optional(),
      received_events_url: z.string().url().optional(),
      type: z.string(),
      site_admin: z.boolean().optional(),
      contributions: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('Contributor')
  export type Contributor = z.infer<typeof ContributorSchema>

  export const DependabotAlertCommaSeparatedManifestsSchema = z
    .any()
    .describe(
      'A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.'
    )
  export type DependabotAlertCommaSeparatedManifests = z.infer<
    typeof DependabotAlertCommaSeparatedManifestsSchema
  >

  export const DependabotSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set secrets for Dependabot.')
  export type DependabotSecret = z.infer<typeof DependabotSecretSchema>

  export const DependencyGraphDiffSchema = z
    .array(
      z.object({
        change_type: z.enum(['added', 'removed']),
        manifest: z.string(),
        ecosystem: z.string(),
        name: z.string(),
        version: z.string(),
        package_url: z.string(),
        license: z.string(),
        source_repository_url: z.string(),
        vulnerabilities: z.array(
          z.object({
            severity: z.string(),
            advisory_ghsa_id: z.string(),
            advisory_summary: z.string(),
            advisory_url: z.string()
          })
        ),
        scope: z
          .enum(['unknown', 'runtime', 'development'])
          .describe(
            'Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.'
          )
      })
    )
    .describe('A diff of the dependencies between two commits.')
  export type DependencyGraphDiff = z.infer<typeof DependencyGraphDiffSchema>

  export const ManifestPathSchema = z
    .any()
    .describe(
      'The full path, relative to the repository root, of the dependency manifest file.'
    )
  export type ManifestPath = z.infer<typeof ManifestPathSchema>

  export const DependencyGraphSpdxSbomSchema = z
    .object({
      sbom: z.object({
        SPDXID: z
          .string()
          .describe('The SPDX identifier for the SPDX document.'),
        spdxVersion: z
          .string()
          .describe(
            'The version of the SPDX specification that this document conforms to.'
          ),
        comment: z
          .string()
          .describe('An optional comment about the SPDX document.')
          .optional(),
        creationInfo: z.object({
          created: z
            .string()
            .describe('The date and time the SPDX document was created.'),
          creators: z
            .array(z.string())
            .describe('The tools that were used to generate the SPDX document.')
        }),
        name: z.string().describe('The name of the SPDX document.'),
        dataLicense: z
          .string()
          .describe('The license under which the SPDX document is licensed.'),
        documentNamespace: z
          .string()
          .describe('The namespace for the SPDX document.'),
        packages: z.array(
          z.object({
            SPDXID: z
              .string()
              .describe('A unique SPDX identifier for the package.')
              .optional(),
            name: z.string().describe('The name of the package.').optional(),
            versionInfo: z
              .string()
              .describe(
                'The version of the package. If the package does not have an exact version specified,\na version range is given.'
              )
              .optional(),
            downloadLocation: z
              .string()
              .describe(
                'The location where the package can be downloaded,\nor NOASSERTION if this has not been determined.'
              )
              .optional(),
            filesAnalyzed: z
              .boolean()
              .describe(
                "Whether the package's file content has been subjected to\nanalysis during the creation of the SPDX document."
              )
              .optional(),
            licenseConcluded: z
              .string()
              .describe(
                'The license of the package as determined while creating the SPDX document.'
              )
              .optional(),
            licenseDeclared: z
              .string()
              .describe(
                'The license of the package as declared by its author, or NOASSERTION if this information\nwas not available when the SPDX document was created.'
              )
              .optional(),
            supplier: z
              .string()
              .describe(
                'The distribution source of this package, or NOASSERTION if this was not determined.'
              )
              .optional(),
            copyrightText: z
              .string()
              .describe(
                'The copyright holders of the package, and any dates present with those notices, if available.'
              )
              .optional(),
            externalRefs: z
              .array(
                z.object({
                  referenceCategory: z
                    .string()
                    .describe(
                      'The category of reference to an external resource this reference refers to.'
                    ),
                  referenceLocator: z
                    .string()
                    .describe(
                      'A locator for the particular external resource this reference refers to.'
                    ),
                  referenceType: z
                    .string()
                    .describe(
                      'The category of reference to an external resource this reference refers to.'
                    )
                })
              )
              .optional()
          })
        ),
        relationships: z
          .array(
            z.object({
              relationshipType: z
                .string()
                .describe(
                  'The type of relationship between the two SPDX elements.'
                )
                .optional(),
              spdxElementId: z
                .string()
                .describe(
                  'The SPDX identifier of the package that is the source of the relationship.'
                )
                .optional(),
              relatedSpdxElement: z
                .string()
                .describe(
                  'The SPDX identifier of the package that is the target of the relationship.'
                )
                .optional()
            })
          )
          .optional()
      })
    })
    .describe(
      'A schema for the SPDX JSON format returned by the Dependency Graph.'
    )
  export type DependencyGraphSpdxSbom = z.infer<
    typeof DependencyGraphSpdxSbomSchema
  >

  export const MetadataSchema = z
    .record(z.union([z.string(), z.number(), z.boolean()]))
    .describe(
      'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.'
    )
  export type Metadata = z.infer<typeof MetadataSchema>

  export const DeploymentIdSchema = z.any().describe('deployment_id parameter')
  export type DeploymentId = z.infer<typeof DeploymentIdSchema>

  export const WaitTimerSchema = z
    .number()
    .int()
    .describe(
      'The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).'
    )
  export type WaitTimer = z.infer<typeof WaitTimerSchema>

  export const DeploymentBranchPolicySettingsSchema = z
    .object({
      protected_branches: z
        .boolean()
        .describe(
          'Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.'
        ),
      custom_branch_policies: z
        .boolean()
        .describe(
          'Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.'
        )
    })
    .describe(
      'The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.'
    )
  export type DeploymentBranchPolicySettings = z.infer<
    typeof DeploymentBranchPolicySettingsSchema
  >

  export const EnvironmentNameSchema = z
    .any()
    .describe(
      'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
    )
  export type EnvironmentName = z.infer<typeof EnvironmentNameSchema>

  export const PreventSelfReviewSchema = z
    .boolean()
    .describe(
      'Whether or not a user who created the job is prevented from approving their own job.'
    )
  export type PreventSelfReview = z.infer<typeof PreventSelfReviewSchema>

  export const DeploymentBranchPolicySchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the branch or tag policy.')
        .optional(),
      node_id: z.string().optional(),
      name: z
        .string()
        .describe(
          'The name pattern that branches or tags must match in order to deploy to the environment.'
        )
        .optional(),
      type: z
        .enum(['branch', 'tag'])
        .describe('Whether this rule targets a branch or tag.')
        .optional()
    })
    .describe('Details of a deployment branch or tag policy.')
  export type DeploymentBranchPolicy = z.infer<
    typeof DeploymentBranchPolicySchema
  >

  export const DeploymentBranchPolicyNamePatternWithTypeSchema = z.object({
    name: z
      .string()
      .describe(
        'The name pattern that branches or tags must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).'
      ),
    type: z
      .enum(['branch', 'tag'])
      .describe('Whether this rule targets a branch or tag')
      .optional()
  })
  export type DeploymentBranchPolicyNamePatternWithType = z.infer<
    typeof DeploymentBranchPolicyNamePatternWithTypeSchema
  >

  export const BranchPolicyIdSchema = z
    .any()
    .describe('The unique identifier of the branch policy.')
  export type BranchPolicyId = z.infer<typeof BranchPolicyIdSchema>

  export const DeploymentBranchPolicyNamePatternSchema = z.object({
    name: z
      .string()
      .describe(
        'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).'
      )
  })
  export type DeploymentBranchPolicyNamePattern = z.infer<
    typeof DeploymentBranchPolicyNamePatternSchema
  >

  export const CustomDeploymentRuleAppSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the deployment protection rule integration.'
        ),
      slug: z
        .string()
        .describe(
          'The slugified name of the deployment protection rule integration.'
        ),
      integration_url: z
        .string()
        .describe('The URL for the endpoint to get details about the app.'),
      node_id: z
        .string()
        .describe('The node ID for the deployment protection rule integration.')
    })
    .describe(
      'A GitHub App that is providing a custom deployment protection rule.'
    )
  export type CustomDeploymentRuleApp = z.infer<
    typeof CustomDeploymentRuleAppSchema
  >

  export const DeploymentProtectionRulesSchema = z.any()
  export type DeploymentProtectionRules = z.infer<
    typeof DeploymentProtectionRulesSchema
  >

  export const ProtectionRuleIdSchema = z
    .any()
    .describe('The unique identifier of the protection rule.')
  export type ProtectionRuleId = z.infer<typeof ProtectionRuleIdSchema>

  export const ShortBlobSchema = z
    .object({ url: z.string(), sha: z.string() })
    .describe('Short Blob')
  export type ShortBlob = z.infer<typeof ShortBlobSchema>

  export const BlobSchema = z
    .object({
      content: z.string(),
      encoding: z.string(),
      url: z.string().url(),
      sha: z.string(),
      size: z.number().int(),
      node_id: z.string(),
      highlighted_content: z.string().optional()
    })
    .describe('Blob')
  export type Blob = z.infer<typeof BlobSchema>

  export const GitCommitSchema = z
    .object({
      sha: z.string().describe('SHA for the commit'),
      node_id: z.string(),
      url: z.string().url(),
      author: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      committer: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      tree: z.object({
        sha: z.string().describe('SHA for the commit'),
        url: z.string().url()
      }),
      parents: z.array(
        z.object({
          sha: z.string().describe('SHA for the commit'),
          url: z.string().url(),
          html_url: z.string().url()
        })
      ),
      verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.string(),
        payload: z.string(),
        verified_at: z.string()
      }),
      html_url: z.string().url()
    })
    .describe('Low-level Git commit operations within a repository')
  export type GitCommit = z.infer<typeof GitCommitSchema>

  export const GitRefSchema = z
    .any()
    .describe(
      'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
    )
  export type GitRef = z.infer<typeof GitRefSchema>

  export const GitRefOnlySchema = z
    .any()
    .describe(
      'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
    )
  export type GitRefOnly = z.infer<typeof GitRefOnlySchema>

  export const GitTreeSchema = z
    .object({
      sha: z.string(),
      url: z.string().url(),
      truncated: z.boolean(),
      tree: z
        .array(
          z.object({
            path: z.string().optional(),
            mode: z.string().optional(),
            type: z.string().optional(),
            sha: z.string().optional(),
            size: z.number().int().optional(),
            url: z.string().optional()
          })
        )
        .describe('Objects specifying a tree structure')
    })
    .describe('The hierarchy between files in a Git repository.')
  export type GitTree = z.infer<typeof GitTreeSchema>

  export const HookResponseSchema = z.object({
    code: z.number().int(),
    status: z.string(),
    message: z.string()
  })
  export type HookResponse = z.infer<typeof HookResponseSchema>

  export const ImportSchema = z
    .object({
      vcs: z.string(),
      use_lfs: z.boolean().optional(),
      vcs_url: z.string().describe('The URL of the originating repository.'),
      svc_root: z.string().optional(),
      tfvc_project: z.string().optional(),
      status: z.enum([
        'auth',
        'error',
        'none',
        'detecting',
        'choose',
        'auth_failed',
        'importing',
        'mapping',
        'waiting_to_push',
        'pushing',
        'complete',
        'setup',
        'unknown',
        'detection_found_multiple',
        'detection_found_nothing',
        'detection_needs_auth'
      ]),
      status_text: z.string().optional(),
      failed_step: z.string().optional(),
      error_message: z.string().optional(),
      import_percent: z.number().int().optional(),
      commit_count: z.number().int().optional(),
      push_percent: z.number().int().optional(),
      has_large_files: z.boolean().optional(),
      large_files_size: z.number().int().optional(),
      large_files_count: z.number().int().optional(),
      project_choices: z
        .array(
          z.object({
            vcs: z.string().optional(),
            tfvc_project: z.string().optional(),
            human_name: z.string().optional()
          })
        )
        .optional(),
      message: z.string().optional(),
      authors_count: z.number().int().optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      authors_url: z.string().url(),
      repository_url: z.string().url(),
      svn_root: z.string().optional()
    })
    .describe('A repository import from an external source.')
  export type Import = z.infer<typeof ImportSchema>

  export const PorterAuthorSchema = z
    .object({
      id: z.number().int(),
      remote_id: z.string(),
      remote_name: z.string(),
      email: z.string(),
      name: z.string(),
      url: z.string().url(),
      import_url: z.string().url()
    })
    .describe('Porter Author')
  export type PorterAuthor = z.infer<typeof PorterAuthorSchema>

  export const SinceUserSchema = z
    .any()
    .describe('A user ID. Only return users with an ID greater than this ID.')
  export type SinceUser = z.infer<typeof SinceUserSchema>

  export const PorterLargeFileSchema = z
    .object({
      ref_name: z.string(),
      path: z.string(),
      oid: z.string(),
      size: z.number().int()
    })
    .describe('Porter Large File')
  export type PorterLargeFile = z.infer<typeof PorterLargeFileSchema>

  export const IssueEventLabelSchema = z
    .object({ name: z.string(), color: z.string() })
    .describe('Issue Event Label')
  export type IssueEventLabel = z.infer<typeof IssueEventLabelSchema>

  export const IssueEventDismissedReviewSchema = z.object({
    state: z.string(),
    review_id: z.number().int(),
    dismissal_message: z.string(),
    dismissal_commit_id: z.string().optional()
  })
  export type IssueEventDismissedReview = z.infer<
    typeof IssueEventDismissedReviewSchema
  >

  export const IssueEventMilestoneSchema = z
    .object({ title: z.string() })
    .describe('Issue Event Milestone')
  export type IssueEventMilestone = z.infer<typeof IssueEventMilestoneSchema>

  export const IssueEventProjectCardSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      project_url: z.string().url(),
      project_id: z.number().int(),
      column_name: z.string(),
      previous_column_name: z.string().optional()
    })
    .describe('Issue Event Project Card')
  export type IssueEventProjectCard = z.infer<
    typeof IssueEventProjectCardSchema
  >

  export const IssueEventRenameSchema = z
    .object({ from: z.string(), to: z.string() })
    .describe('Issue Event Rename')
  export type IssueEventRename = z.infer<typeof IssueEventRenameSchema>

  export const IssueNumberSchema = z
    .any()
    .describe('The number that identifies the issue.')
  export type IssueNumber = z.infer<typeof IssueNumberSchema>

  export const LabelSchema = z
    .object({
      id: z.number().int().describe('Unique identifier for the label.'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the label'),
      name: z.string().describe('The name of the label.'),
      description: z
        .string()
        .describe('Optional description of the label, such as its purpose.'),
      color: z
        .string()
        .describe(
          '6-character hex code, without the leading #, identifying the color'
        ),
      default: z
        .boolean()
        .describe('Whether this label comes by default in a new repository.')
    })
    .describe(
      'Color-coded labels help you categorize and filter your issues (just like labels in Gmail).'
    )
  export type Label = z.infer<typeof LabelSchema>

  export const TimelineCommittedEventSchema = z
    .object({
      event: z.string().optional(),
      sha: z.string().describe('SHA for the commit'),
      node_id: z.string(),
      url: z.string().url(),
      author: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      committer: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      tree: z.object({
        sha: z.string().describe('SHA for the commit'),
        url: z.string().url()
      }),
      parents: z.array(
        z.object({
          sha: z.string().describe('SHA for the commit'),
          url: z.string().url(),
          html_url: z.string().url()
        })
      ),
      verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.string(),
        payload: z.string(),
        verified_at: z.string()
      }),
      html_url: z.string().url()
    })
    .describe('Timeline Committed Event')
  export type TimelineCommittedEvent = z.infer<
    typeof TimelineCommittedEventSchema
  >

  export const DeployKeySchema = z
    .object({
      id: z.number().int(),
      key: z.string(),
      url: z.string(),
      title: z.string(),
      verified: z.boolean(),
      created_at: z.string(),
      read_only: z.boolean(),
      added_by: z.string().optional(),
      last_used: z.string().optional(),
      enabled: z.boolean().optional()
    })
    .describe('An SSH key granting access to a single repository.')
  export type DeployKey = z.infer<typeof DeployKeySchema>

  export const KeyIdSchema = z
    .any()
    .describe('The unique identifier of the key.')
  export type KeyId = z.infer<typeof KeyIdSchema>

  export const LanguageSchema = z.record(z.number().int()).describe('Language')
  export type Language = z.infer<typeof LanguageSchema>

  export const MergedUpstreamSchema = z
    .object({
      message: z.string().optional(),
      merge_type: z.enum(['merge', 'fast-forward', 'none']).optional(),
      base_branch: z.string().optional()
    })
    .describe('Results of a successful merge upstream request')
  export type MergedUpstream = z.infer<typeof MergedUpstreamSchema>

  export const MilestoneNumberSchema = z
    .any()
    .describe('The number that identifies the milestone.')
  export type MilestoneNumber = z.infer<typeof MilestoneNumberSchema>

  export const PagesSourceHashSchema = z.object({
    branch: z.string(),
    path: z.string()
  })
  export type PagesSourceHash = z.infer<typeof PagesSourceHashSchema>

  export const PagesHttpsCertificateSchema = z.object({
    state: z.enum([
      'new',
      'authorization_created',
      'authorization_pending',
      'authorized',
      'authorization_revoked',
      'issued',
      'uploaded',
      'approved',
      'errored',
      'bad_authz',
      'destroy_pending',
      'dns_changed'
    ]),
    description: z.string(),
    domains: z
      .array(z.string())
      .describe(
        'Array of the domain set and its alternate name (if it is configured)'
      ),
    expires_at: z.string().date().optional()
  })
  export type PagesHttpsCertificate = z.infer<
    typeof PagesHttpsCertificateSchema
  >

  export const PageBuildStatusSchema = z
    .object({ url: z.string().url(), status: z.string() })
    .describe('Page Build Status')
  export type PageBuildStatus = z.infer<typeof PageBuildStatusSchema>

  export const PageDeploymentSchema = z
    .object({
      id: z
        .union([z.number().int(), z.string()])
        .describe(
          'The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.'
        ),
      status_url: z
        .string()
        .url()
        .describe('The URI to monitor GitHub Pages deployment status.'),
      page_url: z
        .string()
        .url()
        .describe('The URI to the deployed GitHub Pages.'),
      preview_url: z
        .string()
        .url()
        .describe('The URI to the deployed GitHub Pages preview.')
        .optional()
    })
    .describe('The GitHub Pages deployment status.')
  export type PageDeployment = z.infer<typeof PageDeploymentSchema>

  export const PagesDeploymentStatusSchema = z.object({
    status: z
      .enum([
        'deployment_in_progress',
        'syncing_files',
        'finished_file_sync',
        'updating_pages',
        'purging_cdn',
        'deployment_cancelled',
        'deployment_failed',
        'deployment_content_failed',
        'deployment_attempt_error',
        'deployment_lost',
        'succeed'
      ])
      .describe('The current status of the deployment.')
      .optional()
  })
  export type PagesDeploymentStatus = z.infer<
    typeof PagesDeploymentStatusSchema
  >

  export const PagesDeploymentIdSchema = z
    .any()
    .describe(
      'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
    )
  export type PagesDeploymentId = z.infer<typeof PagesDeploymentIdSchema>

  export const PagesHealthCheckSchema = z
    .object({
      domain: z
        .object({
          host: z.string().optional(),
          uri: z.string().optional(),
          nameservers: z.string().optional(),
          dns_resolves: z.boolean().optional(),
          is_proxied: z.boolean().optional(),
          is_cloudflare_ip: z.boolean().optional(),
          is_fastly_ip: z.boolean().optional(),
          is_old_ip_address: z.boolean().optional(),
          is_a_record: z.boolean().optional(),
          has_cname_record: z.boolean().optional(),
          has_mx_records_present: z.boolean().optional(),
          is_valid_domain: z.boolean().optional(),
          is_apex_domain: z.boolean().optional(),
          should_be_a_record: z.boolean().optional(),
          is_cname_to_github_user_domain: z.boolean().optional(),
          is_cname_to_pages_dot_github_dot_com: z.boolean().optional(),
          is_cname_to_fastly: z.boolean().optional(),
          is_pointed_to_github_pages_ip: z.boolean().optional(),
          is_non_github_pages_ip_present: z.boolean().optional(),
          is_pages_domain: z.boolean().optional(),
          is_served_by_pages: z.boolean().optional(),
          is_valid: z.boolean().optional(),
          reason: z.string().optional(),
          responds_to_https: z.boolean().optional(),
          enforces_https: z.boolean().optional(),
          https_error: z.string().optional(),
          is_https_eligible: z.boolean().optional(),
          caa_error: z.string().optional()
        })
        .optional(),
      alt_domain: z
        .object({
          host: z.string().optional(),
          uri: z.string().optional(),
          nameservers: z.string().optional(),
          dns_resolves: z.boolean().optional(),
          is_proxied: z.boolean().optional(),
          is_cloudflare_ip: z.boolean().optional(),
          is_fastly_ip: z.boolean().optional(),
          is_old_ip_address: z.boolean().optional(),
          is_a_record: z.boolean().optional(),
          has_cname_record: z.boolean().optional(),
          has_mx_records_present: z.boolean().optional(),
          is_valid_domain: z.boolean().optional(),
          is_apex_domain: z.boolean().optional(),
          should_be_a_record: z.boolean().optional(),
          is_cname_to_github_user_domain: z.boolean().optional(),
          is_cname_to_pages_dot_github_dot_com: z.boolean().optional(),
          is_cname_to_fastly: z.boolean().optional(),
          is_pointed_to_github_pages_ip: z.boolean().optional(),
          is_non_github_pages_ip_present: z.boolean().optional(),
          is_pages_domain: z.boolean().optional(),
          is_served_by_pages: z.boolean().optional(),
          is_valid: z.boolean().optional(),
          reason: z.string().optional(),
          responds_to_https: z.boolean().optional(),
          enforces_https: z.boolean().optional(),
          https_error: z.string().optional(),
          is_https_eligible: z.boolean().optional(),
          caa_error: z.string().optional()
        })
        .optional()
    })
    .describe('Pages Health Check Status')
  export type PagesHealthCheck = z.infer<typeof PagesHealthCheckSchema>

  export const PullNumberSchema = z
    .any()
    .describe('The number that identifies the pull request.')
  export type PullNumber = z.infer<typeof PullNumberSchema>

  export const PullRequestMergeResultSchema = z
    .object({ sha: z.string(), merged: z.boolean(), message: z.string() })
    .describe('Pull Request Merge Result')
  export type PullRequestMergeResult = z.infer<
    typeof PullRequestMergeResultSchema
  >

  export const ReviewIdSchema = z
    .any()
    .describe('The unique identifier of the review.')
  export type ReviewId = z.infer<typeof ReviewIdSchema>

  export const AssetIdSchema = z
    .any()
    .describe('The unique identifier of the asset.')
  export type AssetId = z.infer<typeof AssetIdSchema>

  export const ReleaseNotesContentSchema = z
    .object({
      name: z.string().describe('The generated name of the release'),
      body: z
        .string()
        .describe(
          'The generated body describing the contents of the release supporting markdown formatting'
        )
    })
    .describe('Generated name and body describing a release')
  export type ReleaseNotesContent = z.infer<typeof ReleaseNotesContentSchema>

  export const ReleaseIdSchema = z
    .any()
    .describe('The unique identifier of the release.')
  export type ReleaseId = z.infer<typeof ReleaseIdSchema>

  export const RepositoryRuleRulesetInfoSchema = z
    .any()
    .describe(
      'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.'
    )
  export type RepositoryRuleRulesetInfo = z.infer<
    typeof RepositoryRuleRulesetInfoSchema
  >

  export const SecretScanningAlertResolutionCommentSchema = z
    .string()
    .describe(
      'An optional comment when closing an alert. Cannot be updated or deleted. Must be `null` when changing `state` to `open`.'
    )
  export type SecretScanningAlertResolutionComment = z.infer<
    typeof SecretScanningAlertResolutionCommentSchema
  >

  export const SecretScanningLocationCommitSchema = z
    .object({
      path: z.string().describe('The file path in the repository'),
      start_line: z
        .number()
        .describe('Line number at which the secret starts in the file'),
      end_line: z
        .number()
        .describe('Line number at which the secret ends in the file'),
      start_column: z
        .number()
        .describe(
          'The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII'
        ),
      end_column: z
        .number()
        .describe(
          'The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII'
        ),
      blob_sha: z.string().describe('SHA-1 hash ID of the associated blob'),
      blob_url: z
        .string()
        .describe('The API URL to get the associated blob resource'),
      commit_sha: z.string().describe('SHA-1 hash ID of the associated commit'),
      commit_url: z
        .string()
        .describe('The API URL to get the associated commit resource')
    })
    .describe(
      "Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository."
    )
  export type SecretScanningLocationCommit = z.infer<
    typeof SecretScanningLocationCommitSchema
  >

  export const SecretScanningLocationWikiCommitSchema = z
    .object({
      path: z.string().describe('The file path of the wiki page'),
      start_line: z
        .number()
        .describe('Line number at which the secret starts in the file'),
      end_line: z
        .number()
        .describe('Line number at which the secret ends in the file'),
      start_column: z
        .number()
        .describe(
          'The column at which the secret starts within the start line when the file is interpreted as 8-bit ASCII.'
        ),
      end_column: z
        .number()
        .describe(
          'The column at which the secret ends within the end line when the file is interpreted as 8-bit ASCII.'
        ),
      blob_sha: z.string().describe('SHA-1 hash ID of the associated blob'),
      page_url: z
        .string()
        .describe('The GitHub URL to get the associated wiki page'),
      commit_sha: z.string().describe('SHA-1 hash ID of the associated commit'),
      commit_url: z
        .string()
        .describe('The GitHub URL to get the associated wiki commit')
    })
    .describe(
      "Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki."
    )
  export type SecretScanningLocationWikiCommit = z.infer<
    typeof SecretScanningLocationWikiCommitSchema
  >

  export const SecretScanningLocationIssueTitleSchema = z
    .object({
      issue_title_url: z
        .string()
        .url()
        .describe('The API URL to get the issue where the secret was detected.')
    })
    .describe(
      "Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue."
    )
  export type SecretScanningLocationIssueTitle = z.infer<
    typeof SecretScanningLocationIssueTitleSchema
  >

  export const SecretScanningLocationIssueBodySchema = z
    .object({
      issue_body_url: z
        .string()
        .url()
        .describe('The API URL to get the issue where the secret was detected.')
    })
    .describe(
      "Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue."
    )
  export type SecretScanningLocationIssueBody = z.infer<
    typeof SecretScanningLocationIssueBodySchema
  >

  export const SecretScanningLocationIssueCommentSchema = z
    .object({
      issue_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the issue comment where the secret was detected.'
        )
    })
    .describe(
      "Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue."
    )
  export type SecretScanningLocationIssueComment = z.infer<
    typeof SecretScanningLocationIssueCommentSchema
  >

  export const SecretScanningLocationDiscussionTitleSchema = z
    .object({
      discussion_title_url: z
        .string()
        .url()
        .describe('The URL to the discussion where the secret was detected.')
    })
    .describe(
      "Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion."
    )
  export type SecretScanningLocationDiscussionTitle = z.infer<
    typeof SecretScanningLocationDiscussionTitleSchema
  >

  export const SecretScanningLocationDiscussionBodySchema = z
    .object({
      discussion_body_url: z
        .string()
        .url()
        .describe('The URL to the discussion where the secret was detected.')
    })
    .describe(
      "Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion."
    )
  export type SecretScanningLocationDiscussionBody = z.infer<
    typeof SecretScanningLocationDiscussionBodySchema
  >

  export const SecretScanningLocationDiscussionCommentSchema = z
    .object({
      discussion_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the discussion comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion."
    )
  export type SecretScanningLocationDiscussionComment = z.infer<
    typeof SecretScanningLocationDiscussionCommentSchema
  >

  export const SecretScanningLocationPullRequestTitleSchema = z
    .object({
      pull_request_title_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request."
    )
  export type SecretScanningLocationPullRequestTitle = z.infer<
    typeof SecretScanningLocationPullRequestTitleSchema
  >

  export const SecretScanningLocationPullRequestBodySchema = z
    .object({
      pull_request_body_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request."
    )
  export type SecretScanningLocationPullRequestBody = z.infer<
    typeof SecretScanningLocationPullRequestBodySchema
  >

  export const SecretScanningLocationPullRequestCommentSchema = z
    .object({
      pull_request_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request."
    )
  export type SecretScanningLocationPullRequestComment = z.infer<
    typeof SecretScanningLocationPullRequestCommentSchema
  >

  export const SecretScanningLocationPullRequestReviewSchema = z
    .object({
      pull_request_review_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request review where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request."
    )
  export type SecretScanningLocationPullRequestReview = z.infer<
    typeof SecretScanningLocationPullRequestReviewSchema
  >

  export const SecretScanningLocationPullRequestReviewCommentSchema = z
    .object({
      pull_request_review_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request review comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request."
    )
  export type SecretScanningLocationPullRequestReviewComment = z.infer<
    typeof SecretScanningLocationPullRequestReviewCommentSchema
  >

  export const SecretScanningPushProtectionBypassReasonSchema = z
    .enum(['false_positive', 'used_in_tests', 'will_fix_later'])
    .describe('The reason for bypassing push protection.')
  export type SecretScanningPushProtectionBypassReason = z.infer<
    typeof SecretScanningPushProtectionBypassReasonSchema
  >

  export const SecretScanningPushProtectionBypassPlaceholderIdSchema = z
    .string()
    .describe(
      'The ID of the push protection bypass placeholder. This value is returned on any push protected routes.'
    )
  export type SecretScanningPushProtectionBypassPlaceholderId = z.infer<
    typeof SecretScanningPushProtectionBypassPlaceholderIdSchema
  >

  export const SecretScanningScanSchema = z
    .object({
      type: z.string().describe('The type of scan').optional(),
      status: z
        .string()
        .describe(
          'The state of the scan. Either "completed", "running", or "pending"'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the scan was completed. Empty if the scan is running'
        )
        .optional(),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the scan was started. Empty if the scan is pending'
        )
        .optional()
    })
    .describe(
      'Information on a single scan performed by secret scanning on the repository'
    )
  export type SecretScanningScan = z.infer<typeof SecretScanningScanSchema>

  export const CodeFrequencyStatSchema = z
    .array(z.number().int())
    .describe('Code Frequency Stat')
  export type CodeFrequencyStat = z.infer<typeof CodeFrequencyStatSchema>

  export const CommitActivitySchema = z
    .object({
      days: z.array(z.number().int()),
      total: z.number().int(),
      week: z.number().int()
    })
    .describe('Commit Activity')
  export type CommitActivity = z.infer<typeof CommitActivitySchema>

  export const ParticipationStatsSchema = z.object({
    all: z.array(z.number().int()),
    owner: z.array(z.number().int())
  })
  export type ParticipationStats = z.infer<typeof ParticipationStatsSchema>

  export const RepositorySubscriptionSchema = z
    .object({
      subscribed: z
        .boolean()
        .describe(
          'Determines if notifications should be received from this repository.'
        ),
      ignored: z
        .boolean()
        .describe(
          'Determines if all notifications should be blocked from this repository.'
        ),
      reason: z.string(),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      repository_url: z.string().url()
    })
    .describe('Repository invitations let you manage who you collaborate with.')
  export type RepositorySubscription = z.infer<
    typeof RepositorySubscriptionSchema
  >

  export const TagSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string().url() }),
      zipball_url: z.string().url(),
      tarball_url: z.string().url(),
      node_id: z.string()
    })
    .describe('Tag')
  export type Tag = z.infer<typeof TagSchema>

  export const TagProtectionSchema = z
    .object({
      id: z.number().int().optional(),
      created_at: z.string().optional(),
      updated_at: z.string().optional(),
      enabled: z.boolean().optional(),
      pattern: z.string()
    })
    .describe('Tag protection')
  export type TagProtection = z.infer<typeof TagProtectionSchema>

  export const TagProtectionIdSchema = z
    .any()
    .describe('The unique identifier of the tag protection.')
  export type TagProtectionId = z.infer<typeof TagProtectionIdSchema>

  export const TopicSchema = z
    .object({ names: z.array(z.string()) })
    .describe('A topic aggregates entities that are related to a subject.')
  export type Topic = z.infer<typeof TopicSchema>

  export const TrafficSchema = z.object({
    timestamp: z.string().datetime({ offset: true }),
    uniques: z.number().int(),
    count: z.number().int()
  })
  export type Traffic = z.infer<typeof TrafficSchema>

  export const PerSchema = z
    .any()
    .describe('The time frame to display results for.')
  export type Per = z.infer<typeof PerSchema>

  export const ContentTrafficSchema = z
    .object({
      path: z.string(),
      title: z.string(),
      count: z.number().int(),
      uniques: z.number().int()
    })
    .describe('Content Traffic')
  export type ContentTraffic = z.infer<typeof ContentTrafficSchema>

  export const ReferrerTrafficSchema = z
    .object({
      referrer: z.string(),
      count: z.number().int(),
      uniques: z.number().int()
    })
    .describe('Referrer Traffic')
  export type ReferrerTraffic = z.infer<typeof ReferrerTrafficSchema>

  export const SinceRepoSchema = z
    .any()
    .describe(
      'A repository ID. Only return repositories with an ID greater than this ID.'
    )
  export type SinceRepo = z.infer<typeof SinceRepoSchema>

  export const SearchResultTextMatchesSchema = z.array(
    z.object({
      object_url: z.string().optional(),
      object_type: z.string().optional(),
      property: z.string().optional(),
      fragment: z.string().optional(),
      matches: z
        .array(
          z.object({
            text: z.string().optional(),
            indices: z.array(z.number().int()).optional()
          })
        )
        .optional()
    })
  )
  export type SearchResultTextMatches = z.infer<
    typeof SearchResultTextMatchesSchema
  >

  export const OrderSchema = z
    .any()
    .describe(
      'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
    )
  export type Order = z.infer<typeof OrderSchema>

  export const IssuesAdvancedSearchSchema = z
    .any()
    .describe(
      'Set to `true` to use advanced search.\nExample: `http://api.github.com/search/issues?q={query}&advanced_search=true`'
    )
  export type IssuesAdvancedSearch = z.infer<typeof IssuesAdvancedSearchSchema>

  export const TeamIdSchema = z
    .any()
    .describe('The unique identifier of the team.')
  export type TeamId = z.infer<typeof TeamIdSchema>

  export const PrivateUserSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      user_view_type: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      name: z.string(),
      company: z.string(),
      blog: z.string(),
      location: z.string(),
      email: z.string().email(),
      notification_email: z.string().email().optional(),
      hireable: z.boolean(),
      bio: z.string(),
      twitter_username: z.string().optional(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      private_gists: z.number().int(),
      total_private_repos: z.number().int(),
      owned_private_repos: z.number().int(),
      disk_usage: z.number().int(),
      collaborators: z.number().int(),
      two_factor_authentication: z.boolean(),
      plan: z
        .object({
          collaborators: z.number().int(),
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int()
        })
        .optional(),
      business_plus: z.boolean().optional(),
      ldap_dn: z.string().optional()
    })
    .describe('Private User')
  export type PrivateUser = z.infer<typeof PrivateUserSchema>

  export const RepositoryIdInQuerySchema = z
    .any()
    .describe('ID of the Repository to filter on')
  export type RepositoryIdInQuery = z.infer<typeof RepositoryIdInQuerySchema>

  export const CodespacesSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'The type of repositories in the organization that the secret is visible to'
        ),
      selected_repositories_url: z
        .string()
        .url()
        .describe(
          'The API URL at which the list of repositories this secret is visible to can be retrieved'
        )
    })
    .describe('Secrets for a GitHub Codespace.')
  export type CodespacesSecret = z.infer<typeof CodespacesSecretSchema>

  export const CodespacesUserPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.')
    })
    .describe("The public key used for setting user Codespaces' Secrets.")
  export type CodespacesUserPublicKey = z.infer<
    typeof CodespacesUserPublicKeySchema
  >

  export const CodespaceExportDetailsSchema = z
    .object({
      state: z.string().describe('State of the latest export').optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe('Completion time of the last export operation')
        .optional(),
      branch: z.string().describe('Name of the exported branch').optional(),
      sha: z
        .string()
        .describe('Git commit SHA of the exported branch')
        .optional(),
      id: z.string().describe('Id for the export details').optional(),
      export_url: z
        .string()
        .describe('Url for fetching export details')
        .optional(),
      html_url: z
        .string()
        .describe('Web url for the exported branch')
        .optional()
    })
    .describe(
      'An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest'
    )
  export type CodespaceExportDetails = z.infer<
    typeof CodespaceExportDetailsSchema
  >

  export const ExportIdSchema = z
    .any()
    .describe(
      'The ID of the export operation, or `latest`. Currently only `latest` is currently supported.'
    )
  export type ExportId = z.infer<typeof ExportIdSchema>

  export const EmailSchema = z
    .object({
      email: z.string().email(),
      primary: z.boolean(),
      verified: z.boolean(),
      visibility: z.string()
    })
    .describe('Email')
  export type Email = z.infer<typeof EmailSchema>

  export const GpgKeySchema = z
    .object({
      id: z.number().int(),
      name: z.string().optional(),
      primary_key_id: z.number().int(),
      key_id: z.string(),
      public_key: z.string(),
      emails: z.array(
        z.object({
          email: z.string().optional(),
          verified: z.boolean().optional()
        })
      ),
      subkeys: z.array(
        z.object({
          id: z.number().int().optional(),
          primary_key_id: z.number().int().optional(),
          key_id: z.string().optional(),
          public_key: z.string().optional(),
          emails: z
            .array(
              z.object({
                email: z.string().optional(),
                verified: z.boolean().optional()
              })
            )
            .optional(),
          subkeys: z.array(z.any()).optional(),
          can_sign: z.boolean().optional(),
          can_encrypt_comms: z.boolean().optional(),
          can_encrypt_storage: z.boolean().optional(),
          can_certify: z.boolean().optional(),
          created_at: z.string().optional(),
          expires_at: z.string().optional(),
          raw_key: z.string().optional(),
          revoked: z.boolean().optional()
        })
      ),
      can_sign: z.boolean(),
      can_encrypt_comms: z.boolean(),
      can_encrypt_storage: z.boolean(),
      can_certify: z.boolean(),
      created_at: z.string().datetime({ offset: true }),
      expires_at: z.string().datetime({ offset: true }),
      revoked: z.boolean(),
      raw_key: z.string()
    })
    .describe('A unique encryption key')
  export type GpgKey = z.infer<typeof GpgKeySchema>

  export const GpgKeyIdSchema = z
    .any()
    .describe('The unique identifier of the GPG key.')
  export type GpgKeyId = z.infer<typeof GpgKeyIdSchema>

  export const KeySchema = z
    .object({
      key: z.string(),
      id: z.number().int(),
      url: z.string(),
      title: z.string(),
      created_at: z.string().datetime({ offset: true }),
      verified: z.boolean(),
      read_only: z.boolean()
    })
    .describe('Key')
  export type Key = z.infer<typeof KeySchema>

  export const MarketplaceAccountSchema = z.object({
    url: z.string().url(),
    id: z.number().int(),
    type: z.string(),
    node_id: z.string().optional(),
    login: z.string(),
    email: z.string().email().optional(),
    organization_billing_email: z.string().email().optional()
  })
  export type MarketplaceAccount = z.infer<typeof MarketplaceAccountSchema>

  export const SinceRepoDateSchema = z
    .any()
    .describe(
      'Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type SinceRepoDate = z.infer<typeof SinceRepoDateSchema>

  export const BeforeRepoDateSchema = z
    .any()
    .describe(
      'Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type BeforeRepoDate = z.infer<typeof BeforeRepoDateSchema>

  export const SocialAccountSchema = z
    .object({ provider: z.string(), url: z.string() })
    .describe('Social media account')
  export type SocialAccount = z.infer<typeof SocialAccountSchema>

  export const SshSigningKeySchema = z
    .object({
      key: z.string(),
      id: z.number().int(),
      title: z.string(),
      created_at: z.string().datetime({ offset: true })
    })
    .describe('A public SSH key used to sign Git commits')
  export type SshSigningKey = z.infer<typeof SshSigningKeySchema>

  export const SshSigningKeyIdSchema = z
    .any()
    .describe('The unique identifier of the SSH signing key.')
  export type SshSigningKeyId = z.infer<typeof SshSigningKeyIdSchema>

  export const SortStarredSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
    )
  export type SortStarred = z.infer<typeof SortStarredSchema>

  export const HovercardSchema = z
    .object({
      contexts: z.array(z.object({ message: z.string(), octicon: z.string() }))
    })
    .describe('Hovercard')
  export type Hovercard = z.infer<typeof HovercardSchema>

  export const KeySimpleSchema = z
    .object({ id: z.number().int(), key: z.string() })
    .describe('Key Simple')
  export type KeySimple = z.infer<typeof KeySimpleSchema>

  export const VulnerabilitySchema = z
    .object({
      package: z
        .object({
          ecosystem: SecurityAdvisoryEcosystemsSchema,
          name: z
            .string()
            .describe('The unique package name within its ecosystem.')
        })
        .describe('The name of the package affected by the vulnerability.'),
      vulnerable_version_range: z
        .string()
        .describe(
          'The range of the package versions affected by the vulnerability.'
        ),
      first_patched_version: z
        .string()
        .describe('The package version that resolves the vulnerability.'),
      vulnerable_functions: z
        .array(z.string())
        .describe(
          'The functions in the package that are affected by the vulnerability.'
        )
        .readonly()
    })
    .describe(
      'A vulnerability describing the product and its affected versions within a GitHub Security Advisory.'
    )
  export type Vulnerability = z.infer<typeof VulnerabilitySchema>

  export const ClassroomSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the classroom.'),
      name: z.string().describe('The name of the classroom.'),
      archived: z.boolean().describe('Whether classroom is archived.'),
      organization: SimpleClassroomOrganizationSchema,
      url: z.string().describe('The URL of the classroom on GitHub Classroom.')
    })
    .describe('A GitHub Classroom classroom')
  export type Classroom = z.infer<typeof ClassroomSchema>

  export const SimpleClassroomAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      public_repo: z
        .boolean()
        .describe(
          'Whether an accepted assignment creates a public repository.'
        ),
      title: z.string().describe('Assignment title.'),
      type: z
        .enum(['individual', 'group'])
        .describe("Whether it's a Group Assignment or Individual Assignment."),
      invite_link: z
        .string()
        .describe('The link that a student can use to accept the assignment.'),
      invitations_enabled: z
        .boolean()
        .describe(
          'Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.'
        ),
      slug: z.string().describe('Sluggified name of the assignment.'),
      students_are_repo_admins: z
        .boolean()
        .describe(
          'Whether students are admins on created repository on accepted assignment.'
        ),
      feedback_pull_requests_enabled: z
        .boolean()
        .describe(
          'Whether feedback pull request will be created on assignment acceptance.'
        ),
      max_teams: z
        .number()
        .int()
        .describe('The maximum allowable teams for the assignment.')
        .optional(),
      max_members: z
        .number()
        .int()
        .describe('The maximum allowable members per team.')
        .optional(),
      editor: z.string().describe('The selected editor for the assignment.'),
      accepted: z
        .number()
        .int()
        .describe('The number of students that have accepted the assignment.'),
      submitted: z
        .number()
        .int()
        .describe('The number of students that have submitted the assignment.'),
      passing: z
        .number()
        .int()
        .describe('The number of students that have passed the assignment.'),
      language: z
        .string()
        .describe('The programming language used in the assignment.'),
      deadline: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the assignment is due.'),
      classroom: SimpleClassroomSchema
    })
    .describe('A GitHub Classroom assignment')
  export type SimpleClassroomAssignment = z.infer<
    typeof SimpleClassroomAssignmentSchema
  >

  export const CodeSecurityDefaultConfigurationsSchema = z
    .array(
      z.object({
        default_for_new_repos: z
          .enum(['public', 'private_and_internal', 'all'])
          .describe(
            'The visibility of newly created repositories for which the code security configuration will be applied to by default'
          )
          .optional(),
        configuration: CodeSecurityConfigurationSchema.optional()
      })
    )
    .describe('A list of default code security configurations')
  export type CodeSecurityDefaultConfigurations = z.infer<
    typeof CodeSecurityDefaultConfigurationsSchema
  >

  export const SimpleRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      node_id: z.string().describe('The GraphQL identifier of the repository.'),
      name: z.string().describe('The name of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique, name of the repository.'),
      owner: SimpleUserSchema,
      private: z.boolean().describe('Whether the repository is private.'),
      html_url: z
        .string()
        .url()
        .describe('The URL to view the repository on GitHub.com.'),
      description: z.string().describe('The repository description.'),
      fork: z.boolean().describe('Whether the repository is a fork.'),
      url: z
        .string()
        .url()
        .describe(
          'The URL to get more information about the repository from the GitHub API.'
        ),
      archive_url: z
        .string()
        .describe(
          'A template for the API URL to download the repository as an archive.'
        ),
      assignees_url: z
        .string()
        .describe(
          'A template for the API URL to list the available assignees for issues in the repository.'
        ),
      blobs_url: z
        .string()
        .describe(
          'A template for the API URL to create or retrieve a raw Git blob in the repository.'
        ),
      branches_url: z
        .string()
        .describe(
          'A template for the API URL to get information about branches in the repository.'
        ),
      collaborators_url: z
        .string()
        .describe(
          'A template for the API URL to get information about collaborators of the repository.'
        ),
      comments_url: z
        .string()
        .describe(
          'A template for the API URL to get information about comments on the repository.'
        ),
      commits_url: z
        .string()
        .describe(
          'A template for the API URL to get information about commits on the repository.'
        ),
      compare_url: z
        .string()
        .describe('A template for the API URL to compare two commits or refs.'),
      contents_url: z
        .string()
        .describe(
          'A template for the API URL to get the contents of the repository.'
        ),
      contributors_url: z
        .string()
        .url()
        .describe(
          'A template for the API URL to list the contributors to the repository.'
        ),
      deployments_url: z
        .string()
        .url()
        .describe('The API URL to list the deployments of the repository.'),
      downloads_url: z
        .string()
        .url()
        .describe('The API URL to list the downloads on the repository.'),
      events_url: z
        .string()
        .url()
        .describe('The API URL to list the events of the repository.'),
      forks_url: z
        .string()
        .url()
        .describe('The API URL to list the forks of the repository.'),
      git_commits_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git commits of the repository.'
        ),
      git_refs_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git refs of the repository.'
        ),
      git_tags_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git tags of the repository.'
        ),
      issue_comment_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issue comments on the repository.'
        ),
      issue_events_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issue events on the repository.'
        ),
      issues_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issues on the repository.'
        ),
      keys_url: z
        .string()
        .describe(
          'A template for the API URL to get information about deploy keys on the repository.'
        ),
      labels_url: z
        .string()
        .describe(
          'A template for the API URL to get information about labels of the repository.'
        ),
      languages_url: z
        .string()
        .url()
        .describe(
          'The API URL to get information about the languages of the repository.'
        ),
      merges_url: z
        .string()
        .url()
        .describe('The API URL to merge branches in the repository.'),
      milestones_url: z
        .string()
        .describe(
          'A template for the API URL to get information about milestones of the repository.'
        ),
      notifications_url: z
        .string()
        .describe(
          'A template for the API URL to get information about notifications on the repository.'
        ),
      pulls_url: z
        .string()
        .describe(
          'A template for the API URL to get information about pull requests on the repository.'
        ),
      releases_url: z
        .string()
        .describe(
          'A template for the API URL to get information about releases on the repository.'
        ),
      stargazers_url: z
        .string()
        .url()
        .describe('The API URL to list the stargazers on the repository.'),
      statuses_url: z
        .string()
        .describe(
          'A template for the API URL to get information about statuses of a commit.'
        ),
      subscribers_url: z
        .string()
        .url()
        .describe('The API URL to list the subscribers on the repository.'),
      subscription_url: z
        .string()
        .url()
        .describe(
          'The API URL to subscribe to notifications for this repository.'
        ),
      tags_url: z
        .string()
        .url()
        .describe(
          'The API URL to get information about tags on the repository.'
        ),
      teams_url: z
        .string()
        .url()
        .describe('The API URL to list the teams on the repository.'),
      trees_url: z
        .string()
        .describe(
          'A template for the API URL to create or retrieve a raw Git tree of the repository.'
        ),
      hooks_url: z
        .string()
        .url()
        .describe('The API URL to list the hooks on the repository.')
    })
    .describe('A GitHub repository.')
  export type SimpleRepository = z.infer<typeof SimpleRepositorySchema>

  export const DependabotAlertSecurityVulnerabilitySchema = z
    .object({
      package: DependabotAlertPackageSchema,
      severity: z
        .enum(['low', 'medium', 'high', 'critical'])
        .describe('The severity of the vulnerability.')
        .readonly(),
      vulnerable_version_range: z
        .string()
        .describe(
          "Conditions that identify vulnerable versions of this vulnerability's package."
        )
        .readonly(),
      first_patched_version: z
        .object({
          identifier: z
            .string()
            .describe('The package version that patches this vulnerability.')
            .readonly()
        })
        .strict()
        .describe(
          'Details pertaining to the package version that patches this vulnerability.'
        )
        .readonly()
    })
    .strict()
    .describe(
      'Details pertaining to one vulnerable version range for the advisory.'
    )
    .readonly()
  export type DependabotAlertSecurityVulnerability = z.infer<
    typeof DependabotAlertSecurityVulnerabilitySchema
  >

  export const NullableMilestoneSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      labels_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int().describe('The number of the milestone.'),
      state: z
        .enum(['open', 'closed'])
        .describe('The state of the milestone.')
        .default('open'),
      title: z.string().describe('The title of the milestone.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      open_issues: z.number().int(),
      closed_issues: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      due_on: z.string().datetime({ offset: true })
    })
    .describe('A collection of related issues and pull requests.')
  export type NullableMilestone = z.infer<typeof NullableMilestoneSchema>

  export const FeedSchema = z
    .object({
      timeline_url: z.string(),
      user_url: z.string(),
      current_user_public_url: z.string().optional(),
      current_user_url: z.string().optional(),
      current_user_actor_url: z.string().optional(),
      current_user_organization_url: z.string().optional(),
      current_user_organization_urls: z.array(z.string().url()).optional(),
      security_advisories_url: z.string().optional(),
      repository_discussions_url: z
        .string()
        .describe('A feed of discussions for a given repository.')
        .optional(),
      repository_discussions_category_url: z
        .string()
        .describe('A feed of discussions for a given repository and category.')
        .optional(),
      _links: z.object({
        timeline: LinkWithTypeSchema,
        user: LinkWithTypeSchema,
        security_advisories: LinkWithTypeSchema.optional(),
        current_user: LinkWithTypeSchema.optional(),
        current_user_public: LinkWithTypeSchema.optional(),
        current_user_actor: LinkWithTypeSchema.optional(),
        current_user_organization: LinkWithTypeSchema.optional(),
        current_user_organizations: z.array(LinkWithTypeSchema).optional(),
        repository_discussions: LinkWithTypeSchema.optional(),
        repository_discussions_category: LinkWithTypeSchema.optional()
      })
    })
    .describe('Feed')
  export type Feed = z.infer<typeof FeedSchema>

  export const GistHistorySchema = z
    .object({
      user: NullableSimpleUserSchema.optional(),
      version: z.string().optional(),
      committed_at: z.string().datetime({ offset: true }).optional(),
      change_status: z
        .object({
          total: z.number().int().optional(),
          additions: z.number().int().optional(),
          deletions: z.number().int().optional()
        })
        .optional(),
      url: z.string().url().optional()
    })
    .describe('Gist History')
  export type GistHistory = z.infer<typeof GistHistorySchema>

  export const GistCommitSchema = z
    .object({
      url: z.string().url(),
      version: z.string(),
      user: NullableSimpleUserSchema,
      change_status: z.object({
        total: z.number().int().optional(),
        additions: z.number().int().optional(),
        deletions: z.number().int().optional()
      }),
      committed_at: z.string().datetime({ offset: true })
    })
    .describe('Gist Commit')
  export type GistCommit = z.infer<typeof GistCommitSchema>

  export const MarketplacePurchaseSchema = z
    .object({
      url: z.string(),
      type: z.string(),
      id: z.number().int(),
      login: z.string(),
      organization_billing_email: z.string().optional(),
      email: z.string().optional(),
      marketplace_pending_change: z
        .object({
          is_installed: z.boolean().optional(),
          effective_date: z.string().optional(),
          unit_count: z.number().int().optional(),
          id: z.number().int().optional(),
          plan: MarketplaceListingPlanSchema.optional()
        })
        .optional(),
      marketplace_purchase: z.object({
        billing_cycle: z.string().optional(),
        next_billing_date: z.string().optional(),
        is_installed: z.boolean().optional(),
        unit_count: z.number().int().optional(),
        on_free_trial: z.boolean().optional(),
        free_trial_ends_on: z.string().optional(),
        updated_at: z.string().optional(),
        plan: MarketplaceListingPlanSchema.optional()
      })
    })
    .describe('Marketplace Purchase')
  export type MarketplacePurchase = z.infer<typeof MarketplacePurchaseSchema>

  export const RunnerSchema = z
    .object({
      id: z.number().int().describe('The ID of the runner.'),
      runner_group_id: z
        .number()
        .int()
        .describe('The ID of the runner group.')
        .optional(),
      name: z.string().describe('The name of the runner.'),
      os: z.string().describe('The Operating System of the runner.'),
      status: z.string().describe('The status of the runner.'),
      busy: z.boolean(),
      labels: z.array(RunnerLabelSchema),
      ephemeral: z.boolean().optional()
    })
    .describe('A self hosted runner')
  export type Runner = z.infer<typeof RunnerSchema>

  export const ToolNameSchema = z
    .any()
    .describe(
      'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
    )
  export type ToolName = z.infer<typeof ToolNameSchema>

  export const ToolGuidSchema = z
    .any()
    .describe(
      'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
    )
  export type ToolGuid = z.infer<typeof ToolGuidSchema>

  export const CopilotOrganizationDetailsSchema = z
    .object({
      seat_breakdown: CopilotOrganizationSeatBreakdownSchema,
      public_code_suggestions: z
        .enum(['allow', 'block', 'unconfigured'])
        .describe(
          'The organization policy for allowing or blocking suggestions matching public code (duplication detection filter).'
        ),
      ide_chat: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot Chat in the IDE.'
        )
        .optional(),
      platform_chat: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot features on GitHub.com.'
        )
        .optional(),
      cli: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot in the CLI.'
        )
        .optional(),
      seat_management_setting: z
        .enum(['assign_all', 'assign_selected', 'disabled', 'unconfigured'])
        .describe('The mode of assigning new seats.'),
      plan_type: z
        .enum(['business', 'enterprise'])
        .describe(
          'The Copilot plan of the organization, or the parent enterprise, when applicable.'
        )
        .optional()
    })
    .catchall(z.any())
    .describe(
      'Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.'
    )
  export type CopilotOrganizationDetails = z.infer<
    typeof CopilotOrganizationDetailsSchema
  >

  export const TeamSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string(),
      privacy: z.string().optional(),
      notification_setting: z.string().optional(),
      permission: z.string(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean(),
          push: z.boolean(),
          maintain: z.boolean(),
          admin: z.boolean()
        })
        .optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type Team = z.infer<typeof TeamSchema>

  export const OrganizationInvitationSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      email: z.string(),
      role: z.string(),
      created_at: z.string(),
      failed_at: z.string().optional(),
      failed_reason: z.string().optional(),
      inviter: SimpleUserSchema,
      team_count: z.number().int(),
      node_id: z.string(),
      invitation_teams_url: z.string(),
      invitation_source: z.string().optional()
    })
    .describe('Organization Invitation')
  export type OrganizationInvitation = z.infer<
    typeof OrganizationInvitationSchema
  >

  export const InteractionLimitResponseSchema = z
    .object({
      limit: InteractionGroupSchema,
      origin: z.string(),
      expires_at: z.string().datetime({ offset: true })
    })
    .describe('Interaction limit settings.')
  export type InteractionLimitResponse = z.infer<
    typeof InteractionLimitResponseSchema
  >

  export const OrganizationRoleSchema = z
    .object({
      id: z.number().int().describe('The unique identifier of the role.'),
      name: z.string().describe('The name of the role.'),
      description: z
        .string()
        .describe(
          'A short description about who this role is for or what permissions it grants.'
        )
        .optional(),
      base_role: z
        .enum(['read', 'triage', 'write', 'maintain', 'admin'])
        .describe('The system role from which this role inherits permissions.')
        .optional(),
      source: z
        .enum(['Organization', 'Enterprise', 'Predefined'])
        .describe(
          'Source answers the question, "where did this role come from?"'
        )
        .optional(),
      permissions: z
        .array(z.string())
        .describe('A list of permissions included in this role.'),
      organization: NullableSimpleUserSchema,
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The date and time the role was created.'),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('The date and time the role was last updated.')
    })
    .describe('Organization roles')
  export type OrganizationRole = z.infer<typeof OrganizationRoleSchema>

  export const TeamRoleAssignmentSchema = z
    .object({
      assignment: z
        .enum(['direct', 'indirect', 'mixed'])
        .describe(
          'Determines if the team has a direct, indirect, or mixed relationship to a role'
        )
        .optional(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string(),
      privacy: z.string().optional(),
      notification_setting: z.string().optional(),
      permission: z.string(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean(),
          push: z.boolean(),
          maintain: z.boolean(),
          admin: z.boolean()
        })
        .optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema
    })
    .describe('The Relationship a Team has with a role.')
  export type TeamRoleAssignment = z.infer<typeof TeamRoleAssignmentSchema>

  export const UserRoleAssignmentSchema = z
    .object({
      assignment: z
        .enum(['direct', 'indirect', 'mixed'])
        .describe(
          'Determines if the user has a direct, indirect, or mixed relationship to a role'
        )
        .optional(),
      inherited_from: z
        .array(TeamSimpleSchema)
        .describe('Team the user has gotten the role through')
        .optional(),
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('The Relationship a User has with a role.')
  export type UserRoleAssignment = z.infer<typeof UserRoleAssignmentSchema>

  export const OrganizationProgrammaticAccessGrantRequestSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests.'
        ),
      reason: z.string().describe('Reason for requesting access.'),
      owner: SimpleUserSchema,
      repository_selection: z
        .enum(['none', 'all', 'subset'])
        .describe('Type of repository selection requested.'),
      repositories_url: z
        .string()
        .describe(
          'URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`.'
        ),
      permissions: z
        .object({
          organization: z.record(z.string()).optional(),
          repository: z.record(z.string()).optional(),
          other: z.record(z.string()).optional()
        })
        .describe('Permissions requested, categorized by type of permission.'),
      created_at: z
        .string()
        .describe('Date and time when the request for access was created.'),
      token_id: z
        .number()
        .int()
        .describe(
          "Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."
        ),
      token_name: z
        .string()
        .describe(
          "The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."
        ),
      token_expired: z
        .boolean()
        .describe(
          'Whether the associated fine-grained personal access token has expired.'
        ),
      token_expires_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token expires.'
        ),
      token_last_used_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token was last used for authentication.'
        )
    })
    .describe(
      'Minimal representation of an organization programmatic access grant request for enumerations'
    )
  export type OrganizationProgrammaticAccessGrantRequest = z.infer<
    typeof OrganizationProgrammaticAccessGrantRequestSchema
  >

  export const OrganizationProgrammaticAccessGrantSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'Unique identifier of the fine-grained personal access token grant. The `pat_id` used to get details about an approved fine-grained personal access token.'
        ),
      owner: SimpleUserSchema,
      repository_selection: z
        .enum(['none', 'all', 'subset'])
        .describe('Type of repository selection requested.'),
      repositories_url: z
        .string()
        .describe(
          'URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`.'
        ),
      permissions: z
        .object({
          organization: z.record(z.string()).optional(),
          repository: z.record(z.string()).optional(),
          other: z.record(z.string()).optional()
        })
        .describe('Permissions requested, categorized by type of permission.'),
      access_granted_at: z
        .string()
        .describe(
          'Date and time when the fine-grained personal access token was approved to access the organization.'
        ),
      token_id: z
        .number()
        .int()
        .describe(
          "Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."
        ),
      token_name: z
        .string()
        .describe(
          "The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."
        ),
      token_expired: z
        .boolean()
        .describe(
          'Whether the associated fine-grained personal access token has expired.'
        ),
      token_expires_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token expires.'
        ),
      token_last_used_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token was last used for authentication.'
        )
    })
    .describe(
      'Minimal representation of an organization programmatic access grant for enumerations'
    )
  export type OrganizationProgrammaticAccessGrant = z.infer<
    typeof OrganizationProgrammaticAccessGrantSchema
  >

  export const ProjectSchema = z
    .object({
      owner_url: z.string().url(),
      url: z.string().url(),
      html_url: z.string().url(),
      columns_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('Name of the project'),
      body: z.string().describe('Body of the project'),
      number: z.number().int(),
      state: z
        .string()
        .describe("State of the project; either 'open' or 'closed'"),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      organization_permission: z
        .enum(['read', 'write', 'admin', 'none'])
        .describe(
          'The baseline permission that all organization members have on this project. Only present if owner is an organization.'
        )
        .optional(),
      private: z
        .boolean()
        .describe(
          'Whether or not this project can be seen by everyone. Only present if owner is an organization.'
        )
        .optional()
    })
    .describe('Projects are a way to organize columns and cards of work.')
  export type Project = z.infer<typeof ProjectSchema>

  export const OrgRepoCustomPropertyValuesSchema = z
    .object({
      repository_id: z.number().int(),
      repository_name: z.string(),
      repository_full_name: z.string(),
      properties: z
        .array(CustomPropertyValueSchema)
        .describe('List of custom property names and associated values')
    })
    .describe('List of custom property values for a repository')
  export type OrgRepoCustomPropertyValues = z.infer<
    typeof OrgRepoCustomPropertyValuesSchema
  >

  export const RepositoryRulesetConditionsRepositoryPropertyTargetSchema = z
    .object({
      repository_property: z.object({
        include: z
          .array(RepositoryRulesetConditionsRepositoryPropertySpecSchema)
          .describe(
            'The repository properties and values to include. All of these properties must match for the condition to pass.'
          )
          .optional(),
        exclude: z
          .array(RepositoryRulesetConditionsRepositoryPropertySpecSchema)
          .describe(
            'The repository properties and values to exclude. The condition will not pass if any of these properties match.'
          )
          .optional()
      })
    })
    .describe('Parameters for a repository property condition')
  export type RepositoryRulesetConditionsRepositoryPropertyTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryPropertyTargetSchema
  >

  export const RepositoryRuleRequiredStatusChecksSchema = z
    .object({
      type: z.literal('required_status_checks'),
      parameters: z
        .object({
          do_not_enforce_on_create: z
            .boolean()
            .describe(
              'Allow repositories and branches to be created if a check would otherwise prohibit it.'
            )
            .optional(),
          required_status_checks: z
            .array(RepositoryRuleParamsStatusCheckConfigurationSchema)
            .describe('Status checks that are required.'),
          strict_required_status_checks_policy: z
            .boolean()
            .describe(
              'Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.'
    )
  export type RepositoryRuleRequiredStatusChecks = z.infer<
    typeof RepositoryRuleRequiredStatusChecksSchema
  >

  export const RepositoryRuleWorkflowsSchema = z
    .object({
      type: z.literal('workflows'),
      parameters: z
        .object({
          do_not_enforce_on_create: z
            .boolean()
            .describe(
              'Allow repositories and branches to be created if a check would otherwise prohibit it.'
            )
            .optional(),
          workflows: z
            .array(RepositoryRuleParamsWorkflowFileReferenceSchema)
            .describe('Workflows that must pass for this rule to pass.')
        })
        .optional()
    })
    .describe(
      'Require all changes made to a targeted branch to pass the specified workflows before they can be merged.'
    )
  export type RepositoryRuleWorkflows = z.infer<
    typeof RepositoryRuleWorkflowsSchema
  >

  export const RepositoryRuleCodeScanningSchema = z
    .object({
      type: z.literal('code_scanning'),
      parameters: z
        .object({
          code_scanning_tools: z
            .array(RepositoryRuleParamsCodeScanningToolSchema)
            .describe(
              'Tools that must provide code scanning results for this rule to pass.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.'
    )
  export type RepositoryRuleCodeScanning = z.infer<
    typeof RepositoryRuleCodeScanningSchema
  >

  export const RulesetVersionWithStateSchema = z.intersection(
    RulesetVersionSchema,
    z.object({
      state: z.record(z.any()).describe('The state of the ruleset version')
    })
  )
  export type RulesetVersionWithState = z.infer<
    typeof RulesetVersionWithStateSchema
  >

  export const RepositoryAdvisoryVulnerabilitySchema = z
    .object({
      package: z
        .object({
          ecosystem: SecurityAdvisoryEcosystemsSchema,
          name: z
            .string()
            .describe('The unique package name within its ecosystem.')
        })
        .describe('The name of the package affected by the vulnerability.'),
      vulnerable_version_range: z
        .string()
        .describe(
          'The range of the package versions affected by the vulnerability.'
        ),
      patched_versions: z
        .string()
        .describe('The package version(s) that resolve the vulnerability.'),
      vulnerable_functions: z
        .array(z.string())
        .describe('The functions in the package that are affected.')
    })
    .strict()
    .describe(
      'A product affected by the vulnerability detailed in a repository security advisory.'
    )
  export type RepositoryAdvisoryVulnerability = z.infer<
    typeof RepositoryAdvisoryVulnerabilitySchema
  >

  export const ReactionSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      user: NullableSimpleUserSchema,
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe('The reaction to use'),
      created_at: z.string().datetime({ offset: true })
    })
    .describe(
      'Reactions to conversations provide a way to help people express their feelings more simply and effectively.'
    )
  export type Reaction = z.infer<typeof ReactionSchema>

  export const TeamProjectSchema = z
    .object({
      owner_url: z.string(),
      url: z.string(),
      html_url: z.string(),
      columns_url: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      body: z.string(),
      number: z.number().int(),
      state: z.string(),
      creator: SimpleUserSchema,
      created_at: z.string(),
      updated_at: z.string(),
      organization_permission: z
        .string()
        .describe(
          'The organization permission for this project. Only present when owner is an organization.'
        )
        .optional(),
      private: z
        .boolean()
        .describe(
          'Whether the project is private or not. Only present when owner is an organization.'
        )
        .optional(),
      permissions: z.object({
        read: z.boolean(),
        write: z.boolean(),
        admin: z.boolean()
      })
    })
    .describe("A team's access to a project.")
  export type TeamProject = z.infer<typeof TeamProjectSchema>

  export const ProjectCardSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe("The project card's ID"),
      node_id: z.string(),
      note: z.string(),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      archived: z
        .boolean()
        .describe('Whether or not the card is archived')
        .optional(),
      column_name: z.string().optional(),
      project_id: z.string().optional(),
      column_url: z.string().url(),
      content_url: z.string().url().optional(),
      project_url: z.string().url()
    })
    .describe('Project cards represent a scope of work.')
  export type ProjectCard = z.infer<typeof ProjectCardSchema>

  export const ProjectCollaboratorPermissionSchema = z
    .object({ permission: z.string(), user: NullableSimpleUserSchema })
    .describe('Project Collaborator Permission')
  export type ProjectCollaboratorPermission = z.infer<
    typeof ProjectCollaboratorPermissionSchema
  >

  export const RateLimitOverviewSchema = z
    .object({
      resources: z.object({
        core: RateLimitSchema,
        graphql: RateLimitSchema.optional(),
        search: RateLimitSchema,
        code_search: RateLimitSchema.optional(),
        source_import: RateLimitSchema.optional(),
        integration_manifest: RateLimitSchema.optional(),
        code_scanning_upload: RateLimitSchema.optional(),
        actions_runner_registration: RateLimitSchema.optional(),
        scim: RateLimitSchema.optional(),
        dependency_snapshots: RateLimitSchema.optional(),
        code_scanning_autofix: RateLimitSchema.optional()
      }),
      rate: RateLimitSchema
    })
    .describe('Rate Limit Overview')
  export type RateLimitOverview = z.infer<typeof RateLimitOverviewSchema>

  export const EnvironmentApprovalsSchema = z
    .object({
      environments: z
        .array(
          z.object({
            id: z
              .number()
              .int()
              .describe('The id of the environment.')
              .optional(),
            node_id: z.string().optional(),
            name: z
              .string()
              .describe('The name of the environment.')
              .optional(),
            url: z.string().optional(),
            html_url: z.string().optional(),
            created_at: z
              .string()
              .datetime({ offset: true })
              .describe(
                'The time that the environment was created, in ISO 8601 format.'
              )
              .optional(),
            updated_at: z
              .string()
              .datetime({ offset: true })
              .describe(
                'The time that the environment was last updated, in ISO 8601 format.'
              )
              .optional()
          })
        )
        .describe('The list of environments that were approved or rejected'),
      state: z
        .enum(['approved', 'rejected', 'pending'])
        .describe(
          'Whether deployment to the environment(s) was approved or rejected or pending (with comments)'
        ),
      user: SimpleUserSchema,
      comment: z
        .string()
        .describe('The comment submitted with the deployment review')
    })
    .describe('An entry in the reviews log for environment deployments')
  export type EnvironmentApprovals = z.infer<typeof EnvironmentApprovalsSchema>

  export const ActivitySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      before: z.string().describe('The SHA of the commit before the activity.'),
      after: z.string().describe('The SHA of the commit after the activity.'),
      ref: z
        .string()
        .describe(
          'The full Git reference, formatted as `refs/heads/<branch name>`.'
        ),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('The time when the activity occurred.'),
      activity_type: z
        .enum([
          'push',
          'force_push',
          'branch_deletion',
          'branch_creation',
          'pr_merge',
          'merge_queue_merge'
        ])
        .describe('The type of the activity that was performed.'),
      actor: NullableSimpleUserSchema
    })
    .describe('Activity')
  export type Activity = z.infer<typeof ActivitySchema>

  export const CodeScanningCodeqlDatabaseSchema = z
    .object({
      id: z.number().int().describe('The ID of the CodeQL database.'),
      name: z.string().describe('The name of the CodeQL database.'),
      language: z.string().describe('The language of the CodeQL database.'),
      uploader: SimpleUserSchema,
      content_type: z
        .string()
        .describe('The MIME type of the CodeQL database file.'),
      size: z
        .number()
        .int()
        .describe('The size of the CodeQL database file in bytes.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the CodeQL database was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the CodeQL database was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      url: z
        .string()
        .url()
        .describe(
          'The URL at which to download the CodeQL database. The `Accept` header must be set to the value of the `content_type` property.'
        ),
      commit_oid: z
        .string()
        .describe(
          'The commit SHA of the repository at the time the CodeQL database was created.'
        )
        .optional()
    })
    .describe('A CodeQL database.')
  export type CodeScanningCodeqlDatabase = z.infer<
    typeof CodeScanningCodeqlDatabaseSchema
  >

  export const CodeScanningVariantAnalysisSkippedRepoGroupSchema = z.object({
    repository_count: z
      .number()
      .int()
      .describe(
        'The total number of repositories that were skipped for this reason.'
      ),
    repositories: z
      .array(CodeScanningVariantAnalysisRepositorySchema)
      .describe(
        'A list of repositories that were skipped. This list may not include all repositories that were skipped. This is only available when the repository was found and the user has access to it.'
      )
  })
  export type CodeScanningVariantAnalysisSkippedRepoGroup = z.infer<
    typeof CodeScanningVariantAnalysisSkippedRepoGroupSchema
  >

  export const CodeSecurityConfigurationForRepositorySchema = z
    .object({
      status: z
        .enum([
          'attached',
          'attaching',
          'detached',
          'removed',
          'enforced',
          'failed',
          'updating',
          'removed_by_enterprise'
        ])
        .describe(
          'The attachment status of the code security configuration on the repository.'
        )
        .optional(),
      configuration: CodeSecurityConfigurationSchema.optional()
    })
    .describe(
      'Code security configuration associated with a repository and attachment status'
    )
  export type CodeSecurityConfigurationForRepository = z.infer<
    typeof CodeSecurityConfigurationForRepositorySchema
  >

  export const RepositoryCollaboratorPermissionSchema = z
    .object({
      permission: z.string(),
      role_name: z.string(),
      user: NullableCollaboratorSchema
    })
    .describe('Repository Collaborator Permission')
  export type RepositoryCollaboratorPermission = z.infer<
    typeof RepositoryCollaboratorPermissionSchema
  >

  export const AutoMergeSchema = z
    .object({
      enabled_by: SimpleUserSchema,
      merge_method: z
        .enum(['merge', 'squash', 'rebase'])
        .describe('The merge method to use.'),
      commit_title: z.string().describe('Title for the merge commit message.'),
      commit_message: z
        .string()
        .describe('Commit message for the merge commit.')
    })
    .describe('The status of auto merging a pull request.')
  export type AutoMerge = z.infer<typeof AutoMergeSchema>

  export const DependabotAlertNumberSchema = z
    .any()
    .describe(
      'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
    )
  export type DependabotAlertNumber = z.infer<
    typeof DependabotAlertNumberSchema
  >

  export const DependencySchema = z
    .object({
      package_url: z
        .string()
        .regex(new RegExp('^pkg'))
        .describe(
          'Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.'
        )
        .optional(),
      metadata: MetadataSchema.optional(),
      relationship: z
        .enum(['direct', 'indirect'])
        .describe(
          'A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.'
        )
        .optional(),
      scope: z
        .enum(['runtime', 'development'])
        .describe(
          'A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.'
        )
        .optional(),
      dependencies: z
        .array(z.string())
        .describe('Array of package-url (PURLs) of direct child dependencies.')
        .optional()
    })
    .strict()
  export type Dependency = z.infer<typeof DependencySchema>

  export const DeploymentProtectionRuleSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier for the deployment protection rule.'),
      node_id: z
        .string()
        .describe('The node ID for the deployment protection rule.'),
      enabled: z
        .boolean()
        .describe(
          'Whether the deployment protection rule is enabled for the environment.'
        ),
      app: CustomDeploymentRuleAppSchema
    })
    .describe('Deployment protection rule')
  export type DeploymentProtectionRule = z.infer<
    typeof DeploymentProtectionRuleSchema
  >

  export const GitTagSchema = z
    .object({
      node_id: z.string(),
      tag: z.string().describe('Name of the tag'),
      sha: z.string(),
      url: z.string().url().describe('URL for the tag'),
      message: z.string().describe('Message describing the purpose of the tag'),
      tagger: z.object({
        date: z.string(),
        email: z.string(),
        name: z.string()
      }),
      object: z.object({
        sha: z.string(),
        type: z.string(),
        url: z.string().url()
      }),
      verification: VerificationSchema.optional()
    })
    .describe('Metadata for a Git tag')
  export type GitTag = z.infer<typeof GitTagSchema>

  export const LicenseContentSchema = z
    .object({
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      size: z.number().int(),
      url: z.string().url(),
      html_url: z.string().url(),
      git_url: z.string().url(),
      download_url: z.string().url(),
      type: z.string(),
      content: z.string(),
      encoding: z.string(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      }),
      license: NullableLicenseSimpleSchema
    })
    .describe('License Content')
  export type LicenseContent = z.infer<typeof LicenseContentSchema>

  export const MilestoneSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      labels_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int().describe('The number of the milestone.'),
      state: z
        .enum(['open', 'closed'])
        .describe('The state of the milestone.')
        .default('open'),
      title: z.string().describe('The title of the milestone.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      open_issues: z.number().int(),
      closed_issues: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      due_on: z.string().datetime({ offset: true })
    })
    .describe('A collection of related issues and pull requests.')
  export type Milestone = z.infer<typeof MilestoneSchema>

  export const PageBuildSchema = z
    .object({
      url: z.string().url(),
      status: z.string(),
      error: z.object({ message: z.string() }),
      pusher: NullableSimpleUserSchema,
      commit: z.string(),
      duration: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Page Build')
  export type PageBuild = z.infer<typeof PageBuildSchema>

  export const ReleaseAssetSchema = z
    .object({
      url: z.string().url(),
      browser_download_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('The file name of the asset.'),
      label: z.string(),
      state: z
        .enum(['uploaded', 'open'])
        .describe('State of the release asset.'),
      content_type: z.string(),
      size: z.number().int(),
      download_count: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      uploader: NullableSimpleUserSchema
    })
    .describe('Data related to a release.')
  export type ReleaseAsset = z.infer<typeof ReleaseAssetSchema>

  export const SecretScanningPushProtectionBypassSchema = z.object({
    reason: SecretScanningPushProtectionBypassReasonSchema.optional(),
    expire_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the bypass will expire in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_type: z
      .string()
      .describe('The token type this bypass is for.')
      .optional()
  })
  export type SecretScanningPushProtectionBypass = z.infer<
    typeof SecretScanningPushProtectionBypassSchema
  >

  export const SecretScanningScanHistorySchema = z.object({
    incremental_scans: z.array(SecretScanningScanSchema).optional(),
    pattern_update_scans: z.array(SecretScanningScanSchema).optional(),
    backfill_scans: z.array(SecretScanningScanSchema).optional(),
    custom_pattern_backfill_scans: z
      .array(
        z.intersection(
          SecretScanningScanSchema,
          z.object({
            pattern_name: z
              .string()
              .describe('Name of the custom pattern for custom pattern scans')
              .optional(),
            pattern_scope: z
              .string()
              .describe(
                'Level at which the custom pattern is defined, one of "repository", "organization", or "enterprise"'
              )
              .optional()
          })
        )
      )
      .optional()
  })
  export type SecretScanningScanHistory = z.infer<
    typeof SecretScanningScanHistorySchema
  >

  export const PrivateVulnerabilityReportCreateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.'),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'An array of products affected by the vulnerability detailed in a repository security advisory.'
        )
        .optional(),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      start_private_fork: z
        .boolean()
        .describe(
          'Whether to create a temporary private fork of the repository to collaborate on a fix.'
        )
        .default(false)
    })
    .strict()
  export type PrivateVulnerabilityReportCreate = z.infer<
    typeof PrivateVulnerabilityReportCreateSchema
  >

  export const StargazerSchema = z
    .object({
      starred_at: z.string().datetime({ offset: true }),
      user: NullableSimpleUserSchema
    })
    .describe('Stargazer')
  export type Stargazer = z.infer<typeof StargazerSchema>

  export const ContributorActivitySchema = z
    .object({
      author: NullableSimpleUserSchema,
      total: z.number().int(),
      weeks: z.array(
        z.object({
          w: z.number().int().optional(),
          a: z.number().int().optional(),
          d: z.number().int().optional(),
          c: z.number().int().optional()
        })
      )
    })
    .describe('Contributor Activity')
  export type ContributorActivity = z.infer<typeof ContributorActivitySchema>

  export const CloneTrafficSchema = z
    .object({
      count: z.number().int(),
      uniques: z.number().int(),
      clones: z.array(TrafficSchema)
    })
    .describe('Clone Traffic')
  export type CloneTraffic = z.infer<typeof CloneTrafficSchema>

  export const ViewTrafficSchema = z
    .object({
      count: z.number().int(),
      uniques: z.number().int(),
      views: z.array(TrafficSchema)
    })
    .describe('View Traffic')
  export type ViewTraffic = z.infer<typeof ViewTrafficSchema>

  export const LabelSearchResultItemSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      name: z.string(),
      color: z.string(),
      default: z.boolean(),
      description: z.string(),
      score: z.number(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Label Search Result Item')
  export type LabelSearchResultItem = z.infer<
    typeof LabelSearchResultItemSchema
  >

  export const TopicSearchResultItemSchema = z
    .object({
      name: z.string(),
      display_name: z.string(),
      short_description: z.string(),
      description: z.string(),
      created_by: z.string(),
      released: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      featured: z.boolean(),
      curated: z.boolean(),
      score: z.number(),
      repository_count: z.number().int().optional(),
      logo_url: z.string().url().optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      related: z
        .array(
          z.object({
            topic_relation: z
              .object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                topic_id: z.number().int().optional(),
                relation_type: z.string().optional()
              })
              .optional()
          })
        )
        .optional(),
      aliases: z
        .array(
          z.object({
            topic_relation: z
              .object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                topic_id: z.number().int().optional(),
                relation_type: z.string().optional()
              })
              .optional()
          })
        )
        .optional()
    })
    .describe('Topic Search Result Item')
  export type TopicSearchResultItem = z.infer<
    typeof TopicSearchResultItemSchema
  >

  export const UserSearchResultItemSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      received_events_url: z.string().url(),
      type: z.string(),
      score: z.number(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      events_url: z.string(),
      public_repos: z.number().int().optional(),
      public_gists: z.number().int().optional(),
      followers: z.number().int().optional(),
      following: z.number().int().optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      name: z.string().optional(),
      bio: z.string().optional(),
      email: z.string().email().optional(),
      location: z.string().optional(),
      site_admin: z.boolean(),
      hireable: z.boolean().optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      blog: z.string().optional(),
      company: z.string().optional(),
      suspended_at: z.string().datetime({ offset: true }).optional(),
      user_view_type: z.string().optional()
    })
    .describe('User Search Result Item')
  export type UserSearchResultItem = z.infer<typeof UserSearchResultItemSchema>

  export const IntegrationSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the GitHub app'),
      slug: z.string().describe('The slug name of the GitHub app').optional(),
      node_id: z.string(),
      client_id: z.string().optional(),
      owner: z.union([SimpleUserSchema, EnterpriseSchema]),
      name: z.string().describe('The name of the GitHub app'),
      description: z.string(),
      external_url: z.string().url(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          issues: z.string().optional(),
          checks: z.string().optional(),
          metadata: z.string().optional(),
          contents: z.string().optional(),
          deployments: z.string().optional()
        })
        .catchall(z.string())
        .describe('The set of permissions for the GitHub app'),
      events: z
        .array(z.string())
        .describe('The list of events for the GitHub app'),
      installations_count: z
        .number()
        .int()
        .describe('The number of installations associated with the GitHub app')
        .optional(),
      client_secret: z.string().optional(),
      webhook_secret: z.string().optional(),
      pem: z.string().optional()
    })
    .describe(
      'GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.'
    )
  export type Integration = z.infer<typeof IntegrationSchema>

  export const IntegrationInstallationRequestSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the request installation.'),
      node_id: z.string().optional(),
      account: z.union([SimpleUserSchema, EnterpriseSchema]),
      requester: SimpleUserSchema,
      created_at: z.string().datetime({ offset: true })
    })
    .describe('Request to install an integration on a target')
  export type IntegrationInstallationRequest = z.infer<
    typeof IntegrationInstallationRequestSchema
  >

  export const RepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      owner: SimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      has_discussions: z
        .boolean()
        .describe('Whether discussions are enabled.')
        .default(false),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_update_branch: z
        .boolean()
        .describe(
          'Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.'
        )
        .default(false),
      use_squash_pr_title_as_default: z
        .boolean()
        .describe(
          'Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.'
        )
        .default(false),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .optional(),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional(),
      starred_at: z.string().optional(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is enabled for this repository')
        .optional()
    })
    .describe('A repository on GitHub.')
  export type Repository = z.infer<typeof RepositorySchema>

  export const NullableScopedInstallationSchema = z.object({
    permissions: AppPermissionsSchema,
    repository_selection: z
      .enum(['all', 'selected'])
      .describe(
        "Describe whether all repositories have been selected or there's a selection involved"
      ),
    single_file_name: z.string(),
    has_multiple_single_files: z.boolean().optional(),
    single_file_paths: z.array(z.string()).optional(),
    repositories_url: z.string().url(),
    account: SimpleUserSchema
  })
  export type NullableScopedInstallation = z.infer<
    typeof NullableScopedInstallationSchema
  >

  export const CodeSecurityConfigurationRepositoriesSchema = z
    .object({
      status: z
        .enum([
          'attached',
          'attaching',
          'detached',
          'removed',
          'enforced',
          'failed',
          'updating',
          'removed_by_enterprise'
        ])
        .describe(
          'The attachment status of the code security configuration on the repository.'
        )
        .optional(),
      repository: SimpleRepositorySchema.optional()
    })
    .describe(
      'Repositories associated with a code security configuration and attachment status'
    )
  export type CodeSecurityConfigurationRepositories = z.infer<
    typeof CodeSecurityConfigurationRepositoriesSchema
  >

  export const NullableIntegrationSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the GitHub app'),
      slug: z.string().describe('The slug name of the GitHub app').optional(),
      node_id: z.string(),
      client_id: z.string().optional(),
      owner: z.union([SimpleUserSchema, EnterpriseSchema]),
      name: z.string().describe('The name of the GitHub app'),
      description: z.string(),
      external_url: z.string().url(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          issues: z.string().optional(),
          checks: z.string().optional(),
          metadata: z.string().optional(),
          contents: z.string().optional(),
          deployments: z.string().optional()
        })
        .catchall(z.string())
        .describe('The set of permissions for the GitHub app'),
      events: z
        .array(z.string())
        .describe('The list of events for the GitHub app'),
      installations_count: z
        .number()
        .int()
        .describe('The number of installations associated with the GitHub app')
        .optional(),
      client_secret: z.string().optional(),
      webhook_secret: z.string().optional(),
      pem: z.string().optional()
    })
    .describe(
      'GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.'
    )
  export type NullableIntegration = z.infer<typeof NullableIntegrationSchema>

  export const BaseGistSchema = z
    .object({
      url: z.string().url(),
      forks_url: z.string().url(),
      commits_url: z.string().url(),
      id: z.string(),
      node_id: z.string(),
      git_pull_url: z.string().url(),
      git_push_url: z.string().url(),
      html_url: z.string().url(),
      files: z.record(
        z.object({
          filename: z.string().optional(),
          type: z.string().optional(),
          language: z.string().optional(),
          raw_url: z.string().optional(),
          size: z.number().int().optional(),
          encoding: z
            .string()
            .describe(
              'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
            )
            .default('utf-8')
        })
      ),
      public: z.boolean(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      description: z.string(),
      comments: z.number().int(),
      comments_enabled: z.boolean().optional(),
      user: NullableSimpleUserSchema,
      comments_url: z.string().url(),
      owner: SimpleUserSchema.optional(),
      truncated: z.boolean().optional(),
      forks: z.array(z.any()).optional(),
      history: z.array(z.any()).optional()
    })
    .describe('Base Gist')
  export type BaseGist = z.infer<typeof BaseGistSchema>

  export const GistCommentSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      body: z.string().max(65_535).describe('The comment text.'),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      author_association: AuthorAssociationSchema
    })
    .describe('A comment made to a gist.')
  export type GistComment = z.infer<typeof GistCommentSchema>

  export const BillingUsageReportOrgSchema = z
    .any()
    .describe('Billing usage report response for an organization')
  export type BillingUsageReportOrg = z.infer<
    typeof BillingUsageReportOrgSchema
  >

  export const ActionsGetDefaultWorkflowPermissionsSchema = z.object({
    default_workflow_permissions: ActionsDefaultWorkflowPermissionsSchema,
    can_approve_pull_request_reviews: ActionsCanApprovePullRequestReviewsSchema
  })
  export type ActionsGetDefaultWorkflowPermissions = z.infer<
    typeof ActionsGetDefaultWorkflowPermissionsSchema
  >

  export const ActionsSetDefaultWorkflowPermissionsSchema = z.object({
    default_workflow_permissions:
      ActionsDefaultWorkflowPermissionsSchema.optional(),
    can_approve_pull_request_reviews:
      ActionsCanApprovePullRequestReviewsSchema.optional()
  })
  export type ActionsSetDefaultWorkflowPermissions = z.infer<
    typeof ActionsSetDefaultWorkflowPermissionsSchema
  >

  export const ActionsRunnerLabelsSchema = z.any().describe('Response')
  export type ActionsRunnerLabels = z.infer<typeof ActionsRunnerLabelsSchema>

  export const ActionsRunnerLabelsReadonlySchema = z.any().describe('Response')
  export type ActionsRunnerLabelsReadonly = z.infer<
    typeof ActionsRunnerLabelsReadonlySchema
  >

  export const InteractionLimitSchema = z
    .object({
      limit: InteractionGroupSchema,
      expiry: InteractionExpirySchema.optional()
    })
    .describe(
      'Limit interactions to a specific type of user for a specified duration'
    )
  export type InteractionLimit = z.infer<typeof InteractionLimitSchema>

  export const OrgMembershipSchema = z
    .object({
      url: z.string().url(),
      state: z
        .enum(['active', 'pending'])
        .describe(
          'The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.'
        ),
      role: z
        .enum(['admin', 'member', 'billing_manager'])
        .describe("The user's membership type in the organization."),
      organization_url: z.string().url(),
      organization: OrganizationSimpleSchema,
      user: NullableSimpleUserSchema,
      permissions: z.object({ can_create_repository: z.boolean() }).optional()
    })
    .describe('Org Membership')
  export type OrgMembership = z.infer<typeof OrgMembershipSchema>

  export const NullableRepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      owner: SimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      has_discussions: z
        .boolean()
        .describe('Whether discussions are enabled.')
        .default(false),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_update_branch: z
        .boolean()
        .describe(
          'Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.'
        )
        .default(false),
      use_squash_pr_title_as_default: z
        .boolean()
        .describe(
          'Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.'
        )
        .default(false),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .optional(),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional(),
      starred_at: z.string().optional(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is enabled for this repository')
        .optional()
    })
    .describe('A repository on GitHub.')
  export type NullableRepository = z.infer<typeof NullableRepositorySchema>

  export const RepositoryAdvisoryCreditSchema = z
    .object({
      user: SimpleUserSchema,
      type: SecurityAdvisoryCreditTypesSchema,
      state: z
        .enum(['accepted', 'declined', 'pending'])
        .describe("The state of the user's acceptance of the credit.")
    })
    .strict()
    .describe('A credit given to a user for a repository security advisory.')
  export type RepositoryAdvisoryCredit = z.infer<
    typeof RepositoryAdvisoryCreditSchema
  >

  export const TeamFullSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      html_url: z.string().url(),
      name: z.string().describe('Name of the team'),
      slug: z.string(),
      description: z.string(),
      privacy: z
        .enum(['closed', 'secret'])
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .enum(['notifications_enabled', 'notifications_disabled'])
        .describe('The notification setting the team has set')
        .optional(),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema.optional(),
      members_count: z.number().int(),
      repos_count: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      organization: TeamOrganizationSchema,
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type TeamFull = z.infer<typeof TeamFullSchema>

  export const TeamDiscussionSchema = z
    .object({
      author: NullableSimpleUserSchema,
      body: z.string().describe('The main text of the discussion.'),
      body_html: z.string(),
      body_version: z
        .string()
        .describe(
          'The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.'
        ),
      comments_count: z.number().int(),
      comments_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      last_edited_at: z.string().datetime({ offset: true }),
      html_url: z.string().url(),
      node_id: z.string(),
      number: z
        .number()
        .int()
        .describe('The unique sequence number of a team discussion.'),
      pinned: z
        .boolean()
        .describe(
          'Whether or not this discussion should be pinned for easy retrieval.'
        ),
      private: z
        .boolean()
        .describe(
          'Whether or not this discussion should be restricted to team members and organization owners.'
        ),
      team_url: z.string().url(),
      title: z.string().describe('The title of the discussion.'),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe(
      'A team discussion is a persistent record of a free-form conversation within a team.'
    )
  export type TeamDiscussion = z.infer<typeof TeamDiscussionSchema>

  export const TeamDiscussionCommentSchema = z
    .object({
      author: NullableSimpleUserSchema,
      body: z.string().describe('The main text of the comment.'),
      body_html: z.string(),
      body_version: z
        .string()
        .describe(
          'The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.'
        ),
      created_at: z.string().datetime({ offset: true }),
      last_edited_at: z.string().datetime({ offset: true }),
      discussion_url: z.string().url(),
      html_url: z.string().url(),
      node_id: z.string(),
      number: z
        .number()
        .int()
        .describe('The unique sequence number of a team discussion comment.'),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('A reply to a discussion within a team.')
  export type TeamDiscussionComment = z.infer<
    typeof TeamDiscussionCommentSchema
  >

  export const TeamRepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      owner: NullableSimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z.number().int(),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .default(false),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional()
    })
    .describe("A team's access to a repository.")
  export type TeamRepository = z.infer<typeof TeamRepositorySchema>

  export const ManifestSchema = z
    .object({
      name: z.string().describe('The name of the manifest.'),
      file: z
        .object({
          source_location: z
            .string()
            .describe(
              'The path of the manifest file relative to the root of the Git repository.'
            )
            .optional()
        })
        .strict()
        .optional(),
      metadata: MetadataSchema.optional(),
      resolved: z
        .record(DependencySchema)
        .describe('A collection of resolved package dependencies.')
        .optional()
    })
    .strict()
  export type Manifest = z.infer<typeof ManifestSchema>

  export const TimelineReviewedEventSchema = z
    .object({
      event: z.string(),
      id: z.number().int().describe('Unique identifier of the review'),
      node_id: z.string(),
      user: SimpleUserSchema,
      body: z.string().describe('The text of the review.'),
      state: z.string(),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      _links: z.object({
        html: z.object({ href: z.string() }),
        pull_request: z.object({ href: z.string() })
      }),
      submitted_at: z.string().datetime({ offset: true }).optional(),
      commit_id: z.string().describe('A commit SHA for the review.'),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      author_association: AuthorAssociationSchema
    })
    .describe('Timeline Reviewed Event')
  export type TimelineReviewedEvent = z.infer<
    typeof TimelineReviewedEventSchema
  >

  export const PullRequestReviewSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the review'),
      node_id: z.string(),
      user: NullableSimpleUserSchema,
      body: z.string().describe('The text of the review.'),
      state: z.string(),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      _links: z.object({
        html: z.object({ href: z.string() }),
        pull_request: z.object({ href: z.string() })
      }),
      submitted_at: z.string().datetime({ offset: true }).optional(),
      commit_id: z
        .string()
        .describe(
          'A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.'
        ),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      author_association: AuthorAssociationSchema
    })
    .describe('Pull Request Reviews are reviews on pull requests.')
  export type PullRequestReview = z.infer<typeof PullRequestReviewSchema>

  export const RepositoryAdvisoryCreateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.'),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .optional(),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'A product affected by the vulnerability detailed in a repository security advisory.'
        ),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      credits: z
        .array(
          z
            .object({
              login: z.string().describe('The username of the user credited.'),
              type: SecurityAdvisoryCreditTypesSchema
            })
            .strict()
        )
        .describe(
          'A list of users receiving credit for their participation in the security advisory.'
        )
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      start_private_fork: z
        .boolean()
        .describe(
          'Whether to create a temporary private fork of the repository to collaborate on a fix.'
        )
        .default(false)
    })
    .strict()
  export type RepositoryAdvisoryCreate = z.infer<
    typeof RepositoryAdvisoryCreateSchema
  >

  export const RepositoryAdvisoryUpdateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.')
        .optional(),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.')
        .optional(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .optional(),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'A product affected by the vulnerability detailed in a repository security advisory.'
        )
        .optional(),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      credits: z
        .array(
          z
            .object({
              login: z.string().describe('The username of the user credited.'),
              type: SecurityAdvisoryCreditTypesSchema
            })
            .strict()
        )
        .describe(
          'A list of users receiving credit for their participation in the security advisory.'
        )
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      state: z
        .enum(['published', 'closed', 'draft'])
        .describe('The state of the advisory.')
        .optional(),
      collaborating_users: z
        .array(z.string())
        .describe(
          'A list of usernames who have been granted write access to the advisory.'
        )
        .optional(),
      collaborating_teams: z
        .array(z.string())
        .describe(
          'A list of team slugs which have been granted write access to the advisory.'
        )
        .optional()
    })
    .strict()
  export type RepositoryAdvisoryUpdate = z.infer<
    typeof RepositoryAdvisoryUpdateSchema
  >

  export const UserMarketplacePurchaseSchema = z
    .object({
      billing_cycle: z.string(),
      next_billing_date: z.string().datetime({ offset: true }),
      unit_count: z.number().int(),
      on_free_trial: z.boolean(),
      free_trial_ends_on: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      account: MarketplaceAccountSchema,
      plan: MarketplaceListingPlanSchema
    })
    .describe('User Marketplace Purchase')
  export type UserMarketplacePurchase = z.infer<
    typeof UserMarketplacePurchaseSchema
  >

  export const ClassroomAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      public_repo: z
        .boolean()
        .describe(
          'Whether an accepted assignment creates a public repository.'
        ),
      title: z.string().describe('Assignment title.'),
      type: z
        .enum(['individual', 'group'])
        .describe("Whether it's a group assignment or individual assignment."),
      invite_link: z
        .string()
        .describe('The link that a student can use to accept the assignment.'),
      invitations_enabled: z
        .boolean()
        .describe(
          'Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.'
        ),
      slug: z.string().describe('Sluggified name of the assignment.'),
      students_are_repo_admins: z
        .boolean()
        .describe(
          'Whether students are admins on created repository when a student accepts the assignment.'
        ),
      feedback_pull_requests_enabled: z
        .boolean()
        .describe(
          'Whether feedback pull request will be created when a student accepts the assignment.'
        ),
      max_teams: z
        .number()
        .int()
        .describe('The maximum allowable teams for the assignment.'),
      max_members: z
        .number()
        .int()
        .describe('The maximum allowable members per team.'),
      editor: z.string().describe('The selected editor for the assignment.'),
      accepted: z
        .number()
        .int()
        .describe('The number of students that have accepted the assignment.'),
      submitted: z
        .number()
        .int()
        .describe('The number of students that have submitted the assignment.'),
      passing: z
        .number()
        .int()
        .describe('The number of students that have passed the assignment.'),
      language: z
        .string()
        .describe('The programming language used in the assignment.'),
      deadline: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the assignment is due.'),
      starter_code_repository: SimpleClassroomRepositorySchema,
      classroom: ClassroomSchema
    })
    .describe('A GitHub Classroom assignment')
  export type ClassroomAssignment = z.infer<typeof ClassroomAssignmentSchema>

  export const MinimalRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string().optional(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string().optional(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string().optional(),
      mirror_url: z.string().optional(),
      hooks_url: z.string().url(),
      svn_url: z.string().optional(),
      homepage: z.string().optional(),
      language: z.string().optional(),
      forks_count: z.number().int().optional(),
      stargazers_count: z.number().int().optional(),
      watchers_count: z.number().int().optional(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        )
        .optional(),
      default_branch: z.string().optional(),
      open_issues_count: z.number().int().optional(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean().optional(),
      has_projects: z.boolean().optional(),
      has_wiki: z.boolean().optional(),
      has_pages: z.boolean().optional(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean().optional(),
      disabled: z.boolean().optional(),
      visibility: z.string().optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      permissions: z
        .object({
          admin: z.boolean().optional(),
          maintain: z.boolean().optional(),
          push: z.boolean().optional(),
          triage: z.boolean().optional(),
          pull: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      temp_clone_token: z.string().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      code_of_conduct: CodeOfConductSchema.optional(),
      license: z
        .object({
          key: z.string().optional(),
          name: z.string().optional(),
          spdx_id: z.string().optional(),
          url: z.string().optional(),
          node_id: z.string().optional()
        })
        .optional(),
      forks: z.number().int().optional(),
      open_issues: z.number().int().optional(),
      watchers: z.number().int().optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional()
    })
    .describe('Minimal Repository')
  export type MinimalRepository = z.infer<typeof MinimalRepositorySchema>

  export const ActionsHostedRunnerSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the hosted runner.'),
      name: z.string().describe('The name of the hosted runner.'),
      runner_group_id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the group that the hosted runner belongs to.'
        )
        .optional(),
      image_details: NullableActionsHostedRunnerPoolImageSchema,
      machine_size_details: ActionsHostedRunnerMachineSpecSchema,
      status: z
        .enum(['Ready', 'Provisioning', 'Shutdown', 'Deleting', 'Stuck'])
        .describe('The status of the runner.'),
      platform: z.string().describe('The operating system of the image.'),
      maximum_runners: z
        .number()
        .int()
        .describe(
          'The maximum amount of hosted runners. Runners will not scale automatically above this number. Use this setting to limit your cost.'
        )
        .default(10),
      public_ip_enabled: z
        .boolean()
        .describe('Whether public IP is enabled for the hosted runners.'),
      public_ips: z
        .array(PublicIpSchema)
        .describe(
          'The public IP ranges when public IP is enabled for the hosted runners.'
        )
        .optional(),
      last_active_on: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time at which the runner was last used, in ISO 8601 format.'
        )
        .optional()
    })
    .describe('A Github-hosted hosted runner.')
  export type ActionsHostedRunner = z.infer<typeof ActionsHostedRunnerSchema>

  export const ActionsOrganizationPermissionsSchema = z.object({
    enabled_repositories: EnabledRepositoriesSchema,
    selected_repositories_url: z
      .string()
      .describe(
        'The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.'
      )
      .optional(),
    allowed_actions: AllowedActionsSchema.optional(),
    selected_actions_url: SelectedActionsUrlSchema.optional()
  })
  export type ActionsOrganizationPermissions = z.infer<
    typeof ActionsOrganizationPermissionsSchema
  >

  export const ActionsRunnerJitconfigSchema = z.any().describe('Response')
  export type ActionsRunnerJitconfig = z.infer<
    typeof ActionsRunnerJitconfigSchema
  >

  export const AuthenticationTokenSchema = z
    .object({
      token: z.string().describe('The token used for authentication'),
      expires_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time this token expires'),
      permissions: z.record(z.any()).optional(),
      repositories: z
        .array(RepositorySchema)
        .describe('The repositories this token has access to')
        .optional(),
      single_file: z.string().optional(),
      repository_selection: z
        .enum(['all', 'selected'])
        .describe(
          "Describe whether all repositories have been selected or there's a selection involved"
        )
        .optional()
    })
    .describe('Authentication Token')
  export type AuthenticationToken = z.infer<typeof AuthenticationTokenSchema>

  export const CodeScanningAnalysisToolSchema = z.object({
    name: CodeScanningAnalysisToolNameSchema.optional(),
    version: CodeScanningAnalysisToolVersionSchema.optional(),
    guid: CodeScanningAnalysisToolGuidSchema.optional()
  })
  export type CodeScanningAnalysisTool = z.infer<
    typeof CodeScanningAnalysisToolSchema
  >

  export const NullableMinimalRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string().optional(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string().optional(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string().optional(),
      mirror_url: z.string().optional(),
      hooks_url: z.string().url(),
      svn_url: z.string().optional(),
      homepage: z.string().optional(),
      language: z.string().optional(),
      forks_count: z.number().int().optional(),
      stargazers_count: z.number().int().optional(),
      watchers_count: z.number().int().optional(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        )
        .optional(),
      default_branch: z.string().optional(),
      open_issues_count: z.number().int().optional(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean().optional(),
      has_projects: z.boolean().optional(),
      has_wiki: z.boolean().optional(),
      has_pages: z.boolean().optional(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean().optional(),
      disabled: z.boolean().optional(),
      visibility: z.string().optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      permissions: z
        .object({
          admin: z.boolean().optional(),
          maintain: z.boolean().optional(),
          push: z.boolean().optional(),
          triage: z.boolean().optional(),
          pull: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      temp_clone_token: z.string().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      code_of_conduct: CodeOfConductSchema.optional(),
      license: z
        .object({
          key: z.string().optional(),
          name: z.string().optional(),
          spdx_id: z.string().optional(),
          url: z.string().optional(),
          node_id: z.string().optional()
        })
        .optional(),
      forks: z.number().int().optional(),
      open_issues: z.number().int().optional(),
      watchers: z.number().int().optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional()
    })
    .describe('Minimal Repository')
  export type NullableMinimalRepository = z.infer<
    typeof NullableMinimalRepositorySchema
  >

  export const ActionsRepositoryPermissionsSchema = z.object({
    enabled: ActionsEnabledSchema,
    allowed_actions: AllowedActionsSchema.optional(),
    selected_actions_url: SelectedActionsUrlSchema.optional()
  })
  export type ActionsRepositoryPermissions = z.infer<
    typeof ActionsRepositoryPermissionsSchema
  >

  export const DeploymentSimpleSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe('Unique identifier of the deployment'),
      node_id: z.string(),
      task: z.string().describe('Parameter to specify a task to execute'),
      original_environment: z.string().optional(),
      environment: z
        .string()
        .describe('Name for the target deployment environment.'),
      description: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      statuses_url: z.string().url(),
      repository_url: z.string().url(),
      transient_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is will no longer exist at some point in the future. Default: false.'
        )
        .optional(),
      production_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is one that end-users directly interact with. Default: false.'
        )
        .optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe(
      'A deployment created as the result of an Actions check run from a workflow that references an environment'
    )
  export type DeploymentSimple = z.infer<typeof DeploymentSimpleSchema>

  export const CodeScanningAutofixSchema = z.object({
    status: CodeScanningAutofixStatusSchema,
    description: CodeScanningAutofixDescriptionSchema,
    started_at: CodeScanningAutofixStartedAtSchema
  })
  export type CodeScanningAutofix = z.infer<typeof CodeScanningAutofixSchema>

  export const CodeScanningVariantAnalysisRepoTaskSchema = z.object({
    repository: SimpleRepositorySchema,
    analysis_status: CodeScanningVariantAnalysisStatusSchema,
    artifact_size_in_bytes: z
      .number()
      .int()
      .describe(
        'The size of the artifact. This is only available for successful analyses.'
      )
      .optional(),
    result_count: z
      .number()
      .int()
      .describe(
        'The number of results in the case of a successful analysis. This is only available for successful analyses.'
      )
      .optional(),
    failure_message: z
      .string()
      .describe(
        'The reason of the failure of this repo task. This is only available if the repository task has failed.'
      )
      .optional(),
    database_commit_sha: z
      .string()
      .describe(
        'The SHA of the commit the CodeQL database was built against. This is only available for successful analyses.'
      )
      .optional(),
    source_location_prefix: z
      .string()
      .describe(
        'The source location prefix to use. This is only available for successful analyses.'
      )
      .optional(),
    artifact_url: z
      .string()
      .describe(
        'The URL of the artifact. This is only available for successful analyses.'
      )
      .optional()
  })
  export type CodeScanningVariantAnalysisRepoTask = z.infer<
    typeof CodeScanningVariantAnalysisRepoTaskSchema
  >

  export const CommitCommentSchema = z
    .object({
      html_url: z.string().url(),
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      body: z.string(),
      path: z.string(),
      position: z.number().int(),
      line: z.number().int(),
      commit_id: z.string(),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Commit Comment')
  export type CommitComment = z.infer<typeof CommitCommentSchema>

  export const CommunityProfileSchema = z
    .object({
      health_percentage: z.number().int(),
      description: z.string(),
      documentation: z.string(),
      files: z.object({
        code_of_conduct: NullableCodeOfConductSimpleSchema,
        code_of_conduct_file: NullableCommunityHealthFileSchema,
        license: NullableLicenseSimpleSchema,
        contributing: NullableCommunityHealthFileSchema,
        readme: NullableCommunityHealthFileSchema,
        issue_template: NullableCommunityHealthFileSchema,
        pull_request_template: NullableCommunityHealthFileSchema
      }),
      updated_at: z.string().datetime({ offset: true }),
      content_reports_enabled: z.boolean().optional()
    })
    .describe('Community Profile')
  export type CommunityProfile = z.infer<typeof CommunityProfileSchema>

  export const SnapshotSchema = z
    .object({
      version: z
        .number()
        .int()
        .describe('The version of the repository snapshot submission.'),
      job: z
        .object({
          id: z.string().describe('The external ID of the job.'),
          correlator: z
            .string()
            .describe(
              'Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository\'s current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you\'re using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you\'re using a build matrix, then you\'ll also need to add additional key(s) to distinguish between each submission inside a matrix variation.'
            ),
          html_url: z.string().describe('The url for the job.').optional()
        })
        .strict(),
      sha: z
        .string()
        .min(40)
        .max(40)
        .describe(
          'The commit SHA associated with this dependency snapshot. Maximum length: 40 characters.'
        ),
      ref: z
        .string()
        .regex(new RegExp('^refs/'))
        .describe('The repository branch that triggered this snapshot.'),
      detector: z
        .object({
          name: z.string().describe('The name of the detector used.'),
          version: z.string().describe('The version of the detector used.'),
          url: z.string().describe('The url of the detector used.')
        })
        .strict()
        .describe('A description of the detector used.'),
      metadata: MetadataSchema.optional(),
      manifests: z
        .record(ManifestSchema)
        .describe(
          'A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.'
        )
        .optional(),
      scanned: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the snapshot was scanned.')
    })
    .strict()
    .describe("Create a new snapshot of a repository's dependencies.")
  export type Snapshot = z.infer<typeof SnapshotSchema>

  export const LabeledIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      label: z.object({ name: z.string(), color: z.string() })
    })
    .describe('Labeled Issue Event')
  export type LabeledIssueEvent = z.infer<typeof LabeledIssueEventSchema>

  export const UnlabeledIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      label: z.object({ name: z.string(), color: z.string() })
    })
    .describe('Unlabeled Issue Event')
  export type UnlabeledIssueEvent = z.infer<typeof UnlabeledIssueEventSchema>

  export const AssignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: IntegrationSchema,
      assignee: SimpleUserSchema,
      assigner: SimpleUserSchema
    })
    .describe('Assigned Issue Event')
  export type AssignedIssueEvent = z.infer<typeof AssignedIssueEventSchema>

  export const UnassignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema,
      assigner: SimpleUserSchema
    })
    .describe('Unassigned Issue Event')
  export type UnassignedIssueEvent = z.infer<typeof UnassignedIssueEventSchema>

  export const MilestonedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      milestone: z.object({ title: z.string() })
    })
    .describe('Milestoned Issue Event')
  export type MilestonedIssueEvent = z.infer<typeof MilestonedIssueEventSchema>

  export const DemilestonedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      milestone: z.object({ title: z.string() })
    })
    .describe('Demilestoned Issue Event')
  export type DemilestonedIssueEvent = z.infer<
    typeof DemilestonedIssueEventSchema
  >

  export const RenamedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      rename: z.object({ from: z.string(), to: z.string() })
    })
    .describe('Renamed Issue Event')
  export type RenamedIssueEvent = z.infer<typeof RenamedIssueEventSchema>

  export const ReviewDismissedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      dismissed_review: z.object({
        state: z.string(),
        review_id: z.number().int(),
        dismissal_message: z.string(),
        dismissal_commit_id: z.string().optional()
      })
    })
    .describe('Review Dismissed Issue Event')
  export type ReviewDismissedIssueEvent = z.infer<
    typeof ReviewDismissedIssueEventSchema
  >

  export const LockedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      lock_reason: z.string()
    })
    .describe('Locked Issue Event')
  export type LockedIssueEvent = z.infer<typeof LockedIssueEventSchema>

  export const AddedToProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Added to Project Issue Event')
  export type AddedToProjectIssueEvent = z.infer<
    typeof AddedToProjectIssueEventSchema
  >

  export const MovedColumnInProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Moved Column in Project Issue Event')
  export type MovedColumnInProjectIssueEvent = z.infer<
    typeof MovedColumnInProjectIssueEventSchema
  >

  export const RemovedFromProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Removed from Project Issue Event')
  export type RemovedFromProjectIssueEvent = z.infer<
    typeof RemovedFromProjectIssueEventSchema
  >

  export const ConvertedNoteToIssueIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: IntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Converted Note to Issue Issue Event')
  export type ConvertedNoteToIssueIssueEvent = z.infer<
    typeof ConvertedNoteToIssueIssueEventSchema
  >

  export const PullRequestReviewCommentSchema = z
    .object({
      url: z.string().describe('URL for the pull request review comment'),
      pull_request_review_id: z
        .number()
        .int()
        .describe(
          'The ID of the pull request review to which the comment belongs.'
        ),
      id: z
        .number()
        .int()
        .describe('The ID of the pull request review comment.'),
      node_id: z
        .string()
        .describe('The node ID of the pull request review comment.'),
      diff_hunk: z
        .string()
        .describe('The diff of the line that the comment refers to.'),
      path: z
        .string()
        .describe(
          'The relative path of the file to which the comment applies.'
        ),
      position: z
        .number()
        .int()
        .describe(
          'The line index in the diff to which the comment applies. This field is closing down; use `line` instead.'
        )
        .optional(),
      original_position: z
        .number()
        .int()
        .describe(
          'The index of the original line in the diff to which the comment applies. This field is closing down; use `original_line` instead.'
        )
        .optional(),
      commit_id: z
        .string()
        .describe('The SHA of the commit to which the comment applies.'),
      original_commit_id: z
        .string()
        .describe(
          'The SHA of the original commit to which the comment applies.'
        ),
      in_reply_to_id: z
        .number()
        .int()
        .describe('The comment ID to reply to.')
        .optional(),
      user: SimpleUserSchema,
      body: z.string().describe('The text of the comment.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      html_url: z
        .string()
        .url()
        .describe('HTML URL for the pull request review comment.'),
      pull_request_url: z
        .string()
        .url()
        .describe(
          'URL for the pull request that the review comment belongs to.'
        ),
      author_association: AuthorAssociationSchema,
      _links: z.object({
        self: z.object({ href: z.string().url() }),
        html: z.object({ href: z.string().url() }),
        pull_request: z.object({ href: z.string().url() })
      }),
      start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      original_start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      start_side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      original_line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment'
        )
        .default('RIGHT'),
      subject_type: z
        .enum(['line', 'file'])
        .describe(
          'The level at which the comment is targeted, can be a diff line or a file.'
        )
        .optional(),
      reactions: ReactionRollupSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional()
    })
    .describe(
      "Pull Request Review Comments are comments on a portion of the Pull Request's diff."
    )
  export type PullRequestReviewComment = z.infer<
    typeof PullRequestReviewCommentSchema
  >

  export const TimelineAssignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema
    })
    .describe('Timeline Assigned Issue Event')
  export type TimelineAssignedIssueEvent = z.infer<
    typeof TimelineAssignedIssueEventSchema
  >

  export const TimelineUnassignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema
    })
    .describe('Timeline Unassigned Issue Event')
  export type TimelineUnassignedIssueEvent = z.infer<
    typeof TimelineUnassignedIssueEventSchema
  >

  export const StateChangeIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      state_reason: z.string().optional()
    })
    .describe('State Change Issue Event')
  export type StateChangeIssueEvent = z.infer<
    typeof StateChangeIssueEventSchema
  >

  export const PullRequestReviewRequestSchema = z
    .object({ users: z.array(SimpleUserSchema), teams: z.array(TeamSchema) })
    .describe('Pull Request Review Request')
  export type PullRequestReviewRequest = z.infer<
    typeof PullRequestReviewRequestSchema
  >

  export const RepoSearchResultItemSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: NullableSimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      pushed_at: z.string().datetime({ offset: true }),
      homepage: z.string().url(),
      size: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      language: z.string(),
      forks_count: z.number().int(),
      open_issues_count: z.number().int(),
      master_branch: z.string().optional(),
      default_branch: z.string(),
      score: z.number(),
      forks_url: z.string().url(),
      keys_url: z.string(),
      collaborators_url: z.string(),
      teams_url: z.string().url(),
      hooks_url: z.string().url(),
      issue_events_url: z.string(),
      events_url: z.string().url(),
      assignees_url: z.string(),
      branches_url: z.string(),
      tags_url: z.string().url(),
      blobs_url: z.string(),
      git_tags_url: z.string(),
      git_refs_url: z.string(),
      trees_url: z.string(),
      statuses_url: z.string(),
      languages_url: z.string().url(),
      stargazers_url: z.string().url(),
      contributors_url: z.string().url(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      commits_url: z.string(),
      git_commits_url: z.string(),
      comments_url: z.string(),
      issue_comment_url: z.string(),
      contents_url: z.string(),
      compare_url: z.string(),
      merges_url: z.string().url(),
      archive_url: z.string(),
      downloads_url: z.string().url(),
      issues_url: z.string(),
      pulls_url: z.string(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      labels_url: z.string(),
      releases_url: z.string(),
      deployments_url: z.string().url(),
      git_url: z.string(),
      ssh_url: z.string(),
      clone_url: z.string(),
      svn_url: z.string().url(),
      forks: z.number().int(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      topics: z.array(z.string()).optional(),
      mirror_url: z.string().url(),
      has_issues: z.boolean(),
      has_projects: z.boolean(),
      has_pages: z.boolean(),
      has_wiki: z.boolean(),
      has_downloads: z.boolean(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean(),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .optional(),
      license: NullableLicenseSimpleSchema,
      permissions: z
        .object({
          admin: z.boolean(),
          maintain: z.boolean().optional(),
          push: z.boolean(),
          triage: z.boolean().optional(),
          pull: z.boolean()
        })
        .optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      temp_clone_token: z.string().optional(),
      allow_merge_commit: z.boolean().optional(),
      allow_squash_merge: z.boolean().optional(),
      allow_rebase_merge: z.boolean().optional(),
      allow_auto_merge: z.boolean().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      allow_forking: z.boolean().optional(),
      is_template: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional()
    })
    .describe('Repo Search Result Item')
  export type RepoSearchResultItem = z.infer<typeof RepoSearchResultItemSchema>

  export const StarredRepositorySchema = z
    .object({
      starred_at: z.string().datetime({ offset: true }),
      repo: RepositorySchema
    })
    .describe('Starred Repository')
  export type StarredRepository = z.infer<typeof StarredRepositorySchema>

  export const WebhookConfigSchema = z
    .object({
      url: WebhookConfigUrlSchema.optional(),
      content_type: WebhookConfigContentTypeSchema.optional(),
      secret: WebhookConfigSecretSchema.optional(),
      insecure_ssl: WebhookConfigInsecureSslSchema.optional()
    })
    .describe('Configuration object of the webhook')
  export type WebhookConfig = z.infer<typeof WebhookConfigSchema>

  export const InstallationSchema = z
    .object({
      id: z.number().int().describe('The ID of the installation.'),
      account: z.union([SimpleUserSchema, EnterpriseSchema]),
      repository_selection: z
        .enum(['all', 'selected'])
        .describe(
          "Describe whether all repositories have been selected or there's a selection involved"
        ),
      access_tokens_url: z.string().url(),
      repositories_url: z.string().url(),
      html_url: z.string().url(),
      app_id: z.number().int(),
      target_id: z
        .number()
        .int()
        .describe(
          'The ID of the user or organization this token is being scoped to.'
        ),
      target_type: z.string(),
      permissions: AppPermissionsSchema,
      events: z.array(z.string()),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      single_file_name: z.string(),
      has_multiple_single_files: z.boolean().optional(),
      single_file_paths: z.array(z.string()).optional(),
      app_slug: z.string(),
      suspended_by: NullableSimpleUserSchema,
      suspended_at: z.string().datetime({ offset: true }),
      contact_email: z.string().optional()
    })
    .describe('Installation')
  export type Installation = z.infer<typeof InstallationSchema>

  export const InstallationTokenSchema = z
    .object({
      token: z.string(),
      expires_at: z.string(),
      permissions: AppPermissionsSchema.optional(),
      repository_selection: z.enum(['all', 'selected']).optional(),
      repositories: z.array(RepositorySchema).optional(),
      single_file: z.string().optional(),
      has_multiple_single_files: z.boolean().optional(),
      single_file_paths: z.array(z.string()).optional()
    })
    .describe(
      'Authentication token for a GitHub App installed on a user or org.'
    )
  export type InstallationToken = z.infer<typeof InstallationTokenSchema>

  export const AuthorizationSchema = z
    .object({
      id: z.number().int(),
      url: z.string().url(),
      scopes: z
        .array(z.string())
        .describe('A list of scopes that this authorization is in.'),
      token: z.string(),
      token_last_eight: z.string(),
      hashed_token: z.string(),
      app: z.object({
        client_id: z.string(),
        name: z.string(),
        url: z.string().url()
      }),
      note: z.string(),
      note_url: z.string().url(),
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      fingerprint: z.string(),
      user: NullableSimpleUserSchema.optional(),
      installation: NullableScopedInstallationSchema.optional(),
      expires_at: z.string().datetime({ offset: true })
    })
    .describe(
      'The authorization for an OAuth app, GitHub App, or a Personal Access Token.'
    )
  export type Authorization = z.infer<typeof AuthorizationSchema>

  export const ClassroomAcceptedAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      submitted: z
        .boolean()
        .describe('Whether an accepted assignment has been submitted.'),
      passing: z.boolean().describe('Whether a submission passed.'),
      commit_count: z.number().int().describe('Count of student commits.'),
      grade: z.string().describe('Most recent grade.'),
      students: z.array(SimpleClassroomUserSchema),
      repository: SimpleClassroomRepositorySchema,
      assignment: SimpleClassroomAssignmentSchema
    })
    .describe('A GitHub Classroom accepted assignment')
  export type ClassroomAcceptedAssignment = z.infer<
    typeof ClassroomAcceptedAssignmentSchema
  >

  export const DependabotAlertSecurityAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe(
          'The unique GitHub Security Advisory ID assigned to the advisory.'
        )
        .readonly(),
      cve_id: z
        .string()
        .describe('The unique CVE ID assigned to the advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short, plain text summary of the advisory.')
        .readonly(),
      description: z
        .string()
        .describe('A long-form Markdown-supported description of the advisory.')
        .readonly(),
      vulnerabilities: z
        .array(DependabotAlertSecurityVulnerabilitySchema)
        .describe('Vulnerable version range information for the advisory.')
        .readonly(),
      severity: z
        .enum(['low', 'medium', 'high', 'critical'])
        .describe('The severity of the advisory.')
        .readonly(),
      cvss: z
        .object({
          score: z
            .number()
            .gte(0)
            .lte(10)
            .describe('The overall CVSS score of the advisory.')
            .readonly(),
          vector_string: z
            .string()
            .describe('The full CVSS vector string for the advisory.')
            .readonly()
        })
        .strict()
        .describe(
          'Details for the advisory pertaining to the Common Vulnerability Scoring System.'
        )
        .readonly(),
      cvss_severities: CvssSeveritiesSchema.optional(),
      epss: SecurityAdvisoryEpssSchema.optional(),
      cwes: z
        .array(
          z
            .object({
              cwe_id: z.string().describe('The unique CWE ID.').readonly(),
              name: z
                .string()
                .describe('The short, plain text name of the CWE.')
                .readonly()
            })
            .strict()
            .describe('A CWE weakness assigned to the advisory.')
            .readonly()
        )
        .describe(
          'Details for the advisory pertaining to Common Weakness Enumeration.'
        )
        .readonly(),
      identifiers: z
        .array(
          z
            .object({
              type: z
                .enum(['CVE', 'GHSA'])
                .describe('The type of advisory identifier.')
                .readonly(),
              value: z
                .string()
                .describe('The value of the advisory identifer.')
                .readonly()
            })
            .strict()
            .describe('An advisory identifier.')
            .readonly()
        )
        .describe(
          'Values that identify this advisory among security information sources.'
        )
        .readonly(),
      references: z
        .array(
          z
            .object({
              url: z
                .string()
                .url()
                .describe('The URL of the reference.')
                .readonly()
            })
            .strict()
            .describe('A link to additional advisory information.')
            .readonly()
        )
        .describe('Links to additional advisory information.')
        .readonly(),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was published in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was last modified in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was withdrawn in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly()
    })
    .strict()
    .describe('Details for the GitHub Security Advisory.')
    .readonly()
  export type DependabotAlertSecurityAdvisory = z.infer<
    typeof DependabotAlertSecurityAdvisorySchema
  >

  export const GistSimpleSchema = z
    .object({
      forks: z
        .array(
          z.object({
            id: z.string().optional(),
            url: z.string().url().optional(),
            user: PublicUserSchema.optional(),
            created_at: z.string().datetime({ offset: true }).optional(),
            updated_at: z.string().datetime({ offset: true }).optional()
          })
        )
        .optional(),
      history: z.array(GistHistorySchema).optional(),
      fork_of: z
        .object({
          url: z.string().url(),
          forks_url: z.string().url(),
          commits_url: z.string().url(),
          id: z.string(),
          node_id: z.string(),
          git_pull_url: z.string().url(),
          git_push_url: z.string().url(),
          html_url: z.string().url(),
          files: z.record(
            z.object({
              filename: z.string().optional(),
              type: z.string().optional(),
              language: z.string().optional(),
              raw_url: z.string().optional(),
              size: z.number().int().optional()
            })
          ),
          public: z.boolean(),
          created_at: z.string().datetime({ offset: true }),
          updated_at: z.string().datetime({ offset: true }),
          description: z.string(),
          comments: z.number().int(),
          comments_enabled: z.boolean().optional(),
          user: NullableSimpleUserSchema,
          comments_url: z.string().url(),
          owner: NullableSimpleUserSchema.optional(),
          truncated: z.boolean().optional(),
          forks: z.array(z.any()).optional(),
          history: z.array(z.any()).optional()
        })
        .describe('Gist')
        .optional(),
      url: z.string().optional(),
      forks_url: z.string().optional(),
      commits_url: z.string().optional(),
      id: z.string().optional(),
      node_id: z.string().optional(),
      git_pull_url: z.string().optional(),
      git_push_url: z.string().optional(),
      html_url: z.string().optional(),
      files: z
        .record(
          z.object({
            filename: z.string().optional(),
            type: z.string().optional(),
            language: z.string().optional(),
            raw_url: z.string().optional(),
            size: z.number().int().optional(),
            truncated: z.boolean().optional(),
            content: z.string().optional(),
            encoding: z
              .string()
              .describe(
                'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
              )
              .default('utf-8')
          })
        )
        .optional(),
      public: z.boolean().optional(),
      created_at: z.string().optional(),
      updated_at: z.string().optional(),
      description: z.string().optional(),
      comments: z.number().int().optional(),
      comments_enabled: z.boolean().optional(),
      user: z.string().optional(),
      comments_url: z.string().optional(),
      owner: SimpleUserSchema.optional(),
      truncated: z.boolean().optional()
    })
    .describe('Gist Simple')
  export type GistSimple = z.infer<typeof GistSimpleSchema>

  export const ThreadSchema = z
    .object({
      id: z.string(),
      repository: MinimalRepositorySchema,
      subject: z.object({
        title: z.string(),
        url: z.string(),
        latest_comment_url: z.string(),
        type: z.string()
      }),
      reason: z.string(),
      unread: z.boolean(),
      updated_at: z.string(),
      last_read_at: z.string(),
      url: z.string(),
      subscription_url: z.string()
    })
    .describe('Thread')
  export type Thread = z.infer<typeof ThreadSchema>

  export const CopilotUsageMetricsDaySchema = z
    .object({
      date: z
        .string()
        .date()
        .describe(
          'The date for which the usage metrics are aggregated, in `YYYY-MM-DD` format.'
        ),
      total_active_users: z
        .number()
        .int()
        .describe(
          'The total number of Copilot users with activity belonging to any Copilot feature, globally, for the given day. Includes passive activity such as receiving a code suggestion, as well as engagement activity such as accepting a code suggestion or prompting chat. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.'
        )
        .optional(),
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'The total number of Copilot users who engaged with any Copilot feature, for the given day. Examples include but are not limited to accepting a code suggestion, prompting Copilot chat, or triggering a PR Summary. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.'
        )
        .optional(),
      copilot_ide_code_completions: CopilotIdeCodeCompletionsSchema.optional(),
      copilot_ide_chat: CopilotIdeChatSchema.optional(),
      copilot_dotcom_chat: CopilotDotcomChatSchema.optional(),
      copilot_dotcom_pull_requests: CopilotDotcomPullRequestsSchema.optional()
    })
    .catchall(z.any())
    .describe('Copilot usage metrics for a given day.')
  export type CopilotUsageMetricsDay = z.infer<
    typeof CopilotUsageMetricsDaySchema
  >

  export const MigrationSchema = z
    .object({
      id: z.number().int(),
      owner: NullableSimpleUserSchema,
      guid: z.string(),
      state: z.string(),
      lock_repositories: z.boolean(),
      exclude_metadata: z.boolean(),
      exclude_git_data: z.boolean(),
      exclude_attachments: z.boolean(),
      exclude_releases: z.boolean(),
      exclude_owner_projects: z.boolean(),
      org_metadata_only: z.boolean(),
      repositories: z
        .array(RepositorySchema)
        .describe(
          'The repositories included in the migration. Only returned for export migrations.'
        ),
      url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      node_id: z.string(),
      archive_url: z.string().url().optional(),
      exclude: z
        .array(
          z
            .string()
            .describe(
              'Allowed values that can be passed to the exclude parameter. The array can include any of: `"repositories"`.'
            )
        )
        .describe(
          'Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.'
        )
        .optional()
    })
    .describe('A migration.')
  export type Migration = z.infer<typeof MigrationSchema>

  export const PendingDeploymentSchema = z
    .object({
      environment: z.object({
        id: z.number().int().describe('The id of the environment.').optional(),
        node_id: z.string().optional(),
        name: z.string().describe('The name of the environment.').optional(),
        url: z.string().optional(),
        html_url: z.string().optional()
      }),
      wait_timer: z
        .number()
        .int()
        .describe('The set duration of the wait timer'),
      wait_timer_started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the wait timer began.'),
      current_user_can_approve: z
        .boolean()
        .describe(
          'Whether the currently authenticated user can approve the deployment'
        ),
      reviewers: z
        .array(
          z.object({
            type: DeploymentReviewerTypeSchema.optional(),
            reviewer: z.union([SimpleUserSchema, TeamSchema]).optional()
          })
        )
        .describe(
          'The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
        )
    })
    .describe(
      'Details of a deployment that is waiting for protection rules to pass'
    )
  export type PendingDeployment = z.infer<typeof PendingDeploymentSchema>

  export const DeploymentSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe('Unique identifier of the deployment'),
      node_id: z.string(),
      sha: z.string(),
      ref: z
        .string()
        .describe('The ref to deploy. This can be a branch, tag, or sha.'),
      task: z.string().describe('Parameter to specify a task to execute'),
      payload: z.union([z.record(z.any()), z.string()]),
      original_environment: z.string().optional(),
      environment: z
        .string()
        .describe('Name for the target deployment environment.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      statuses_url: z.string().url(),
      repository_url: z.string().url(),
      transient_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is will no longer exist at some point in the future. Default: false.'
        )
        .optional(),
      production_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is one that end-users directly interact with. Default: false.'
        )
        .optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('A request for a specific ref(branch,sha,tag) to be deployed')
  export type Deployment = z.infer<typeof DeploymentSchema>

  export const CheckSuitePreferenceSchema = z
    .object({
      preferences: z.object({
        auto_trigger_checks: z
          .array(z.object({ app_id: z.number().int(), setting: z.boolean() }))
          .optional()
      }),
      repository: MinimalRepositorySchema
    })
    .describe('Check suite configuration preferences for a repository.')
  export type CheckSuitePreference = z.infer<typeof CheckSuitePreferenceSchema>

  export const DeploymentStatusSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      state: z
        .enum([
          'error',
          'failure',
          'inactive',
          'pending',
          'success',
          'queued',
          'in_progress'
        ])
        .describe('The state of the status.'),
      creator: NullableSimpleUserSchema,
      description: z
        .string()
        .max(140)
        .describe('A short description of the status.')
        .default(''),
      environment: z
        .string()
        .describe('The environment of the deployment that the status is for.')
        .default(''),
      target_url: z
        .string()
        .url()
        .describe('Closing down notice: the URL to associate with this status.')
        .default(''),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      deployment_url: z.string().url(),
      repository_url: z.string().url(),
      environment_url: z
        .string()
        .url()
        .describe('The URL for accessing your environment.')
        .default(''),
      log_url: z
        .string()
        .url()
        .describe('The URL to associate with this status.')
        .default(''),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('The status of a deployment.')
  export type DeploymentStatus = z.infer<typeof DeploymentStatusSchema>

  export const TimelineLineCommentedEventSchema = z
    .object({
      event: z.string().optional(),
      node_id: z.string().optional(),
      comments: z.array(PullRequestReviewCommentSchema).optional()
    })
    .describe('Timeline Line Commented Event')
  export type TimelineLineCommentedEvent = z.infer<
    typeof TimelineLineCommentedEventSchema
  >

  export const TimelineCommitCommentedEventSchema = z
    .object({
      event: z.string().optional(),
      node_id: z.string().optional(),
      commit_id: z.string().optional(),
      comments: z.array(CommitCommentSchema).optional()
    })
    .describe('Timeline Commit Commented Event')
  export type TimelineCommitCommentedEvent = z.infer<
    typeof TimelineCommitCommentedEventSchema
  >

  export const ReviewCommentSchema = z
    .object({
      url: z.string().url(),
      pull_request_review_id: z.number().int(),
      id: z.number().int(),
      node_id: z.string(),
      diff_hunk: z.string(),
      path: z.string(),
      position: z.number().int(),
      original_position: z.number().int(),
      commit_id: z.string(),
      original_commit_id: z.string(),
      in_reply_to_id: z.number().int().optional(),
      user: NullableSimpleUserSchema,
      body: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      _links: z.object({
        self: LinkSchema,
        html: LinkSchema,
        pull_request: LinkSchema
      }),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      reactions: ReactionRollupSchema.optional(),
      side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      start_side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      original_line: z
        .number()
        .int()
        .describe(
          'The original line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      original_start_line: z
        .number()
        .int()
        .describe(
          'The original first line of the range for a multi-line comment.'
        )
        .optional()
    })
    .describe('Legacy Review Comment')
  export type ReviewComment = z.infer<typeof ReviewCommentSchema>

  export const ReleaseSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      assets_url: z.string().url(),
      upload_url: z.string(),
      tarball_url: z.string().url(),
      zipball_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      tag_name: z.string().describe('The name of the tag.'),
      target_commitish: z
        .string()
        .describe(
          'Specifies the commitish value that determines where the Git tag is created from.'
        ),
      name: z.string(),
      body: z.string().optional(),
      draft: z
        .boolean()
        .describe(
          'true to create a draft (unpublished) release, false to create a published one.'
        ),
      prerelease: z
        .boolean()
        .describe(
          'Whether to identify the release as a prerelease or a full release.'
        ),
      created_at: z.string().datetime({ offset: true }),
      published_at: z.string().datetime({ offset: true }),
      author: SimpleUserSchema,
      assets: z.array(ReleaseAssetSchema),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      mentions_count: z.number().int().optional(),
      discussion_url: z
        .string()
        .url()
        .describe('The URL of the release discussion.')
        .optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('A release.')
  export type Release = z.infer<typeof ReleaseSchema>

  export const CodespaceSchema = z
    .object({
      id: z.number().int(),
      name: z
        .string()
        .describe('Automatically generated name of this codespace.'),
      display_name: z
        .string()
        .describe('Display name for this codespace.')
        .optional(),
      environment_id: z
        .string()
        .describe("UUID identifying this codespace's environment."),
      owner: SimpleUserSchema,
      billable_owner: SimpleUserSchema,
      repository: MinimalRepositorySchema,
      machine: NullableCodespaceMachineSchema,
      devcontainer_path: z
        .string()
        .describe(
          'Path to devcontainer.json from repo root used to create Codespace.'
        )
        .optional(),
      prebuild: z
        .boolean()
        .describe('Whether the codespace was created from a prebuild.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      last_used_at: z
        .string()
        .datetime({ offset: true })
        .describe('Last known time this codespace was started.'),
      state: z
        .enum([
          'Unknown',
          'Created',
          'Queued',
          'Provisioning',
          'Available',
          'Awaiting',
          'Unavailable',
          'Deleted',
          'Moved',
          'Shutdown',
          'Archived',
          'Starting',
          'ShuttingDown',
          'Failed',
          'Exporting',
          'Updating',
          'Rebuilding'
        ])
        .describe('State of this codespace.'),
      url: z.string().url().describe('API URL for this codespace.'),
      git_status: z
        .object({
          ahead: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is ahead of the remote.'
            )
            .optional(),
          behind: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is behind the remote.'
            )
            .optional(),
          has_unpushed_changes: z
            .boolean()
            .describe('Whether the local repository has unpushed changes.')
            .optional(),
          has_uncommitted_changes: z
            .boolean()
            .describe('Whether the local repository has uncommitted changes.')
            .optional(),
          ref: z
            .string()
            .describe(
              'The current branch (or SHA if in detached HEAD state) of the local repository.'
            )
            .optional()
        })
        .describe("Details about the codespace's git repository."),
      location: z
        .enum(['EastUs', 'SouthEastAsia', 'WestEurope', 'WestUs2'])
        .describe('The initally assigned location of a new codespace.'),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe(
          'The number of minutes of inactivity after which this codespace will be automatically stopped.'
        ),
      web_url: z
        .string()
        .url()
        .describe('URL to access this codespace on the web.'),
      machines_url: z
        .string()
        .url()
        .describe(
          'API URL to access available alternate machine types for this codespace.'
        ),
      start_url: z.string().url().describe('API URL to start this codespace.'),
      stop_url: z.string().url().describe('API URL to stop this codespace.'),
      publish_url: z
        .string()
        .url()
        .describe('API URL to publish this codespace to a new repository.')
        .optional(),
      pulls_url: z
        .string()
        .url()
        .describe(
          'API URL for the Pull Request associated with this codespace, if any.'
        ),
      recent_folders: z.array(z.string()),
      runtime_constraints: z
        .object({
          allowed_port_privacy_settings: z
            .array(z.string())
            .describe(
              'The privacy settings a user can select from when forwarding a port.'
            )
            .optional()
        })
        .optional(),
      pending_operation: z
        .boolean()
        .describe(
          'Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.'
        )
        .optional(),
      pending_operation_disabled_reason: z
        .string()
        .describe(
          'Text to show user when codespace is disabled by a pending operation'
        )
        .optional(),
      idle_timeout_notice: z
        .string()
        .describe(
          'Text to show user when codespace idle timeout minutes has been overriden by an organization policy'
        )
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      retention_expires_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'When a codespace will be auto-deleted based on the "retention_period_minutes" and "last_used_at"'
        )
        .optional(),
      last_known_stop_notice: z
        .string()
        .describe(
          'The text to display to a user when a codespace has been stopped for a potentially actionable reason.'
        )
        .optional()
    })
    .describe('A codespace.')
  export type Codespace = z.infer<typeof CodespaceSchema>

  export const CopilotSeatDetailsSchema = z
    .object({
      assignee: SimpleUserSchema,
      organization: NullableOrganizationSimpleSchema.optional(),
      assigning_team: z
        .union([TeamSchema, EnterpriseTeamSchema])
        .describe(
          'The team through which the assignee is granted access to GitHub Copilot, if applicable.'
        )
        .optional(),
      pending_cancellation_date: z
        .string()
        .date()
        .describe(
          "The pending cancellation date for the seat, in `YYYY-MM-DD` format. This will be null unless the assignee's Copilot access has been canceled during the current billing cycle. If the seat has been cancelled, this corresponds to the start of the organization's next billing cycle."
        )
        .optional(),
      last_activity_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "Timestamp of user's last GitHub Copilot activity, in ISO 8601 format."
        )
        .optional(),
      last_activity_editor: z
        .string()
        .describe(
          'Last editor that was used by the user for a GitHub Copilot completion.'
        )
        .optional(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Timestamp of when the assignee was last granted access to GitHub Copilot, in ISO 8601 format.'
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "**Closing down notice:** This field is no longer relevant and is closing down. Use the `created_at` field to determine when the assignee was last granted access to GitHub Copilot. Timestamp of when the assignee's GitHub Copilot access was last updated, in ISO 8601 format."
        )
        .optional(),
      plan_type: z
        .enum(['business', 'enterprise', 'unknown'])
        .describe(
          'The Copilot plan of the organization, or the parent enterprise, when applicable.'
        )
        .optional()
    })
    .strict()
    .describe(
      'Information about a Copilot Business seat assignment for a user, team, or organization.'
    )
  export type CopilotSeatDetails = z.infer<typeof CopilotSeatDetailsSchema>

  export const PackageSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the package.'),
      name: z.string().describe('The name of the package.'),
      package_type: z.enum([
        'npm',
        'maven',
        'rubygems',
        'docker',
        'nuget',
        'container'
      ]),
      url: z.string(),
      html_url: z.string(),
      version_count: z
        .number()
        .int()
        .describe('The number of versions of the package.'),
      visibility: z.enum(['private', 'public']),
      owner: NullableSimpleUserSchema.optional(),
      repository: NullableMinimalRepositorySchema.optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('A software package')
  export type Package = z.infer<typeof PackageSchema>

  export const OrgRulesetConditionsSchema = z
    .record(z.any())
    .and(
      z.union([
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryNameTargetSchema
            )
          )
          .describe(
            'Conditions to target repositories by name and refs by name'
          ),
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryIdTargetSchema
            )
          )
          .describe('Conditions to target repositories by id and refs by name'),
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryPropertyTargetSchema
            )
          )
          .describe(
            'Conditions to target repositories by property and refs by name'
          )
      ])
    )
    .describe(
      'Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.'
    )
  export type OrgRulesetConditions = z.infer<typeof OrgRulesetConditionsSchema>

  export const ProtectedBranchPullRequestReviewSchema = z
    .object({
      url: z.string().url().optional(),
      dismissal_restrictions: z
        .object({
          users: z
            .array(SimpleUserSchema)
            .describe('The list of users with review dismissal access.')
            .optional(),
          teams: z
            .array(TeamSchema)
            .describe('The list of teams with review dismissal access.')
            .optional(),
          apps: z
            .array(IntegrationSchema)
            .describe('The list of apps with review dismissal access.')
            .optional(),
          url: z.string().optional(),
          users_url: z.string().optional(),
          teams_url: z.string().optional()
        })
        .optional(),
      bypass_pull_request_allowances: z
        .object({
          users: z
            .array(SimpleUserSchema)
            .describe(
              'The list of users allowed to bypass pull request requirements.'
            )
            .optional(),
          teams: z
            .array(TeamSchema)
            .describe(
              'The list of teams allowed to bypass pull request requirements.'
            )
            .optional(),
          apps: z
            .array(IntegrationSchema)
            .describe(
              'The list of apps allowed to bypass pull request requirements.'
            )
            .optional()
        })
        .describe(
          'Allow specific users, teams, or apps to bypass pull request requirements.'
        )
        .optional(),
      dismiss_stale_reviews: z.boolean(),
      require_code_owner_reviews: z.boolean(),
      required_approving_review_count: z
        .number()
        .int()
        .gte(0)
        .lte(6)
        .optional(),
      require_last_push_approval: z
        .boolean()
        .describe(
          'Whether the most recent push must be approved by someone other than the person who pushed it.'
        )
        .default(false)
    })
    .describe('Protected Branch Pull Request Review')
  export type ProtectedBranchPullRequestReview = z.infer<
    typeof ProtectedBranchPullRequestReviewSchema
  >

  export const CommitSchema = z
    .object({
      url: z.string().url(),
      sha: z.string(),
      node_id: z.string(),
      html_url: z.string().url(),
      comments_url: z.string().url(),
      commit: z.object({
        url: z.string().url(),
        author: NullableGitUserSchema,
        committer: NullableGitUserSchema,
        message: z.string(),
        comment_count: z.number().int(),
        tree: z.object({ sha: z.string(), url: z.string().url() }),
        verification: VerificationSchema.optional()
      }),
      author: z.union([SimpleUserSchema, EmptyObjectSchema]),
      committer: z.union([SimpleUserSchema, EmptyObjectSchema]),
      parents: z.array(
        z.object({
          sha: z.string(),
          url: z.string().url(),
          html_url: z.string().url().optional()
        })
      ),
      stats: z
        .object({
          additions: z.number().int().optional(),
          deletions: z.number().int().optional(),
          total: z.number().int().optional()
        })
        .optional(),
      files: z.array(DiffEntrySchema).optional()
    })
    .describe('Commit')
  export type Commit = z.infer<typeof CommitSchema>

  export const CheckRunSchema = z
    .object({
      id: z.number().int().describe('The id of the check.'),
      head_sha: z
        .string()
        .describe('The SHA of the commit that is being checked.'),
      node_id: z.string(),
      external_id: z.string(),
      url: z.string(),
      html_url: z.string(),
      details_url: z.string(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs.'
        ),
      conclusion: z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required'
      ]),
      started_at: z.string().datetime({ offset: true }),
      completed_at: z.string().datetime({ offset: true }),
      output: z.object({
        title: z.string(),
        summary: z.string(),
        text: z.string(),
        annotations_count: z.number().int(),
        annotations_url: z.string().url()
      }),
      name: z.string().describe('The name of the check.'),
      check_suite: z.object({ id: z.number().int() }),
      app: NullableIntegrationSchema,
      pull_requests: z
        .array(PullRequestMinimalSchema)
        .describe(
          'Pull requests that are open with a `head_sha` or `head_branch` that matches the check. The returned pull requests do not necessarily indicate pull requests that triggered the check.'
        ),
      deployment: DeploymentSimpleSchema.optional()
    })
    .describe('A check performed on the code of a given code change')
  export type CheckRun = z.infer<typeof CheckRunSchema>

  export const RepositoryInvitationSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the repository invitation.'),
      repository: MinimalRepositorySchema,
      invitee: NullableSimpleUserSchema,
      inviter: NullableSimpleUserSchema,
      permissions: z
        .enum(['read', 'write', 'admin', 'triage', 'maintain'])
        .describe('The permission associated with the invitation.'),
      created_at: z.string().datetime({ offset: true }),
      expired: z
        .boolean()
        .describe('Whether or not the invitation has expired')
        .optional(),
      url: z.string().describe('URL for the repository invitation'),
      html_url: z.string(),
      node_id: z.string()
    })
    .describe('Repository invitations let you manage who you collaborate with.')
  export type RepositoryInvitation = z.infer<typeof RepositoryInvitationSchema>

  export const CombinedCommitStatusSchema = z
    .object({
      state: z.string(),
      statuses: z.array(SimpleCommitStatusSchema),
      sha: z.string(),
      total_count: z.number().int(),
      repository: MinimalRepositorySchema,
      commit_url: z.string().url(),
      url: z.string().url()
    })
    .describe('Combined Commit Status')
  export type CombinedCommitStatus = z.infer<typeof CombinedCommitStatusSchema>

  export const ReviewRequestedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      review_requester: SimpleUserSchema,
      requested_team: TeamSchema.optional(),
      requested_reviewer: SimpleUserSchema.optional()
    })
    .describe('Review Requested Issue Event')
  export type ReviewRequestedIssueEvent = z.infer<
    typeof ReviewRequestedIssueEventSchema
  >

  export const ReviewRequestRemovedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      review_requester: SimpleUserSchema,
      requested_team: TeamSchema.optional(),
      requested_reviewer: SimpleUserSchema.optional()
    })
    .describe('Review Request Removed Issue Event')
  export type ReviewRequestRemovedIssueEvent = z.infer<
    typeof ReviewRequestRemovedIssueEventSchema
  >

  export const TimelineCommentEventSchema = z
    .object({
      event: z.string(),
      actor: SimpleUserSchema,
      id: z.number().int().describe('Unique identifier of the issue comment'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue comment'),
      body: z.string().describe('Contents of the issue comment').optional(),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      html_url: z.string().url(),
      user: SimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      issue_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Timeline Comment Event')
  export type TimelineCommentEvent = z.infer<typeof TimelineCommentEventSchema>

  export const CodeSearchResultItemSchema = z
    .object({
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      repository: MinimalRepositorySchema,
      score: z.number(),
      file_size: z.number().int().optional(),
      language: z.string().optional(),
      last_modified_at: z.string().datetime({ offset: true }).optional(),
      line_numbers: z.array(z.string()).optional(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Code Search Result Item')
  export type CodeSearchResultItem = z.infer<typeof CodeSearchResultItemSchema>

  export const GlobalAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe('The GitHub Security Advisory ID.')
        .readonly(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .readonly(),
      url: z.string().describe('The API URL for the advisory.').readonly(),
      html_url: z
        .string()
        .url()
        .describe('The URL for the advisory.')
        .readonly(),
      repository_advisory_url: z
        .string()
        .url()
        .describe('The API URL for the repository advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory entails.'),
      type: z
        .enum(['reviewed', 'unreviewed', 'malware'])
        .describe('The type of advisory.')
        .readonly(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low', 'unknown'])
        .describe('The severity of the advisory.'),
      source_code_location: z
        .string()
        .url()
        .describe("The URL of the advisory's source code."),
      identifiers: z
        .array(
          z.object({
            type: z.enum(['CVE', 'GHSA']).describe('The type of identifier.'),
            value: z.string().describe('The identifier value.')
          })
        )
        .readonly(),
      references: z.array(
        z
          .string()
          .describe('URLs with more information regarding the advisory.')
      ),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was published, in ISO 8601 format.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was last updated, in ISO 8601 format.'
        )
        .readonly(),
      github_reviewed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was reviewed by GitHub, in ISO 8601 format.'
        )
        .readonly(),
      nvd_published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time when the advisory was published in the National Vulnerability Database, in ISO 8601 format.\nThis field is only populated when the advisory is imported from the National Vulnerability Database.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was withdrawn, in ISO 8601 format.'
        )
        .readonly(),
      vulnerabilities: z
        .array(VulnerabilitySchema)
        .describe(
          'The products and respective version ranges affected by the advisory.'
        ),
      cvss: z.object({
        vector_string: z.string().describe('The CVSS vector.'),
        score: z.number().gte(0).lte(10).describe('The CVSS score.').readonly()
      }),
      cvss_severities: CvssSeveritiesSchema.optional(),
      epss: SecurityAdvisoryEpssSchema.optional(),
      cwes: z.array(
        z.object({
          cwe_id: z
            .string()
            .describe('The Common Weakness Enumeration (CWE) identifier.'),
          name: z.string().describe('The name of the CWE.').readonly()
        })
      ),
      credits: z
        .array(
          z.object({
            user: SimpleUserSchema,
            type: SecurityAdvisoryCreditTypesSchema
          })
        )
        .describe('The users who contributed to the advisory.')
        .readonly()
    })
    .strict()
    .describe('A GitHub Security Advisory.')
  export type GlobalAdvisory = z.infer<typeof GlobalAdvisorySchema>

  export const IssueCommentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the issue comment'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue comment'),
      body: z.string().describe('Contents of the issue comment').optional(),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      html_url: z.string().url(),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      issue_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Comments provide a way for people to collaborate on an issue.')
  export type IssueComment = z.infer<typeof IssueCommentSchema>

  export const CodeScanningVariantAnalysisSchema = z
    .object({
      id: z.number().int().describe('The ID of the variant analysis.'),
      controller_repo: SimpleRepositorySchema,
      actor: SimpleUserSchema,
      query_language: CodeScanningVariantAnalysisLanguageSchema,
      query_pack_url: z
        .string()
        .describe('The download url for the query pack.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        )
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was completed, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ. Will be null if the variant analysis has not yet completed or this information is not available."
        )
        .optional(),
      status: z.enum(['in_progress', 'succeeded', 'failed', 'cancelled']),
      actions_workflow_run_id: z
        .number()
        .int()
        .describe(
          'The GitHub Actions workflow run used to execute this variant analysis. This is only available if the workflow run has started.'
        )
        .optional(),
      failure_reason: z
        .enum([
          'no_repos_queried',
          'actions_workflow_run_failed',
          'internal_error'
        ])
        .describe(
          'The reason for a failure of the variant analysis. This is only available if the variant analysis has failed.'
        )
        .optional(),
      scanned_repositories: z
        .array(
          z.object({
            repository: CodeScanningVariantAnalysisRepositorySchema,
            analysis_status: CodeScanningVariantAnalysisStatusSchema,
            result_count: z
              .number()
              .int()
              .describe(
                'The number of results in the case of a successful analysis. This is only available for successful analyses.'
              )
              .optional(),
            artifact_size_in_bytes: z
              .number()
              .int()
              .describe(
                'The size of the artifact. This is only available for successful analyses.'
              )
              .optional(),
            failure_message: z
              .string()
              .describe(
                'The reason of the failure of this repo task. This is only available if the repository task has failed.'
              )
              .optional()
          })
        )
        .optional(),
      skipped_repositories: z
        .object({
          access_mismatch_repos:
            CodeScanningVariantAnalysisSkippedRepoGroupSchema,
          not_found_repos: z.object({
            repository_count: z
              .number()
              .int()
              .describe(
                'The total number of repositories that were skipped for this reason.'
              ),
            repository_full_names: z
              .array(z.string())
              .describe(
                'A list of full repository names that were skipped. This list may not include all repositories that were skipped.'
              )
          }),
          no_codeql_db_repos: CodeScanningVariantAnalysisSkippedRepoGroupSchema,
          over_limit_repos: CodeScanningVariantAnalysisSkippedRepoGroupSchema
        })
        .describe(
          'Information about repositories that were skipped from processing. This information is only available to the user that initiated the variant analysis.'
        )
        .optional()
    })
    .describe('A run of a CodeQL query against one or more repositories.')
  export type CodeScanningVariantAnalysis = z.infer<
    typeof CodeScanningVariantAnalysisSchema
  >

  export const CommitComparisonSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      permalink_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      base_commit: CommitSchema,
      merge_base_commit: CommitSchema,
      status: z.enum(['diverged', 'ahead', 'behind', 'identical']),
      ahead_by: z.number().int(),
      behind_by: z.number().int(),
      total_commits: z.number().int(),
      commits: z.array(CommitSchema),
      files: z.array(DiffEntrySchema).optional()
    })
    .describe('Commit Comparison')
  export type CommitComparison = z.infer<typeof CommitComparisonSchema>

  export const EnvironmentSchema = z
    .object({
      id: z.number().int().describe('The id of the environment.'),
      node_id: z.string(),
      name: z.string().describe('The name of the environment.'),
      url: z.string(),
      html_url: z.string(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the environment was created, in ISO 8601 format.'
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the environment was last updated, in ISO 8601 format.'
        ),
      protection_rules: z
        .array(
          z.union([
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              type: z.string(),
              wait_timer: WaitTimerSchema.optional()
            }),
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              prevent_self_review: z
                .boolean()
                .describe(
                  'Whether deployments to this environment can be approved by the user who created the deployment.'
                )
                .optional(),
              type: z.string(),
              reviewers: z
                .array(
                  z.object({
                    type: DeploymentReviewerTypeSchema.optional(),
                    reviewer: z.union([SimpleUserSchema, TeamSchema]).optional()
                  })
                )
                .describe(
                  'The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
                )
                .optional()
            }),
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              type: z.string()
            })
          ])
        )
        .describe('Built-in deployment protection rules for the environment.')
        .optional(),
      deployment_branch_policy: DeploymentBranchPolicySettingsSchema.optional()
    })
    .describe('Details of a deployment environment')
  export type Environment = z.infer<typeof EnvironmentSchema>

  export const HookSchema = z
    .object({
      type: z.string(),
      id: z.number().int().describe('Unique identifier of the webhook.'),
      name: z
        .string()
        .describe("The name of a valid service, use 'web' for a webhook."),
      active: z
        .boolean()
        .describe(
          'Determines whether the hook is actually triggered on pushes.'
        ),
      events: z
        .array(z.string())
        .describe(
          "Determines what events the hook is triggered for. Default: ['push']."
        ),
      config: WebhookConfigSchema,
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      test_url: z.string().url(),
      ping_url: z.string().url(),
      deliveries_url: z.string().url().optional(),
      last_response: HookResponseSchema
    })
    .describe('Webhooks for repositories.')
  export type Hook = z.infer<typeof HookSchema>

  export const CodeScanningAlertInstanceSchema = z.object({
    ref: CodeScanningRefSchema.optional(),
    analysis_key: CodeScanningAnalysisAnalysisKeySchema.optional(),
    environment: CodeScanningAlertEnvironmentSchema.optional(),
    category: CodeScanningAnalysisCategorySchema.optional(),
    state: CodeScanningAlertStateSchema.optional(),
    commit_sha: z.string().optional(),
    message: z.object({ text: z.string().optional() }).optional(),
    location: CodeScanningAlertLocationSchema.optional(),
    html_url: z.string().optional(),
    classifications: z
      .array(CodeScanningAlertClassificationSchema)
      .describe(
        'Classifications that have been applied to the file that triggered the alert.\nFor example identifying it as documentation, or a generated file.'
      )
      .optional()
  })
  export type CodeScanningAlertInstance = z.infer<
    typeof CodeScanningAlertInstanceSchema
  >

  export const FullRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z.string(),
      open_issues_count: z.number().int(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean(),
      has_projects: z.boolean(),
      has_wiki: z.boolean(),
      has_pages: z.boolean(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean(),
      archived: z.boolean(),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .optional(),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          admin: z.boolean(),
          maintain: z.boolean().optional(),
          push: z.boolean(),
          triage: z.boolean().optional(),
          pull: z.boolean()
        })
        .optional(),
      allow_rebase_merge: z.boolean().optional(),
      template_repository: NullableRepositorySchema.optional(),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z.boolean().optional(),
      allow_auto_merge: z.boolean().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      allow_merge_commit: z.boolean().optional(),
      allow_update_branch: z.boolean().optional(),
      use_squash_pr_title_as_default: z.boolean().optional(),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n  - `PR_TITLE` - default to the pull request's title.\n  - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      subscribers_count: z.number().int(),
      network_count: z.number().int(),
      license: NullableLicenseSimpleSchema,
      organization: NullableSimpleUserSchema.optional(),
      parent: RepositorySchema.optional(),
      source: RepositorySchema.optional(),
      forks: z.number().int(),
      master_branch: z.string().optional(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is allowed.')
        .default(true),
      code_of_conduct: CodeOfConductSimpleSchema.optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional(),
      custom_properties: z
        .record(z.any())
        .describe(
          'The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.'
        )
        .optional()
    })
    .describe('Full Repository')
  export type FullRepository = z.infer<typeof FullRepositorySchema>

  export const WorkflowRunSchema = z
    .object({
      id: z.number().int().describe('The ID of the workflow run.'),
      name: z.string().describe('The name of the workflow run.').optional(),
      node_id: z.string(),
      check_suite_id: z
        .number()
        .int()
        .describe('The ID of the associated check suite.')
        .optional(),
      check_suite_node_id: z
        .string()
        .describe('The node ID of the associated check suite.')
        .optional(),
      head_branch: z.string(),
      head_sha: z
        .string()
        .describe(
          'The SHA of the head commit that points to the version of the workflow being run.'
        ),
      path: z.string().describe('The full path of the workflow'),
      run_number: z
        .number()
        .int()
        .describe('The auto incrementing run number for the workflow run.'),
      run_attempt: z
        .number()
        .int()
        .describe(
          'Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.'
        )
        .optional(),
      referenced_workflows: z.array(ReferencedWorkflowSchema).optional(),
      event: z.string(),
      status: z.string(),
      conclusion: z.string(),
      workflow_id: z.number().int().describe('The ID of the parent workflow.'),
      url: z.string().describe('The URL to the workflow run.'),
      html_url: z.string(),
      pull_requests: z
        .array(PullRequestMinimalSchema)
        .describe(
          'Pull requests that are open with a `head_sha` or `head_branch` that matches the workflow run. The returned pull requests do not necessarily indicate pull requests that triggered the run.'
        ),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      actor: SimpleUserSchema.optional(),
      triggering_actor: SimpleUserSchema.optional(),
      run_started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The start time of the latest run. Resets on re-run.')
        .optional(),
      jobs_url: z
        .string()
        .describe('The URL to the jobs for the workflow run.'),
      logs_url: z
        .string()
        .describe('The URL to download the logs for the workflow run.'),
      check_suite_url: z
        .string()
        .describe('The URL to the associated check suite.'),
      artifacts_url: z
        .string()
        .describe('The URL to the artifacts for the workflow run.'),
      cancel_url: z.string().describe('The URL to cancel the workflow run.'),
      rerun_url: z.string().describe('The URL to rerun the workflow run.'),
      previous_attempt_url: z
        .string()
        .describe(
          'The URL to the previous attempted run of this workflow, if one exists.'
        )
        .optional(),
      workflow_url: z.string().describe('The URL to the workflow.'),
      head_commit: NullableSimpleCommitSchema,
      repository: MinimalRepositorySchema,
      head_repository: MinimalRepositorySchema,
      head_repository_id: z.number().int().optional(),
      display_title: z
        .string()
        .describe(
          'The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.'
        )
    })
    .describe('An invocation of a workflow')
  export type WorkflowRun = z.infer<typeof WorkflowRunSchema>

  export const ProtectedBranchSchema = z
    .object({
      url: z.string().url(),
      required_status_checks: StatusCheckPolicySchema.optional(),
      required_pull_request_reviews: z
        .object({
          url: z.string().url(),
          dismiss_stale_reviews: z.boolean().optional(),
          require_code_owner_reviews: z.boolean().optional(),
          required_approving_review_count: z.number().int().optional(),
          require_last_push_approval: z
            .boolean()
            .describe(
              'Whether the most recent push must be approved by someone other than the person who pushed it.'
            )
            .default(false),
          dismissal_restrictions: z
            .object({
              url: z.string().url(),
              users_url: z.string().url(),
              teams_url: z.string().url(),
              users: z.array(SimpleUserSchema),
              teams: z.array(TeamSchema),
              apps: z.array(IntegrationSchema).optional()
            })
            .optional(),
          bypass_pull_request_allowances: z
            .object({
              users: z.array(SimpleUserSchema),
              teams: z.array(TeamSchema),
              apps: z.array(IntegrationSchema).optional()
            })
            .optional()
        })
        .optional(),
      required_signatures: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .optional(),
      enforce_admins: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .strict()
        .optional(),
      required_linear_history: z
        .object({ enabled: z.boolean() })
        .strict()
        .optional(),
      allow_force_pushes: z
        .object({ enabled: z.boolean() })
        .strict()
        .optional(),
      allow_deletions: z.object({ enabled: z.boolean() }).strict().optional(),
      restrictions: BranchRestrictionPolicySchema.optional(),
      required_conversation_resolution: z
        .object({ enabled: z.boolean().optional() })
        .strict()
        .optional(),
      block_creations: z.object({ enabled: z.boolean() }).strict().optional(),
      lock_branch: z
        .object({ enabled: z.boolean().default(false) })
        .strict()
        .describe(
          'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.'
        )
        .optional(),
      allow_fork_syncing: z
        .object({ enabled: z.boolean().default(false) })
        .strict()
        .describe(
          'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.'
        )
        .optional()
    })
    .describe('Branch protections protect branches')
  export type ProtectedBranch = z.infer<typeof ProtectedBranchSchema>

  export const CheckSuiteSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      head_branch: z.string(),
      head_sha: z
        .string()
        .describe('The SHA of the head commit that is being checked.'),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.'
        ),
      conclusion: z.union([
        z.literal('success'),
        z.literal('failure'),
        z.literal('neutral'),
        z.literal('cancelled'),
        z.literal('skipped'),
        z.literal('timed_out'),
        z.literal('action_required'),
        z.literal('startup_failure'),
        z.literal('stale'),
        z.literal(null)
      ]),
      url: z.string(),
      before: z.string(),
      after: z.string(),
      pull_requests: z.array(PullRequestMinimalSchema),
      app: NullableIntegrationSchema,
      repository: MinimalRepositorySchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      head_commit: SimpleCommitSchema,
      latest_check_runs_count: z.number().int(),
      check_runs_url: z.string(),
      rerequestable: z.boolean().optional(),
      runs_rerequestable: z.boolean().optional()
    })
    .describe('A suite of checks performed on the code of a given code change')
  export type CheckSuite = z.infer<typeof CheckSuiteSchema>

  export const SecretScanningAlertSchema = z.object({
    number: AlertNumberSchema.optional(),
    created_at: AlertCreatedAtSchema.optional(),
    updated_at: NullableAlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema.optional(),
    html_url: AlertHtmlUrlSchema.optional(),
    locations_url: z
      .string()
      .url()
      .describe('The REST API URL of the code locations for this alert.')
      .optional(),
    state: SecretScanningAlertStateSchema.optional(),
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolved_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    resolved_by: NullableSimpleUserSchema.optional(),
    resolution_comment: z
      .string()
      .describe('An optional comment to resolve an alert.')
      .optional(),
    secret_type: z
      .string()
      .describe('The type of secret that secret scanning detected.')
      .optional(),
    secret_type_display_name: z
      .string()
      .describe(
        'User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
      )
      .optional(),
    secret: z.string().describe('The secret that was detected.').optional(),
    push_protection_bypassed: z
      .boolean()
      .describe('Whether push protection was bypassed for the detected secret.')
      .optional(),
    push_protection_bypassed_by: NullableSimpleUserSchema.optional(),
    push_protection_bypassed_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    push_protection_bypass_request_reviewer:
      NullableSimpleUserSchema.optional(),
    push_protection_bypass_request_reviewer_comment: z
      .string()
      .describe('An optional comment when reviewing a push protection bypass.')
      .optional(),
    push_protection_bypass_request_comment: z
      .string()
      .describe('An optional comment when requesting a push protection bypass.')
      .optional(),
    push_protection_bypass_request_html_url: z
      .string()
      .url()
      .describe('The URL to a push protection bypass request.')
      .optional(),
    validity: z
      .enum(['active', 'inactive', 'unknown'])
      .describe('The token status as of the latest validity check.')
      .optional(),
    publicly_leaked: z
      .boolean()
      .describe('Whether the detected secret was publicly leaked.')
      .optional(),
    multi_repo: z
      .boolean()
      .describe(
        'Whether the detected secret was found in multiple repositories under the same organization or enterprise.'
      )
      .optional(),
    is_base64_encoded: z
      .boolean()
      .describe(
        'A boolean value representing whether or not alert is base64 encoded'
      )
      .optional()
  })
  export type SecretScanningAlert = z.infer<typeof SecretScanningAlertSchema>

  export const CommitSearchResultItemSchema = z
    .object({
      url: z.string().url(),
      sha: z.string(),
      html_url: z.string().url(),
      comments_url: z.string().url(),
      commit: z.object({
        author: z.object({
          name: z.string(),
          email: z.string(),
          date: z.string().datetime({ offset: true })
        }),
        committer: NullableGitUserSchema,
        comment_count: z.number().int(),
        message: z.string(),
        tree: z.object({ sha: z.string(), url: z.string().url() }),
        url: z.string().url(),
        verification: VerificationSchema.optional()
      }),
      author: NullableSimpleUserSchema,
      committer: NullableGitUserSchema,
      parents: z.array(
        z.object({
          url: z.string().optional(),
          html_url: z.string().optional(),
          sha: z.string().optional()
        })
      ),
      repository: MinimalRepositorySchema,
      score: z.number(),
      node_id: z.string(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Commit Search Result Item')
  export type CommitSearchResultItem = z.infer<
    typeof CommitSearchResultItemSchema
  >

  export const RepositoryAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe('The GitHub Security Advisory ID.')
        .readonly(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.'),
      url: z
        .string()
        .url()
        .describe('The API URL for the advisory.')
        .readonly(),
      html_url: z
        .string()
        .url()
        .describe('The URL for the advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory entails.'),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe('The severity of the advisory.'),
      author: SimpleUserSchema.describe(
        'The author of the advisory.'
      ).readonly(),
      publisher: SimpleUserSchema.describe(
        'The publisher of the advisory.'
      ).readonly(),
      identifiers: z
        .array(
          z.object({
            type: z.enum(['CVE', 'GHSA']).describe('The type of identifier.'),
            value: z.string().describe('The identifier value.')
          })
        )
        .readonly(),
      state: z
        .enum(['published', 'closed', 'withdrawn', 'draft', 'triage'])
        .describe('The state of the advisory.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was created, in ISO 8601 format.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was last updated, in ISO 8601 format.'
        )
        .readonly(),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was published, in ISO 8601 format.'
        )
        .readonly(),
      closed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was closed, in ISO 8601 format.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was withdrawn, in ISO 8601 format.'
        )
        .readonly(),
      submission: z
        .object({
          accepted: z
            .boolean()
            .describe(
              "Whether a private vulnerability report was accepted by the repository's administrators."
            )
            .readonly()
        })
        .readonly(),
      vulnerabilities: z.array(RepositoryAdvisoryVulnerabilitySchema),
      cvss: z.object({
        vector_string: z.string().describe('The CVSS vector.'),
        score: z.number().gte(0).lte(10).describe('The CVSS score.').readonly()
      }),
      cvss_severities: CvssSeveritiesSchema.optional(),
      cwes: z
        .array(
          z.object({
            cwe_id: z
              .string()
              .describe('The Common Weakness Enumeration (CWE) identifier.'),
            name: z.string().describe('The name of the CWE.').readonly()
          })
        )
        .readonly(),
      cwe_ids: z.array(z.string()).describe('A list of only the CWE IDs.'),
      credits: z.array(
        z.object({
          login: z
            .string()
            .describe('The username of the user credited.')
            .optional(),
          type: SecurityAdvisoryCreditTypesSchema.optional()
        })
      ),
      credits_detailed: z.array(RepositoryAdvisoryCreditSchema).readonly(),
      collaborating_users: z
        .array(SimpleUserSchema)
        .describe('A list of users that collaborate on the advisory.'),
      collaborating_teams: z
        .array(TeamSchema)
        .describe('A list of teams that collaborate on the advisory.'),
      private_fork: SimpleRepositorySchema.describe(
        "A temporary private fork of the advisory's repository for collaborating on a fix."
      ).readonly()
    })
    .strict()
    .describe('A repository security advisory.')
  export type RepositoryAdvisory = z.infer<typeof RepositoryAdvisorySchema>

  export const BranchProtectionSchema = z
    .object({
      url: z.string().optional(),
      enabled: z.boolean().optional(),
      required_status_checks:
        ProtectedBranchRequiredStatusCheckSchema.optional(),
      enforce_admins: ProtectedBranchAdminEnforcedSchema.optional(),
      required_pull_request_reviews:
        ProtectedBranchPullRequestReviewSchema.optional(),
      restrictions: BranchRestrictionPolicySchema.optional(),
      required_linear_history: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      allow_force_pushes: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      allow_deletions: z.object({ enabled: z.boolean().optional() }).optional(),
      block_creations: z.object({ enabled: z.boolean().optional() }).optional(),
      required_conversation_resolution: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      name: z.string().optional(),
      protection_url: z.string().optional(),
      required_signatures: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .optional(),
      lock_branch: z
        .object({ enabled: z.boolean().default(false) })
        .describe(
          'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.'
        )
        .optional(),
      allow_fork_syncing: z
        .object({ enabled: z.boolean().default(false) })
        .describe(
          'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.'
        )
        .optional()
    })
    .describe('Branch Protection')
  export type BranchProtection = z.infer<typeof BranchProtectionSchema>

  export const PullRequestSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      html_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      issue_url: z.string().url(),
      commits_url: z.string().url(),
      review_comments_url: z.string().url(),
      review_comment_url: z.string(),
      comments_url: z.string().url(),
      statuses_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the pull request within its repository.'
        ),
      state: z
        .enum(['open', 'closed'])
        .describe('State of this Pull Request. Either `open` or `closed`.'),
      locked: z.boolean(),
      title: z.string().describe('The title of the pull request.'),
      user: SimpleUserSchema,
      body: z.string(),
      labels: z.array(
        z.object({
          id: z.number().int(),
          node_id: z.string(),
          url: z.string(),
          name: z.string(),
          description: z.string(),
          color: z.string(),
          default: z.boolean()
        })
      ),
      milestone: NullableMilestoneSchema,
      active_lock_reason: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      merged_at: z.string().datetime({ offset: true }),
      merge_commit_sha: z.string(),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      requested_reviewers: z.array(SimpleUserSchema).optional(),
      requested_teams: z.array(TeamSimpleSchema).optional(),
      head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: SimpleUserSchema
      }),
      base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: SimpleUserSchema
      }),
      _links: z.object({
        comments: LinkSchema,
        commits: LinkSchema,
        statuses: LinkSchema,
        html: LinkSchema,
        issue: LinkSchema,
        review_comments: LinkSchema,
        review_comment: LinkSchema,
        self: LinkSchema
      }),
      author_association: AuthorAssociationSchema,
      auto_merge: AutoMergeSchema,
      draft: z
        .boolean()
        .describe('Indicates whether or not the pull request is a draft.')
        .optional(),
      merged: z.boolean(),
      mergeable: z.boolean(),
      rebaseable: z.boolean().optional(),
      mergeable_state: z.string(),
      merged_by: NullableSimpleUserSchema,
      comments: z.number().int(),
      review_comments: z.number().int(),
      maintainer_can_modify: z
        .boolean()
        .describe('Indicates whether maintainers can modify the pull request.'),
      commits: z.number().int(),
      additions: z.number().int(),
      deletions: z.number().int(),
      changed_files: z.number().int()
    })
    .describe(
      "Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary."
    )
  export type PullRequest = z.infer<typeof PullRequestSchema>

  export const CodespaceWithFullRepositorySchema = z
    .object({
      id: z.number().int(),
      name: z
        .string()
        .describe('Automatically generated name of this codespace.'),
      display_name: z
        .string()
        .describe('Display name for this codespace.')
        .optional(),
      environment_id: z
        .string()
        .describe("UUID identifying this codespace's environment."),
      owner: SimpleUserSchema,
      billable_owner: SimpleUserSchema,
      repository: FullRepositorySchema,
      machine: NullableCodespaceMachineSchema,
      devcontainer_path: z
        .string()
        .describe(
          'Path to devcontainer.json from repo root used to create Codespace.'
        )
        .optional(),
      prebuild: z
        .boolean()
        .describe('Whether the codespace was created from a prebuild.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      last_used_at: z
        .string()
        .datetime({ offset: true })
        .describe('Last known time this codespace was started.'),
      state: z
        .enum([
          'Unknown',
          'Created',
          'Queued',
          'Provisioning',
          'Available',
          'Awaiting',
          'Unavailable',
          'Deleted',
          'Moved',
          'Shutdown',
          'Archived',
          'Starting',
          'ShuttingDown',
          'Failed',
          'Exporting',
          'Updating',
          'Rebuilding'
        ])
        .describe('State of this codespace.'),
      url: z.string().url().describe('API URL for this codespace.'),
      git_status: z
        .object({
          ahead: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is ahead of the remote.'
            )
            .optional(),
          behind: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is behind the remote.'
            )
            .optional(),
          has_unpushed_changes: z
            .boolean()
            .describe('Whether the local repository has unpushed changes.')
            .optional(),
          has_uncommitted_changes: z
            .boolean()
            .describe('Whether the local repository has uncommitted changes.')
            .optional(),
          ref: z
            .string()
            .describe(
              'The current branch (or SHA if in detached HEAD state) of the local repository.'
            )
            .optional()
        })
        .describe("Details about the codespace's git repository."),
      location: z
        .enum(['EastUs', 'SouthEastAsia', 'WestEurope', 'WestUs2'])
        .describe('The initally assigned location of a new codespace.'),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe(
          'The number of minutes of inactivity after which this codespace will be automatically stopped.'
        ),
      web_url: z
        .string()
        .url()
        .describe('URL to access this codespace on the web.'),
      machines_url: z
        .string()
        .url()
        .describe(
          'API URL to access available alternate machine types for this codespace.'
        ),
      start_url: z.string().url().describe('API URL to start this codespace.'),
      stop_url: z.string().url().describe('API URL to stop this codespace.'),
      publish_url: z
        .string()
        .url()
        .describe('API URL to publish this codespace to a new repository.')
        .optional(),
      pulls_url: z
        .string()
        .url()
        .describe(
          'API URL for the Pull Request associated with this codespace, if any.'
        ),
      recent_folders: z.array(z.string()),
      runtime_constraints: z
        .object({
          allowed_port_privacy_settings: z
            .array(z.string())
            .describe(
              'The privacy settings a user can select from when forwarding a port.'
            )
            .optional()
        })
        .optional(),
      pending_operation: z
        .boolean()
        .describe(
          'Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.'
        )
        .optional(),
      pending_operation_disabled_reason: z
        .string()
        .describe(
          'Text to show user when codespace is disabled by a pending operation'
        )
        .optional(),
      idle_timeout_notice: z
        .string()
        .describe(
          'Text to show user when codespace idle timeout minutes has been overriden by an organization policy'
        )
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      retention_expires_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'When a codespace will be auto-deleted based on the "retention_period_minutes" and "last_used_at"'
        )
        .optional()
    })
    .describe('A codespace.')
  export type CodespaceWithFullRepository = z.infer<
    typeof CodespaceWithFullRepositorySchema
  >

  export const OrganizationSecretScanningAlertSchema = z.object({
    number: AlertNumberSchema.optional(),
    created_at: AlertCreatedAtSchema.optional(),
    updated_at: NullableAlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema.optional(),
    html_url: AlertHtmlUrlSchema.optional(),
    locations_url: z
      .string()
      .url()
      .describe('The REST API URL of the code locations for this alert.')
      .optional(),
    state: SecretScanningAlertStateSchema.optional(),
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolved_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    resolved_by: NullableSimpleUserSchema.optional(),
    secret_type: z
      .string()
      .describe('The type of secret that secret scanning detected.')
      .optional(),
    secret_type_display_name: z
      .string()
      .describe(
        'User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
      )
      .optional(),
    secret: z.string().describe('The secret that was detected.').optional(),
    repository: SimpleRepositorySchema.optional(),
    push_protection_bypassed: z
      .boolean()
      .describe('Whether push protection was bypassed for the detected secret.')
      .optional(),
    push_protection_bypassed_by: NullableSimpleUserSchema.optional(),
    push_protection_bypassed_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    push_protection_bypass_request_reviewer:
      NullableSimpleUserSchema.optional(),
    push_protection_bypass_request_reviewer_comment: z
      .string()
      .describe('An optional comment when reviewing a push protection bypass.')
      .optional(),
    push_protection_bypass_request_comment: z
      .string()
      .describe('An optional comment when requesting a push protection bypass.')
      .optional(),
    push_protection_bypass_request_html_url: z
      .string()
      .url()
      .describe('The URL to a push protection bypass request.')
      .optional(),
    resolution_comment: z
      .string()
      .describe(
        'The comment that was optionally added when this alert was closed'
      )
      .optional(),
    validity: z
      .enum(['active', 'inactive', 'unknown'])
      .describe('The token status as of the latest validity check.')
      .optional(),
    publicly_leaked: z
      .boolean()
      .describe('Whether the secret was publicly leaked.')
      .optional(),
    multi_repo: z
      .boolean()
      .describe(
        'Whether the detected secret was found in multiple repositories in the same organization or enterprise.'
      )
      .optional(),
    is_base64_encoded: z
      .boolean()
      .describe(
        'A boolean value representing whether or not alert is base64 encoded'
      )
      .optional()
  })
  export type OrganizationSecretScanningAlert = z.infer<
    typeof OrganizationSecretScanningAlertSchema
  >

  export const ShortBranchSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string().url() }),
      protected: z.boolean(),
      protection: BranchProtectionSchema.optional(),
      protection_url: z.string().url().optional()
    })
    .describe('Short Branch')
  export type ShortBranch = z.infer<typeof ShortBranchSchema>

  export const PullRequestSimpleSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      html_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      issue_url: z.string().url(),
      commits_url: z.string().url(),
      review_comments_url: z.string().url(),
      review_comment_url: z.string(),
      comments_url: z.string().url(),
      statuses_url: z.string().url(),
      number: z.number().int(),
      state: z.string(),
      locked: z.boolean(),
      title: z.string(),
      user: NullableSimpleUserSchema,
      body: z.string(),
      labels: z.array(
        z.object({
          id: z.number().int(),
          node_id: z.string(),
          url: z.string(),
          name: z.string(),
          description: z.string(),
          color: z.string(),
          default: z.boolean()
        })
      ),
      milestone: NullableMilestoneSchema,
      active_lock_reason: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      merged_at: z.string().datetime({ offset: true }),
      merge_commit_sha: z.string(),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      requested_reviewers: z.array(SimpleUserSchema).optional(),
      requested_teams: z.array(TeamSchema).optional(),
      head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: NullableSimpleUserSchema
      }),
      base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: NullableSimpleUserSchema
      }),
      _links: z.object({
        comments: LinkSchema,
        commits: LinkSchema,
        statuses: LinkSchema,
        html: LinkSchema,
        issue: LinkSchema,
        review_comments: LinkSchema,
        review_comment: LinkSchema,
        self: LinkSchema
      }),
      author_association: AuthorAssociationSchema,
      auto_merge: AutoMergeSchema,
      draft: z
        .boolean()
        .describe('Indicates whether or not the pull request is a draft.')
        .optional()
    })
    .describe('Pull Request Simple')
  export type PullRequestSimple = z.infer<typeof PullRequestSimpleSchema>

  export const IssueSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue'),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the issue within its repository'
        ),
      state: z
        .string()
        .describe("State of the issue; either 'open' or 'closed'"),
      state_reason: z
        .enum(['completed', 'reopened', 'not_planned'])
        .describe('The reason for the current state')
        .optional(),
      title: z.string().describe('Title of the issue'),
      body: z.string().describe('Contents of the issue').optional(),
      user: NullableSimpleUserSchema,
      labels: z
        .array(
          z.union([
            z.string(),
            z.object({
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().url().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
              color: z.string().optional(),
              default: z.boolean().optional()
            })
          ])
        )
        .describe(
          'Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository'
        ),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      milestone: NullableMilestoneSchema,
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      comments: z.number().int(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      closed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      draft: z.boolean().optional(),
      closed_by: NullableSimpleUserSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      repository: RepositorySchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional(),
      sub_issues_summary: SubIssuesSummarySchema.optional()
    })
    .describe(
      'Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.'
    )
  export type Issue = z.infer<typeof IssueSchema>

  export const NullableIssueSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue'),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the issue within its repository'
        ),
      state: z
        .string()
        .describe("State of the issue; either 'open' or 'closed'"),
      state_reason: z
        .enum(['completed', 'reopened', 'not_planned'])
        .describe('The reason for the current state')
        .optional(),
      title: z.string().describe('Title of the issue'),
      body: z.string().describe('Contents of the issue').optional(),
      user: NullableSimpleUserSchema,
      labels: z
        .array(
          z.union([
            z.string(),
            z.object({
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().url().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
              color: z.string().optional(),
              default: z.boolean().optional()
            })
          ])
        )
        .describe(
          'Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository'
        ),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      milestone: NullableMilestoneSchema,
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      comments: z.number().int(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      closed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      draft: z.boolean().optional(),
      closed_by: NullableSimpleUserSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      repository: RepositorySchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional(),
      sub_issues_summary: SubIssuesSummarySchema.optional()
    })
    .describe(
      'Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.'
    )
  export type NullableIssue = z.infer<typeof NullableIssueSchema>

  export const IssueSearchResultItemSchema = z
    .object({
      url: z.string().url(),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int(),
      title: z.string(),
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      assignees: z.array(SimpleUserSchema).optional(),
      user: NullableSimpleUserSchema,
      labels: z.array(
        z.object({
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          name: z.string().optional(),
          color: z.string().optional(),
          default: z.boolean().optional(),
          description: z.string().optional()
        })
      ),
      sub_issues_summary: z
        .object({
          total: z.number().int(),
          completed: z.number().int(),
          percent_completed: z.number().int()
        })
        .optional(),
      state: z.string(),
      state_reason: z.string().optional(),
      assignee: NullableSimpleUserSchema,
      milestone: NullableMilestoneSchema,
      comments: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      text_matches: SearchResultTextMatchesSchema.optional(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      body: z.string().optional(),
      score: z.number(),
      author_association: AuthorAssociationSchema,
      draft: z.boolean().optional(),
      repository: RepositorySchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Issue Search Result Item')
  export type IssueSearchResultItem = z.infer<
    typeof IssueSearchResultItemSchema
  >

  export const CodeScanningAnalysisSchema = z.object({
    ref: CodeScanningRefSchema,
    commit_sha: CodeScanningAnalysisCommitShaSchema,
    analysis_key: CodeScanningAnalysisAnalysisKeySchema,
    environment: CodeScanningAnalysisEnvironmentSchema,
    category: CodeScanningAnalysisCategorySchema.optional(),
    error: z.string(),
    created_at: CodeScanningAnalysisCreatedAtSchema,
    results_count: z
      .number()
      .int()
      .describe('The total number of results in the analysis.'),
    rules_count: z
      .number()
      .int()
      .describe('The total number of rules used in the analysis.'),
    id: z.number().int().describe('Unique identifier for this analysis.'),
    url: CodeScanningAnalysisUrlSchema,
    sarif_id: CodeScanningAnalysisSarifIdSchema,
    tool: CodeScanningAnalysisToolSchema,
    deletable: z.boolean(),
    warning: z
      .string()
      .describe('Warning generated when processing the analysis')
  })
  export type CodeScanningAnalysis = z.infer<typeof CodeScanningAnalysisSchema>

  export const TimelineCrossReferencedEventSchema = z
    .object({
      event: z.string(),
      actor: SimpleUserSchema.optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      source: z.object({
        type: z.string().optional(),
        issue: IssueSchema.optional()
      })
    })
    .describe('Timeline Cross Referenced Event')
  export type TimelineCrossReferencedEvent = z.infer<
    typeof TimelineCrossReferencedEventSchema
  >

  export const SecretScanningLocationSchema = z.object({
    type: z
      .enum([
        'commit',
        'wiki_commit',
        'issue_title',
        'issue_body',
        'issue_comment',
        'discussion_title',
        'discussion_body',
        'discussion_comment',
        'pull_request_title',
        'pull_request_body',
        'pull_request_comment',
        'pull_request_review',
        'pull_request_review_comment'
      ])
      .describe(
        'The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.'
      )
      .optional(),
    details: z
      .union([
        SecretScanningLocationCommitSchema,
        SecretScanningLocationWikiCommitSchema,
        SecretScanningLocationIssueTitleSchema,
        SecretScanningLocationIssueBodySchema,
        SecretScanningLocationIssueCommentSchema,
        SecretScanningLocationDiscussionTitleSchema,
        SecretScanningLocationDiscussionBodySchema,
        SecretScanningLocationDiscussionCommentSchema,
        SecretScanningLocationPullRequestTitleSchema,
        SecretScanningLocationPullRequestBodySchema,
        SecretScanningLocationPullRequestCommentSchema,
        SecretScanningLocationPullRequestReviewSchema,
        SecretScanningLocationPullRequestReviewCommentSchema
      ])
      .optional()
  })
  export type SecretScanningLocation = z.infer<
    typeof SecretScanningLocationSchema
  >

  export const DependabotAlertSchema = z
    .object({
      number: AlertNumberSchema,
      state: z
        .enum(['auto_dismissed', 'dismissed', 'fixed', 'open'])
        .describe('The state of the Dependabot alert.')
        .readonly(),
      dependency: z
        .object({
          package: DependabotAlertPackageSchema.optional(),
          manifest_path: z
            .string()
            .describe(
              'The full path to the dependency manifest file, relative to the root of the repository.'
            )
            .readonly()
            .optional(),
          scope: z
            .enum(['development', 'runtime'])
            .describe('The execution scope of the vulnerable dependency.')
            .readonly()
            .optional(),
          relationship: z
            .enum(['unknown', 'direct', 'transitive'])
            .describe(
              'The vulnerable dependency\'s relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be "unknown" for all dependencies in unsupported ecosystems.\n'
            )
            .readonly()
            .optional()
        })
        .describe('Details for the vulnerable dependency.')
        .readonly(),
      security_advisory: DependabotAlertSecurityAdvisorySchema,
      security_vulnerability: DependabotAlertSecurityVulnerabilitySchema,
      url: AlertUrlSchema,
      html_url: AlertHtmlUrlSchema,
      created_at: AlertCreatedAtSchema,
      updated_at: AlertUpdatedAtSchema,
      dismissed_at: AlertDismissedAtSchema,
      dismissed_by: NullableSimpleUserSchema,
      dismissed_reason: z
        .enum([
          'fix_started',
          'inaccurate',
          'no_bandwidth',
          'not_used',
          'tolerable_risk'
        ])
        .describe('The reason that the alert was dismissed.'),
      dismissed_comment: z
        .string()
        .max(280)
        .describe("An optional comment associated with the alert's dismissal."),
      fixed_at: AlertFixedAtSchema,
      auto_dismissed_at: AlertAutoDismissedAtSchema.optional()
    })
    .strict()
    .describe('A Dependabot alert.')
  export type DependabotAlert = z.infer<typeof DependabotAlertSchema>

  export const BranchWithProtectionSchema = z
    .object({
      name: z.string(),
      commit: CommitSchema,
      _links: z.object({ html: z.string(), self: z.string().url() }),
      protected: z.boolean(),
      protection: BranchProtectionSchema,
      protection_url: z.string().url(),
      pattern: z.string().optional(),
      required_approving_review_count: z.number().int().optional()
    })
    .describe('Branch With Protection')
  export type BranchWithProtection = z.infer<typeof BranchWithProtectionSchema>

  export const DependabotAlertWithRepositorySchema = z
    .object({
      number: AlertNumberSchema,
      state: z
        .enum(['auto_dismissed', 'dismissed', 'fixed', 'open'])
        .describe('The state of the Dependabot alert.')
        .readonly(),
      dependency: z
        .object({
          package: DependabotAlertPackageSchema.optional(),
          manifest_path: z
            .string()
            .describe(
              'The full path to the dependency manifest file, relative to the root of the repository.'
            )
            .readonly()
            .optional(),
          scope: z
            .enum(['development', 'runtime'])
            .describe('The execution scope of the vulnerable dependency.')
            .readonly()
            .optional(),
          relationship: z
            .enum(['unknown', 'direct', 'transitive'])
            .describe(
              'The vulnerable dependency\'s relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be "unknown" for all dependencies in unsupported ecosystems.\n'
            )
            .readonly()
            .optional()
        })
        .describe('Details for the vulnerable dependency.')
        .readonly(),
      security_advisory: DependabotAlertSecurityAdvisorySchema,
      security_vulnerability: DependabotAlertSecurityVulnerabilitySchema,
      url: AlertUrlSchema,
      html_url: AlertHtmlUrlSchema,
      created_at: AlertCreatedAtSchema,
      updated_at: AlertUpdatedAtSchema,
      dismissed_at: AlertDismissedAtSchema,
      dismissed_by: NullableSimpleUserSchema,
      dismissed_reason: z
        .enum([
          'fix_started',
          'inaccurate',
          'no_bandwidth',
          'not_used',
          'tolerable_risk'
        ])
        .describe('The reason that the alert was dismissed.'),
      dismissed_comment: z
        .string()
        .max(280)
        .describe("An optional comment associated with the alert's dismissal."),
      fixed_at: AlertFixedAtSchema,
      auto_dismissed_at: AlertAutoDismissedAtSchema.optional(),
      repository: SimpleRepositorySchema
    })
    .strict()
    .describe('A Dependabot alert.')
  export type DependabotAlertWithRepository = z.infer<
    typeof DependabotAlertWithRepositorySchema
  >

  export const IssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      actor: NullableSimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string().datetime({ offset: true }),
      issue: NullableIssueSchema.optional(),
      label: IssueEventLabelSchema.optional(),
      assignee: NullableSimpleUserSchema.optional(),
      assigner: NullableSimpleUserSchema.optional(),
      review_requester: NullableSimpleUserSchema.optional(),
      requested_reviewer: NullableSimpleUserSchema.optional(),
      requested_team: TeamSchema.optional(),
      dismissed_review: IssueEventDismissedReviewSchema.optional(),
      milestone: IssueEventMilestoneSchema.optional(),
      project_card: IssueEventProjectCardSchema.optional(),
      rename: IssueEventRenameSchema.optional(),
      author_association: AuthorAssociationSchema.optional(),
      lock_reason: z.string().optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('Issue Event')
  export type IssueEvent = z.infer<typeof IssueEventSchema>

  export const IssueEventForIssueSchema = z
    .union([
      LabeledIssueEventSchema,
      UnlabeledIssueEventSchema,
      AssignedIssueEventSchema,
      UnassignedIssueEventSchema,
      MilestonedIssueEventSchema,
      DemilestonedIssueEventSchema,
      RenamedIssueEventSchema,
      ReviewRequestedIssueEventSchema,
      ReviewRequestRemovedIssueEventSchema,
      ReviewDismissedIssueEventSchema,
      LockedIssueEventSchema,
      AddedToProjectIssueEventSchema,
      MovedColumnInProjectIssueEventSchema,
      RemovedFromProjectIssueEventSchema,
      ConvertedNoteToIssueIssueEventSchema
    ])
    .describe('Issue Event for Issue')
  export type IssueEventForIssue = z.infer<typeof IssueEventForIssueSchema>

  export const RepositoryRuleSchema = z
    .record(z.any())
    .and(
      z.union([
        RepositoryRuleCreationSchema,
        RepositoryRuleUpdateSchema,
        RepositoryRuleDeletionSchema,
        RepositoryRuleRequiredLinearHistorySchema,
        RepositoryRuleMergeQueueSchema,
        RepositoryRuleRequiredDeploymentsSchema,
        RepositoryRuleRequiredSignaturesSchema,
        RepositoryRulePullRequestSchema,
        RepositoryRuleRequiredStatusChecksSchema,
        RepositoryRuleNonFastForwardSchema,
        RepositoryRuleCommitMessagePatternSchema,
        RepositoryRuleCommitAuthorEmailPatternSchema,
        RepositoryRuleCommitterEmailPatternSchema,
        RepositoryRuleBranchNamePatternSchema,
        RepositoryRuleTagNamePatternSchema,
        RepositoryRuleFilePathRestrictionSchema,
        RepositoryRuleMaxFilePathLengthSchema,
        RepositoryRuleFileExtensionRestrictionSchema,
        RepositoryRuleMaxFileSizeSchema,
        RepositoryRuleWorkflowsSchema,
        RepositoryRuleCodeScanningSchema
      ])
    )
    .describe('A repository rule.')
  export type RepositoryRule = z.infer<typeof RepositoryRuleSchema>

  export const CodeScanningAlertItemsSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSummarySchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningAlertItems = z.infer<
    typeof CodeScanningAlertItemsSchema
  >

  export const CodeScanningAlertSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningAlert = z.infer<typeof CodeScanningAlertSchema>

  export const RepositoryRuleDetailedSchema = z
    .record(z.any())
    .and(
      z.union([
        z.intersection(
          RepositoryRuleCreationSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleUpdateSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleDeletionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredLinearHistorySchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMergeQueueSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredDeploymentsSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredSignaturesSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRulePullRequestSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredStatusChecksSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleNonFastForwardSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitMessagePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitAuthorEmailPatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitterEmailPatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleBranchNamePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleTagNamePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleFilePathRestrictionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMaxFilePathLengthSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleFileExtensionRestrictionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMaxFileSizeSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleWorkflowsSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCodeScanningSchema,
          RepositoryRuleRulesetInfoSchema
        )
      ])
    )
    .describe('A repository rule with ruleset details.')
  export type RepositoryRuleDetailed = z.infer<
    typeof RepositoryRuleDetailedSchema
  >

  export const CodeScanningOrganizationAlertItemsSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSummarySchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    repository: SimpleRepositorySchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningOrganizationAlertItems = z.infer<
    typeof CodeScanningOrganizationAlertItemsSchema
  >

  export const RepositoryRulesetSchema = z
    .object({
      id: z.number().int().describe('The ID of the ruleset'),
      name: z.string().describe('The name of the ruleset'),
      target: z
        .enum(['branch', 'tag', 'push', 'repository'])
        .describe('The target of the ruleset')
        .optional(),
      source_type: z
        .enum(['Repository', 'Organization', 'Enterprise'])
        .describe('The type of the source of the ruleset')
        .optional(),
      source: z.string().describe('The name of the source'),
      enforcement: RepositoryRuleEnforcementSchema,
      bypass_actors: z
        .array(RepositoryRulesetBypassActorSchema)
        .describe('The actors that can bypass the rules in this ruleset')
        .optional(),
      current_user_can_bypass: z
        .enum(['always', 'pull_requests_only', 'never'])
        .describe(
          'The bypass type of the user making the API request for this ruleset. This field is only returned when\nquerying the repository-level endpoint.'
        )
        .optional(),
      node_id: z.string().optional(),
      _links: z
        .object({
          self: z
            .object({
              href: z.string().describe('The URL of the ruleset').optional()
            })
            .optional(),
          html: z
            .object({
              href: z
                .string()
                .describe('The html URL of the ruleset')
                .optional()
            })
            .optional()
        })
        .optional(),
      conditions: z
        .union([RepositoryRulesetConditionsSchema, OrgRulesetConditionsSchema])
        .optional(),
      rules: z.array(RepositoryRuleSchema).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A set of rules to apply when specified conditions are met.')
  export type RepositoryRuleset = z.infer<typeof RepositoryRulesetSchema>

  export const TimelineIssueEventsSchema = z
    .record(z.any())
    .and(
      z.union([
        LabeledIssueEventSchema,
        UnlabeledIssueEventSchema,
        MilestonedIssueEventSchema,
        DemilestonedIssueEventSchema,
        RenamedIssueEventSchema,
        ReviewRequestedIssueEventSchema,
        ReviewRequestRemovedIssueEventSchema,
        ReviewDismissedIssueEventSchema,
        LockedIssueEventSchema,
        AddedToProjectIssueEventSchema,
        MovedColumnInProjectIssueEventSchema,
        RemovedFromProjectIssueEventSchema,
        ConvertedNoteToIssueIssueEventSchema,
        TimelineCommentEventSchema,
        TimelineCrossReferencedEventSchema,
        TimelineCommittedEventSchema,
        TimelineReviewedEventSchema,
        TimelineLineCommentedEventSchema,
        TimelineCommitCommentedEventSchema,
        TimelineAssignedIssueEventSchema,
        TimelineUnassignedIssueEventSchema,
        StateChangeIssueEventSchema
      ])
    )
    .describe('Timeline Event')
  export type TimelineIssueEvents = z.infer<typeof TimelineIssueEventsSchema>

  // -----------------------------------------------------------------------------
  // Operation schemas
  // -----------------------------------------------------------------------------

  export const MetaRootParamsSchema = z.object({})
  export type MetaRootParams = z.infer<typeof MetaRootParamsSchema>

  export const MetaRootResponseSchema = RootSchema
  export type MetaRootResponse = z.infer<typeof MetaRootResponseSchema>

  export const SecurityAdvisoriesListGlobalAdvisoriesParamsSchema = z.object({
    ghsa_id: z
      .string()
      .describe(
        'If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.'
      )
      .optional(),
    type: z
      .enum(['reviewed', 'malware', 'unreviewed'])
      .describe(
        'If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.'
      )
      .default('reviewed'),
    cve_id: z
      .string()
      .describe(
        'If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.'
      )
      .optional(),
    ecosystem: z
      .any()
      .describe(
        'If specified, only advisories for these ecosystems will be returned.'
      )
      .optional(),
    severity: z
      .enum(['unknown', 'low', 'medium', 'high', 'critical'])
      .describe(
        'If specified, only advisories with these severities will be returned.'
      )
      .optional(),
    cwes: z
      .union([z.string(), z.array(z.string())])
      .describe(
        'If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.\n\nExample: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`'
      )
      .optional(),
    is_withdrawn: z
      .boolean()
      .describe('Whether to only return advisories that have been withdrawn.')
      .optional(),
    affects: z
      .union([z.string(), z.array(z.string()).max(1000)])
      .describe(
        'If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified.\nIf the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.\n\nExample: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`'
      )
      .optional(),
    published: z
      .string()
      .describe(
        'If specified, only return advisories that were published on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    updated: z
      .string()
      .describe(
        'If specified, only return advisories that were updated on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    modified: z
      .string()
      .describe(
        'If specified, only show advisories that were updated or published on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'If specified, only return advisories that have an EPSS percentage score that matches the provided value.\nThe EPSS percentage represents the likelihood of a CVE being exploited.'
      )
      .optional(),
    epss_percentile: z
      .string()
      .describe(
        "If specified, only return advisories that have an EPSS percentile score that matches the provided value.\nThe EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs."
      )
      .optional(),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    sort: z
      .enum(['updated', 'published', 'epss_percentage', 'epss_percentile'])
      .describe('The property to sort the results by.')
      .default('published')
  })
  export type SecurityAdvisoriesListGlobalAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListGlobalAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListGlobalAdvisoriesResponseSchema =
    z.array(GlobalAdvisorySchema)
  export type SecurityAdvisoriesListGlobalAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListGlobalAdvisoriesResponseSchema
  >

  export const SecurityAdvisoriesGetGlobalAdvisoryParamsSchema = z.object({
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesGetGlobalAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesGetGlobalAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesGetGlobalAdvisoryResponseSchema =
    GlobalAdvisorySchema
  export type SecurityAdvisoriesGetGlobalAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesGetGlobalAdvisoryResponseSchema
  >

  export const AppsGetAuthenticatedParamsSchema = z.object({})
  export type AppsGetAuthenticatedParams = z.infer<
    typeof AppsGetAuthenticatedParamsSchema
  >

  export const AppsGetAuthenticatedResponseSchema = IntegrationSchema
  export type AppsGetAuthenticatedResponse = z.infer<
    typeof AppsGetAuthenticatedResponseSchema
  >

  export const AppsCreateFromManifestParamsSchema = z.object({
    code: z.string()
  })
  export type AppsCreateFromManifestParams = z.infer<
    typeof AppsCreateFromManifestParamsSchema
  >

  export type AppsCreateFromManifestResponse = undefined

  export const AppsGetWebhookConfigForAppParamsSchema = z.object({})
  export type AppsGetWebhookConfigForAppParams = z.infer<
    typeof AppsGetWebhookConfigForAppParamsSchema
  >

  export const AppsGetWebhookConfigForAppResponseSchema = WebhookConfigSchema
  export type AppsGetWebhookConfigForAppResponse = z.infer<
    typeof AppsGetWebhookConfigForAppResponseSchema
  >

  export const AppsUpdateWebhookConfigForAppParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional()
  })
  export type AppsUpdateWebhookConfigForAppParams = z.infer<
    typeof AppsUpdateWebhookConfigForAppParamsSchema
  >

  export const AppsUpdateWebhookConfigForAppResponseSchema = WebhookConfigSchema
  export type AppsUpdateWebhookConfigForAppResponse = z.infer<
    typeof AppsUpdateWebhookConfigForAppResponseSchema
  >

  export const AppsListWebhookDeliveriesParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type AppsListWebhookDeliveriesParams = z.infer<
    typeof AppsListWebhookDeliveriesParamsSchema
  >

  export const AppsListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type AppsListWebhookDeliveriesResponse = z.infer<
    typeof AppsListWebhookDeliveriesResponseSchema
  >

  export const AppsGetWebhookDeliveryParamsSchema = z.object({
    delivery_id: z.number().int()
  })
  export type AppsGetWebhookDeliveryParams = z.infer<
    typeof AppsGetWebhookDeliveryParamsSchema
  >

  export const AppsGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type AppsGetWebhookDeliveryResponse = z.infer<
    typeof AppsGetWebhookDeliveryResponseSchema
  >

  export const AppsRedeliverWebhookDeliveryParamsSchema = z.object({
    delivery_id: z.number().int()
  })
  export type AppsRedeliverWebhookDeliveryParams = z.infer<
    typeof AppsRedeliverWebhookDeliveryParamsSchema
  >

  export type AppsRedeliverWebhookDeliveryResponse = undefined

  export const AppsListInstallationRequestsForAuthenticatedAppParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListInstallationRequestsForAuthenticatedAppParams = z.infer<
    typeof AppsListInstallationRequestsForAuthenticatedAppParamsSchema
  >

  export const AppsListInstallationRequestsForAuthenticatedAppResponseSchema =
    z.array(IntegrationInstallationRequestSchema)
  export type AppsListInstallationRequestsForAuthenticatedAppResponse = z.infer<
    typeof AppsListInstallationRequestsForAuthenticatedAppResponseSchema
  >

  export const AppsListInstallationsParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    outdated: z.string().optional()
  })
  export type AppsListInstallationsParams = z.infer<
    typeof AppsListInstallationsParamsSchema
  >

  export const AppsListInstallationsResponseSchema = z.array(InstallationSchema)
  export type AppsListInstallationsResponse = z.infer<
    typeof AppsListInstallationsResponseSchema
  >

  export const AppsGetInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsGetInstallationParams = z.infer<
    typeof AppsGetInstallationParamsSchema
  >

  export const AppsGetInstallationResponseSchema = InstallationSchema
  export type AppsGetInstallationResponse = z.infer<
    typeof AppsGetInstallationResponseSchema
  >

  export const AppsDeleteInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsDeleteInstallationParams = z.infer<
    typeof AppsDeleteInstallationParamsSchema
  >

  export type AppsDeleteInstallationResponse = undefined

  export const AppsCreateInstallationAccessTokenParamsSchema = z.object({
    repositories: z
      .array(z.string())
      .describe('List of repository names that the token should have access to')
      .optional(),
    repository_ids: z
      .array(z.number().int())
      .describe('List of repository IDs that the token should have access to')
      .optional(),
    permissions: AppPermissionsSchema.optional(),
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsCreateInstallationAccessTokenParams = z.infer<
    typeof AppsCreateInstallationAccessTokenParamsSchema
  >

  export type AppsCreateInstallationAccessTokenResponse = undefined

  export const AppsSuspendInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsSuspendInstallationParams = z.infer<
    typeof AppsSuspendInstallationParamsSchema
  >

  export type AppsSuspendInstallationResponse = undefined

  export const AppsUnsuspendInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsUnsuspendInstallationParams = z.infer<
    typeof AppsUnsuspendInstallationParamsSchema
  >

  export type AppsUnsuspendInstallationResponse = undefined

  export const AppsDeleteAuthorizationParamsSchema = z.object({
    access_token: z
      .string()
      .describe(
        'The OAuth access token used to authenticate to the GitHub API.'
      ),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsDeleteAuthorizationParams = z.infer<
    typeof AppsDeleteAuthorizationParamsSchema
  >

  export type AppsDeleteAuthorizationResponse = undefined

  export const AppsCheckTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access_token of the OAuth or GitHub application.'),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsCheckTokenParams = z.infer<typeof AppsCheckTokenParamsSchema>

  export const AppsCheckTokenResponseSchema = AuthorizationSchema
  export type AppsCheckTokenResponse = z.infer<
    typeof AppsCheckTokenResponseSchema
  >

  export const AppsDeleteTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe(
        'The OAuth access token used to authenticate to the GitHub API.'
      ),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsDeleteTokenParams = z.infer<
    typeof AppsDeleteTokenParamsSchema
  >

  export type AppsDeleteTokenResponse = undefined

  export const AppsResetTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access_token of the OAuth or GitHub application.'),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsResetTokenParams = z.infer<typeof AppsResetTokenParamsSchema>

  export const AppsResetTokenResponseSchema = AuthorizationSchema
  export type AppsResetTokenResponse = z.infer<
    typeof AppsResetTokenResponseSchema
  >

  export const AppsScopeTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access token used to authenticate to the GitHub API.'),
    target: z
      .string()
      .describe(
        'The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified.'
      )
      .optional(),
    target_id: z
      .number()
      .int()
      .describe(
        'The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified.'
      )
      .optional(),
    repositories: z
      .array(z.string())
      .describe(
        'The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.'
      )
      .optional(),
    repository_ids: z
      .array(z.number().int())
      .describe(
        'The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified.'
      )
      .optional(),
    permissions: AppPermissionsSchema.optional(),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsScopeTokenParams = z.infer<typeof AppsScopeTokenParamsSchema>

  export const AppsScopeTokenResponseSchema = AuthorizationSchema
  export type AppsScopeTokenResponse = z.infer<
    typeof AppsScopeTokenResponseSchema
  >

  export const AppsGetBySlugParamsSchema = z.object({ app_slug: z.string() })
  export type AppsGetBySlugParams = z.infer<typeof AppsGetBySlugParamsSchema>

  export const AppsGetBySlugResponseSchema = IntegrationSchema
  export type AppsGetBySlugResponse = z.infer<
    typeof AppsGetBySlugResponseSchema
  >

  export const ClassroomGetAnAssignmentParamsSchema = z.object({
    assignment_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom assignment.')
  })
  export type ClassroomGetAnAssignmentParams = z.infer<
    typeof ClassroomGetAnAssignmentParamsSchema
  >

  export const ClassroomGetAnAssignmentResponseSchema =
    ClassroomAssignmentSchema
  export type ClassroomGetAnAssignmentResponse = z.infer<
    typeof ClassroomGetAnAssignmentResponseSchema
  >

  export const ClassroomListAcceptedAssignmentsForAnAssignmentParamsSchema =
    z.object({
      assignment_id: z
        .number()
        .int()
        .describe('The unique identifier of the classroom assignment.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    })
  export type ClassroomListAcceptedAssignmentsForAnAssignmentParams = z.infer<
    typeof ClassroomListAcceptedAssignmentsForAnAssignmentParamsSchema
  >

  export const ClassroomListAcceptedAssignmentsForAnAssignmentResponseSchema =
    z.array(ClassroomAcceptedAssignmentSchema)
  export type ClassroomListAcceptedAssignmentsForAnAssignmentResponse = z.infer<
    typeof ClassroomListAcceptedAssignmentsForAnAssignmentResponseSchema
  >

  export const ClassroomGetAssignmentGradesParamsSchema = z.object({
    assignment_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom assignment.')
  })
  export type ClassroomGetAssignmentGradesParams = z.infer<
    typeof ClassroomGetAssignmentGradesParamsSchema
  >

  export const ClassroomGetAssignmentGradesResponseSchema = z.array(
    ClassroomAssignmentGradeSchema
  )
  export type ClassroomGetAssignmentGradesResponse = z.infer<
    typeof ClassroomGetAssignmentGradesResponseSchema
  >

  export const ClassroomListClassroomsParamsSchema = z.object({
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ClassroomListClassroomsParams = z.infer<
    typeof ClassroomListClassroomsParamsSchema
  >

  export const ClassroomListClassroomsResponseSchema = z.array(
    SimpleClassroomSchema
  )
  export type ClassroomListClassroomsResponse = z.infer<
    typeof ClassroomListClassroomsResponseSchema
  >

  export const ClassroomGetAclassroomParamsSchema = z.object({
    classroom_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom.')
  })
  export type ClassroomGetAclassroomParams = z.infer<
    typeof ClassroomGetAclassroomParamsSchema
  >

  export const ClassroomGetAclassroomResponseSchema = ClassroomSchema
  export type ClassroomGetAclassroomResponse = z.infer<
    typeof ClassroomGetAclassroomResponseSchema
  >

  export const ClassroomListAssignmentsForAclassroomParamsSchema = z.object({
    classroom_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ClassroomListAssignmentsForAclassroomParams = z.infer<
    typeof ClassroomListAssignmentsForAclassroomParamsSchema
  >

  export const ClassroomListAssignmentsForAclassroomResponseSchema = z.array(
    SimpleClassroomAssignmentSchema
  )
  export type ClassroomListAssignmentsForAclassroomResponse = z.infer<
    typeof ClassroomListAssignmentsForAclassroomResponseSchema
  >

  export const CodesOfConductGetAllCodesOfConductParamsSchema = z.object({})
  export type CodesOfConductGetAllCodesOfConductParams = z.infer<
    typeof CodesOfConductGetAllCodesOfConductParamsSchema
  >

  export const CodesOfConductGetAllCodesOfConductResponseSchema =
    z.array(CodeOfConductSchema)
  export type CodesOfConductGetAllCodesOfConductResponse = z.infer<
    typeof CodesOfConductGetAllCodesOfConductResponseSchema
  >

  export const CodesOfConductGetConductCodeParamsSchema = z.object({
    key: z.string()
  })
  export type CodesOfConductGetConductCodeParams = z.infer<
    typeof CodesOfConductGetConductCodeParamsSchema
  >

  export const CodesOfConductGetConductCodeResponseSchema = CodeOfConductSchema
  export type CodesOfConductGetConductCodeResponse = z.infer<
    typeof CodesOfConductGetConductCodeResponseSchema
  >

  export const EmojisGetParamsSchema = z.object({})
  export type EmojisGetParams = z.infer<typeof EmojisGetParamsSchema>

  export const EmojisGetResponseSchema = z.record(z.string())
  export type EmojisGetResponse = z.infer<typeof EmojisGetResponseSchema>

  export const CodeSecurityGetConfigurationsForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional()
    })
  export type CodeSecurityGetConfigurationsForEnterpriseParams = z.infer<
    typeof CodeSecurityGetConfigurationsForEnterpriseParamsSchema
  >

  export const CodeSecurityGetConfigurationsForEnterpriseResponseSchema =
    z.array(CodeSecurityConfigurationSchema)
  export type CodeSecurityGetConfigurationsForEnterpriseResponse = z.infer<
    typeof CodeSecurityGetConfigurationsForEnterpriseResponseSchema
  >

  export const CodeSecurityCreateConfigurationForEnterpriseParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique within the enterprise.'
        ),
      description: z
        .string()
        .max(255)
        .describe('A description of the code security configuration'),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe('The enablement status of GitHub Advanced Security')
        .default('disabled'),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .default('enabled'),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .default('disabled'),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .default(false)
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .default('disabled'),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .default('disabled'),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .default('disabled'),
      code_scanning_default_setup_options:
        CodeScanningDefaultSetupOptionsSchema.optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .default('disabled'),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .default('disabled'),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .default('disabled'),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .default('disabled'),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non provider patterns'
        )
        .default('disabled'),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .default('disabled'),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .default('disabled'),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .default('disabled'),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .default('enforced'),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        )
    })
  export type CodeSecurityCreateConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityCreateConfigurationForEnterpriseParamsSchema
  >

  export type CodeSecurityCreateConfigurationForEnterpriseResponse = undefined

  export const CodeSecurityGetDefaultConfigurationsForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        )
    })
  export type CodeSecurityGetDefaultConfigurationsForEnterpriseParams = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsForEnterpriseParamsSchema
  >

  export const CodeSecurityGetDefaultConfigurationsForEnterpriseResponseSchema =
    CodeSecurityDefaultConfigurationsSchema
  export type CodeSecurityGetDefaultConfigurationsForEnterpriseResponse =
    z.infer<
      typeof CodeSecurityGetDefaultConfigurationsForEnterpriseResponseSchema
    >

  export const CodeSecurityGetSingleConfigurationForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecurityGetSingleConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityGetSingleConfigurationForEnterpriseParamsSchema
  >

  export const CodeSecurityGetSingleConfigurationForEnterpriseResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityGetSingleConfigurationForEnterpriseResponse = z.infer<
    typeof CodeSecurityGetSingleConfigurationForEnterpriseResponseSchema
  >

  export const CodeSecurityDeleteConfigurationForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecurityDeleteConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityDeleteConfigurationForEnterpriseParamsSchema
  >

  export type CodeSecurityDeleteConfigurationForEnterpriseResponse = undefined

  export const CodeSecurityUpdateEnterpriseConfigurationParamsSchema = z.object(
    {
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique across the enterprise.'
        )
        .optional(),
      description: z
        .string()
        .max(255)
        .describe('A description of the code security configuration')
        .optional(),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe(
          'The enablement status of GitHub Advanced Security. Must be set to enabled if you want to enable any GHAS settings.'
        )
        .optional(),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .optional(),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .optional(),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .optional()
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .optional(),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .optional(),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .optional(),
      code_scanning_default_setup_options:
        CodeScanningDefaultSetupOptionsSchema.optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .default('disabled'),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .optional(),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .optional(),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .optional(),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non-provider patterns'
        )
        .optional(),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .default('disabled'),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .default('disabled'),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .optional(),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .optional(),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    }
  )
  export type CodeSecurityUpdateEnterpriseConfigurationParams = z.infer<
    typeof CodeSecurityUpdateEnterpriseConfigurationParamsSchema
  >

  export const CodeSecurityUpdateEnterpriseConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityUpdateEnterpriseConfigurationResponse = z.infer<
    typeof CodeSecurityUpdateEnterpriseConfigurationResponseSchema
  >

  export const CodeSecurityAttachEnterpriseConfigurationParamsSchema = z.object(
    {
      scope: z
        .enum(['all', 'all_without_configurations'])
        .describe('The type of repositories to attach the configuration to.'),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    }
  )
  export type CodeSecurityAttachEnterpriseConfigurationParams = z.infer<
    typeof CodeSecurityAttachEnterpriseConfigurationParamsSchema
  >

  export type CodeSecurityAttachEnterpriseConfigurationResponse = undefined

  export const CodeSecuritySetConfigurationAsDefaultForEnterpriseParamsSchema =
    z.object({
      default_for_new_repos: z
        .enum(['all', 'none', 'private_and_internal', 'public'])
        .describe(
          'Specify which types of repository this security configuration should be applied to by default.'
        )
        .optional(),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecuritySetConfigurationAsDefaultForEnterpriseParams =
    z.infer<
      typeof CodeSecuritySetConfigurationAsDefaultForEnterpriseParamsSchema
    >

  export const CodeSecuritySetConfigurationAsDefaultForEnterpriseResponseSchema =
    z.object({
      default_for_new_repos: z
        .enum(['all', 'none', 'private_and_internal', 'public'])
        .describe(
          'Specifies which types of repository this security configuration is applied to by default.'
        )
        .optional(),
      configuration: CodeSecurityConfigurationSchema.optional()
    })
  export type CodeSecuritySetConfigurationAsDefaultForEnterpriseResponse =
    z.infer<
      typeof CodeSecuritySetConfigurationAsDefaultForEnterpriseResponseSchema
    >

  export const CodeSecurityGetRepositoriesForEnterpriseConfigurationParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      status: z
        .string()
        .describe(
          'A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`'
        )
        .default('all')
    })
  export type CodeSecurityGetRepositoriesForEnterpriseConfigurationParams =
    z.infer<
      typeof CodeSecurityGetRepositoriesForEnterpriseConfigurationParamsSchema
    >

  export const CodeSecurityGetRepositoriesForEnterpriseConfigurationResponseSchema =
    z.array(CodeSecurityConfigurationRepositoriesSchema)
  export type CodeSecurityGetRepositoriesForEnterpriseConfigurationResponse =
    z.infer<
      typeof CodeSecurityGetRepositoriesForEnterpriseConfigurationResponseSchema
    >

  export const DependabotListAlertsForEnterpriseParamsSchema = z.object({
    enterprise: z
      .string()
      .describe(
        'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
      ),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListAlertsForEnterpriseParams = z.infer<
    typeof DependabotListAlertsForEnterpriseParamsSchema
  >

  export const DependabotListAlertsForEnterpriseResponseSchema = z.array(
    DependabotAlertWithRepositorySchema
  )
  export type DependabotListAlertsForEnterpriseResponse = z.infer<
    typeof DependabotListAlertsForEnterpriseResponseSchema
  >

  export const SecretScanningListAlertsForEnterpriseParamsSchema = z.object({
    enterprise: z
      .string()
      .describe(
        'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
      ),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForEnterpriseParams = z.infer<
    typeof SecretScanningListAlertsForEnterpriseParamsSchema
  >

  export const SecretScanningListAlertsForEnterpriseResponseSchema = z.array(
    OrganizationSecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForEnterpriseResponse = z.infer<
    typeof SecretScanningListAlertsForEnterpriseResponseSchema
  >

  export const ActivityListPublicEventsParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsParams = z.infer<
    typeof ActivityListPublicEventsParamsSchema
  >

  export const ActivityListPublicEventsResponseSchema = z.array(EventSchema)
  export type ActivityListPublicEventsResponse = z.infer<
    typeof ActivityListPublicEventsResponseSchema
  >

  export const ActivityGetFeedsParamsSchema = z.object({})
  export type ActivityGetFeedsParams = z.infer<
    typeof ActivityGetFeedsParamsSchema
  >

  export const ActivityGetFeedsResponseSchema = FeedSchema
  export type ActivityGetFeedsResponse = z.infer<
    typeof ActivityGetFeedsResponseSchema
  >

  export const GistsListParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListParams = z.infer<typeof GistsListParamsSchema>

  export const GistsListResponseSchema = z.array(BaseGistSchema)
  export type GistsListResponse = z.infer<typeof GistsListResponseSchema>

  export const GistsCreateParamsSchema = z.object({
    description: z.string().describe('Description of the gist').optional(),
    files: z
      .record(z.object({ content: z.string().describe('Content of the file') }))
      .describe('Names and content for the files that make up the gist'),
    public: z
      .union([
        z
          .boolean()
          .describe('Flag indicating whether the gist is public')
          .default(false),
        z.enum(['true', 'false']).default('false')
      ])
      .optional()
  })
  export type GistsCreateParams = z.infer<typeof GistsCreateParamsSchema>

  export type GistsCreateResponse = undefined

  export const GistsListPublicParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListPublicParams = z.infer<
    typeof GistsListPublicParamsSchema
  >

  export const GistsListPublicResponseSchema = z.array(BaseGistSchema)
  export type GistsListPublicResponse = z.infer<
    typeof GistsListPublicResponseSchema
  >

  export const GistsListStarredParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListStarredParams = z.infer<
    typeof GistsListStarredParamsSchema
  >

  export const GistsListStarredResponseSchema = z.array(BaseGistSchema)
  export type GistsListStarredResponse = z.infer<
    typeof GistsListStarredResponseSchema
  >

  export const GistsGetParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsGetParams = z.infer<typeof GistsGetParamsSchema>

  export const GistsGetResponseSchema = GistSimpleSchema
  export type GistsGetResponse = z.infer<typeof GistsGetResponseSchema>

  export const GistsDeleteParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsDeleteParams = z.infer<typeof GistsDeleteParamsSchema>

  export type GistsDeleteResponse = undefined

  export const GistsUpdateParamsSchema = z.object({
    description: z.string().describe('The description of the gist.').optional(),
    files: z
      .record(
        z.object({
          content: z
            .string()
            .describe('The new content of the file.')
            .optional(),
          filename: z
            .string()
            .describe('The new filename for the file.')
            .optional()
        })
      )
      .describe(
        'The gist files to be updated, renamed, or deleted. Each `key` must match the current filename\n(including extension) of the targeted gist file. For example: `hello.py`.\n\nTo delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be\ndeleted if the specified object does not contain at least one of `content` or `filename`.'
      )
      .optional(),
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsUpdateParams = z.infer<typeof GistsUpdateParamsSchema>

  export const GistsUpdateResponseSchema = GistSimpleSchema
  export type GistsUpdateResponse = z.infer<typeof GistsUpdateResponseSchema>

  export const GistsListCommentsParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListCommentsParams = z.infer<
    typeof GistsListCommentsParamsSchema
  >

  export const GistsListCommentsResponseSchema = z.array(GistCommentSchema)
  export type GistsListCommentsResponse = z.infer<
    typeof GistsListCommentsResponseSchema
  >

  export const GistsCreateCommentParamsSchema = z.object({
    body: z.string().max(65_535).describe('The comment text.'),
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsCreateCommentParams = z.infer<
    typeof GistsCreateCommentParamsSchema
  >

  export type GistsCreateCommentResponse = undefined

  export const GistsGetCommentParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsGetCommentParams = z.infer<
    typeof GistsGetCommentParamsSchema
  >

  export const GistsGetCommentResponseSchema = GistCommentSchema
  export type GistsGetCommentResponse = z.infer<
    typeof GistsGetCommentResponseSchema
  >

  export const GistsDeleteCommentParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsDeleteCommentParams = z.infer<
    typeof GistsDeleteCommentParamsSchema
  >

  export type GistsDeleteCommentResponse = undefined

  export const GistsUpdateCommentParamsSchema = z.object({
    body: z.string().max(65_535).describe('The comment text.'),
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsUpdateCommentParams = z.infer<
    typeof GistsUpdateCommentParamsSchema
  >

  export const GistsUpdateCommentResponseSchema = GistCommentSchema
  export type GistsUpdateCommentResponse = z.infer<
    typeof GistsUpdateCommentResponseSchema
  >

  export const GistsListCommitsParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListCommitsParams = z.infer<
    typeof GistsListCommitsParamsSchema
  >

  export const GistsListCommitsResponseSchema = z.array(GistCommitSchema)
  export type GistsListCommitsResponse = z.infer<
    typeof GistsListCommitsResponseSchema
  >

  export const GistsListForksParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListForksParams = z.infer<typeof GistsListForksParamsSchema>

  export const GistsListForksResponseSchema = z.array(GistSimpleSchema)
  export type GistsListForksResponse = z.infer<
    typeof GistsListForksResponseSchema
  >

  export const GistsForkParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsForkParams = z.infer<typeof GistsForkParamsSchema>

  export type GistsForkResponse = undefined

  export const GistsCheckIsStarredParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsCheckIsStarredParams = z.infer<
    typeof GistsCheckIsStarredParamsSchema
  >

  export type GistsCheckIsStarredResponse = undefined

  export const GistsStarParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsStarParams = z.infer<typeof GistsStarParamsSchema>

  export type GistsStarResponse = undefined

  export const GistsUnstarParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsUnstarParams = z.infer<typeof GistsUnstarParamsSchema>

  export type GistsUnstarResponse = undefined

  export const GistsGetRevisionParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    sha: z.string()
  })
  export type GistsGetRevisionParams = z.infer<
    typeof GistsGetRevisionParamsSchema
  >

  export const GistsGetRevisionResponseSchema = GistSimpleSchema
  export type GistsGetRevisionResponse = z.infer<
    typeof GistsGetRevisionResponseSchema
  >

  export const GitignoreGetAllTemplatesParamsSchema = z.object({})
  export type GitignoreGetAllTemplatesParams = z.infer<
    typeof GitignoreGetAllTemplatesParamsSchema
  >

  export const GitignoreGetAllTemplatesResponseSchema = z.array(z.string())
  export type GitignoreGetAllTemplatesResponse = z.infer<
    typeof GitignoreGetAllTemplatesResponseSchema
  >

  export const GitignoreGetTemplateParamsSchema = z.object({ name: z.string() })
  export type GitignoreGetTemplateParams = z.infer<
    typeof GitignoreGetTemplateParamsSchema
  >

  export const GitignoreGetTemplateResponseSchema = GitignoreTemplateSchema
  export type GitignoreGetTemplateResponse = z.infer<
    typeof GitignoreGetTemplateResponseSchema
  >

  export const AppsListReposAccessibleToInstallationParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListReposAccessibleToInstallationParams = z.infer<
    typeof AppsListReposAccessibleToInstallationParamsSchema
  >

  export const AppsListReposAccessibleToInstallationResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(RepositorySchema),
    repository_selection: z.string().optional()
  })
  export type AppsListReposAccessibleToInstallationResponse = z.infer<
    typeof AppsListReposAccessibleToInstallationResponseSchema
  >

  export const AppsRevokeInstallationAccessTokenParamsSchema = z.object({})
  export type AppsRevokeInstallationAccessTokenParams = z.infer<
    typeof AppsRevokeInstallationAccessTokenParamsSchema
  >

  export type AppsRevokeInstallationAccessTokenResponse = undefined

  export const IssuesListParamsSchema = z.object({
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    collab: z.boolean().optional(),
    orgs: z.boolean().optional(),
    owned: z.boolean().optional(),
    pulls: z.boolean().optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListParams = z.infer<typeof IssuesListParamsSchema>

  export const IssuesListResponseSchema = z.array(IssueSchema)
  export type IssuesListResponse = z.infer<typeof IssuesListResponseSchema>

  export const LicensesGetAllCommonlyUsedParamsSchema = z.object({
    featured: z.boolean().optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type LicensesGetAllCommonlyUsedParams = z.infer<
    typeof LicensesGetAllCommonlyUsedParamsSchema
  >

  export const LicensesGetAllCommonlyUsedResponseSchema =
    z.array(LicenseSimpleSchema)
  export type LicensesGetAllCommonlyUsedResponse = z.infer<
    typeof LicensesGetAllCommonlyUsedResponseSchema
  >

  export const LicensesGetParamsSchema = z.object({ license: z.string() })
  export type LicensesGetParams = z.infer<typeof LicensesGetParamsSchema>

  export const LicensesGetResponseSchema = LicenseSchema
  export type LicensesGetResponse = z.infer<typeof LicensesGetResponseSchema>

  export const MarkdownRenderParamsSchema = z.object({
    text: z.string().describe('The Markdown text to render in HTML.'),
    mode: z
      .enum(['markdown', 'gfm'])
      .describe('The rendering mode.')
      .default('markdown'),
    context: z
      .string()
      .describe(
        'The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.'
      )
      .optional()
  })
  export type MarkdownRenderParams = z.infer<typeof MarkdownRenderParamsSchema>

  export type MarkdownRenderResponse = undefined

  export const MarkdownRenderRawParamsSchema = z.object({})
  export type MarkdownRenderRawParams = z.infer<
    typeof MarkdownRenderRawParamsSchema
  >

  export type MarkdownRenderRawResponse = undefined

  export const AppsGetSubscriptionPlanForAccountParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type AppsGetSubscriptionPlanForAccountParams = z.infer<
    typeof AppsGetSubscriptionPlanForAccountParamsSchema
  >

  export const AppsGetSubscriptionPlanForAccountResponseSchema =
    MarketplacePurchaseSchema
  export type AppsGetSubscriptionPlanForAccountResponse = z.infer<
    typeof AppsGetSubscriptionPlanForAccountResponseSchema
  >

  export const AppsListPlansParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListPlansParams = z.infer<typeof AppsListPlansParamsSchema>

  export const AppsListPlansResponseSchema = z.array(
    MarketplaceListingPlanSchema
  )
  export type AppsListPlansResponse = z.infer<
    typeof AppsListPlansResponseSchema
  >

  export const AppsListAccountsForPlanParamsSchema = z.object({
    plan_id: z.number().int().describe('The unique identifier of the plan.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListAccountsForPlanParams = z.infer<
    typeof AppsListAccountsForPlanParamsSchema
  >

  export const AppsListAccountsForPlanResponseSchema = z.array(
    MarketplacePurchaseSchema
  )
  export type AppsListAccountsForPlanResponse = z.infer<
    typeof AppsListAccountsForPlanResponseSchema
  >

  export const AppsGetSubscriptionPlanForAccountStubbedParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type AppsGetSubscriptionPlanForAccountStubbedParams = z.infer<
    typeof AppsGetSubscriptionPlanForAccountStubbedParamsSchema
  >

  export const AppsGetSubscriptionPlanForAccountStubbedResponseSchema =
    MarketplacePurchaseSchema
  export type AppsGetSubscriptionPlanForAccountStubbedResponse = z.infer<
    typeof AppsGetSubscriptionPlanForAccountStubbedResponseSchema
  >

  export const AppsListPlansStubbedParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListPlansStubbedParams = z.infer<
    typeof AppsListPlansStubbedParamsSchema
  >

  export const AppsListPlansStubbedResponseSchema = z.array(
    MarketplaceListingPlanSchema
  )
  export type AppsListPlansStubbedResponse = z.infer<
    typeof AppsListPlansStubbedResponseSchema
  >

  export const AppsListAccountsForPlanStubbedParamsSchema = z.object({
    plan_id: z.number().int().describe('The unique identifier of the plan.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListAccountsForPlanStubbedParams = z.infer<
    typeof AppsListAccountsForPlanStubbedParamsSchema
  >

  export const AppsListAccountsForPlanStubbedResponseSchema = z.array(
    MarketplacePurchaseSchema
  )
  export type AppsListAccountsForPlanStubbedResponse = z.infer<
    typeof AppsListAccountsForPlanStubbedResponseSchema
  >

  export const MetaGetParamsSchema = z.object({})
  export type MetaGetParams = z.infer<typeof MetaGetParamsSchema>

  export const MetaGetResponseSchema = ApiOverviewSchema
  export type MetaGetResponse = z.infer<typeof MetaGetResponseSchema>

  export const ActivityListPublicEventsForRepoNetworkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsForRepoNetworkParams = z.infer<
    typeof ActivityListPublicEventsForRepoNetworkParamsSchema
  >

  export const ActivityListPublicEventsForRepoNetworkResponseSchema =
    z.array(EventSchema)
  export type ActivityListPublicEventsForRepoNetworkResponse = z.infer<
    typeof ActivityListPublicEventsForRepoNetworkResponseSchema
  >

  export const ActivityListNotificationsForAuthenticatedUserParamsSchema =
    z.object({
      all: z
        .boolean()
        .describe('If `true`, show notifications marked as read.')
        .default(false),
      participating: z
        .boolean()
        .describe(
          'If `true`, only shows notifications in which the user is directly participating or mentioned.'
        )
        .default(false),
      since: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      before: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 50). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(50)
    })
  export type ActivityListNotificationsForAuthenticatedUserParams = z.infer<
    typeof ActivityListNotificationsForAuthenticatedUserParamsSchema
  >

  export const ActivityListNotificationsForAuthenticatedUserResponseSchema =
    z.array(ThreadSchema)
  export type ActivityListNotificationsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListNotificationsForAuthenticatedUserResponseSchema
  >

  export const ActivityMarkNotificationsAsReadParamsSchema = z.object({
    last_read_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
      )
      .optional(),
    read: z
      .boolean()
      .describe('Whether the notification has been read.')
      .optional()
  })
  export type ActivityMarkNotificationsAsReadParams = z.infer<
    typeof ActivityMarkNotificationsAsReadParamsSchema
  >

  export type ActivityMarkNotificationsAsReadResponse = undefined

  export const ActivityGetThreadParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityGetThreadParams = z.infer<
    typeof ActivityGetThreadParamsSchema
  >

  export const ActivityGetThreadResponseSchema = ThreadSchema
  export type ActivityGetThreadResponse = z.infer<
    typeof ActivityGetThreadResponseSchema
  >

  export const ActivityMarkThreadAsDoneParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityMarkThreadAsDoneParams = z.infer<
    typeof ActivityMarkThreadAsDoneParamsSchema
  >

  export type ActivityMarkThreadAsDoneResponse = undefined

  export const ActivityMarkThreadAsReadParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityMarkThreadAsReadParams = z.infer<
    typeof ActivityMarkThreadAsReadParamsSchema
  >

  export type ActivityMarkThreadAsReadResponse = undefined

  export const ActivityGetThreadSubscriptionForAuthenticatedUserParamsSchema =
    z.object({
      thread_id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
        )
    })
  export type ActivityGetThreadSubscriptionForAuthenticatedUserParams = z.infer<
    typeof ActivityGetThreadSubscriptionForAuthenticatedUserParamsSchema
  >

  export const ActivityGetThreadSubscriptionForAuthenticatedUserResponseSchema =
    ThreadSubscriptionSchema
  export type ActivityGetThreadSubscriptionForAuthenticatedUserResponse =
    z.infer<
      typeof ActivityGetThreadSubscriptionForAuthenticatedUserResponseSchema
    >

  export const ActivitySetThreadSubscriptionParamsSchema = z.object({
    ignored: z
      .boolean()
      .describe('Whether to block all notifications from a thread.')
      .default(false),
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivitySetThreadSubscriptionParams = z.infer<
    typeof ActivitySetThreadSubscriptionParamsSchema
  >

  export const ActivitySetThreadSubscriptionResponseSchema =
    ThreadSubscriptionSchema
  export type ActivitySetThreadSubscriptionResponse = z.infer<
    typeof ActivitySetThreadSubscriptionResponseSchema
  >

  export const ActivityDeleteThreadSubscriptionParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityDeleteThreadSubscriptionParams = z.infer<
    typeof ActivityDeleteThreadSubscriptionParamsSchema
  >

  export type ActivityDeleteThreadSubscriptionResponse = undefined

  export const MetaGetOctocatParamsSchema = z.object({
    s: z
      .string()
      .describe("The words to show in Octocat's speech bubble")
      .optional()
  })
  export type MetaGetOctocatParams = z.infer<typeof MetaGetOctocatParamsSchema>

  export type MetaGetOctocatResponse = undefined

  export const OrgsListParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe(
        'An organization ID. Only return organizations with an ID greater than this ID.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type OrgsListParams = z.infer<typeof OrgsListParamsSchema>

  export const OrgsListResponseSchema = z.array(OrganizationSimpleSchema)
  export type OrgsListResponse = z.infer<typeof OrgsListResponseSchema>

  export const BillingGetGithubBillingUsageReportOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    year: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.'
      )
      .optional(),
    month: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.'
      )
      .optional(),
    day: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.'
      )
      .optional(),
    hour: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.'
      )
      .optional()
  })
  export type BillingGetGithubBillingUsageReportOrgParams = z.infer<
    typeof BillingGetGithubBillingUsageReportOrgParamsSchema
  >

  export const BillingGetGithubBillingUsageReportOrgResponseSchema =
    BillingUsageReportSchema
  export type BillingGetGithubBillingUsageReportOrgResponse = z.infer<
    typeof BillingGetGithubBillingUsageReportOrgResponseSchema
  >

  export const OrgsGetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetParams = z.infer<typeof OrgsGetParamsSchema>

  export const OrgsGetResponseSchema = OrganizationFullSchema
  export type OrgsGetResponse = z.infer<typeof OrgsGetResponseSchema>

  export const OrgsDeleteParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsDeleteParams = z.infer<typeof OrgsDeleteParamsSchema>

  export type OrgsDeleteResponse = undefined

  export const OrgsUpdateParamsSchema = z.object({
    billing_email: z
      .string()
      .describe('Billing email address. This address is not publicized.')
      .optional(),
    company: z.string().describe('The company name.').optional(),
    email: z
      .string()
      .describe('The publicly visible email address.')
      .optional(),
    twitter_username: z
      .string()
      .describe('The Twitter username of the company.')
      .optional(),
    location: z.string().describe('The location.').optional(),
    name: z.string().describe('The shorthand name of the company.').optional(),
    description: z
      .string()
      .describe(
        'The description of the company. The maximum size is 160 characters.'
      )
      .optional(),
    has_organization_projects: z
      .boolean()
      .describe('Whether an organization can use organization projects.')
      .optional(),
    has_repository_projects: z
      .boolean()
      .describe(
        'Whether repositories that belong to the organization can use repository projects.'
      )
      .optional(),
    default_repository_permission: z
      .enum(['read', 'write', 'admin', 'none'])
      .describe(
        'Default permission level members have for organization repositories.'
      )
      .default('read'),
    members_can_create_repositories: z
      .boolean()
      .describe(
        'Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.'
      )
      .default(true),
    members_can_create_internal_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_can_create_private_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_can_create_public_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_allowed_repository_creation_type: z
      .enum(['all', 'private', 'none'])
      .describe(
        'Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. \n**Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.'
      )
      .optional(),
    members_can_create_pages: z
      .boolean()
      .describe(
        'Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_create_public_pages: z
      .boolean()
      .describe(
        'Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_create_private_pages: z
      .boolean()
      .describe(
        'Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_fork_private_repositories: z
      .boolean()
      .describe(
        'Whether organization members can fork private organization repositories.'
      )
      .default(false),
    web_commit_signoff_required: z
      .boolean()
      .describe(
        "Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface."
      )
      .default(false),
    blog: z.string().optional(),
    advanced_security_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependabot_alerts_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependabot_security_updates_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependency_graph_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_push_protection_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_push_protection_custom_link_enabled: z
      .boolean()
      .describe(
        'Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.'
      )
      .optional(),
    secret_scanning_push_protection_custom_link: z
      .string()
      .describe(
        'If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.'
      )
      .optional(),
    deploy_keys_enabled_for_repositories: z
      .boolean()
      .describe(
        'Controls whether or not deploy keys may be added and used for repositories in the organization.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdateParams = z.infer<typeof OrgsUpdateParamsSchema>

  export const OrgsUpdateResponseSchema = OrganizationFullSchema
  export type OrgsUpdateResponse = z.infer<typeof OrgsUpdateResponseSchema>

  export const ActionsGetActionsCacheUsageForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetActionsCacheUsageForOrgParams = z.infer<
    typeof ActionsGetActionsCacheUsageForOrgParamsSchema
  >

  export const ActionsGetActionsCacheUsageForOrgResponseSchema =
    ActionsCacheUsageOrgEnterpriseSchema
  export type ActionsGetActionsCacheUsageForOrgResponse = z.infer<
    typeof ActionsGetActionsCacheUsageForOrgResponseSchema
  >

  export const ActionsGetActionsCacheUsageByRepoForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsGetActionsCacheUsageByRepoForOrgParams = z.infer<
    typeof ActionsGetActionsCacheUsageByRepoForOrgParamsSchema
  >

  export const ActionsGetActionsCacheUsageByRepoForOrgResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repository_cache_usages: z.array(ActionsCacheUsageByRepositorySchema)
    }
  )
  export type ActionsGetActionsCacheUsageByRepoForOrgResponse = z.infer<
    typeof ActionsGetActionsCacheUsageByRepoForOrgResponseSchema
  >

  export const ActionsListHostedRunnersForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListHostedRunnersForOrgParams = z.infer<
    typeof ActionsListHostedRunnersForOrgParamsSchema
  >

  export const ActionsListHostedRunnersForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(ActionsHostedRunnerSchema)
  })
  export type ActionsListHostedRunnersForOrgResponse = z.infer<
    typeof ActionsListHostedRunnersForOrgResponseSchema
  >

  export const ActionsCreateHostedRunnerForOrgParamsSchema = z.object({
    name: z
      .string()
      .describe(
        "Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
      ),
    image: z
      .object({
        id: z
          .string()
          .describe('The unique identifier of the runner image.')
          .optional(),
        source: z
          .enum(['github', 'partner', 'custom'])
          .describe('The source of the runner image.')
          .optional()
      })
      .describe(
        'The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`.'
      ),
    size: z
      .string()
      .describe(
        'The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`'
      ),
    runner_group_id: z
      .number()
      .int()
      .describe('The existing runner group to add this runner to.'),
    maximum_runners: z
      .number()
      .int()
      .describe(
        'The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.'
      )
      .optional(),
    enable_static_ip: z
      .boolean()
      .describe(
        'Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateHostedRunnerForOrgParams = z.infer<
    typeof ActionsCreateHostedRunnerForOrgParamsSchema
  >

  export type ActionsCreateHostedRunnerForOrgResponse = undefined

  export const ActionsGetHostedRunnersGithubOwnedImagesForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetHostedRunnersGithubOwnedImagesForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersGithubOwnedImagesForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersGithubOwnedImagesForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      images: z.array(ActionsHostedRunnerImageSchema)
    })
  export type ActionsGetHostedRunnersGithubOwnedImagesForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersGithubOwnedImagesForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersPartnerImagesForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetHostedRunnersPartnerImagesForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersPartnerImagesForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersPartnerImagesForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      images: z.array(ActionsHostedRunnerImageSchema)
    })
  export type ActionsGetHostedRunnersPartnerImagesForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersPartnerImagesForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersLimitsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetHostedRunnersLimitsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersLimitsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersLimitsForOrgResponseSchema =
    ActionsHostedRunnerLimitsSchema
  export type ActionsGetHostedRunnersLimitsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersLimitsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersMachineSpecsForOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    }
  )
  export type ActionsGetHostedRunnersMachineSpecsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersMachineSpecsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersMachineSpecsForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      machine_specs: z.array(ActionsHostedRunnerMachineSpecSchema)
    })
  export type ActionsGetHostedRunnersMachineSpecsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersMachineSpecsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersPlatformsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetHostedRunnersPlatformsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersPlatformsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersPlatformsForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    platforms: z.array(z.string())
  })
  export type ActionsGetHostedRunnersPlatformsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersPlatformsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsGetHostedRunnerForOrgParams = z.infer<
    typeof ActionsGetHostedRunnerForOrgParamsSchema
  >

  export const ActionsGetHostedRunnerForOrgResponseSchema =
    ActionsHostedRunnerSchema
  export type ActionsGetHostedRunnerForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnerForOrgResponseSchema
  >

  export const ActionsDeleteHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsDeleteHostedRunnerForOrgParams = z.infer<
    typeof ActionsDeleteHostedRunnerForOrgParamsSchema
  >

  export type ActionsDeleteHostedRunnerForOrgResponse = undefined

  export const ActionsUpdateHostedRunnerForOrgParamsSchema = z.object({
    name: z
      .string()
      .describe(
        "Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
      )
      .optional(),
    runner_group_id: z
      .number()
      .int()
      .describe('The existing runner group to add this runner to.')
      .optional(),
    maximum_runners: z
      .number()
      .int()
      .describe(
        'The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.'
      )
      .optional(),
    enable_static_ip: z
      .boolean()
      .describe(
        'Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsUpdateHostedRunnerForOrgParams = z.infer<
    typeof ActionsUpdateHostedRunnerForOrgParamsSchema
  >

  export const ActionsUpdateHostedRunnerForOrgResponseSchema =
    ActionsHostedRunnerSchema
  export type ActionsUpdateHostedRunnerForOrgResponse = z.infer<
    typeof ActionsUpdateHostedRunnerForOrgResponseSchema
  >

  export const OidcGetOidcCustomSubTemplateForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OidcGetOidcCustomSubTemplateForOrgParams = z.infer<
    typeof OidcGetOidcCustomSubTemplateForOrgParamsSchema
  >

  export const OidcGetOidcCustomSubTemplateForOrgResponseSchema =
    OidcCustomSubSchema
  export type OidcGetOidcCustomSubTemplateForOrgResponse = z.infer<
    typeof OidcGetOidcCustomSubTemplateForOrgResponseSchema
  >

  export const OidcUpdateOidcCustomSubTemplateForOrgParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(OidcCustomSubSchema)
  export type OidcUpdateOidcCustomSubTemplateForOrgParams = z.infer<
    typeof OidcUpdateOidcCustomSubTemplateForOrgParamsSchema
  >

  export type OidcUpdateOidcCustomSubTemplateForOrgResponse = undefined

  export const ActionsGetGithubActionsPermissionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetGithubActionsPermissionsOrganizationParams = z.infer<
    typeof ActionsGetGithubActionsPermissionsOrganizationParamsSchema
  >

  export const ActionsGetGithubActionsPermissionsOrganizationResponseSchema =
    ActionsOrganizationPermissionsSchema
  export type ActionsGetGithubActionsPermissionsOrganizationResponse = z.infer<
    typeof ActionsGetGithubActionsPermissionsOrganizationResponseSchema
  >

  export const ActionsSetGithubActionsPermissionsOrganizationParamsSchema =
    z.object({
      enabled_repositories: EnabledRepositoriesSchema,
      allowed_actions: AllowedActionsSchema.optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsSetGithubActionsPermissionsOrganizationParams = z.infer<
    typeof ActionsSetGithubActionsPermissionsOrganizationParamsSchema
  >

  export type ActionsSetGithubActionsPermissionsOrganizationResponse = undefined

  export const ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
    >

  export const ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseSchema =
    z.object({
      total_count: z.number(),
      repositories: z.array(RepositorySchema)
    })
  export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse =
    z.infer<
      typeof ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseSchema
    >

  export const ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(
          z.number().int().describe('Unique identifier of the repository.')
        )
        .describe('List of repository IDs to enable for GitHub Actions.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
    >

  export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse =
    undefined

  export const ActionsEnableSelectedRepositoryGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsEnableSelectedRepositoryGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsEnableSelectedRepositoryGithubActionsOrganizationParamsSchema
    >

  export type ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse =
    undefined

  export const ActionsDisableSelectedRepositoryGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsDisableSelectedRepositoryGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsDisableSelectedRepositoryGithubActionsOrganizationParamsSchema
    >

  export type ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse =
    undefined

  export const ActionsGetAllowedActionsOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetAllowedActionsOrganizationParams = z.infer<
    typeof ActionsGetAllowedActionsOrganizationParamsSchema
  >

  export const ActionsGetAllowedActionsOrganizationResponseSchema =
    SelectedActionsSchema
  export type ActionsGetAllowedActionsOrganizationResponse = z.infer<
    typeof ActionsGetAllowedActionsOrganizationResponseSchema
  >

  export const ActionsSetAllowedActionsOrganizationParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(SelectedActionsSchema)
  export type ActionsSetAllowedActionsOrganizationParams = z.infer<
    typeof ActionsSetAllowedActionsOrganizationParamsSchema
  >

  export type ActionsSetAllowedActionsOrganizationResponse = undefined

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParams =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
    >

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseSchema =
    ActionsGetDefaultWorkflowPermissionsSchema
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseSchema
    >

  export const ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema =
    z
      .object({
        org: z
          .string()
          .describe('The organization name. The name is not case sensitive.')
      })
      .merge(ActionsSetDefaultWorkflowPermissionsSchema)
  export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParams =
    z.infer<
      typeof ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
    >

  export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse =
    undefined

  export const ActionsListSelfHostedRunnerGroupsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    visible_to_repository: z
      .string()
      .describe(
        'Only return runner groups that are allowed to be used by this repository.'
      )
      .optional()
  })
  export type ActionsListSelfHostedRunnerGroupsForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnerGroupsForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnerGroupsForOrgResponseSchema = z.object(
    { total_count: z.number(), runner_groups: z.array(RunnerGroupsOrgSchema) }
  )
  export type ActionsListSelfHostedRunnerGroupsForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnerGroupsForOrgResponseSchema
  >

  export const ActionsCreateSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    name: z.string().describe('Name of the runner group.'),
    visibility: z
      .enum(['selected', 'all', 'private'])
      .describe(
        'Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.'
      )
      .default('all'),
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe('List of repository IDs that can access the runner group.')
      .optional(),
    runners: z
      .array(z.number().int().describe('Unique identifier of the runner.'))
      .describe('List of runner IDs to add to the runner group.')
      .optional(),
    allows_public_repositories: z
      .boolean()
      .describe(
        'Whether the runner group can be used by `public` repositories.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsCreateSelfHostedRunnerGroupForOrgParamsSchema
  >

  export type ActionsCreateSelfHostedRunnerGroupForOrgResponse = undefined

  export const ActionsGetSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsGetSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsGetSelfHostedRunnerGroupForOrgParamsSchema
  >

  export const ActionsGetSelfHostedRunnerGroupForOrgResponseSchema =
    RunnerGroupsOrgSchema
  export type ActionsGetSelfHostedRunnerGroupForOrgResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerGroupForOrgResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerGroupFromOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.')
    }
  )
  export type ActionsDeleteSelfHostedRunnerGroupFromOrgParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerGroupFromOrgParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerGroupFromOrgResponse = undefined

  export const ActionsUpdateSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    name: z.string().describe('Name of the runner group.'),
    visibility: z
      .enum(['selected', 'all', 'private'])
      .describe(
        'Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.'
      )
      .optional(),
    allows_public_repositories: z
      .boolean()
      .describe(
        'Whether the runner group can be used by `public` repositories.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsUpdateSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsUpdateSelfHostedRunnerGroupForOrgParamsSchema
  >

  export const ActionsUpdateSelfHostedRunnerGroupForOrgResponseSchema =
    RunnerGroupsOrgSchema
  export type ActionsUpdateSelfHostedRunnerGroupForOrgResponse = z.infer<
    typeof ActionsUpdateSelfHostedRunnerGroupForOrgResponseSchema
  >

  export const ActionsListGithubHostedRunnersInGroupForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActionsListGithubHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsListGithubHostedRunnersInGroupForOrgParamsSchema
  >

  export const ActionsListGithubHostedRunnersInGroupForOrgResponseSchema =
    z.object({
      total_count: z.number(),
      runners: z.array(ActionsHostedRunnerSchema)
    })
  export type ActionsListGithubHostedRunnersInGroupForOrgResponse = z.infer<
    typeof ActionsListGithubHostedRunnersInGroupForOrgResponseSchema
  >

  export const ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    })
  export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export const ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseSchema =
    z.object({
      total_count: z.number(),
      repositories: z.array(MinimalRepositorySchema)
    })
  export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    z.infer<
      typeof ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseSchema
    >

  export const ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(
          z.number().int().describe('Unique identifier of the repository.')
        )
        .describe('List of repository IDs that can access the runner group.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.')
    })
  export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams =
    z.infer<
      typeof ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
    >

  export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsListSelfHostedRunnersInGroupForOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ActionsListSelfHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnersInGroupForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnersInGroupForOrgResponseSchema =
    z.object({ total_count: z.number(), runners: z.array(RunnerSchema) })
  export type ActionsListSelfHostedRunnersInGroupForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnersInGroupForOrgResponseSchema
  >

  export const ActionsSetSelfHostedRunnersInGroupForOrgParamsSchema = z.object({
    runners: z
      .array(z.number().int().describe('Unique identifier of the runner.'))
      .describe('List of runner IDs to add to the runner group.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsSetSelfHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsSetSelfHostedRunnersInGroupForOrgParamsSchema
  >

  export type ActionsSetSelfHostedRunnersInGroupForOrgResponse = undefined

  export const ActionsAddSelfHostedRunnerToGroupForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsAddSelfHostedRunnerToGroupForOrgParams = z.infer<
    typeof ActionsAddSelfHostedRunnerToGroupForOrgParamsSchema
  >

  export type ActionsAddSelfHostedRunnerToGroupForOrgResponse = undefined

  export const ActionsRemoveSelfHostedRunnerFromGroupForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveSelfHostedRunnerFromGroupForOrgParams = z.infer<
    typeof ActionsRemoveSelfHostedRunnerFromGroupForOrgParamsSchema
  >

  export type ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse = undefined

  export const ActionsListSelfHostedRunnersForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of a self-hosted runner.').optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListSelfHostedRunnersForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnersForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnersForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(RunnerSchema)
  })
  export type ActionsListSelfHostedRunnersForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnersForOrgResponseSchema
  >

  export const ActionsListRunnerApplicationsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsListRunnerApplicationsForOrgParams = z.infer<
    typeof ActionsListRunnerApplicationsForOrgParamsSchema
  >

  export const ActionsListRunnerApplicationsForOrgResponseSchema = z.array(
    RunnerApplicationSchema
  )
  export type ActionsListRunnerApplicationsForOrgResponse = z.infer<
    typeof ActionsListRunnerApplicationsForOrgResponseSchema
  >

  export const ActionsGenerateRunnerJitconfigForOrgParamsSchema = z.object({
    name: z.string().describe('The name of the new runner.'),
    runner_group_id: z
      .number()
      .int()
      .describe('The ID of the runner group to register the runner to.'),
    labels: z
      .array(z.string())
      .min(1)
      .max(100)
      .describe(
        'The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.'
      ),
    work_folder: z
      .string()
      .describe(
        'The working directory to be used for job execution, relative to the runner install directory.'
      )
      .default('_work'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGenerateRunnerJitconfigForOrgParams = z.infer<
    typeof ActionsGenerateRunnerJitconfigForOrgParamsSchema
  >

  export type ActionsGenerateRunnerJitconfigForOrgResponse = undefined

  export const ActionsCreateRegistrationTokenForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateRegistrationTokenForOrgParams = z.infer<
    typeof ActionsCreateRegistrationTokenForOrgParamsSchema
  >

  export type ActionsCreateRegistrationTokenForOrgResponse = undefined

  export const ActionsCreateRemoveTokenForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateRemoveTokenForOrgParams = z.infer<
    typeof ActionsCreateRemoveTokenForOrgParamsSchema
  >

  export type ActionsCreateRemoveTokenForOrgResponse = undefined

  export const ActionsGetSelfHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsGetSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsGetSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsGetSelfHostedRunnerForOrgResponseSchema = RunnerSchema
  export type ActionsGetSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerFromOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsDeleteSelfHostedRunnerFromOrgParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerFromOrgParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerFromOrgResponse = undefined

  export const ActionsListLabelsForSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsListLabelsForSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsListLabelsForSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsListLabelsForSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(1)
        .max(100)
        .describe('The names of the custom labels to add to the runner.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(0)
        .max(100)
        .describe(
          'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParams =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamsSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.'),
      name: z
        .string()
        .describe("The name of a self-hosted runner's custom label.")
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParams =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamsSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseSchema
    >

  export const ActionsListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListOrgSecretsParams = z.infer<
    typeof ActionsListOrgSecretsParamsSchema
  >

  export const ActionsListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(OrganizationActionsSecretSchema)
  })
  export type ActionsListOrgSecretsResponse = z.infer<
    typeof ActionsListOrgSecretsResponseSchema
  >

  export const ActionsGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetOrgPublicKeyParams = z.infer<
    typeof ActionsGetOrgPublicKeyParamsSchema
  >

  export const ActionsGetOrgPublicKeyResponseSchema = ActionsPublicKeySchema
  export type ActionsGetOrgPublicKeyResponse = z.infer<
    typeof ActionsGetOrgPublicKeyResponseSchema
  >

  export const ActionsGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetOrgSecretParams = z.infer<
    typeof ActionsGetOrgSecretParamsSchema
  >

  export const ActionsGetOrgSecretResponseSchema =
    OrganizationActionsSecretSchema
  export type ActionsGetOrgSecretResponse = z.infer<
    typeof ActionsGetOrgSecretResponseSchema
  >

  export const ActionsCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateOrgSecretParams = z.infer<
    typeof ActionsCreateOrUpdateOrgSecretParamsSchema
  >

  export type ActionsCreateOrUpdateOrgSecretResponse = undefined

  export const ActionsDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteOrgSecretParams = z.infer<
    typeof ActionsDeleteOrgSecretParamsSchema
  >

  export type ActionsDeleteOrgSecretResponse = undefined

  export const ActionsListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ActionsListSelectedReposForOrgSecretParams = z.infer<
    typeof ActionsListSelectedReposForOrgSecretParamsSchema
  >

  export const ActionsListSelectedReposForOrgSecretResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(MinimalRepositorySchema)
  })
  export type ActionsListSelectedReposForOrgSecretResponse = z.infer<
    typeof ActionsListSelectedReposForOrgSecretResponseSchema
  >

  export const ActionsSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsSetSelectedReposForOrgSecretParams = z.infer<
    typeof ActionsSetSelectedReposForOrgSecretParamsSchema
  >

  export type ActionsSetSelectedReposForOrgSecretResponse = undefined

  export const ActionsAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type ActionsAddSelectedRepoToOrgSecretParams = z.infer<
    typeof ActionsAddSelectedRepoToOrgSecretParamsSchema
  >

  export type ActionsAddSelectedRepoToOrgSecretResponse = undefined

  export const ActionsRemoveSelectedRepoFromOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type ActionsRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof ActionsRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type ActionsRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const ActionsListOrgVariablesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListOrgVariablesParams = z.infer<
    typeof ActionsListOrgVariablesParamsSchema
  >

  export const ActionsListOrgVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(OrganizationActionsVariableSchema)
  })
  export type ActionsListOrgVariablesResponse = z.infer<
    typeof ActionsListOrgVariablesResponseSchema
  >

  export const ActionsCreateOrgVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateOrgVariableParams = z.infer<
    typeof ActionsCreateOrgVariableParamsSchema
  >

  export type ActionsCreateOrgVariableResponse = undefined

  export const ActionsGetOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetOrgVariableParams = z.infer<
    typeof ActionsGetOrgVariableParamsSchema
  >

  export const ActionsGetOrgVariableResponseSchema =
    OrganizationActionsVariableSchema
  export type ActionsGetOrgVariableResponse = z.infer<
    typeof ActionsGetOrgVariableResponseSchema
  >

  export const ActionsDeleteOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsDeleteOrgVariableParams = z.infer<
    typeof ActionsDeleteOrgVariableParamsSchema
  >

  export type ActionsDeleteOrgVariableResponse = undefined

  export const ActionsUpdateOrgVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.'
      )
      .optional(),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsUpdateOrgVariableParams = z.infer<
    typeof ActionsUpdateOrgVariableParamsSchema
  >

  export type ActionsUpdateOrgVariableResponse = undefined

  export const ActionsListSelectedReposForOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ActionsListSelectedReposForOrgVariableParams = z.infer<
    typeof ActionsListSelectedReposForOrgVariableParamsSchema
  >

  export const ActionsListSelectedReposForOrgVariableResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(MinimalRepositorySchema)
  })
  export type ActionsListSelectedReposForOrgVariableResponse = z.infer<
    typeof ActionsListSelectedReposForOrgVariableResponseSchema
  >

  export const ActionsSetSelectedReposForOrgVariableParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'The IDs of the repositories that can access the organization variable.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsSetSelectedReposForOrgVariableParams = z.infer<
    typeof ActionsSetSelectedReposForOrgVariableParamsSchema
  >

  export type ActionsSetSelectedReposForOrgVariableResponse = undefined

  export const ActionsAddSelectedRepoToOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    repository_id: z.number().int()
  })
  export type ActionsAddSelectedRepoToOrgVariableParams = z.infer<
    typeof ActionsAddSelectedRepoToOrgVariableParamsSchema
  >

  export type ActionsAddSelectedRepoToOrgVariableResponse = undefined

  export const ActionsRemoveSelectedRepoFromOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    repository_id: z.number().int()
  })
  export type ActionsRemoveSelectedRepoFromOrgVariableParams = z.infer<
    typeof ActionsRemoveSelectedRepoFromOrgVariableParamsSchema
  >

  export type ActionsRemoveSelectedRepoFromOrgVariableResponse = undefined

  export const OrgsListAttestationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    subject_digest: z
      .string()
      .describe(
        "The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`."
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type OrgsListAttestationsParams = z.infer<
    typeof OrgsListAttestationsParamsSchema
  >

  export const OrgsListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type OrgsListAttestationsResponse = z.infer<
    typeof OrgsListAttestationsResponseSchema
  >

  export const OrgsListBlockedUsersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListBlockedUsersParams = z.infer<
    typeof OrgsListBlockedUsersParamsSchema
  >

  export const OrgsListBlockedUsersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListBlockedUsersResponse = z.infer<
    typeof OrgsListBlockedUsersResponseSchema
  >

  export const OrgsCheckBlockedUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckBlockedUserParams = z.infer<
    typeof OrgsCheckBlockedUserParamsSchema
  >

  export type OrgsCheckBlockedUserResponse = undefined

  export const OrgsBlockUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsBlockUserParams = z.infer<typeof OrgsBlockUserParamsSchema>

  export type OrgsBlockUserResponse = undefined

  export const OrgsUnblockUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsUnblockUserParams = z.infer<
    typeof OrgsUnblockUserParamsSchema
  >

  export type OrgsUnblockUserResponse = undefined

  export const CodeScanningListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    state: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this state will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property by which to sort the results.')
      .default('created'),
    severity: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this severity will be returned.'
      )
      .optional()
  })
  export type CodeScanningListAlertsForOrgParams = z.infer<
    typeof CodeScanningListAlertsForOrgParamsSchema
  >

  export const CodeScanningListAlertsForOrgResponseSchema = z.array(
    CodeScanningOrganizationAlertItemsSchema
  )
  export type CodeScanningListAlertsForOrgResponse = z.infer<
    typeof CodeScanningListAlertsForOrgResponseSchema
  >

  export const CodeSecurityGetConfigurationsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    target_type: z
      .enum(['global', 'all'])
      .describe('The target type of the code security configuration')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional()
  })
  export type CodeSecurityGetConfigurationsForOrgParams = z.infer<
    typeof CodeSecurityGetConfigurationsForOrgParamsSchema
  >

  export const CodeSecurityGetConfigurationsForOrgResponseSchema = z.array(
    CodeSecurityConfigurationSchema
  )
  export type CodeSecurityGetConfigurationsForOrgResponse = z.infer<
    typeof CodeSecurityGetConfigurationsForOrgResponseSchema
  >

  export const CodeSecurityCreateConfigurationParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the code security configuration. Must be unique within the organization.'
      ),
    description: z
      .string()
      .max(255)
      .describe('A description of the code security configuration'),
    advanced_security: z
      .enum(['enabled', 'disabled'])
      .describe('The enablement status of GitHub Advanced Security')
      .default('disabled'),
    dependency_graph: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependency Graph')
      .default('enabled'),
    dependency_graph_autosubmit_action: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Automatic dependency submission')
      .default('disabled'),
    dependency_graph_autosubmit_action_options: z
      .object({
        labeled_runners: z
          .boolean()
          .describe(
            "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
          )
          .default(false)
      })
      .describe('Feature options for Automatic dependency submission')
      .optional(),
    dependabot_alerts: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot alerts')
      .default('disabled'),
    dependabot_security_updates: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot security updates')
      .default('disabled'),
    code_scanning_default_setup: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of code scanning default setup')
      .default('disabled'),
    code_scanning_default_setup_options:
      CodeScanningDefaultSetupOptionsSchema.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of code scanning delegated alert dismissal'
      )
      .default('not_set'),
    secret_scanning: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning')
      .default('disabled'),
    secret_scanning_push_protection: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning push protection')
      .default('disabled'),
    secret_scanning_delegated_bypass: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning delegated bypass')
      .default('disabled'),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z
                .number()
                .int()
                .describe(
                  'The ID of the team or role selected as a bypass reviewer'
                ),
              reviewer_type: z
                .enum(['TEAM', 'ROLE'])
                .describe('The type of the bypass reviewer')
            })
          )
          .describe('The bypass reviewers for secret scanning delegated bypass')
          .optional()
      })
      .describe('Feature options for secret scanning delegated bypass')
      .optional(),
    secret_scanning_validity_checks: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning validity checks')
      .default('disabled'),
    secret_scanning_non_provider_patterns: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning non provider patterns'
      )
      .default('disabled'),
    secret_scanning_generic_secrets: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Copilot secret scanning')
      .default('disabled'),
    secret_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning delegated alert dismissal'
      )
      .optional(),
    private_vulnerability_reporting: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of private vulnerability reporting')
      .default('disabled'),
    enforcement: z
      .enum(['enforced', 'unenforced'])
      .describe('The enforcement status for a security configuration')
      .default('enforced'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityCreateConfigurationParams = z.infer<
    typeof CodeSecurityCreateConfigurationParamsSchema
  >

  export type CodeSecurityCreateConfigurationResponse = undefined

  export const CodeSecurityGetDefaultConfigurationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityGetDefaultConfigurationsParams = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsParamsSchema
  >

  export const CodeSecurityGetDefaultConfigurationsResponseSchema =
    CodeSecurityDefaultConfigurationsSchema
  export type CodeSecurityGetDefaultConfigurationsResponse = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsResponseSchema
  >

  export const CodeSecurityDetachConfigurationParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe('An array of repository IDs to detach from configurations.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityDetachConfigurationParams = z.infer<
    typeof CodeSecurityDetachConfigurationParamsSchema
  >

  export type CodeSecurityDetachConfigurationResponse = undefined

  export const CodeSecurityGetConfigurationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityGetConfigurationParams = z.infer<
    typeof CodeSecurityGetConfigurationParamsSchema
  >

  export const CodeSecurityGetConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityGetConfigurationResponse = z.infer<
    typeof CodeSecurityGetConfigurationResponseSchema
  >

  export const CodeSecurityDeleteConfigurationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityDeleteConfigurationParams = z.infer<
    typeof CodeSecurityDeleteConfigurationParamsSchema
  >

  export type CodeSecurityDeleteConfigurationResponse = undefined

  export const CodeSecurityUpdateConfigurationParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the code security configuration. Must be unique within the organization.'
      )
      .optional(),
    description: z
      .string()
      .max(255)
      .describe('A description of the code security configuration')
      .optional(),
    advanced_security: z
      .enum(['enabled', 'disabled'])
      .describe('The enablement status of GitHub Advanced Security')
      .optional(),
    dependency_graph: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependency Graph')
      .optional(),
    dependency_graph_autosubmit_action: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Automatic dependency submission')
      .optional(),
    dependency_graph_autosubmit_action_options: z
      .object({
        labeled_runners: z
          .boolean()
          .describe(
            "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
          )
          .optional()
      })
      .describe('Feature options for Automatic dependency submission')
      .optional(),
    dependabot_alerts: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot alerts')
      .optional(),
    dependabot_security_updates: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot security updates')
      .optional(),
    code_scanning_default_setup: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of code scanning default setup')
      .optional(),
    code_scanning_default_setup_options:
      CodeScanningDefaultSetupOptionsSchema.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of code scanning delegated alert dismissal'
      )
      .default('disabled'),
    secret_scanning: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning')
      .optional(),
    secret_scanning_push_protection: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning push protection')
      .optional(),
    secret_scanning_delegated_bypass: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning delegated bypass')
      .optional(),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z
                .number()
                .int()
                .describe(
                  'The ID of the team or role selected as a bypass reviewer'
                ),
              reviewer_type: z
                .enum(['TEAM', 'ROLE'])
                .describe('The type of the bypass reviewer')
            })
          )
          .describe('The bypass reviewers for secret scanning delegated bypass')
          .optional()
      })
      .describe('Feature options for secret scanning delegated bypass')
      .optional(),
    secret_scanning_validity_checks: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning validity checks')
      .optional(),
    secret_scanning_non_provider_patterns: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning non-provider patterns'
      )
      .optional(),
    secret_scanning_generic_secrets: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Copilot secret scanning')
      .optional(),
    secret_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning delegated alert dismissal'
      )
      .optional(),
    private_vulnerability_reporting: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of private vulnerability reporting')
      .optional(),
    enforcement: z
      .enum(['enforced', 'unenforced'])
      .describe('The enforcement status for a security configuration')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityUpdateConfigurationParams = z.infer<
    typeof CodeSecurityUpdateConfigurationParamsSchema
  >

  export const CodeSecurityUpdateConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityUpdateConfigurationResponse = z.infer<
    typeof CodeSecurityUpdateConfigurationResponseSchema
  >

  export const CodeSecurityAttachConfigurationParamsSchema = z.object({
    scope: z
      .enum([
        'all',
        'all_without_configurations',
        'public',
        'private_or_internal',
        'selected'
      ])
      .describe(
        'The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids`'
      ),
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe(
        'An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityAttachConfigurationParams = z.infer<
    typeof CodeSecurityAttachConfigurationParamsSchema
  >

  export type CodeSecurityAttachConfigurationResponse = undefined

  export const CodeSecuritySetConfigurationAsDefaultParamsSchema = z.object({
    default_for_new_repos: z
      .enum(['all', 'none', 'private_and_internal', 'public'])
      .describe(
        'Specify which types of repository this security configuration should be applied to by default.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecuritySetConfigurationAsDefaultParams = z.infer<
    typeof CodeSecuritySetConfigurationAsDefaultParamsSchema
  >

  export const CodeSecuritySetConfigurationAsDefaultResponseSchema = z.object({
    default_for_new_repos: z
      .enum(['all', 'none', 'private_and_internal', 'public'])
      .describe(
        'Specifies which types of repository this security configuration is applied to by default.'
      )
      .optional(),
    configuration: CodeSecurityConfigurationSchema.optional()
  })
  export type CodeSecuritySetConfigurationAsDefaultResponse = z.infer<
    typeof CodeSecuritySetConfigurationAsDefaultResponseSchema
  >

  export const CodeSecurityGetRepositoriesForConfigurationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      status: z
        .string()
        .describe(
          'A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `detached`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`'
        )
        .default('all')
    })
  export type CodeSecurityGetRepositoriesForConfigurationParams = z.infer<
    typeof CodeSecurityGetRepositoriesForConfigurationParamsSchema
  >

  export const CodeSecurityGetRepositoriesForConfigurationResponseSchema =
    z.array(CodeSecurityConfigurationRepositoriesSchema)
  export type CodeSecurityGetRepositoriesForConfigurationResponse = z.infer<
    typeof CodeSecurityGetRepositoriesForConfigurationResponseSchema
  >

  export const CodespacesListInOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListInOrganizationParams = z.infer<
    typeof CodespacesListInOrganizationParamsSchema
  >

  export const CodespacesListInOrganizationResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesListInOrganizationResponse = z.infer<
    typeof CodespacesListInOrganizationResponseSchema
  >

  export const CodespacesSetCodespacesAccessParamsSchema = z.object({
    visibility: z
      .enum([
        'disabled',
        'selected_members',
        'all_members',
        'all_members_and_outside_collaborators'
      ])
      .describe(
        'Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.'
      ),
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesSetCodespacesAccessParams = z.infer<
    typeof CodespacesSetCodespacesAccessParamsSchema
  >

  export type CodespacesSetCodespacesAccessResponse = undefined

  export const CodespacesSetCodespacesAccessUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members whose codespaces be billed to the organization.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesSetCodespacesAccessUsersParams = z.infer<
    typeof CodespacesSetCodespacesAccessUsersParamsSchema
  >

  export type CodespacesSetCodespacesAccessUsersResponse = undefined

  export const CodespacesDeleteCodespacesAccessUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members whose codespaces should not be billed to the organization.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesDeleteCodespacesAccessUsersParams = z.infer<
    typeof CodespacesDeleteCodespacesAccessUsersParamsSchema
  >

  export type CodespacesDeleteCodespacesAccessUsersResponse = undefined

  export const CodespacesListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListOrgSecretsParams = z.infer<
    typeof CodespacesListOrgSecretsParamsSchema
  >

  export const CodespacesListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(CodespacesOrgSecretSchema)
  })
  export type CodespacesListOrgSecretsResponse = z.infer<
    typeof CodespacesListOrgSecretsResponseSchema
  >

  export const CodespacesGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesGetOrgPublicKeyParams = z.infer<
    typeof CodespacesGetOrgPublicKeyParamsSchema
  >

  export const CodespacesGetOrgPublicKeyResponseSchema =
    CodespacesPublicKeySchema
  export type CodespacesGetOrgPublicKeyResponse = z.infer<
    typeof CodespacesGetOrgPublicKeyResponseSchema
  >

  export const CodespacesGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetOrgSecretParams = z.infer<
    typeof CodespacesGetOrgSecretParamsSchema
  >

  export const CodespacesGetOrgSecretResponseSchema = CodespacesOrgSecretSchema
  export type CodespacesGetOrgSecretResponse = z.infer<
    typeof CodespacesGetOrgSecretResponseSchema
  >

  export const CodespacesCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('The ID of the key you used to encrypt the secret.')
      .optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesCreateOrUpdateOrgSecretParams = z.infer<
    typeof CodespacesCreateOrUpdateOrgSecretParamsSchema
  >

  export type CodespacesCreateOrUpdateOrgSecretResponse = undefined

  export const CodespacesDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesDeleteOrgSecretParams = z.infer<
    typeof CodespacesDeleteOrgSecretParamsSchema
  >

  export type CodespacesDeleteOrgSecretResponse = undefined

  export const CodespacesListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type CodespacesListSelectedReposForOrgSecretParams = z.infer<
    typeof CodespacesListSelectedReposForOrgSecretParamsSchema
  >

  export const CodespacesListSelectedReposForOrgSecretResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    }
  )
  export type CodespacesListSelectedReposForOrgSecretResponse = z.infer<
    typeof CodespacesListSelectedReposForOrgSecretResponseSchema
  >

  export const CodespacesSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesSetSelectedReposForOrgSecretParams = z.infer<
    typeof CodespacesSetSelectedReposForOrgSecretParamsSchema
  >

  export type CodespacesSetSelectedReposForOrgSecretResponse = undefined

  export const CodespacesAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type CodespacesAddSelectedRepoToOrgSecretParams = z.infer<
    typeof CodespacesAddSelectedRepoToOrgSecretParamsSchema
  >

  export type CodespacesAddSelectedRepoToOrgSecretResponse = undefined

  export const CodespacesRemoveSelectedRepoFromOrgSecretParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    }
  )
  export type CodespacesRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof CodespacesRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type CodespacesRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const CopilotGetCopilotOrganizationDetailsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotGetCopilotOrganizationDetailsParams = z.infer<
    typeof CopilotGetCopilotOrganizationDetailsParamsSchema
  >

  export const CopilotGetCopilotOrganizationDetailsResponseSchema =
    CopilotOrganizationDetailsSchema
  export type CopilotGetCopilotOrganizationDetailsResponse = z.infer<
    typeof CopilotGetCopilotOrganizationDetailsResponseSchema
  >

  export const CopilotListCopilotSeatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(50)
  })
  export type CopilotListCopilotSeatsParams = z.infer<
    typeof CopilotListCopilotSeatsParamsSchema
  >

  export const CopilotListCopilotSeatsResponseSchema = z.object({
    total_seats: z
      .number()
      .int()
      .describe(
        'Total number of Copilot seats for the organization currently being billed.'
      )
      .optional(),
    seats: z.array(CopilotSeatDetailsSchema).optional()
  })
  export type CopilotListCopilotSeatsResponse = z.infer<
    typeof CopilotListCopilotSeatsResponseSchema
  >

  export const CopilotAddCopilotSeatsForTeamsParamsSchema = z.object({
    selected_teams: z
      .array(z.string())
      .min(1)
      .describe(
        'List of team names within the organization to which to grant access to GitHub Copilot.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotAddCopilotSeatsForTeamsParams = z.infer<
    typeof CopilotAddCopilotSeatsForTeamsParamsSchema
  >

  export type CopilotAddCopilotSeatsForTeamsResponse = undefined

  export const CopilotCancelCopilotSeatAssignmentForTeamsParamsSchema =
    z.object({
      selected_teams: z
        .array(z.string())
        .min(1)
        .describe(
          'The names of teams from which to revoke access to GitHub Copilot.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type CopilotCancelCopilotSeatAssignmentForTeamsParams = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForTeamsParamsSchema
  >

  export const CopilotCancelCopilotSeatAssignmentForTeamsResponseSchema = z
    .object({ seats_cancelled: z.number().int() })
    .describe(
      'The total number of seats set to "pending cancellation" for members of the specified team(s).'
    )
  export type CopilotCancelCopilotSeatAssignmentForTeamsResponse = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForTeamsResponseSchema
  >

  export const CopilotAddCopilotSeatsForUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .min(1)
      .describe(
        'The usernames of the organization members to be granted access to GitHub Copilot.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotAddCopilotSeatsForUsersParams = z.infer<
    typeof CopilotAddCopilotSeatsForUsersParamsSchema
  >

  export type CopilotAddCopilotSeatsForUsersResponse = undefined

  export const CopilotCancelCopilotSeatAssignmentForUsersParamsSchema =
    z.object({
      selected_usernames: z
        .array(z.string())
        .min(1)
        .describe(
          'The usernames of the organization members for which to revoke access to GitHub Copilot.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type CopilotCancelCopilotSeatAssignmentForUsersParams = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForUsersParamsSchema
  >

  export const CopilotCancelCopilotSeatAssignmentForUsersResponseSchema = z
    .object({ seats_cancelled: z.number().int() })
    .describe(
      'The total number of seats set to "pending cancellation" for the specified users.'
    )
  export type CopilotCancelCopilotSeatAssignmentForUsersResponse = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForUsersResponseSchema
  >

  export const CopilotCopilotMetricsForOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotCopilotMetricsForOrganizationParams = z.infer<
    typeof CopilotCopilotMetricsForOrganizationParamsSchema
  >

  export const CopilotCopilotMetricsForOrganizationResponseSchema = z.array(
    CopilotUsageMetricsDaySchema
  )
  export type CopilotCopilotMetricsForOrganizationResponse = z.infer<
    typeof CopilotCopilotMetricsForOrganizationResponseSchema
  >

  export const CopilotUsageMetricsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotUsageMetricsForOrgParams = z.infer<
    typeof CopilotUsageMetricsForOrgParamsSchema
  >

  export const CopilotUsageMetricsForOrgResponseSchema = z.array(
    CopilotUsageMetricsSchema
  )
  export type CopilotUsageMetricsForOrgResponse = z.infer<
    typeof CopilotUsageMetricsForOrgResponseSchema
  >

  export const DependabotListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListAlertsForOrgParams = z.infer<
    typeof DependabotListAlertsForOrgParamsSchema
  >

  export const DependabotListAlertsForOrgResponseSchema = z.array(
    DependabotAlertWithRepositorySchema
  )
  export type DependabotListAlertsForOrgResponse = z.infer<
    typeof DependabotListAlertsForOrgResponseSchema
  >

  export const DependabotListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type DependabotListOrgSecretsParams = z.infer<
    typeof DependabotListOrgSecretsParamsSchema
  >

  export const DependabotListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(OrganizationDependabotSecretSchema)
  })
  export type DependabotListOrgSecretsResponse = z.infer<
    typeof DependabotListOrgSecretsResponseSchema
  >

  export const DependabotGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type DependabotGetOrgPublicKeyParams = z.infer<
    typeof DependabotGetOrgPublicKeyParamsSchema
  >

  export const DependabotGetOrgPublicKeyResponseSchema =
    DependabotPublicKeySchema
  export type DependabotGetOrgPublicKeyResponse = z.infer<
    typeof DependabotGetOrgPublicKeyResponseSchema
  >

  export const DependabotGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotGetOrgSecretParams = z.infer<
    typeof DependabotGetOrgSecretParamsSchema
  >

  export const DependabotGetOrgSecretResponseSchema =
    OrganizationDependabotSecretSchema
  export type DependabotGetOrgSecretResponse = z.infer<
    typeof DependabotGetOrgSecretResponseSchema
  >

  export const DependabotCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.string())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotCreateOrUpdateOrgSecretParams = z.infer<
    typeof DependabotCreateOrUpdateOrgSecretParamsSchema
  >

  export type DependabotCreateOrUpdateOrgSecretResponse = undefined

  export const DependabotDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotDeleteOrgSecretParams = z.infer<
    typeof DependabotDeleteOrgSecretParamsSchema
  >

  export type DependabotDeleteOrgSecretResponse = undefined

  export const DependabotListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListSelectedReposForOrgSecretParams = z.infer<
    typeof DependabotListSelectedReposForOrgSecretParamsSchema
  >

  export const DependabotListSelectedReposForOrgSecretResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    }
  )
  export type DependabotListSelectedReposForOrgSecretResponse = z.infer<
    typeof DependabotListSelectedReposForOrgSecretResponseSchema
  >

  export const DependabotSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotSetSelectedReposForOrgSecretParams = z.infer<
    typeof DependabotSetSelectedReposForOrgSecretParamsSchema
  >

  export type DependabotSetSelectedReposForOrgSecretResponse = undefined

  export const DependabotAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type DependabotAddSelectedRepoToOrgSecretParams = z.infer<
    typeof DependabotAddSelectedRepoToOrgSecretParamsSchema
  >

  export type DependabotAddSelectedRepoToOrgSecretResponse = undefined

  export const DependabotRemoveSelectedRepoFromOrgSecretParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    }
  )
  export type DependabotRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof DependabotRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type DependabotRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const PackagesListDockerMigrationConflictingPackagesForOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type PackagesListDockerMigrationConflictingPackagesForOrganizationParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForOrganizationParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForOrganizationResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForOrganizationResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForOrganizationResponseSchema
    >

  export const ActivityListPublicOrgEventsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicOrgEventsParams = z.infer<
    typeof ActivityListPublicOrgEventsParamsSchema
  >

  export const ActivityListPublicOrgEventsResponseSchema = z.array(EventSchema)
  export type ActivityListPublicOrgEventsResponse = z.infer<
    typeof ActivityListPublicOrgEventsResponseSchema
  >

  export const OrgsListFailedInvitationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListFailedInvitationsParams = z.infer<
    typeof OrgsListFailedInvitationsParamsSchema
  >

  export const OrgsListFailedInvitationsResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type OrgsListFailedInvitationsResponse = z.infer<
    typeof OrgsListFailedInvitationsResponseSchema
  >

  export const OrgsListWebhooksParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListWebhooksParams = z.infer<
    typeof OrgsListWebhooksParamsSchema
  >

  export const OrgsListWebhooksResponseSchema = z.array(OrgHookSchema)
  export type OrgsListWebhooksResponse = z.infer<
    typeof OrgsListWebhooksResponseSchema
  >

  export const OrgsCreateWebhookParamsSchema = z.object({
    name: z.string().describe('Must be passed as "web".'),
    config: z
      .object({
        url: WebhookConfigUrlSchema,
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
        username: z.string().optional(),
        password: z.string().optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.'),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateWebhookParams = z.infer<
    typeof OrgsCreateWebhookParamsSchema
  >

  export type OrgsCreateWebhookResponse = undefined

  export const OrgsGetWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsGetWebhookParams = z.infer<typeof OrgsGetWebhookParamsSchema>

  export const OrgsGetWebhookResponseSchema = OrgHookSchema
  export type OrgsGetWebhookResponse = z.infer<
    typeof OrgsGetWebhookResponseSchema
  >

  export const OrgsDeleteWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsDeleteWebhookParams = z.infer<
    typeof OrgsDeleteWebhookParamsSchema
  >

  export type OrgsDeleteWebhookResponse = undefined

  export const OrgsUpdateWebhookParamsSchema = z.object({
    config: z
      .object({
        url: WebhookConfigUrlSchema,
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.')
      .optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    name: z.string().optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsUpdateWebhookParams = z.infer<
    typeof OrgsUpdateWebhookParamsSchema
  >

  export const OrgsUpdateWebhookResponseSchema = OrgHookSchema
  export type OrgsUpdateWebhookResponse = z.infer<
    typeof OrgsUpdateWebhookResponseSchema
  >

  export const OrgsGetWebhookConfigForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsGetWebhookConfigForOrgParams = z.infer<
    typeof OrgsGetWebhookConfigForOrgParamsSchema
  >

  export const OrgsGetWebhookConfigForOrgResponseSchema = WebhookConfigSchema
  export type OrgsGetWebhookConfigForOrgResponse = z.infer<
    typeof OrgsGetWebhookConfigForOrgResponseSchema
  >

  export const OrgsUpdateWebhookConfigForOrgParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsUpdateWebhookConfigForOrgParams = z.infer<
    typeof OrgsUpdateWebhookConfigForOrgParamsSchema
  >

  export const OrgsUpdateWebhookConfigForOrgResponseSchema = WebhookConfigSchema
  export type OrgsUpdateWebhookConfigForOrgResponse = z.infer<
    typeof OrgsUpdateWebhookConfigForOrgResponseSchema
  >

  export const OrgsListWebhookDeliveriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type OrgsListWebhookDeliveriesParams = z.infer<
    typeof OrgsListWebhookDeliveriesParamsSchema
  >

  export const OrgsListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type OrgsListWebhookDeliveriesResponse = z.infer<
    typeof OrgsListWebhookDeliveriesResponseSchema
  >

  export const OrgsGetWebhookDeliveryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type OrgsGetWebhookDeliveryParams = z.infer<
    typeof OrgsGetWebhookDeliveryParamsSchema
  >

  export const OrgsGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type OrgsGetWebhookDeliveryResponse = z.infer<
    typeof OrgsGetWebhookDeliveryResponseSchema
  >

  export const OrgsRedeliverWebhookDeliveryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type OrgsRedeliverWebhookDeliveryParams = z.infer<
    typeof OrgsRedeliverWebhookDeliveryParamsSchema
  >

  export type OrgsRedeliverWebhookDeliveryResponse = undefined

  export const OrgsPingWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsPingWebhookParams = z.infer<
    typeof OrgsPingWebhookParamsSchema
  >

  export type OrgsPingWebhookResponse = undefined

  export const ApiInsightsGetRouteStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'http_method',
            'api_route',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    api_route_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetRouteStatsByActorParams = z.infer<
    typeof ApiInsightsGetRouteStatsByActorParamsSchema
  >

  export const ApiInsightsGetRouteStatsByActorResponseSchema =
    ApiInsightsRouteStatsSchema
  export type ApiInsightsGetRouteStatsByActorResponse = z.infer<
    typeof ApiInsightsGetRouteStatsByActorResponseSchema
  >

  export const ApiInsightsGetSubjectStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    subject_name_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetSubjectStatsParams = z.infer<
    typeof ApiInsightsGetSubjectStatsParamsSchema
  >

  export const ApiInsightsGetSubjectStatsResponseSchema =
    ApiInsightsSubjectStatsSchema
  export type ApiInsightsGetSubjectStatsResponse = z.infer<
    typeof ApiInsightsGetSubjectStatsResponseSchema
  >

  export const ApiInsightsGetSummaryStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsParams = z.infer<
    typeof ApiInsightsGetSummaryStatsParamsSchema
  >

  export const ApiInsightsGetSummaryStatsResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsResponseSchema
  >

  export const ApiInsightsGetSummaryStatsByUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsByUserParams = z.infer<
    typeof ApiInsightsGetSummaryStatsByUserParamsSchema
  >

  export const ApiInsightsGetSummaryStatsByUserResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsByUserResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsByUserResponseSchema
  >

  export const ApiInsightsGetSummaryStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsByActorParams = z.infer<
    typeof ApiInsightsGetSummaryStatsByActorParamsSchema
  >

  export const ApiInsightsGetSummaryStatsByActorResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsByActorResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsByActorResponseSchema
  >

  export const ApiInsightsGetTimeStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsParams = z.infer<
    typeof ApiInsightsGetTimeStatsParamsSchema
  >

  export const ApiInsightsGetTimeStatsResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsResponse = z.infer<
    typeof ApiInsightsGetTimeStatsResponseSchema
  >

  export const ApiInsightsGetTimeStatsByUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsByUserParams = z.infer<
    typeof ApiInsightsGetTimeStatsByUserParamsSchema
  >

  export const ApiInsightsGetTimeStatsByUserResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsByUserResponse = z.infer<
    typeof ApiInsightsGetTimeStatsByUserResponseSchema
  >

  export const ApiInsightsGetTimeStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsByActorParams = z.infer<
    typeof ApiInsightsGetTimeStatsByActorParamsSchema
  >

  export const ApiInsightsGetTimeStatsByActorResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsByActorResponse = z.infer<
    typeof ApiInsightsGetTimeStatsByActorResponseSchema
  >

  export const ApiInsightsGetUserStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    actor_name_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetUserStatsParams = z.infer<
    typeof ApiInsightsGetUserStatsParamsSchema
  >

  export const ApiInsightsGetUserStatsResponseSchema =
    ApiInsightsUserStatsSchema
  export type ApiInsightsGetUserStatsResponse = z.infer<
    typeof ApiInsightsGetUserStatsResponseSchema
  >

  export const AppsGetOrgInstallationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type AppsGetOrgInstallationParams = z.infer<
    typeof AppsGetOrgInstallationParamsSchema
  >

  export const AppsGetOrgInstallationResponseSchema = InstallationSchema
  export type AppsGetOrgInstallationResponse = z.infer<
    typeof AppsGetOrgInstallationResponseSchema
  >

  export const OrgsListAppInstallationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListAppInstallationsParams = z.infer<
    typeof OrgsListAppInstallationsParamsSchema
  >

  export const OrgsListAppInstallationsResponseSchema = z.object({
    total_count: z.number().int(),
    installations: z.array(InstallationSchema)
  })
  export type OrgsListAppInstallationsResponse = z.infer<
    typeof OrgsListAppInstallationsResponseSchema
  >

  export const InteractionsGetRestrictionsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type InteractionsGetRestrictionsForOrgParams = z.infer<
    typeof InteractionsGetRestrictionsForOrgParamsSchema
  >

  export const InteractionsGetRestrictionsForOrgResponseSchema = z.union([
    InteractionLimitResponseSchema,
    z.object({}).strict()
  ])
  export type InteractionsGetRestrictionsForOrgResponse = z.infer<
    typeof InteractionsGetRestrictionsForOrgResponseSchema
  >

  export const InteractionsSetRestrictionsForOrgParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(InteractionLimitSchema)
  export type InteractionsSetRestrictionsForOrgParams = z.infer<
    typeof InteractionsSetRestrictionsForOrgParamsSchema
  >

  export const InteractionsSetRestrictionsForOrgResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForOrgResponse = z.infer<
    typeof InteractionsSetRestrictionsForOrgResponseSchema
  >

  export const InteractionsRemoveRestrictionsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type InteractionsRemoveRestrictionsForOrgParams = z.infer<
    typeof InteractionsRemoveRestrictionsForOrgParamsSchema
  >

  export type InteractionsRemoveRestrictionsForOrgResponse = undefined

  export const OrgsListPendingInvitationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    role: z
      .enum([
        'all',
        'admin',
        'direct_member',
        'billing_manager',
        'hiring_manager'
      ])
      .describe('Filter invitations by their member role.')
      .default('all'),
    invitation_source: z
      .enum(['all', 'member', 'scim'])
      .describe('Filter invitations by their invitation source.')
      .default('all')
  })
  export type OrgsListPendingInvitationsParams = z.infer<
    typeof OrgsListPendingInvitationsParamsSchema
  >

  export const OrgsListPendingInvitationsResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type OrgsListPendingInvitationsResponse = z.infer<
    typeof OrgsListPendingInvitationsResponseSchema
  >

  export const OrgsCreateInvitationParamsSchema = z.object({
    invitee_id: z
      .number()
      .int()
      .describe(
        '**Required unless you provide `email`**. GitHub user ID for the person you are inviting.'
      )
      .optional(),
    email: z
      .string()
      .describe(
        '**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.'
      )
      .optional(),
    role: z
      .enum(['admin', 'direct_member', 'billing_manager', 'reinstate'])
      .describe(
        'The role for the new member. \n * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization. \n * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.'
      )
      .default('direct_member'),
    team_ids: z
      .array(z.number().int())
      .describe('Specify IDs for the teams you want to invite new members to.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateInvitationParams = z.infer<
    typeof OrgsCreateInvitationParamsSchema
  >

  export type OrgsCreateInvitationResponse = undefined

  export const OrgsCancelInvitationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type OrgsCancelInvitationParams = z.infer<
    typeof OrgsCancelInvitationParamsSchema
  >

  export type OrgsCancelInvitationResponse = undefined

  export const OrgsListInvitationTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListInvitationTeamsParams = z.infer<
    typeof OrgsListInvitationTeamsParamsSchema
  >

  export const OrgsListInvitationTeamsResponseSchema = z.array(TeamSchema)
  export type OrgsListInvitationTeamsResponse = z.infer<
    typeof OrgsListInvitationTeamsResponseSchema
  >

  export const OrgsListIssueTypesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListIssueTypesParams = z.infer<
    typeof OrgsListIssueTypesParamsSchema
  >

  export const OrgsListIssueTypesResponseSchema = z.array(IssueTypeSchema)
  export type OrgsListIssueTypesResponse = z.infer<
    typeof OrgsListIssueTypesResponseSchema
  >

  export const OrgsCreateIssueTypeParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(OrganizationCreateIssueTypeSchema)
  export type OrgsCreateIssueTypeParams = z.infer<
    typeof OrgsCreateIssueTypeParamsSchema
  >

  export const OrgsCreateIssueTypeResponseSchema = IssueTypeSchema
  export type OrgsCreateIssueTypeResponse = z.infer<
    typeof OrgsCreateIssueTypeResponseSchema
  >

  export const OrgsUpdateIssueTypeParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      issue_type_id: z
        .number()
        .int()
        .describe('The unique identifier of the issue type.')
    })
    .merge(OrganizationUpdateIssueTypeSchema)
  export type OrgsUpdateIssueTypeParams = z.infer<
    typeof OrgsUpdateIssueTypeParamsSchema
  >

  export const OrgsUpdateIssueTypeResponseSchema = IssueTypeSchema
  export type OrgsUpdateIssueTypeResponse = z.infer<
    typeof OrgsUpdateIssueTypeResponseSchema
  >

  export const OrgsDeleteIssueTypeParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    issue_type_id: z
      .number()
      .int()
      .describe('The unique identifier of the issue type.')
  })
  export type OrgsDeleteIssueTypeParams = z.infer<
    typeof OrgsDeleteIssueTypeParamsSchema
  >

  export type OrgsDeleteIssueTypeResponse = undefined

  export const IssuesListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    type: z.string().describe('Can be the name of an issue type.').optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForOrgParams = z.infer<
    typeof IssuesListForOrgParamsSchema
  >

  export const IssuesListForOrgResponseSchema = z.array(IssueSchema)
  export type IssuesListForOrgResponse = z.infer<
    typeof IssuesListForOrgResponseSchema
  >

  export const OrgsListMembersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['2fa_disabled', 'all'])
      .describe(
        'Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. This options is only available for organization owners.'
      )
      .default('all'),
    role: z
      .enum(['all', 'admin', 'member'])
      .describe('Filter members returned by their role.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListMembersParams = z.infer<
    typeof OrgsListMembersParamsSchema
  >

  export const OrgsListMembersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListMembersResponse = z.infer<
    typeof OrgsListMembersResponseSchema
  >

  export const OrgsCheckMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckMembershipForUserParams = z.infer<
    typeof OrgsCheckMembershipForUserParamsSchema
  >

  export type OrgsCheckMembershipForUserResponse = undefined

  export const OrgsRemoveMemberParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveMemberParams = z.infer<
    typeof OrgsRemoveMemberParamsSchema
  >

  export type OrgsRemoveMemberResponse = undefined

  export const CodespacesGetCodespacesForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesGetCodespacesForUserInOrgParams = z.infer<
    typeof CodespacesGetCodespacesForUserInOrgParamsSchema
  >

  export const CodespacesGetCodespacesForUserInOrgResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesGetCodespacesForUserInOrgResponse = z.infer<
    typeof CodespacesGetCodespacesForUserInOrgResponseSchema
  >

  export const CodespacesDeleteFromOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesDeleteFromOrganizationParams = z.infer<
    typeof CodespacesDeleteFromOrganizationParamsSchema
  >

  export type CodespacesDeleteFromOrganizationResponse = undefined

  export const CodespacesStopInOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStopInOrganizationParams = z.infer<
    typeof CodespacesStopInOrganizationParamsSchema
  >

  export const CodespacesStopInOrganizationResponseSchema = CodespaceSchema
  export type CodespacesStopInOrganizationResponse = z.infer<
    typeof CodespacesStopInOrganizationResponseSchema
  >

  export const CopilotGetCopilotSeatDetailsForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type CopilotGetCopilotSeatDetailsForUserParams = z.infer<
    typeof CopilotGetCopilotSeatDetailsForUserParamsSchema
  >

  export const CopilotGetCopilotSeatDetailsForUserResponseSchema =
    CopilotSeatDetailsSchema
  export type CopilotGetCopilotSeatDetailsForUserResponse = z.infer<
    typeof CopilotGetCopilotSeatDetailsForUserResponseSchema
  >

  export const OrgsGetMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsGetMembershipForUserParams = z.infer<
    typeof OrgsGetMembershipForUserParamsSchema
  >

  export const OrgsGetMembershipForUserResponseSchema = OrgMembershipSchema
  export type OrgsGetMembershipForUserResponse = z.infer<
    typeof OrgsGetMembershipForUserResponseSchema
  >

  export const OrgsSetMembershipForUserParamsSchema = z.object({
    role: z
      .enum(['admin', 'member'])
      .describe(
        'The role to give the user in the organization. Can be one of:  \n * `admin` - The user will become an owner of the organization.  \n * `member` - The user will become a non-owner member of the organization.'
      )
      .default('member'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsSetMembershipForUserParams = z.infer<
    typeof OrgsSetMembershipForUserParamsSchema
  >

  export const OrgsSetMembershipForUserResponseSchema = OrgMembershipSchema
  export type OrgsSetMembershipForUserResponse = z.infer<
    typeof OrgsSetMembershipForUserResponseSchema
  >

  export const OrgsRemoveMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveMembershipForUserParams = z.infer<
    typeof OrgsRemoveMembershipForUserParamsSchema
  >

  export type OrgsRemoveMembershipForUserResponse = undefined

  export const MigrationsListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional()
  })
  export type MigrationsListForOrgParams = z.infer<
    typeof MigrationsListForOrgParamsSchema
  >

  export const MigrationsListForOrgResponseSchema = z.array(MigrationSchema)
  export type MigrationsListForOrgResponse = z.infer<
    typeof MigrationsListForOrgResponseSchema
  >

  export const MigrationsStartForOrgParamsSchema = z.object({
    repositories: z
      .array(z.string())
      .describe(
        'A list of arrays indicating which repositories should be migrated.'
      ),
    lock_repositories: z
      .boolean()
      .describe(
        'Indicates whether repositories should be locked (to prevent manipulation) while migrating data.'
      )
      .default(false),
    exclude_metadata: z
      .boolean()
      .describe(
        'Indicates whether metadata should be excluded and only git source should be included for the migration.'
      )
      .default(false),
    exclude_git_data: z
      .boolean()
      .describe(
        'Indicates whether the repository git data should be excluded from the migration.'
      )
      .default(false),
    exclude_attachments: z
      .boolean()
      .describe(
        'Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).'
      )
      .default(false),
    exclude_releases: z
      .boolean()
      .describe(
        'Indicates whether releases should be excluded from the migration (to reduce migration archive file size).'
      )
      .default(false),
    exclude_owner_projects: z
      .boolean()
      .describe(
        'Indicates whether projects owned by the organization or users should be excluded. from the migration.'
      )
      .default(false),
    org_metadata_only: z
      .boolean()
      .describe(
        'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).'
      )
      .default(false),
    exclude: z
      .array(z.literal('repositories'))
      .describe(
        'Exclude related items from being returned in the response in order to improve performance of the request.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type MigrationsStartForOrgParams = z.infer<
    typeof MigrationsStartForOrgParamsSchema
  >

  export type MigrationsStartForOrgResponse = undefined

  export const MigrationsGetStatusForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional()
  })
  export type MigrationsGetStatusForOrgParams = z.infer<
    typeof MigrationsGetStatusForOrgParamsSchema
  >

  export const MigrationsGetStatusForOrgResponseSchema = MigrationSchema
  export type MigrationsGetStatusForOrgResponse = z.infer<
    typeof MigrationsGetStatusForOrgResponseSchema
  >

  export const MigrationsDownloadArchiveForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsDownloadArchiveForOrgParams = z.infer<
    typeof MigrationsDownloadArchiveForOrgParamsSchema
  >

  export type MigrationsDownloadArchiveForOrgResponse = undefined

  export const MigrationsDeleteArchiveForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsDeleteArchiveForOrgParams = z.infer<
    typeof MigrationsDeleteArchiveForOrgParamsSchema
  >

  export type MigrationsDeleteArchiveForOrgResponse = undefined

  export const MigrationsUnlockRepoForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    repo_name: z.string().describe('repo_name parameter')
  })
  export type MigrationsUnlockRepoForOrgParams = z.infer<
    typeof MigrationsUnlockRepoForOrgParamsSchema
  >

  export type MigrationsUnlockRepoForOrgResponse = undefined

  export const MigrationsListReposForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListReposForOrgParams = z.infer<
    typeof MigrationsListReposForOrgParamsSchema
  >

  export const MigrationsListReposForOrgResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type MigrationsListReposForOrgResponse = z.infer<
    typeof MigrationsListReposForOrgResponseSchema
  >

  export const OrgsListOrgRolesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListOrgRolesParams = z.infer<
    typeof OrgsListOrgRolesParamsSchema
  >

  export const OrgsListOrgRolesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The total number of organization roles available to the organization.'
      )
      .optional(),
    roles: z
      .array(OrganizationRoleSchema)
      .describe('The list of organization roles available to the organization.')
      .optional()
  })
  export type OrgsListOrgRolesResponse = z.infer<
    typeof OrgsListOrgRolesResponseSchema
  >

  export const OrgsRevokeAllOrgRolesTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsRevokeAllOrgRolesTeamParams = z.infer<
    typeof OrgsRevokeAllOrgRolesTeamParamsSchema
  >

  export type OrgsRevokeAllOrgRolesTeamResponse = undefined

  export const OrgsAssignTeamToOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsAssignTeamToOrgRoleParams = z.infer<
    typeof OrgsAssignTeamToOrgRoleParamsSchema
  >

  export type OrgsAssignTeamToOrgRoleResponse = undefined

  export const OrgsRevokeOrgRoleTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsRevokeOrgRoleTeamParams = z.infer<
    typeof OrgsRevokeOrgRoleTeamParamsSchema
  >

  export type OrgsRevokeOrgRoleTeamResponse = undefined

  export const OrgsRevokeAllOrgRolesUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRevokeAllOrgRolesUserParams = z.infer<
    typeof OrgsRevokeAllOrgRolesUserParamsSchema
  >

  export type OrgsRevokeAllOrgRolesUserResponse = undefined

  export const OrgsAssignUserToOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsAssignUserToOrgRoleParams = z.infer<
    typeof OrgsAssignUserToOrgRoleParamsSchema
  >

  export type OrgsAssignUserToOrgRoleResponse = undefined

  export const OrgsRevokeOrgRoleUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsRevokeOrgRoleUserParams = z.infer<
    typeof OrgsRevokeOrgRoleUserParamsSchema
  >

  export type OrgsRevokeOrgRoleUserResponse = undefined

  export const OrgsGetOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsGetOrgRoleParams = z.infer<typeof OrgsGetOrgRoleParamsSchema>

  export const OrgsGetOrgRoleResponseSchema = OrganizationRoleSchema
  export type OrgsGetOrgRoleResponse = z.infer<
    typeof OrgsGetOrgRoleResponseSchema
  >

  export const OrgsListOrgRoleTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOrgRoleTeamsParams = z.infer<
    typeof OrgsListOrgRoleTeamsParamsSchema
  >

  export const OrgsListOrgRoleTeamsResponseSchema = z
    .array(TeamRoleAssignmentSchema)
    .describe('List of teams assigned to the organization role')
  export type OrgsListOrgRoleTeamsResponse = z.infer<
    typeof OrgsListOrgRoleTeamsResponseSchema
  >

  export const OrgsListOrgRoleUsersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOrgRoleUsersParams = z.infer<
    typeof OrgsListOrgRoleUsersParamsSchema
  >

  export const OrgsListOrgRoleUsersResponseSchema = z
    .array(UserRoleAssignmentSchema)
    .describe('List of users assigned to the organization role')
  export type OrgsListOrgRoleUsersResponse = z.infer<
    typeof OrgsListOrgRoleUsersResponseSchema
  >

  export const OrgsListOutsideCollaboratorsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['2fa_disabled', 'all'])
      .describe(
        'Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOutsideCollaboratorsParams = z.infer<
    typeof OrgsListOutsideCollaboratorsParamsSchema
  >

  export const OrgsListOutsideCollaboratorsResponseSchema =
    z.array(SimpleUserSchema)
  export type OrgsListOutsideCollaboratorsResponse = z.infer<
    typeof OrgsListOutsideCollaboratorsResponseSchema
  >

  export const OrgsConvertMemberToOutsideCollaboratorParamsSchema = z.object({
    async: z
      .boolean()
      .describe(
        'When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.'
      )
      .default(false),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsConvertMemberToOutsideCollaboratorParams = z.infer<
    typeof OrgsConvertMemberToOutsideCollaboratorParamsSchema
  >

  export type OrgsConvertMemberToOutsideCollaboratorResponse = undefined

  export const OrgsRemoveOutsideCollaboratorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveOutsideCollaboratorParams = z.infer<
    typeof OrgsRemoveOutsideCollaboratorParamsSchema
  >

  export type OrgsRemoveOutsideCollaboratorResponse = undefined

  export const PackagesListPackagesForOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForOrganizationParams = z.infer<
    typeof PackagesListPackagesForOrganizationParamsSchema
  >

  export const PackagesListPackagesForOrganizationResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForOrganizationResponse = z.infer<
    typeof PackagesListPackagesForOrganizationResponseSchema
  >

  export const PackagesGetPackageForOrganizationParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PackagesGetPackageForOrganizationParams = z.infer<
    typeof PackagesGetPackageForOrganizationParamsSchema
  >

  export const PackagesGetPackageForOrganizationResponseSchema = PackageSchema
  export type PackagesGetPackageForOrganizationResponse = z.infer<
    typeof PackagesGetPackageForOrganizationResponseSchema
  >

  export const PackagesDeletePackageForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PackagesDeletePackageForOrgParams = z.infer<
    typeof PackagesDeletePackageForOrgParamsSchema
  >

  export type PackagesDeletePackageForOrgResponse = undefined

  export const PackagesRestorePackageForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    token: z.string().describe('package token').optional()
  })
  export type PackagesRestorePackageForOrgParams = z.infer<
    typeof PackagesRestorePackageForOrgParamsSchema
  >

  export type PackagesRestorePackageForOrgResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByOrgParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['active', 'deleted'])
        .describe('The state of the package, either active or deleted.')
        .default('active')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByOrgParams = z.infer<
    typeof PackagesGetAllPackageVersionsForPackageOwnedByOrgParamsSchema
  >

  export const PackagesGetAllPackageVersionsForPackageOwnedByOrgResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByOrgResponseSchema
    >

  export const PackagesGetPackageVersionForOrganizationParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesGetPackageVersionForOrganizationParams = z.infer<
    typeof PackagesGetPackageVersionForOrganizationParamsSchema
  >

  export const PackagesGetPackageVersionForOrganizationResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForOrganizationResponse = z.infer<
    typeof PackagesGetPackageVersionForOrganizationResponseSchema
  >

  export const PackagesDeletePackageVersionForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesDeletePackageVersionForOrgParams = z.infer<
    typeof PackagesDeletePackageVersionForOrgParamsSchema
  >

  export type PackagesDeletePackageVersionForOrgResponse = undefined

  export const PackagesRestorePackageVersionForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesRestorePackageVersionForOrgParams = z.infer<
    typeof PackagesRestorePackageVersionForOrgParamsSchema
  >

  export type PackagesRestorePackageVersionForOrgResponse = undefined

  export const OrgsListPatGrantRequestsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    sort: z
      .literal('created_at')
      .describe('The property by which to sort the results.')
      .default('created_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    owner: z
      .array(z.string())
      .max(10)
      .describe('A list of owner usernames to use to filter the results.')
      .optional(),
    repository: z
      .string()
      .describe('The name of the repository to use to filter the results.')
      .optional(),
    permission: z
      .string()
      .describe('The permission to use to filter the results.')
      .optional(),
    last_used_before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    last_used_after: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_id: z
      .array(z.string())
      .max(50)
      .describe('The ID of the token')
      .optional()
  })
  export type OrgsListPatGrantRequestsParams = z.infer<
    typeof OrgsListPatGrantRequestsParamsSchema
  >

  export const OrgsListPatGrantRequestsResponseSchema = z.array(
    OrganizationProgrammaticAccessGrantRequestSchema
  )
  export type OrgsListPatGrantRequestsResponse = z.infer<
    typeof OrgsListPatGrantRequestsResponseSchema
  >

  export const OrgsReviewPatGrantRequestsInBulkParamsSchema = z.object({
    pat_request_ids: z
      .array(z.number().int())
      .min(1)
      .max(100)
      .describe(
        'Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.'
      )
      .optional(),
    action: z
      .enum(['approve', 'deny'])
      .describe('Action to apply to the requests.'),
    reason: z
      .string()
      .max(1024)
      .describe(
        'Reason for approving or denying the requests. Max 1024 characters.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsReviewPatGrantRequestsInBulkParams = z.infer<
    typeof OrgsReviewPatGrantRequestsInBulkParamsSchema
  >

  export type OrgsReviewPatGrantRequestsInBulkResponse = undefined

  export const OrgsReviewPatGrantRequestParamsSchema = z.object({
    action: z
      .enum(['approve', 'deny'])
      .describe('Action to apply to the request.'),
    reason: z
      .string()
      .max(1024)
      .describe(
        'Reason for approving or denying the request. Max 1024 characters.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_request_id: z
      .number()
      .int()
      .describe(
        'Unique identifier of the request for access via fine-grained personal access token.'
      )
  })
  export type OrgsReviewPatGrantRequestParams = z.infer<
    typeof OrgsReviewPatGrantRequestParamsSchema
  >

  export type OrgsReviewPatGrantRequestResponse = undefined

  export const OrgsListPatGrantRequestRepositoriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_request_id: z
      .number()
      .int()
      .describe(
        'Unique identifier of the request for access via fine-grained personal access token.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPatGrantRequestRepositoriesParams = z.infer<
    typeof OrgsListPatGrantRequestRepositoriesParamsSchema
  >

  export const OrgsListPatGrantRequestRepositoriesResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type OrgsListPatGrantRequestRepositoriesResponse = z.infer<
    typeof OrgsListPatGrantRequestRepositoriesResponseSchema
  >

  export const OrgsListPatGrantsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    sort: z
      .literal('created_at')
      .describe('The property by which to sort the results.')
      .default('created_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    owner: z
      .array(z.string())
      .max(10)
      .describe('A list of owner usernames to use to filter the results.')
      .optional(),
    repository: z
      .string()
      .describe('The name of the repository to use to filter the results.')
      .optional(),
    permission: z
      .string()
      .describe('The permission to use to filter the results.')
      .optional(),
    last_used_before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    last_used_after: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_id: z
      .array(z.string())
      .max(50)
      .describe('The ID of the token')
      .optional()
  })
  export type OrgsListPatGrantsParams = z.infer<
    typeof OrgsListPatGrantsParamsSchema
  >

  export const OrgsListPatGrantsResponseSchema = z.array(
    OrganizationProgrammaticAccessGrantSchema
  )
  export type OrgsListPatGrantsResponse = z.infer<
    typeof OrgsListPatGrantsResponseSchema
  >

  export const OrgsUpdatePatAccessesParamsSchema = z.object({
    action: z
      .literal('revoke')
      .describe('Action to apply to the fine-grained personal access token.'),
    pat_ids: z
      .array(
        z
          .number()
          .int()
          .describe(
            'Unique identifier of the fine-grained personal access token.'
          )
      )
      .min(1)
      .max(100)
      .describe('The IDs of the fine-grained personal access tokens.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdatePatAccessesParams = z.infer<
    typeof OrgsUpdatePatAccessesParamsSchema
  >

  export type OrgsUpdatePatAccessesResponse = undefined

  export const OrgsUpdatePatAccessParamsSchema = z.object({
    action: z
      .literal('revoke')
      .describe('Action to apply to the fine-grained personal access token.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the fine-grained personal access token.'
      )
  })
  export type OrgsUpdatePatAccessParams = z.infer<
    typeof OrgsUpdatePatAccessParamsSchema
  >

  export type OrgsUpdatePatAccessResponse = undefined

  export const OrgsListPatGrantRepositoriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_id: z
      .number()
      .int()
      .describe('Unique identifier of the fine-grained personal access token.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPatGrantRepositoriesParams = z.infer<
    typeof OrgsListPatGrantRepositoriesParamsSchema
  >

  export const OrgsListPatGrantRepositoriesResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type OrgsListPatGrantRepositoriesResponse = z.infer<
    typeof OrgsListPatGrantRepositoriesResponseSchema
  >

  export const PrivateRegistriesListOrgPrivateRegistriesParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type PrivateRegistriesListOrgPrivateRegistriesParams = z.infer<
    typeof PrivateRegistriesListOrgPrivateRegistriesParamsSchema
  >

  export const PrivateRegistriesListOrgPrivateRegistriesResponseSchema =
    z.object({
      total_count: z.number().int(),
      configurations: z.array(OrgPrivateRegistryConfigurationSchema)
    })
  export type PrivateRegistriesListOrgPrivateRegistriesResponse = z.infer<
    typeof PrivateRegistriesListOrgPrivateRegistriesResponseSchema
  >

  export const PrivateRegistriesCreateOrgPrivateRegistryParamsSchema = z.object(
    {
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.'
        )
        .optional(),
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.'
        ),
      key_id: z
        .string()
        .describe('The ID of the key you used to encrypt the secret.'),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        ),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    }
  )
  export type PrivateRegistriesCreateOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesCreateOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesCreateOrgPrivateRegistryResponse = undefined

  export const PrivateRegistriesGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PrivateRegistriesGetOrgPublicKeyParams = z.infer<
    typeof PrivateRegistriesGetOrgPublicKeyParamsSchema
  >

  export const PrivateRegistriesGetOrgPublicKeyResponseSchema = z.object({
    key_id: z.string().describe('The identifier for the key.'),
    key: z.string().describe('The Base64 encoded public key.')
  })
  export type PrivateRegistriesGetOrgPublicKeyResponse = z.infer<
    typeof PrivateRegistriesGetOrgPublicKeyResponseSchema
  >

  export const PrivateRegistriesGetOrgPrivateRegistryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type PrivateRegistriesGetOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesGetOrgPrivateRegistryParamsSchema
  >

  export const PrivateRegistriesGetOrgPrivateRegistryResponseSchema =
    OrgPrivateRegistryConfigurationSchema
  export type PrivateRegistriesGetOrgPrivateRegistryResponse = z.infer<
    typeof PrivateRegistriesGetOrgPrivateRegistryResponseSchema
  >

  export const PrivateRegistriesDeleteOrgPrivateRegistryParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.')
    }
  )
  export type PrivateRegistriesDeleteOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesDeleteOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesDeleteOrgPrivateRegistryResponse = undefined

  export const PrivateRegistriesUpdateOrgPrivateRegistryParamsSchema = z.object(
    {
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.')
        .optional(),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.'
        )
        .optional(),
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.'
        )
        .optional(),
      key_id: z
        .string()
        .describe('The ID of the key you used to encrypt the secret.')
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        )
        .optional(),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.')
    }
  )
  export type PrivateRegistriesUpdateOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesUpdateOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesUpdateOrgPrivateRegistryResponse = undefined

  export const ProjectsListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForOrgParams = z.infer<
    typeof ProjectsListForOrgParamsSchema
  >

  export const ProjectsListForOrgResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForOrgResponse = z.infer<
    typeof ProjectsListForOrgResponseSchema
  >

  export const ProjectsCreateForOrgParamsSchema = z.object({
    name: z.string().describe('The name of the project.'),
    body: z.string().describe('The description of the project.').optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ProjectsCreateForOrgParams = z.infer<
    typeof ProjectsCreateForOrgParamsSchema
  >

  export type ProjectsCreateForOrgResponse = undefined

  export const OrgsGetAllCustomPropertiesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetAllCustomPropertiesParams = z.infer<
    typeof OrgsGetAllCustomPropertiesParamsSchema
  >

  export const OrgsGetAllCustomPropertiesResponseSchema =
    z.array(CustomPropertySchema)
  export type OrgsGetAllCustomPropertiesResponse = z.infer<
    typeof OrgsGetAllCustomPropertiesResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesParamsSchema = z.object({
    properties: z
      .array(CustomPropertySchema)
      .min(1)
      .max(100)
      .describe('The array of custom properties to create or update.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateOrUpdateCustomPropertiesParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesParamsSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesResponseSchema =
    z.array(CustomPropertySchema)
  export type OrgsCreateOrUpdateCustomPropertiesResponse = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesResponseSchema
  >

  export const OrgsGetCustomPropertyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    custom_property_name: z.string().describe('The custom property name')
  })
  export type OrgsGetCustomPropertyParams = z.infer<
    typeof OrgsGetCustomPropertyParamsSchema
  >

  export const OrgsGetCustomPropertyResponseSchema = CustomPropertySchema
  export type OrgsGetCustomPropertyResponse = z.infer<
    typeof OrgsGetCustomPropertyResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertyParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      custom_property_name: z.string().describe('The custom property name')
    })
    .merge(CustomPropertySetPayloadSchema)
  export type OrgsCreateOrUpdateCustomPropertyParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertyParamsSchema
  >

  export const OrgsCreateOrUpdateCustomPropertyResponseSchema =
    CustomPropertySchema
  export type OrgsCreateOrUpdateCustomPropertyResponse = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertyResponseSchema
  >

  export const OrgsRemoveCustomPropertyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    custom_property_name: z.string().describe('The custom property name')
  })
  export type OrgsRemoveCustomPropertyParams = z.infer<
    typeof OrgsRemoveCustomPropertyParamsSchema
  >

  export type OrgsRemoveCustomPropertyResponse = undefined

  export const OrgsListCustomPropertiesValuesForReposParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    repository_query: z
      .string()
      .describe(
        'Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.'
      )
      .optional()
  })
  export type OrgsListCustomPropertiesValuesForReposParams = z.infer<
    typeof OrgsListCustomPropertiesValuesForReposParamsSchema
  >

  export const OrgsListCustomPropertiesValuesForReposResponseSchema = z.array(
    OrgRepoCustomPropertyValuesSchema
  )
  export type OrgsListCustomPropertiesValuesForReposResponse = z.infer<
    typeof OrgsListCustomPropertiesValuesForReposResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesValuesForReposParamsSchema =
    z.object({
      repository_names: z
        .array(z.string())
        .min(1)
        .max(30)
        .describe(
          'The names of repositories that the custom property values will be applied to.'
        ),
      properties: z
        .array(CustomPropertyValueSchema)
        .describe(
          'List of custom property names and associated values to apply to the repositories.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type OrgsCreateOrUpdateCustomPropertiesValuesForReposParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesValuesForReposParamsSchema
  >

  export type OrgsCreateOrUpdateCustomPropertiesValuesForReposResponse =
    undefined

  export const OrgsListPublicMembersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPublicMembersParams = z.infer<
    typeof OrgsListPublicMembersParamsSchema
  >

  export const OrgsListPublicMembersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListPublicMembersResponse = z.infer<
    typeof OrgsListPublicMembersResponseSchema
  >

  export const OrgsCheckPublicMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckPublicMembershipForUserParams = z.infer<
    typeof OrgsCheckPublicMembershipForUserParamsSchema
  >

  export type OrgsCheckPublicMembershipForUserResponse = undefined

  export const OrgsSetPublicMembershipForAuthenticatedUserParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type OrgsSetPublicMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsSetPublicMembershipForAuthenticatedUserParamsSchema
  >

  export type OrgsSetPublicMembershipForAuthenticatedUserResponse = undefined

  export const OrgsRemovePublicMembershipForAuthenticatedUserParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type OrgsRemovePublicMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsRemovePublicMembershipForAuthenticatedUserParamsSchema
  >

  export type OrgsRemovePublicMembershipForAuthenticatedUserResponse = undefined

  export const ReposListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    type: z
      .enum(['all', 'public', 'private', 'forks', 'sources', 'member'])
      .describe('Specifies the types of repositories you want returned.')
      .default('all'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForOrgParams = z.infer<
    typeof ReposListForOrgParamsSchema
  >

  export const ReposListForOrgResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForOrgResponse = z.infer<
    typeof ReposListForOrgResponseSchema
  >

  export const ReposCreateInOrgParamsSchema = z.object({
    name: z.string().describe('The name of the repository.'),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe('Whether the repository is private.')
      .default(false),
    visibility: z
      .enum(['public', 'private'])
      .describe('The visibility of the repository.')
      .optional(),
    has_issues: z
      .boolean()
      .describe(
        'Either `true` to enable issues for this repository or `false` to disable them.'
      )
      .default(true),
    has_projects: z
      .boolean()
      .describe(
        "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error."
      )
      .default(true),
    has_wiki: z
      .boolean()
      .describe(
        'Either `true` to enable the wiki for this repository or `false` to disable it.'
      )
      .default(true),
    has_downloads: z
      .boolean()
      .describe('Whether downloads are enabled.')
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Either `true` to make this repo available as a template repository or `false` to prevent it.'
      )
      .default(false),
    team_id: z
      .number()
      .int()
      .describe(
        'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
      )
      .optional(),
    auto_init: z
      .boolean()
      .describe('Pass `true` to create an initial commit with empty README.')
      .default(false),
    gitignore_template: z
      .string()
      .describe(
        'Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".'
      )
      .optional(),
    license_template: z
      .string()
      .describe(
        'Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".'
      )
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.'
      )
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe(
        'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.'
      )
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe(
        'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.'
      )
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe(
        'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.'
      )
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe(
        'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**'
      )
      .default(false),
    use_squash_pr_title_as_default: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.'
      )
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    custom_properties: z
      .record(z.any())
      .describe(
        'The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ReposCreateInOrgParams = z.infer<
    typeof ReposCreateInOrgParamsSchema
  >

  export type ReposCreateInOrgResponse = undefined

  export const ReposGetOrgRulesetsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    targets: z
      .string()
      .describe(
        'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
      )
      .optional()
  })
  export type ReposGetOrgRulesetsParams = z.infer<
    typeof ReposGetOrgRulesetsParamsSchema
  >

  export const ReposGetOrgRulesetsResponseSchema = z.array(
    RepositoryRulesetSchema
  )
  export type ReposGetOrgRulesetsResponse = z.infer<
    typeof ReposGetOrgRulesetsResponseSchema
  >

  export const ReposCreateOrgRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.'),
    target: z
      .enum(['branch', 'tag', 'push', 'repository'])
      .describe('The target of the ruleset')
      .default('branch'),
    enforcement: RepositoryRuleEnforcementSchema,
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: OrgRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ReposCreateOrgRulesetParams = z.infer<
    typeof ReposCreateOrgRulesetParamsSchema
  >

  export type ReposCreateOrgRulesetResponse = undefined

  export const ReposGetOrgRuleSuitesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ref: z
      .string()
      .describe(
        'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
      )
      .optional(),
    repository_name: z
      .string()
      .describe('The name of the repository to filter on.')
      .optional(),
    time_period: z
      .enum(['hour', 'day', 'week', 'month'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
      )
      .default('day'),
    actor_name: z
      .string()
      .describe(
        'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
      )
      .optional(),
    rule_suite_result: z
      .enum(['pass', 'fail', 'bypass', 'all'])
      .describe(
        'The rule results to filter on. When specified, only suites with this result will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetOrgRuleSuitesParams = z.infer<
    typeof ReposGetOrgRuleSuitesParamsSchema
  >

  export const ReposGetOrgRuleSuitesResponseSchema = RuleSuitesSchema
  export type ReposGetOrgRuleSuitesResponse = z.infer<
    typeof ReposGetOrgRuleSuitesResponseSchema
  >

  export const ReposGetOrgRuleSuiteParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    rule_suite_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
      )
  })
  export type ReposGetOrgRuleSuiteParams = z.infer<
    typeof ReposGetOrgRuleSuiteParamsSchema
  >

  export const ReposGetOrgRuleSuiteResponseSchema = RuleSuiteSchema
  export type ReposGetOrgRuleSuiteResponse = z.infer<
    typeof ReposGetOrgRuleSuiteResponseSchema
  >

  export const ReposGetOrgRulesetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposGetOrgRulesetParams = z.infer<
    typeof ReposGetOrgRulesetParamsSchema
  >

  export const ReposGetOrgRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposGetOrgRulesetResponse = z.infer<
    typeof ReposGetOrgRulesetResponseSchema
  >

  export const ReposUpdateOrgRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.').optional(),
    target: z
      .enum(['branch', 'tag', 'push', 'repository'])
      .describe('The target of the ruleset')
      .optional(),
    enforcement: RepositoryRuleEnforcementSchema.optional(),
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: OrgRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposUpdateOrgRulesetParams = z.infer<
    typeof ReposUpdateOrgRulesetParamsSchema
  >

  export const ReposUpdateOrgRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposUpdateOrgRulesetResponse = z.infer<
    typeof ReposUpdateOrgRulesetResponseSchema
  >

  export const ReposDeleteOrgRulesetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposDeleteOrgRulesetParams = z.infer<
    typeof ReposDeleteOrgRulesetParamsSchema
  >

  export type ReposDeleteOrgRulesetResponse = undefined

  export const OrgsGetOrgRulesetHistoryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsGetOrgRulesetHistoryParams = z.infer<
    typeof OrgsGetOrgRulesetHistoryParamsSchema
  >

  export const OrgsGetOrgRulesetHistoryResponseSchema =
    z.array(RulesetVersionSchema)
  export type OrgsGetOrgRulesetHistoryResponse = z.infer<
    typeof OrgsGetOrgRulesetHistoryResponseSchema
  >

  export const OrgsGetOrgRulesetVersionParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    version_id: z.number().int().describe('The ID of the version')
  })
  export type OrgsGetOrgRulesetVersionParams = z.infer<
    typeof OrgsGetOrgRulesetVersionParamsSchema
  >

  export const OrgsGetOrgRulesetVersionResponseSchema =
    RulesetVersionWithStateSchema
  export type OrgsGetOrgRulesetVersionResponse = z.infer<
    typeof OrgsGetOrgRulesetVersionResponseSchema
  >

  export const SecretScanningListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForOrgParams = z.infer<
    typeof SecretScanningListAlertsForOrgParamsSchema
  >

  export const SecretScanningListAlertsForOrgResponseSchema = z.array(
    OrganizationSecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForOrgResponse = z.infer<
    typeof SecretScanningListAlertsForOrgResponseSchema
  >

  export const SecurityAdvisoriesListOrgRepositoryAdvisoriesParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      sort: z
        .enum(['created', 'updated', 'published'])
        .describe('The property to sort the results by.')
        .default('created'),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .gte(1)
        .lte(100)
        .describe(
          'The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['triage', 'draft', 'published', 'closed'])
        .describe(
          'Filter by the state of the repository advisories. Only advisories of this state will be returned.'
        )
        .optional()
    })
  export type SecurityAdvisoriesListOrgRepositoryAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListOrgRepositoryAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListOrgRepositoryAdvisoriesResponseSchema =
    z.array(RepositoryAdvisorySchema)
  export type SecurityAdvisoriesListOrgRepositoryAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListOrgRepositoryAdvisoriesResponseSchema
  >

  export const OrgsListSecurityManagerTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListSecurityManagerTeamsParams = z.infer<
    typeof OrgsListSecurityManagerTeamsParamsSchema
  >

  export const OrgsListSecurityManagerTeamsResponseSchema =
    z.array(TeamSimpleSchema)
  export type OrgsListSecurityManagerTeamsResponse = z.infer<
    typeof OrgsListSecurityManagerTeamsResponseSchema
  >

  export const OrgsAddSecurityManagerTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsAddSecurityManagerTeamParams = z.infer<
    typeof OrgsAddSecurityManagerTeamParamsSchema
  >

  export type OrgsAddSecurityManagerTeamResponse = undefined

  export const OrgsRemoveSecurityManagerTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsRemoveSecurityManagerTeamParams = z.infer<
    typeof OrgsRemoveSecurityManagerTeamParamsSchema
  >

  export type OrgsRemoveSecurityManagerTeamResponse = undefined

  export const BillingGetGithubActionsBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetGithubActionsBillingOrgParams = z.infer<
    typeof BillingGetGithubActionsBillingOrgParamsSchema
  >

  export const BillingGetGithubActionsBillingOrgResponseSchema =
    ActionsBillingUsageSchema
  export type BillingGetGithubActionsBillingOrgResponse = z.infer<
    typeof BillingGetGithubActionsBillingOrgResponseSchema
  >

  export const BillingGetGithubPackagesBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetGithubPackagesBillingOrgParams = z.infer<
    typeof BillingGetGithubPackagesBillingOrgParamsSchema
  >

  export const BillingGetGithubPackagesBillingOrgResponseSchema =
    PackagesBillingUsageSchema
  export type BillingGetGithubPackagesBillingOrgResponse = z.infer<
    typeof BillingGetGithubPackagesBillingOrgResponseSchema
  >

  export const BillingGetSharedStorageBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetSharedStorageBillingOrgParams = z.infer<
    typeof BillingGetSharedStorageBillingOrgParamsSchema
  >

  export const BillingGetSharedStorageBillingOrgResponseSchema =
    CombinedBillingUsageSchema
  export type BillingGetSharedStorageBillingOrgResponse = z.infer<
    typeof BillingGetSharedStorageBillingOrgResponseSchema
  >

  export const HostedComputeListNetworkConfigurationsForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type HostedComputeListNetworkConfigurationsForOrgParams = z.infer<
    typeof HostedComputeListNetworkConfigurationsForOrgParamsSchema
  >

  export const HostedComputeListNetworkConfigurationsForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      network_configurations: z.array(NetworkConfigurationSchema)
    })
  export type HostedComputeListNetworkConfigurationsForOrgResponse = z.infer<
    typeof HostedComputeListNetworkConfigurationsForOrgResponseSchema
  >

  export const HostedComputeCreateNetworkConfigurationForOrgParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          "Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
        ),
      compute_service: z
        .enum(['none', 'actions'])
        .describe(
          'The hosted compute service to use for the network configuration.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .min(1)
        .max(1)
        .describe(
          'The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type HostedComputeCreateNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeCreateNetworkConfigurationForOrgParamsSchema
  >

  export type HostedComputeCreateNetworkConfigurationForOrgResponse = undefined

  export const HostedComputeGetNetworkConfigurationForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeGetNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeGetNetworkConfigurationForOrgParamsSchema
  >

  export const HostedComputeGetNetworkConfigurationForOrgResponseSchema =
    NetworkConfigurationSchema
  export type HostedComputeGetNetworkConfigurationForOrgResponse = z.infer<
    typeof HostedComputeGetNetworkConfigurationForOrgResponseSchema
  >

  export const HostedComputeDeleteNetworkConfigurationFromOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeDeleteNetworkConfigurationFromOrgParams = z.infer<
    typeof HostedComputeDeleteNetworkConfigurationFromOrgParamsSchema
  >

  export type HostedComputeDeleteNetworkConfigurationFromOrgResponse = undefined

  export const HostedComputeUpdateNetworkConfigurationForOrgParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          "Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
        )
        .optional(),
      compute_service: z
        .enum(['none', 'actions'])
        .describe(
          'The hosted compute service to use for the network configuration.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .min(0)
        .max(1)
        .describe(
          'The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeUpdateNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeUpdateNetworkConfigurationForOrgParamsSchema
  >

  export const HostedComputeUpdateNetworkConfigurationForOrgResponseSchema =
    NetworkConfigurationSchema
  export type HostedComputeUpdateNetworkConfigurationForOrgResponse = z.infer<
    typeof HostedComputeUpdateNetworkConfigurationForOrgResponseSchema
  >

  export const HostedComputeGetNetworkSettingsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    network_settings_id: z
      .string()
      .describe('Unique identifier of the hosted compute network settings.')
  })
  export type HostedComputeGetNetworkSettingsForOrgParams = z.infer<
    typeof HostedComputeGetNetworkSettingsForOrgParamsSchema
  >

  export const HostedComputeGetNetworkSettingsForOrgResponseSchema =
    NetworkSettingsSchema
  export type HostedComputeGetNetworkSettingsForOrgResponse = z.infer<
    typeof HostedComputeGetNetworkSettingsForOrgResponseSchema
  >

  export const CopilotCopilotMetricsForTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotCopilotMetricsForTeamParams = z.infer<
    typeof CopilotCopilotMetricsForTeamParamsSchema
  >

  export const CopilotCopilotMetricsForTeamResponseSchema = z.array(
    CopilotUsageMetricsDaySchema
  )
  export type CopilotCopilotMetricsForTeamResponse = z.infer<
    typeof CopilotCopilotMetricsForTeamResponseSchema
  >

  export const CopilotUsageMetricsForTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotUsageMetricsForTeamParams = z.infer<
    typeof CopilotUsageMetricsForTeamParamsSchema
  >

  export const CopilotUsageMetricsForTeamResponseSchema = z.array(
    CopilotUsageMetricsSchema
  )
  export type CopilotUsageMetricsForTeamResponse = z.infer<
    typeof CopilotUsageMetricsForTeamResponseSchema
  >

  export const TeamsListParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListParams = z.infer<typeof TeamsListParamsSchema>

  export const TeamsListResponseSchema = z.array(TeamSchema)
  export type TeamsListResponse = z.infer<typeof TeamsListResponseSchema>

  export const TeamsCreateParamsSchema = z.object({
    name: z.string().describe('The name of the team.'),
    description: z.string().describe('The description of the team.').optional(),
    maintainers: z
      .array(z.string())
      .describe(
        'List GitHub IDs for organization members who will become team maintainers.'
      )
      .optional(),
    repo_names: z
      .array(z.string())
      .describe(
        'The full name (e.g., "organization-name/repository-name") of repositories to add the team to.'
      )
      .optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.  \nDefault for child team: `closed`'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. The options are:  \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.  \nDefault: `notifications_enabled`'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type TeamsCreateParams = z.infer<typeof TeamsCreateParamsSchema>

  export type TeamsCreateResponse = undefined

  export const TeamsGetByNameParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsGetByNameParams = z.infer<typeof TeamsGetByNameParamsSchema>

  export const TeamsGetByNameResponseSchema = TeamFullSchema
  export type TeamsGetByNameResponse = z.infer<
    typeof TeamsGetByNameResponseSchema
  >

  export const TeamsDeleteInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsDeleteInOrgParams = z.infer<
    typeof TeamsDeleteInOrgParamsSchema
  >

  export type TeamsDeleteInOrgResponse = undefined

  export const TeamsUpdateInOrgParamsSchema = z.object({
    name: z.string().describe('The name of the team.').optional(),
    description: z.string().describe('The description of the team.').optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsUpdateInOrgParams = z.infer<
    typeof TeamsUpdateInOrgParamsSchema
  >

  export const TeamsUpdateInOrgResponseSchema = TeamFullSchema
  export type TeamsUpdateInOrgResponse = z.infer<
    typeof TeamsUpdateInOrgResponseSchema
  >

  export const TeamsListDiscussionsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    pinned: z.string().describe('Pinned discussions only filter').optional()
  })
  export type TeamsListDiscussionsInOrgParams = z.infer<
    typeof TeamsListDiscussionsInOrgParamsSchema
  >

  export const TeamsListDiscussionsInOrgResponseSchema =
    z.array(TeamDiscussionSchema)
  export type TeamsListDiscussionsInOrgResponse = z.infer<
    typeof TeamsListDiscussionsInOrgResponseSchema
  >

  export const TeamsCreateDiscussionInOrgParamsSchema = z.object({
    title: z.string().describe("The discussion post's title."),
    body: z.string().describe("The discussion post's body text."),
    private: z
      .boolean()
      .describe(
        'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.'
      )
      .default(false),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsCreateDiscussionInOrgParams = z.infer<
    typeof TeamsCreateDiscussionInOrgParamsSchema
  >

  export type TeamsCreateDiscussionInOrgResponse = undefined

  export const TeamsGetDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsGetDiscussionInOrgParams = z.infer<
    typeof TeamsGetDiscussionInOrgParamsSchema
  >

  export const TeamsGetDiscussionInOrgResponseSchema = TeamDiscussionSchema
  export type TeamsGetDiscussionInOrgResponse = z.infer<
    typeof TeamsGetDiscussionInOrgResponseSchema
  >

  export const TeamsDeleteDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsDeleteDiscussionInOrgParams = z.infer<
    typeof TeamsDeleteDiscussionInOrgParamsSchema
  >

  export type TeamsDeleteDiscussionInOrgResponse = undefined

  export const TeamsUpdateDiscussionInOrgParamsSchema = z.object({
    title: z.string().describe("The discussion post's title.").optional(),
    body: z.string().describe("The discussion post's body text.").optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsUpdateDiscussionInOrgParams = z.infer<
    typeof TeamsUpdateDiscussionInOrgParamsSchema
  >

  export const TeamsUpdateDiscussionInOrgResponseSchema = TeamDiscussionSchema
  export type TeamsUpdateDiscussionInOrgResponse = z.infer<
    typeof TeamsUpdateDiscussionInOrgResponseSchema
  >

  export const TeamsListDiscussionCommentsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionCommentsInOrgParams = z.infer<
    typeof TeamsListDiscussionCommentsInOrgParamsSchema
  >

  export const TeamsListDiscussionCommentsInOrgResponseSchema = z.array(
    TeamDiscussionCommentSchema
  )
  export type TeamsListDiscussionCommentsInOrgResponse = z.infer<
    typeof TeamsListDiscussionCommentsInOrgResponseSchema
  >

  export const TeamsCreateDiscussionCommentInOrgParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsCreateDiscussionCommentInOrgParams = z.infer<
    typeof TeamsCreateDiscussionCommentInOrgParamsSchema
  >

  export type TeamsCreateDiscussionCommentInOrgResponse = undefined

  export const TeamsGetDiscussionCommentInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsGetDiscussionCommentInOrgParams = z.infer<
    typeof TeamsGetDiscussionCommentInOrgParamsSchema
  >

  export const TeamsGetDiscussionCommentInOrgResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsGetDiscussionCommentInOrgResponse = z.infer<
    typeof TeamsGetDiscussionCommentInOrgResponseSchema
  >

  export const TeamsDeleteDiscussionCommentInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsDeleteDiscussionCommentInOrgParams = z.infer<
    typeof TeamsDeleteDiscussionCommentInOrgParamsSchema
  >

  export type TeamsDeleteDiscussionCommentInOrgResponse = undefined

  export const TeamsUpdateDiscussionCommentInOrgParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsUpdateDiscussionCommentInOrgParams = z.infer<
    typeof TeamsUpdateDiscussionCommentInOrgParamsSchema
  >

  export const TeamsUpdateDiscussionCommentInOrgResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsUpdateDiscussionCommentInOrgResponse = z.infer<
    typeof TeamsUpdateDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsListForTeamDiscussionCommentInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      team_slug: z.string().describe('The slug of the team name.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.'),
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ReactionsListForTeamDiscussionCommentInOrgParams = z.infer<
    typeof ReactionsListForTeamDiscussionCommentInOrgParamsSchema
  >

  export const ReactionsListForTeamDiscussionCommentInOrgResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionCommentInOrgResponse = z.infer<
    typeof ReactionsListForTeamDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentInOrgParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      team_slug: z.string().describe('The slug of the team name.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.')
    })
  export type ReactionsCreateForTeamDiscussionCommentInOrgParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentInOrgParamsSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentInOrgResponseSchema =
    ReactionSchema
  export type ReactionsCreateForTeamDiscussionCommentInOrgResponse = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsDeleteForTeamDiscussionCommentParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForTeamDiscussionCommentParams = z.infer<
    typeof ReactionsDeleteForTeamDiscussionCommentParamsSchema
  >

  export type ReactionsDeleteForTeamDiscussionCommentResponse = undefined

  export const ReactionsListForTeamDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForTeamDiscussionInOrgParams = z.infer<
    typeof ReactionsListForTeamDiscussionInOrgParamsSchema
  >

  export const ReactionsListForTeamDiscussionInOrgResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionInOrgResponse = z.infer<
    typeof ReactionsListForTeamDiscussionInOrgResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionInOrgParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type ReactionsCreateForTeamDiscussionInOrgParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionInOrgParamsSchema
  >

  export const ReactionsCreateForTeamDiscussionInOrgResponseSchema =
    ReactionSchema
  export type ReactionsCreateForTeamDiscussionInOrgResponse = z.infer<
    typeof ReactionsCreateForTeamDiscussionInOrgResponseSchema
  >

  export const ReactionsDeleteForTeamDiscussionParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForTeamDiscussionParams = z.infer<
    typeof ReactionsDeleteForTeamDiscussionParamsSchema
  >

  export type ReactionsDeleteForTeamDiscussionResponse = undefined

  export const TeamsListPendingInvitationsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListPendingInvitationsInOrgParams = z.infer<
    typeof TeamsListPendingInvitationsInOrgParamsSchema
  >

  export const TeamsListPendingInvitationsInOrgResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type TeamsListPendingInvitationsInOrgResponse = z.infer<
    typeof TeamsListPendingInvitationsInOrgResponseSchema
  >

  export const TeamsListMembersInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role: z
      .enum(['member', 'maintainer', 'all'])
      .describe('Filters members returned by their role in the team.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListMembersInOrgParams = z.infer<
    typeof TeamsListMembersInOrgParamsSchema
  >

  export const TeamsListMembersInOrgResponseSchema = z.array(SimpleUserSchema)
  export type TeamsListMembersInOrgResponse = z.infer<
    typeof TeamsListMembersInOrgResponseSchema
  >

  export const TeamsGetMembershipForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMembershipForUserInOrgParams = z.infer<
    typeof TeamsGetMembershipForUserInOrgParamsSchema
  >

  export const TeamsGetMembershipForUserInOrgResponseSchema =
    TeamMembershipSchema
  export type TeamsGetMembershipForUserInOrgResponse = z.infer<
    typeof TeamsGetMembershipForUserInOrgResponseSchema
  >

  export const TeamsAddOrUpdateMembershipForUserInOrgParamsSchema = z.object({
    role: z
      .enum(['member', 'maintainer'])
      .describe('The role that this user should have in the team.')
      .default('member'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddOrUpdateMembershipForUserInOrgParams = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserInOrgParamsSchema
  >

  export const TeamsAddOrUpdateMembershipForUserInOrgResponseSchema =
    TeamMembershipSchema
  export type TeamsAddOrUpdateMembershipForUserInOrgResponse = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserInOrgResponseSchema
  >

  export const TeamsRemoveMembershipForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMembershipForUserInOrgParams = z.infer<
    typeof TeamsRemoveMembershipForUserInOrgParamsSchema
  >

  export type TeamsRemoveMembershipForUserInOrgResponse = undefined

  export const TeamsListProjectsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListProjectsInOrgParams = z.infer<
    typeof TeamsListProjectsInOrgParamsSchema
  >

  export const TeamsListProjectsInOrgResponseSchema = z.array(TeamProjectSchema)
  export type TeamsListProjectsInOrgResponse = z.infer<
    typeof TeamsListProjectsInOrgResponseSchema
  >

  export const TeamsCheckPermissionsForProjectInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsCheckPermissionsForProjectInOrgParams = z.infer<
    typeof TeamsCheckPermissionsForProjectInOrgParamsSchema
  >

  export const TeamsCheckPermissionsForProjectInOrgResponseSchema =
    TeamProjectSchema
  export type TeamsCheckPermissionsForProjectInOrgResponse = z.infer<
    typeof TeamsCheckPermissionsForProjectInOrgResponseSchema
  >

  export const TeamsAddOrUpdateProjectPermissionsInOrgParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe(
        'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsAddOrUpdateProjectPermissionsInOrgParams = z.infer<
    typeof TeamsAddOrUpdateProjectPermissionsInOrgParamsSchema
  >

  export type TeamsAddOrUpdateProjectPermissionsInOrgResponse = undefined

  export const TeamsRemoveProjectInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsRemoveProjectInOrgParams = z.infer<
    typeof TeamsRemoveProjectInOrgParamsSchema
  >

  export type TeamsRemoveProjectInOrgResponse = undefined

  export const TeamsListReposInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListReposInOrgParams = z.infer<
    typeof TeamsListReposInOrgParamsSchema
  >

  export const TeamsListReposInOrgResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type TeamsListReposInOrgResponse = z.infer<
    typeof TeamsListReposInOrgResponseSchema
  >

  export const TeamsCheckPermissionsForRepoInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsCheckPermissionsForRepoInOrgParams = z.infer<
    typeof TeamsCheckPermissionsForRepoInOrgParamsSchema
  >

  export const TeamsCheckPermissionsForRepoInOrgResponseSchema =
    TeamRepositorySchema
  export type TeamsCheckPermissionsForRepoInOrgResponse = z.infer<
    typeof TeamsCheckPermissionsForRepoInOrgResponseSchema
  >

  export const TeamsAddOrUpdateRepoPermissionsInOrgParamsSchema = z.object({
    permission: z
      .string()
      .describe(
        "The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsAddOrUpdateRepoPermissionsInOrgParams = z.infer<
    typeof TeamsAddOrUpdateRepoPermissionsInOrgParamsSchema
  >

  export type TeamsAddOrUpdateRepoPermissionsInOrgResponse = undefined

  export const TeamsRemoveRepoInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsRemoveRepoInOrgParams = z.infer<
    typeof TeamsRemoveRepoInOrgParamsSchema
  >

  export type TeamsRemoveRepoInOrgResponse = undefined

  export const TeamsListChildInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListChildInOrgParams = z.infer<
    typeof TeamsListChildInOrgParamsSchema
  >

  export const TeamsListChildInOrgResponseSchema = z.array(TeamSchema)
  export type TeamsListChildInOrgResponse = z.infer<
    typeof TeamsListChildInOrgResponseSchema
  >

  export const OrgsEnableOrDisableSecurityProductOnAllOrgReposParamsSchema =
    z.object({
      query_suite: z
        .enum(['default', 'extended'])
        .describe(
          "CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.\nIf you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied."
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      security_product: z
        .enum([
          'dependency_graph',
          'dependabot_alerts',
          'dependabot_security_updates',
          'advanced_security',
          'code_scanning_default_setup',
          'secret_scanning',
          'secret_scanning_push_protection'
        ])
        .describe('The security feature to enable or disable.'),
      enablement: z
        .enum(['enable_all', 'disable_all'])
        .describe(
          'The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.'
        )
    })
  export type OrgsEnableOrDisableSecurityProductOnAllOrgReposParams = z.infer<
    typeof OrgsEnableOrDisableSecurityProductOnAllOrgReposParamsSchema
  >

  export type OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse =
    undefined

  export const ProjectsGetCardParamsSchema = z.object({
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsGetCardParams = z.infer<
    typeof ProjectsGetCardParamsSchema
  >

  export const ProjectsGetCardResponseSchema = ProjectCardSchema
  export type ProjectsGetCardResponse = z.infer<
    typeof ProjectsGetCardResponseSchema
  >

  export const ProjectsDeleteCardParamsSchema = z.object({
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsDeleteCardParams = z.infer<
    typeof ProjectsDeleteCardParamsSchema
  >

  export type ProjectsDeleteCardResponse = undefined

  export const ProjectsUpdateCardParamsSchema = z.object({
    note: z.string().describe("The project card's note").optional(),
    archived: z
      .boolean()
      .describe('Whether or not the card is archived')
      .optional(),
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsUpdateCardParams = z.infer<
    typeof ProjectsUpdateCardParamsSchema
  >

  export const ProjectsUpdateCardResponseSchema = ProjectCardSchema
  export type ProjectsUpdateCardResponse = z.infer<
    typeof ProjectsUpdateCardResponseSchema
  >

  export const ProjectsMoveCardParamsSchema = z.object({
    position: z
      .string()
      .regex(new RegExp('^(?:top|bottom|after:\\d+)$'))
      .describe(
        'The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.'
      ),
    column_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the column the card should be moved to'
      )
      .optional(),
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsMoveCardParams = z.infer<
    typeof ProjectsMoveCardParamsSchema
  >

  export type ProjectsMoveCardResponse = undefined

  export const ProjectsGetColumnParamsSchema = z.object({
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsGetColumnParams = z.infer<
    typeof ProjectsGetColumnParamsSchema
  >

  export const ProjectsGetColumnResponseSchema = ProjectColumnSchema
  export type ProjectsGetColumnResponse = z.infer<
    typeof ProjectsGetColumnResponseSchema
  >

  export const ProjectsDeleteColumnParamsSchema = z.object({
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsDeleteColumnParams = z.infer<
    typeof ProjectsDeleteColumnParamsSchema
  >

  export type ProjectsDeleteColumnResponse = undefined

  export const ProjectsUpdateColumnParamsSchema = z.object({
    name: z.string().describe('Name of the project column'),
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsUpdateColumnParams = z.infer<
    typeof ProjectsUpdateColumnParamsSchema
  >

  export const ProjectsUpdateColumnResponseSchema = ProjectColumnSchema
  export type ProjectsUpdateColumnResponse = z.infer<
    typeof ProjectsUpdateColumnResponseSchema
  >

  export const ProjectsListCardsParamsSchema = z.object({
    column_id: z
      .number()
      .int()
      .describe('The unique identifier of the column.'),
    archived_state: z
      .enum(['all', 'archived', 'not_archived'])
      .describe(
        "Filters the project cards that are returned by the card's state."
      )
      .default('not_archived'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListCardsParams = z.infer<
    typeof ProjectsListCardsParamsSchema
  >

  export const ProjectsListCardsResponseSchema = z.array(ProjectCardSchema)
  export type ProjectsListCardsResponse = z.infer<
    typeof ProjectsListCardsResponseSchema
  >

  export const ProjectsCreateCardParamsSchema = z
    .object({
      column_id: z
        .number()
        .int()
        .describe('The unique identifier of the column.')
    })
    .and(
      z.union([
        z.object({ note: z.string().describe("The project card's note") }),
        z.object({
          content_id: z
            .number()
            .int()
            .describe(
              'The unique identifier of the content associated with the card'
            ),
          content_type: z
            .string()
            .describe('The piece of content associated with the card')
        })
      ])
    )
  export type ProjectsCreateCardParams = z.infer<
    typeof ProjectsCreateCardParamsSchema
  >

  export type ProjectsCreateCardResponse = undefined

  export const ProjectsMoveColumnParamsSchema = z.object({
    position: z
      .string()
      .regex(new RegExp('^(?:first|last|after:\\d+)$'))
      .describe(
        'The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.'
      ),
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsMoveColumnParams = z.infer<
    typeof ProjectsMoveColumnParamsSchema
  >

  export type ProjectsMoveColumnResponse = undefined

  export const ProjectsGetParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsGetParams = z.infer<typeof ProjectsGetParamsSchema>

  export const ProjectsGetResponseSchema = ProjectSchema
  export type ProjectsGetResponse = z.infer<typeof ProjectsGetResponseSchema>

  export const ProjectsDeleteParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsDeleteParams = z.infer<typeof ProjectsDeleteParamsSchema>

  export type ProjectsDeleteResponse = undefined

  export const ProjectsUpdateParamsSchema = z.object({
    name: z.string().describe('Name of the project').optional(),
    body: z.string().describe('Body of the project').optional(),
    state: z
      .string()
      .describe("State of the project; either 'open' or 'closed'")
      .optional(),
    organization_permission: z
      .enum(['read', 'write', 'admin', 'none'])
      .describe(
        'The baseline permission that all organization members have on this project'
      )
      .optional(),
    private: z
      .boolean()
      .describe('Whether or not this project can be seen by everyone.')
      .optional(),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsUpdateParams = z.infer<typeof ProjectsUpdateParamsSchema>

  export const ProjectsUpdateResponseSchema = ProjectSchema
  export type ProjectsUpdateResponse = z.infer<
    typeof ProjectsUpdateResponseSchema
  >

  export const ProjectsListCollaboratorsParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    affiliation: z
      .enum(['outside', 'direct', 'all'])
      .describe(
        "Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see."
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListCollaboratorsParams = z.infer<
    typeof ProjectsListCollaboratorsParamsSchema
  >

  export const ProjectsListCollaboratorsResponseSchema =
    z.array(SimpleUserSchema)
  export type ProjectsListCollaboratorsResponse = z.infer<
    typeof ProjectsListCollaboratorsResponseSchema
  >

  export const ProjectsAddCollaboratorParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe('The permission to grant the collaborator.')
      .default('write'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsAddCollaboratorParams = z.infer<
    typeof ProjectsAddCollaboratorParamsSchema
  >

  export type ProjectsAddCollaboratorResponse = undefined

  export const ProjectsRemoveCollaboratorParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsRemoveCollaboratorParams = z.infer<
    typeof ProjectsRemoveCollaboratorParamsSchema
  >

  export type ProjectsRemoveCollaboratorResponse = undefined

  export const ProjectsGetPermissionForUserParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsGetPermissionForUserParams = z.infer<
    typeof ProjectsGetPermissionForUserParamsSchema
  >

  export const ProjectsGetPermissionForUserResponseSchema =
    ProjectCollaboratorPermissionSchema
  export type ProjectsGetPermissionForUserResponse = z.infer<
    typeof ProjectsGetPermissionForUserResponseSchema
  >

  export const ProjectsListColumnsParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListColumnsParams = z.infer<
    typeof ProjectsListColumnsParamsSchema
  >

  export const ProjectsListColumnsResponseSchema = z.array(ProjectColumnSchema)
  export type ProjectsListColumnsResponse = z.infer<
    typeof ProjectsListColumnsResponseSchema
  >

  export const ProjectsCreateColumnParamsSchema = z.object({
    name: z.string().describe('Name of the project column'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsCreateColumnParams = z.infer<
    typeof ProjectsCreateColumnParamsSchema
  >

  export type ProjectsCreateColumnResponse = undefined

  export const RateLimitGetParamsSchema = z.object({})
  export type RateLimitGetParams = z.infer<typeof RateLimitGetParamsSchema>

  export const RateLimitGetResponseSchema = RateLimitOverviewSchema
  export type RateLimitGetResponse = z.infer<typeof RateLimitGetResponseSchema>

  export const ReposGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetParams = z.infer<typeof ReposGetParamsSchema>

  export const ReposGetResponseSchema = FullRepositorySchema
  export type ReposGetResponse = z.infer<typeof ReposGetResponseSchema>

  export const ReposDeleteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDeleteParams = z.infer<typeof ReposDeleteParamsSchema>

  export type ReposDeleteResponse = undefined

  export const ReposUpdateParamsSchema = z.object({
    name: z.string().describe('The name of the repository.').optional(),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe(
        'Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.'
      )
      .default(false),
    visibility: z
      .enum(['public', 'private'])
      .describe('The visibility of the repository.')
      .optional(),
    security_and_analysis: z
      .object({
        advanced_security: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."'
          )
          .optional(),
        secret_scanning: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."'
          )
          .optional(),
        secret_scanning_push_protection: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."'
          )
          .optional(),
        secret_scanning_ai_detection: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."'
          )
          .optional(),
        secret_scanning_non_provider_patterns: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
          )
          .optional()
      })
      .describe(
        'Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.'
      )
      .optional(),
    has_issues: z
      .boolean()
      .describe(
        'Either `true` to enable issues for this repository or `false` to disable them.'
      )
      .default(true),
    has_projects: z
      .boolean()
      .describe(
        "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error."
      )
      .default(true),
    has_wiki: z
      .boolean()
      .describe(
        'Either `true` to enable the wiki for this repository or `false` to disable it.'
      )
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Either `true` to make this repo available as a template repository or `false` to prevent it.'
      )
      .default(false),
    default_branch: z
      .string()
      .describe('Updates the default branch for this repository.')
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.'
      )
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe(
        'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.'
      )
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe(
        'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.'
      )
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe(
        'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.'
      )
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe(
        'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.'
      )
      .default(false),
    allow_update_branch: z
      .boolean()
      .describe(
        'Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.'
      )
      .default(false),
    use_squash_pr_title_as_default: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.'
      )
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    archived: z
      .boolean()
      .describe(
        'Whether to archive this repository. `false` will unarchive a previously archived repository.'
      )
      .default(false),
    allow_forking: z
      .boolean()
      .describe(
        'Either `true` to allow private forks, or `false` to prevent private forks.'
      )
      .default(false),
    web_commit_signoff_required: z
      .boolean()
      .describe(
        'Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.'
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposUpdateParams = z.infer<typeof ReposUpdateParamsSchema>

  export const ReposUpdateResponseSchema = FullRepositorySchema
  export type ReposUpdateResponse = z.infer<typeof ReposUpdateResponseSchema>

  export const ActionsListArtifactsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    name: z
      .string()
      .describe(
        'The name field of an artifact. When specified, only artifacts with this name will be returned.'
      )
      .optional()
  })
  export type ActionsListArtifactsForRepoParams = z.infer<
    typeof ActionsListArtifactsForRepoParamsSchema
  >

  export const ActionsListArtifactsForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    artifacts: z.array(ArtifactSchema)
  })
  export type ActionsListArtifactsForRepoResponse = z.infer<
    typeof ActionsListArtifactsForRepoResponseSchema
  >

  export const ActionsGetArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.')
  })
  export type ActionsGetArtifactParams = z.infer<
    typeof ActionsGetArtifactParamsSchema
  >

  export const ActionsGetArtifactResponseSchema = ArtifactSchema
  export type ActionsGetArtifactResponse = z.infer<
    typeof ActionsGetArtifactResponseSchema
  >

  export const ActionsDeleteArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.')
  })
  export type ActionsDeleteArtifactParams = z.infer<
    typeof ActionsDeleteArtifactParamsSchema
  >

  export type ActionsDeleteArtifactResponse = undefined

  export const ActionsDownloadArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.'),
    archive_format: z.string()
  })
  export type ActionsDownloadArtifactParams = z.infer<
    typeof ActionsDownloadArtifactParamsSchema
  >

  export type ActionsDownloadArtifactResponse = undefined

  export const ActionsGetActionsCacheUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetActionsCacheUsageParams = z.infer<
    typeof ActionsGetActionsCacheUsageParamsSchema
  >

  export const ActionsGetActionsCacheUsageResponseSchema =
    ActionsCacheUsageByRepositorySchema
  export type ActionsGetActionsCacheUsageResponse = z.infer<
    typeof ActionsGetActionsCacheUsageResponseSchema
  >

  export const ActionsGetActionsCacheListParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    ref: z
      .string()
      .describe(
        'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    key: z
      .string()
      .describe('An explicit key or prefix for identifying the cache')
      .optional(),
    sort: z
      .enum(['created_at', 'last_accessed_at', 'size_in_bytes'])
      .describe(
        'The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.'
      )
      .default('last_accessed_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc')
  })
  export type ActionsGetActionsCacheListParams = z.infer<
    typeof ActionsGetActionsCacheListParamsSchema
  >

  export const ActionsGetActionsCacheListResponseSchema = ActionsCacheListSchema
  export type ActionsGetActionsCacheListResponse = z.infer<
    typeof ActionsGetActionsCacheListResponseSchema
  >

  export const ActionsDeleteActionsCacheByKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key: z.string().describe('A key for identifying the cache.'),
    ref: z
      .string()
      .describe(
        'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional()
  })
  export type ActionsDeleteActionsCacheByKeyParams = z.infer<
    typeof ActionsDeleteActionsCacheByKeyParamsSchema
  >

  export const ActionsDeleteActionsCacheByKeyResponseSchema =
    ActionsCacheListSchema
  export type ActionsDeleteActionsCacheByKeyResponse = z.infer<
    typeof ActionsDeleteActionsCacheByKeyResponseSchema
  >

  export const ActionsDeleteActionsCacheByIdParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    cache_id: z
      .number()
      .int()
      .describe('The unique identifier of the GitHub Actions cache.')
  })
  export type ActionsDeleteActionsCacheByIdParams = z.infer<
    typeof ActionsDeleteActionsCacheByIdParamsSchema
  >

  export type ActionsDeleteActionsCacheByIdResponse = undefined

  export const ActionsGetJobForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsGetJobForWorkflowRunParams = z.infer<
    typeof ActionsGetJobForWorkflowRunParamsSchema
  >

  export const ActionsGetJobForWorkflowRunResponseSchema = JobSchema
  export type ActionsGetJobForWorkflowRunResponse = z.infer<
    typeof ActionsGetJobForWorkflowRunResponseSchema
  >

  export const ActionsDownloadJobLogsForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsDownloadJobLogsForWorkflowRunParams = z.infer<
    typeof ActionsDownloadJobLogsForWorkflowRunParamsSchema
  >

  export type ActionsDownloadJobLogsForWorkflowRunResponse = undefined

  export const ActionsReRunJobForWorkflowRunParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsReRunJobForWorkflowRunParams = z.infer<
    typeof ActionsReRunJobForWorkflowRunParamsSchema
  >

  export type ActionsReRunJobForWorkflowRunResponse = undefined

  export const ActionsGetCustomOidcSubClaimForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetCustomOidcSubClaimForRepoParams = z.infer<
    typeof ActionsGetCustomOidcSubClaimForRepoParamsSchema
  >

  export const ActionsGetCustomOidcSubClaimForRepoResponseSchema =
    OidcCustomSubRepoSchema
  export type ActionsGetCustomOidcSubClaimForRepoResponse = z.infer<
    typeof ActionsGetCustomOidcSubClaimForRepoResponseSchema
  >

  export const ActionsSetCustomOidcSubClaimForRepoParamsSchema = z.object({
    use_default: z
      .boolean()
      .describe(
        'Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.'
      ),
    include_claim_keys: z
      .array(z.string())
      .describe(
        'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsSetCustomOidcSubClaimForRepoParams = z.infer<
    typeof ActionsSetCustomOidcSubClaimForRepoParamsSchema
  >

  export type ActionsSetCustomOidcSubClaimForRepoResponse = undefined

  export const ActionsListRepoOrganizationSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoOrganizationSecretsParams = z.infer<
    typeof ActionsListRepoOrganizationSecretsParamsSchema
  >

  export const ActionsListRepoOrganizationSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListRepoOrganizationSecretsResponse = z.infer<
    typeof ActionsListRepoOrganizationSecretsResponseSchema
  >

  export const ActionsListRepoOrganizationVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoOrganizationVariablesParams = z.infer<
    typeof ActionsListRepoOrganizationVariablesParamsSchema
  >

  export const ActionsListRepoOrganizationVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListRepoOrganizationVariablesResponse = z.infer<
    typeof ActionsListRepoOrganizationVariablesResponseSchema
  >

  export const ActionsGetGithubActionsPermissionsRepositoryParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsGetGithubActionsPermissionsRepositoryParams = z.infer<
    typeof ActionsGetGithubActionsPermissionsRepositoryParamsSchema
  >

  export const ActionsGetGithubActionsPermissionsRepositoryResponseSchema =
    ActionsRepositoryPermissionsSchema
  export type ActionsGetGithubActionsPermissionsRepositoryResponse = z.infer<
    typeof ActionsGetGithubActionsPermissionsRepositoryResponseSchema
  >

  export const ActionsSetGithubActionsPermissionsRepositoryParamsSchema =
    z.object({
      enabled: ActionsEnabledSchema,
      allowed_actions: AllowedActionsSchema.optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsSetGithubActionsPermissionsRepositoryParams = z.infer<
    typeof ActionsSetGithubActionsPermissionsRepositoryParamsSchema
  >

  export type ActionsSetGithubActionsPermissionsRepositoryResponse = undefined

  export const ActionsGetWorkflowAccessToRepositoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetWorkflowAccessToRepositoryParams = z.infer<
    typeof ActionsGetWorkflowAccessToRepositoryParamsSchema
  >

  export const ActionsGetWorkflowAccessToRepositoryResponseSchema =
    ActionsWorkflowAccessToRepositorySchema
  export type ActionsGetWorkflowAccessToRepositoryResponse = z.infer<
    typeof ActionsGetWorkflowAccessToRepositoryResponseSchema
  >

  export const ActionsSetWorkflowAccessToRepositoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(ActionsWorkflowAccessToRepositorySchema)
  export type ActionsSetWorkflowAccessToRepositoryParams = z.infer<
    typeof ActionsSetWorkflowAccessToRepositoryParamsSchema
  >

  export type ActionsSetWorkflowAccessToRepositoryResponse = undefined

  export const ActionsGetAllowedActionsRepositoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetAllowedActionsRepositoryParams = z.infer<
    typeof ActionsGetAllowedActionsRepositoryParamsSchema
  >

  export const ActionsGetAllowedActionsRepositoryResponseSchema =
    SelectedActionsSchema
  export type ActionsGetAllowedActionsRepositoryResponse = z.infer<
    typeof ActionsGetAllowedActionsRepositoryResponseSchema
  >

  export const ActionsSetAllowedActionsRepositoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(SelectedActionsSchema)
  export type ActionsSetAllowedActionsRepositoryParams = z.infer<
    typeof ActionsSetAllowedActionsRepositoryParamsSchema
  >

  export type ActionsSetAllowedActionsRepositoryResponse = undefined

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParams =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
    >

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseSchema =
    ActionsGetDefaultWorkflowPermissionsSchema
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseSchema
    >

  export const ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema =
    z
      .object({
        owner: z
          .string()
          .describe(
            'The account owner of the repository. The name is not case sensitive.'
          ),
        repo: z
          .string()
          .describe(
            'The name of the repository without the `.git` extension. The name is not case sensitive.'
          )
      })
      .merge(ActionsSetDefaultWorkflowPermissionsSchema)
  export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParams =
    z.infer<
      typeof ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
    >

  export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse =
    undefined

  export const ActionsListSelfHostedRunnersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of a self-hosted runner.').optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListSelfHostedRunnersForRepoParams = z.infer<
    typeof ActionsListSelfHostedRunnersForRepoParamsSchema
  >

  export const ActionsListSelfHostedRunnersForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(RunnerSchema)
  })
  export type ActionsListSelfHostedRunnersForRepoResponse = z.infer<
    typeof ActionsListSelfHostedRunnersForRepoResponseSchema
  >

  export const ActionsListRunnerApplicationsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsListRunnerApplicationsForRepoParams = z.infer<
    typeof ActionsListRunnerApplicationsForRepoParamsSchema
  >

  export const ActionsListRunnerApplicationsForRepoResponseSchema = z.array(
    RunnerApplicationSchema
  )
  export type ActionsListRunnerApplicationsForRepoResponse = z.infer<
    typeof ActionsListRunnerApplicationsForRepoResponseSchema
  >

  export const ActionsGenerateRunnerJitconfigForRepoParamsSchema = z.object({
    name: z.string().describe('The name of the new runner.'),
    runner_group_id: z
      .number()
      .int()
      .describe('The ID of the runner group to register the runner to.'),
    labels: z
      .array(z.string())
      .min(1)
      .max(100)
      .describe(
        'The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.'
      ),
    work_folder: z
      .string()
      .describe(
        'The working directory to be used for job execution, relative to the runner install directory.'
      )
      .default('_work'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGenerateRunnerJitconfigForRepoParams = z.infer<
    typeof ActionsGenerateRunnerJitconfigForRepoParamsSchema
  >

  export type ActionsGenerateRunnerJitconfigForRepoResponse = undefined

  export const ActionsCreateRegistrationTokenForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRegistrationTokenForRepoParams = z.infer<
    typeof ActionsCreateRegistrationTokenForRepoParamsSchema
  >

  export type ActionsCreateRegistrationTokenForRepoResponse = undefined

  export const ActionsCreateRemoveTokenForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRemoveTokenForRepoParams = z.infer<
    typeof ActionsCreateRemoveTokenForRepoParamsSchema
  >

  export type ActionsCreateRemoveTokenForRepoResponse = undefined

  export const ActionsGetSelfHostedRunnerForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsGetSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsGetSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsGetSelfHostedRunnerForRepoResponseSchema = RunnerSchema
  export type ActionsGetSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerFromRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsDeleteSelfHostedRunnerFromRepoParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerFromRepoParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerFromRepoResponse = undefined

  export const ActionsListLabelsForSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsListLabelsForSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsListLabelsForSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsListLabelsForSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(1)
        .max(100)
        .describe('The names of the custom labels to add to the runner.'),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(0)
        .max(100)
        .describe(
          'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParams =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamsSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.'),
      name: z
        .string()
        .describe("The name of a self-hosted runner's custom label.")
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParams =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamsSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsListWorkflowRunsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    actor: z
      .string()
      .describe(
        "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
      )
      .optional(),
    branch: z
      .string()
      .describe(
        'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
      )
      .optional(),
    event: z
      .string()
      .describe(
        'Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."'
      )
      .optional(),
    status: z
      .enum([
        'completed',
        'action_required',
        'cancelled',
        'failure',
        'neutral',
        'skipped',
        'stale',
        'success',
        'timed_out',
        'in_progress',
        'queued',
        'requested',
        'waiting',
        'pending'
      ])
      .describe(
        'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    created: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false),
    check_suite_id: z
      .number()
      .int()
      .describe(
        'Returns workflow runs with the `check_suite_id` that you specify.'
      )
      .optional(),
    head_sha: z
      .string()
      .describe(
        'Only returns workflow runs that are associated with the specified `head_sha`.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunsForRepoParams = z.infer<
    typeof ActionsListWorkflowRunsForRepoParamsSchema
  >

  export const ActionsListWorkflowRunsForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    workflow_runs: z.array(WorkflowRunSchema)
  })
  export type ActionsListWorkflowRunsForRepoResponse = z.infer<
    typeof ActionsListWorkflowRunsForRepoResponseSchema
  >

  export const ActionsGetWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false)
  })
  export type ActionsGetWorkflowRunParams = z.infer<
    typeof ActionsGetWorkflowRunParamsSchema
  >

  export const ActionsGetWorkflowRunResponseSchema = WorkflowRunSchema
  export type ActionsGetWorkflowRunResponse = z.infer<
    typeof ActionsGetWorkflowRunResponseSchema
  >

  export const ActionsDeleteWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDeleteWorkflowRunParams = z.infer<
    typeof ActionsDeleteWorkflowRunParamsSchema
  >

  export type ActionsDeleteWorkflowRunResponse = undefined

  export const ActionsGetReviewsForRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetReviewsForRunParams = z.infer<
    typeof ActionsGetReviewsForRunParamsSchema
  >

  export const ActionsGetReviewsForRunResponseSchema = z.array(
    EnvironmentApprovalsSchema
  )
  export type ActionsGetReviewsForRunResponse = z.infer<
    typeof ActionsGetReviewsForRunResponseSchema
  >

  export const ActionsApproveWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsApproveWorkflowRunParams = z.infer<
    typeof ActionsApproveWorkflowRunParamsSchema
  >

  export type ActionsApproveWorkflowRunResponse = undefined

  export const ActionsListWorkflowRunArtifactsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    name: z
      .string()
      .describe(
        'The name field of an artifact. When specified, only artifacts with this name will be returned.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunArtifactsParams = z.infer<
    typeof ActionsListWorkflowRunArtifactsParamsSchema
  >

  export const ActionsListWorkflowRunArtifactsResponseSchema = z.object({
    total_count: z.number().int(),
    artifacts: z.array(ArtifactSchema)
  })
  export type ActionsListWorkflowRunArtifactsResponse = z.infer<
    typeof ActionsListWorkflowRunArtifactsResponseSchema
  >

  export const ActionsGetWorkflowRunAttemptParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.'),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false)
  })
  export type ActionsGetWorkflowRunAttemptParams = z.infer<
    typeof ActionsGetWorkflowRunAttemptParamsSchema
  >

  export const ActionsGetWorkflowRunAttemptResponseSchema = WorkflowRunSchema
  export type ActionsGetWorkflowRunAttemptResponse = z.infer<
    typeof ActionsGetWorkflowRunAttemptResponseSchema
  >

  export const ActionsListJobsForWorkflowRunAttemptParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListJobsForWorkflowRunAttemptParams = z.infer<
    typeof ActionsListJobsForWorkflowRunAttemptParamsSchema
  >

  export const ActionsListJobsForWorkflowRunAttemptResponseSchema = z.object({
    total_count: z.number().int(),
    jobs: z.array(JobSchema)
  })
  export type ActionsListJobsForWorkflowRunAttemptResponse = z.infer<
    typeof ActionsListJobsForWorkflowRunAttemptResponseSchema
  >

  export const ActionsDownloadWorkflowRunAttemptLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.')
  })
  export type ActionsDownloadWorkflowRunAttemptLogsParams = z.infer<
    typeof ActionsDownloadWorkflowRunAttemptLogsParamsSchema
  >

  export type ActionsDownloadWorkflowRunAttemptLogsResponse = undefined

  export const ActionsCancelWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsCancelWorkflowRunParams = z.infer<
    typeof ActionsCancelWorkflowRunParamsSchema
  >

  export type ActionsCancelWorkflowRunResponse = undefined

  export const ActionsReviewCustomGatesForRunParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      run_id: z
        .number()
        .int()
        .describe('The unique identifier of the workflow run.')
    })
    .and(
      z.union([
        ReviewCustomGatesCommentRequiredSchema,
        ReviewCustomGatesStateRequiredSchema
      ])
    )
  export type ActionsReviewCustomGatesForRunParams = z.infer<
    typeof ActionsReviewCustomGatesForRunParamsSchema
  >

  export type ActionsReviewCustomGatesForRunResponse = undefined

  export const ActionsForceCancelWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsForceCancelWorkflowRunParams = z.infer<
    typeof ActionsForceCancelWorkflowRunParamsSchema
  >

  export type ActionsForceCancelWorkflowRunResponse = undefined

  export const ActionsListJobsForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListJobsForWorkflowRunParams = z.infer<
    typeof ActionsListJobsForWorkflowRunParamsSchema
  >

  export const ActionsListJobsForWorkflowRunResponseSchema = z.object({
    total_count: z.number().int(),
    jobs: z.array(JobSchema)
  })
  export type ActionsListJobsForWorkflowRunResponse = z.infer<
    typeof ActionsListJobsForWorkflowRunResponseSchema
  >

  export const ActionsDownloadWorkflowRunLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDownloadWorkflowRunLogsParams = z.infer<
    typeof ActionsDownloadWorkflowRunLogsParamsSchema
  >

  export type ActionsDownloadWorkflowRunLogsResponse = undefined

  export const ActionsDeleteWorkflowRunLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDeleteWorkflowRunLogsParams = z.infer<
    typeof ActionsDeleteWorkflowRunLogsParamsSchema
  >

  export type ActionsDeleteWorkflowRunLogsResponse = undefined

  export const ActionsGetPendingDeploymentsForRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetPendingDeploymentsForRunParams = z.infer<
    typeof ActionsGetPendingDeploymentsForRunParamsSchema
  >

  export const ActionsGetPendingDeploymentsForRunResponseSchema = z.array(
    PendingDeploymentSchema
  )
  export type ActionsGetPendingDeploymentsForRunResponse = z.infer<
    typeof ActionsGetPendingDeploymentsForRunResponseSchema
  >

  export const ActionsReviewPendingDeploymentsForRunParamsSchema = z.object({
    environment_ids: z
      .array(z.number().int())
      .describe('The list of environment ids to approve or reject'),
    state: z
      .enum(['approved', 'rejected'])
      .describe(
        'Whether to approve or reject deployment to the specified environments.'
      ),
    comment: z
      .string()
      .describe('A comment to accompany the deployment review'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReviewPendingDeploymentsForRunParams = z.infer<
    typeof ActionsReviewPendingDeploymentsForRunParamsSchema
  >

  export const ActionsReviewPendingDeploymentsForRunResponseSchema =
    z.array(DeploymentSchema)
  export type ActionsReviewPendingDeploymentsForRunResponse = z.infer<
    typeof ActionsReviewPendingDeploymentsForRunResponseSchema
  >

  export const ActionsReRunWorkflowParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReRunWorkflowParams = z.infer<
    typeof ActionsReRunWorkflowParamsSchema
  >

  export type ActionsReRunWorkflowResponse = undefined

  export const ActionsReRunWorkflowFailedJobsParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReRunWorkflowFailedJobsParams = z.infer<
    typeof ActionsReRunWorkflowFailedJobsParamsSchema
  >

  export type ActionsReRunWorkflowFailedJobsResponse = undefined

  export const ActionsGetWorkflowRunUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetWorkflowRunUsageParams = z.infer<
    typeof ActionsGetWorkflowRunUsageParamsSchema
  >

  export const ActionsGetWorkflowRunUsageResponseSchema = WorkflowRunUsageSchema
  export type ActionsGetWorkflowRunUsageResponse = z.infer<
    typeof ActionsGetWorkflowRunUsageResponseSchema
  >

  export const ActionsListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoSecretsParams = z.infer<
    typeof ActionsListRepoSecretsParamsSchema
  >

  export const ActionsListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListRepoSecretsResponse = z.infer<
    typeof ActionsListRepoSecretsResponseSchema
  >

  export const ActionsGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetRepoPublicKeyParams = z.infer<
    typeof ActionsGetRepoPublicKeyParamsSchema
  >

  export const ActionsGetRepoPublicKeyResponseSchema = ActionsPublicKeySchema
  export type ActionsGetRepoPublicKeyResponse = z.infer<
    typeof ActionsGetRepoPublicKeyResponseSchema
  >

  export const ActionsGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetRepoSecretParams = z.infer<
    typeof ActionsGetRepoSecretParamsSchema
  >

  export const ActionsGetRepoSecretResponseSchema = ActionsSecretSchema
  export type ActionsGetRepoSecretResponse = z.infer<
    typeof ActionsGetRepoSecretResponseSchema
  >

  export const ActionsCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateRepoSecretParams = z.infer<
    typeof ActionsCreateOrUpdateRepoSecretParamsSchema
  >

  export type ActionsCreateOrUpdateRepoSecretResponse = undefined

  export const ActionsDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteRepoSecretParams = z.infer<
    typeof ActionsDeleteRepoSecretParamsSchema
  >

  export type ActionsDeleteRepoSecretResponse = undefined

  export const ActionsListRepoVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoVariablesParams = z.infer<
    typeof ActionsListRepoVariablesParamsSchema
  >

  export const ActionsListRepoVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListRepoVariablesResponse = z.infer<
    typeof ActionsListRepoVariablesResponseSchema
  >

  export const ActionsCreateRepoVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRepoVariableParams = z.infer<
    typeof ActionsCreateRepoVariableParamsSchema
  >

  export type ActionsCreateRepoVariableResponse = undefined

  export const ActionsGetRepoVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetRepoVariableParams = z.infer<
    typeof ActionsGetRepoVariableParamsSchema
  >

  export const ActionsGetRepoVariableResponseSchema = ActionsVariableSchema
  export type ActionsGetRepoVariableResponse = z.infer<
    typeof ActionsGetRepoVariableResponseSchema
  >

  export const ActionsDeleteRepoVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsDeleteRepoVariableParams = z.infer<
    typeof ActionsDeleteRepoVariableParamsSchema
  >

  export type ActionsDeleteRepoVariableResponse = undefined

  export const ActionsUpdateRepoVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsUpdateRepoVariableParams = z.infer<
    typeof ActionsUpdateRepoVariableParamsSchema
  >

  export type ActionsUpdateRepoVariableResponse = undefined

  export const ActionsListRepoWorkflowsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoWorkflowsParams = z.infer<
    typeof ActionsListRepoWorkflowsParamsSchema
  >

  export const ActionsListRepoWorkflowsResponseSchema = z.object({
    total_count: z.number().int(),
    workflows: z.array(WorkflowSchema)
  })
  export type ActionsListRepoWorkflowsResponse = z.infer<
    typeof ActionsListRepoWorkflowsResponseSchema
  >

  export const ActionsGetWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsGetWorkflowParams = z.infer<
    typeof ActionsGetWorkflowParamsSchema
  >

  export const ActionsGetWorkflowResponseSchema = WorkflowSchema
  export type ActionsGetWorkflowResponse = z.infer<
    typeof ActionsGetWorkflowResponseSchema
  >

  export const ActionsDisableWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsDisableWorkflowParams = z.infer<
    typeof ActionsDisableWorkflowParamsSchema
  >

  export type ActionsDisableWorkflowResponse = undefined

  export const ActionsCreateWorkflowDispatchParamsSchema = z.object({
    ref: z
      .string()
      .describe(
        'The git reference for the workflow. The reference can be a branch or tag name.'
      ),
    inputs: z
      .record(z.any())
      .describe(
        'Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsCreateWorkflowDispatchParams = z.infer<
    typeof ActionsCreateWorkflowDispatchParamsSchema
  >

  export type ActionsCreateWorkflowDispatchResponse = undefined

  export const ActionsEnableWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsEnableWorkflowParams = z.infer<
    typeof ActionsEnableWorkflowParamsSchema
  >

  export type ActionsEnableWorkflowResponse = undefined

  export const ActionsListWorkflowRunsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      ),
    actor: z
      .string()
      .describe(
        "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
      )
      .optional(),
    branch: z
      .string()
      .describe(
        'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
      )
      .optional(),
    event: z
      .string()
      .describe(
        'Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."'
      )
      .optional(),
    status: z
      .enum([
        'completed',
        'action_required',
        'cancelled',
        'failure',
        'neutral',
        'skipped',
        'stale',
        'success',
        'timed_out',
        'in_progress',
        'queued',
        'requested',
        'waiting',
        'pending'
      ])
      .describe(
        'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    created: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false),
    check_suite_id: z
      .number()
      .int()
      .describe(
        'Returns workflow runs with the `check_suite_id` that you specify.'
      )
      .optional(),
    head_sha: z
      .string()
      .describe(
        'Only returns workflow runs that are associated with the specified `head_sha`.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunsParams = z.infer<
    typeof ActionsListWorkflowRunsParamsSchema
  >

  export const ActionsListWorkflowRunsResponseSchema = z.object({
    total_count: z.number().int(),
    workflow_runs: z.array(WorkflowRunSchema)
  })
  export type ActionsListWorkflowRunsResponse = z.infer<
    typeof ActionsListWorkflowRunsResponseSchema
  >

  export const ActionsGetWorkflowUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsGetWorkflowUsageParams = z.infer<
    typeof ActionsGetWorkflowUsageParamsSchema
  >

  export const ActionsGetWorkflowUsageResponseSchema = WorkflowUsageSchema
  export type ActionsGetWorkflowUsageResponse = z.infer<
    typeof ActionsGetWorkflowUsageResponseSchema
  >

  export const ReposListActivitiesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    ref: z
      .string()
      .describe(
        'The Git reference for the activities you want to list.\n\nThe `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.'
      )
      .optional(),
    actor: z
      .string()
      .describe(
        'The GitHub username to use to filter by the actor who performed the activity.'
      )
      .optional(),
    time_period: z
      .enum(['day', 'week', 'month', 'quarter', 'year'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).'
      )
      .optional(),
    activity_type: z
      .enum([
        'push',
        'force_push',
        'branch_creation',
        'branch_deletion',
        'pr_merge',
        'merge_queue_merge'
      ])
      .describe(
        'The activity type to filter by.\n\nFor example, you can choose to filter by "force_push", to see all force pushes to the repository.'
      )
      .optional()
  })
  export type ReposListActivitiesParams = z.infer<
    typeof ReposListActivitiesParamsSchema
  >

  export const ReposListActivitiesResponseSchema = z.array(ActivitySchema)
  export type ReposListActivitiesResponse = z.infer<
    typeof ReposListActivitiesResponseSchema
  >

  export const IssuesListAssigneesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListAssigneesParams = z.infer<
    typeof IssuesListAssigneesParamsSchema
  >

  export const IssuesListAssigneesResponseSchema = z.array(SimpleUserSchema)
  export type IssuesListAssigneesResponse = z.infer<
    typeof IssuesListAssigneesResponseSchema
  >

  export const IssuesCheckUserCanBeAssignedParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    assignee: z.string()
  })
  export type IssuesCheckUserCanBeAssignedParams = z.infer<
    typeof IssuesCheckUserCanBeAssignedParamsSchema
  >

  export type IssuesCheckUserCanBeAssignedResponse = undefined

  export const ReposCreateAttestationParamsSchema = z.object({
    bundle: z
      .object({
        mediaType: z.string().optional(),
        verificationMaterial: z.object({}).catchall(z.any()).optional(),
        dsseEnvelope: z.object({}).catchall(z.any()).optional()
      })
      .describe(
        "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateAttestationParams = z.infer<
    typeof ReposCreateAttestationParamsSchema
  >

  export type ReposCreateAttestationResponse = undefined

  export const ReposListAttestationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    subject_digest: z
      .string()
      .describe(
        "The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`."
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type ReposListAttestationsParams = z.infer<
    typeof ReposListAttestationsParamsSchema
  >

  export const ReposListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type ReposListAttestationsResponse = z.infer<
    typeof ReposListAttestationsResponseSchema
  >

  export const ReposListAutolinksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListAutolinksParams = z.infer<
    typeof ReposListAutolinksParamsSchema
  >

  export const ReposListAutolinksResponseSchema = z.array(AutolinkSchema)
  export type ReposListAutolinksResponse = z.infer<
    typeof ReposListAutolinksResponseSchema
  >

  export const ReposCreateAutolinkParamsSchema = z.object({
    key_prefix: z
      .string()
      .describe(
        'This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.'
      ),
    url_template: z
      .string()
      .describe(
        'The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.'
      ),
    is_alphanumeric: z
      .boolean()
      .describe(
        'Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateAutolinkParams = z.infer<
    typeof ReposCreateAutolinkParamsSchema
  >

  export type ReposCreateAutolinkResponse = undefined

  export const ReposGetAutolinkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    autolink_id: z
      .number()
      .int()
      .describe('The unique identifier of the autolink.')
  })
  export type ReposGetAutolinkParams = z.infer<
    typeof ReposGetAutolinkParamsSchema
  >

  export const ReposGetAutolinkResponseSchema = AutolinkSchema
  export type ReposGetAutolinkResponse = z.infer<
    typeof ReposGetAutolinkResponseSchema
  >

  export const ReposDeleteAutolinkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    autolink_id: z
      .number()
      .int()
      .describe('The unique identifier of the autolink.')
  })
  export type ReposDeleteAutolinkParams = z.infer<
    typeof ReposDeleteAutolinkParamsSchema
  >

  export type ReposDeleteAutolinkResponse = undefined

  export const ReposCheckAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckAutomatedSecurityFixesParams = z.infer<
    typeof ReposCheckAutomatedSecurityFixesParamsSchema
  >

  export const ReposCheckAutomatedSecurityFixesResponseSchema =
    CheckAutomatedSecurityFixesSchema
  export type ReposCheckAutomatedSecurityFixesResponse = z.infer<
    typeof ReposCheckAutomatedSecurityFixesResponseSchema
  >

  export const ReposEnableAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnableAutomatedSecurityFixesParams = z.infer<
    typeof ReposEnableAutomatedSecurityFixesParamsSchema
  >

  export type ReposEnableAutomatedSecurityFixesResponse = undefined

  export const ReposDisableAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDisableAutomatedSecurityFixesParams = z.infer<
    typeof ReposDisableAutomatedSecurityFixesParamsSchema
  >

  export type ReposDisableAutomatedSecurityFixesResponse = undefined

  export const ReposListBranchesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    protected: z
      .boolean()
      .describe(
        'Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListBranchesParams = z.infer<
    typeof ReposListBranchesParamsSchema
  >

  export const ReposListBranchesResponseSchema = z.array(ShortBranchSchema)
  export type ReposListBranchesResponse = z.infer<
    typeof ReposListBranchesResponseSchema
  >

  export const ReposGetBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetBranchParams = z.infer<typeof ReposGetBranchParamsSchema>

  export const ReposGetBranchResponseSchema = BranchWithProtectionSchema
  export type ReposGetBranchResponse = z.infer<
    typeof ReposGetBranchResponseSchema
  >

  export const ReposGetBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetBranchProtectionParams = z.infer<
    typeof ReposGetBranchProtectionParamsSchema
  >

  export const ReposGetBranchProtectionResponseSchema = BranchProtectionSchema
  export type ReposGetBranchProtectionResponse = z.infer<
    typeof ReposGetBranchProtectionResponseSchema
  >

  export const ReposUpdateBranchProtectionParamsSchema = z.object({
    required_status_checks: z
      .object({
        strict: z
          .boolean()
          .describe('Require branches to be up to date before merging.'),
        contexts: z
          .array(z.string())
          .describe(
            '**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.'
          ),
        checks: z
          .array(
            z.object({
              context: z.string().describe('The name of the required check'),
              app_id: z
                .number()
                .int()
                .describe(
                  'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                )
                .optional()
            })
          )
          .describe(
            'The list of status checks to require in order to merge into this branch.'
          )
          .optional()
      })
      .describe(
        'Require status checks to pass before merging. Set to `null` to disable.'
      ),
    enforce_admins: z
      .boolean()
      .describe(
        'Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.'
      ),
    required_pull_request_reviews: z
      .object({
        dismissal_restrictions: z
          .object({
            users: z
              .array(z.string())
              .describe('The list of user `login`s with dismissal access')
              .optional(),
            teams: z
              .array(z.string())
              .describe('The list of team `slug`s with dismissal access')
              .optional(),
            apps: z
              .array(z.string())
              .describe('The list of app `slug`s with dismissal access')
              .optional()
          })
          .describe(
            'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.'
          )
          .optional(),
        dismiss_stale_reviews: z
          .boolean()
          .describe(
            'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
          )
          .optional(),
        require_code_owner_reviews: z
          .boolean()
          .describe(
            'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.'
          )
          .optional(),
        required_approving_review_count: z
          .number()
          .int()
          .describe(
            'Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
          )
          .optional(),
        require_last_push_approval: z
          .boolean()
          .describe(
            'Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.'
          )
          .default(false),
        bypass_pull_request_allowances: z
          .object({
            users: z
              .array(z.string())
              .describe(
                'The list of user `login`s allowed to bypass pull request requirements.'
              )
              .optional(),
            teams: z
              .array(z.string())
              .describe(
                'The list of team `slug`s allowed to bypass pull request requirements.'
              )
              .optional(),
            apps: z
              .array(z.string())
              .describe(
                'The list of app `slug`s allowed to bypass pull request requirements.'
              )
              .optional()
          })
          .describe(
            'Allow specific users, teams, or apps to bypass pull request requirements.'
          )
          .optional()
      })
      .describe(
        'Require at least one approving review on a pull request, before merging. Set to `null` to disable.'
      ),
    restrictions: z
      .object({
        users: z
          .array(z.string())
          .describe('The list of user `login`s with push access'),
        teams: z
          .array(z.string())
          .describe('The list of team `slug`s with push access'),
        apps: z
          .array(z.string())
          .describe('The list of app `slug`s with push access')
          .optional()
      })
      .describe(
        'Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.'
      ),
    required_linear_history: z
      .boolean()
      .describe(
        'Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.'
      )
      .optional(),
    allow_force_pushes: z
      .boolean()
      .describe(
        'Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."'
      )
      .optional(),
    allow_deletions: z
      .boolean()
      .describe(
        'Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.'
      )
      .optional(),
    block_creations: z
      .boolean()
      .describe(
        'If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.'
      )
      .optional(),
    required_conversation_resolution: z
      .boolean()
      .describe(
        'Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.'
      )
      .optional(),
    lock_branch: z
      .boolean()
      .describe(
        'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.'
      )
      .default(false),
    allow_fork_syncing: z
      .boolean()
      .describe(
        'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.'
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdateBranchProtectionParams = z.infer<
    typeof ReposUpdateBranchProtectionParamsSchema
  >

  export const ReposUpdateBranchProtectionResponseSchema = ProtectedBranchSchema
  export type ReposUpdateBranchProtectionResponse = z.infer<
    typeof ReposUpdateBranchProtectionResponseSchema
  >

  export const ReposDeleteBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteBranchProtectionParams = z.infer<
    typeof ReposDeleteBranchProtectionParamsSchema
  >

  export type ReposDeleteBranchProtectionResponse = undefined

  export const ReposGetAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAdminBranchProtectionParams = z.infer<
    typeof ReposGetAdminBranchProtectionParamsSchema
  >

  export const ReposGetAdminBranchProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposGetAdminBranchProtectionResponse = z.infer<
    typeof ReposGetAdminBranchProtectionResponseSchema
  >

  export const ReposSetAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetAdminBranchProtectionParams = z.infer<
    typeof ReposSetAdminBranchProtectionParamsSchema
  >

  export const ReposSetAdminBranchProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposSetAdminBranchProtectionResponse = z.infer<
    typeof ReposSetAdminBranchProtectionResponseSchema
  >

  export const ReposDeleteAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteAdminBranchProtectionParams = z.infer<
    typeof ReposDeleteAdminBranchProtectionParamsSchema
  >

  export type ReposDeleteAdminBranchProtectionResponse = undefined

  export const ReposGetPullRequestReviewProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetPullRequestReviewProtectionParams = z.infer<
    typeof ReposGetPullRequestReviewProtectionParamsSchema
  >

  export const ReposGetPullRequestReviewProtectionResponseSchema =
    ProtectedBranchPullRequestReviewSchema
  export type ReposGetPullRequestReviewProtectionResponse = z.infer<
    typeof ReposGetPullRequestReviewProtectionResponseSchema
  >

  export const ReposDeletePullRequestReviewProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeletePullRequestReviewProtectionParams = z.infer<
    typeof ReposDeletePullRequestReviewProtectionParamsSchema
  >

  export type ReposDeletePullRequestReviewProtectionResponse = undefined

  export const ReposUpdatePullRequestReviewProtectionParamsSchema = z.object({
    dismissal_restrictions: z
      .object({
        users: z
          .array(z.string())
          .describe('The list of user `login`s with dismissal access')
          .optional(),
        teams: z
          .array(z.string())
          .describe('The list of team `slug`s with dismissal access')
          .optional(),
        apps: z
          .array(z.string())
          .describe('The list of app `slug`s with dismissal access')
          .optional()
      })
      .describe(
        'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.'
      )
      .optional(),
    dismiss_stale_reviews: z
      .boolean()
      .describe(
        'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
      )
      .optional(),
    require_code_owner_reviews: z
      .boolean()
      .describe(
        'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.'
      )
      .optional(),
    required_approving_review_count: z
      .number()
      .int()
      .describe(
        'Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
      )
      .optional(),
    require_last_push_approval: z
      .boolean()
      .describe(
        'Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`'
      )
      .default(false),
    bypass_pull_request_allowances: z
      .object({
        users: z
          .array(z.string())
          .describe(
            'The list of user `login`s allowed to bypass pull request requirements.'
          )
          .optional(),
        teams: z
          .array(z.string())
          .describe(
            'The list of team `slug`s allowed to bypass pull request requirements.'
          )
          .optional(),
        apps: z
          .array(z.string())
          .describe(
            'The list of app `slug`s allowed to bypass pull request requirements.'
          )
          .optional()
      })
      .describe(
        'Allow specific users, teams, or apps to bypass pull request requirements.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdatePullRequestReviewProtectionParams = z.infer<
    typeof ReposUpdatePullRequestReviewProtectionParamsSchema
  >

  export const ReposUpdatePullRequestReviewProtectionResponseSchema =
    ProtectedBranchPullRequestReviewSchema
  export type ReposUpdatePullRequestReviewProtectionResponse = z.infer<
    typeof ReposUpdatePullRequestReviewProtectionResponseSchema
  >

  export const ReposGetCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetCommitSignatureProtectionParams = z.infer<
    typeof ReposGetCommitSignatureProtectionParamsSchema
  >

  export const ReposGetCommitSignatureProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposGetCommitSignatureProtectionResponse = z.infer<
    typeof ReposGetCommitSignatureProtectionResponseSchema
  >

  export const ReposCreateCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposCreateCommitSignatureProtectionParams = z.infer<
    typeof ReposCreateCommitSignatureProtectionParamsSchema
  >

  export const ReposCreateCommitSignatureProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposCreateCommitSignatureProtectionResponse = z.infer<
    typeof ReposCreateCommitSignatureProtectionResponseSchema
  >

  export const ReposDeleteCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteCommitSignatureProtectionParams = z.infer<
    typeof ReposDeleteCommitSignatureProtectionParamsSchema
  >

  export type ReposDeleteCommitSignatureProtectionResponse = undefined

  export const ReposGetStatusChecksProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetStatusChecksProtectionParams = z.infer<
    typeof ReposGetStatusChecksProtectionParamsSchema
  >

  export const ReposGetStatusChecksProtectionResponseSchema =
    StatusCheckPolicySchema
  export type ReposGetStatusChecksProtectionResponse = z.infer<
    typeof ReposGetStatusChecksProtectionResponseSchema
  >

  export const ReposRemoveStatusCheckProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveStatusCheckProtectionParams = z.infer<
    typeof ReposRemoveStatusCheckProtectionParamsSchema
  >

  export type ReposRemoveStatusCheckProtectionResponse = undefined

  export const ReposUpdateStatusCheckProtectionParamsSchema = z.object({
    strict: z
      .boolean()
      .describe('Require branches to be up to date before merging.')
      .optional(),
    contexts: z
      .array(z.string())
      .describe(
        '**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.'
      )
      .optional(),
    checks: z
      .array(
        z.object({
          context: z.string().describe('The name of the required check'),
          app_id: z
            .number()
            .int()
            .describe(
              'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
            )
            .optional()
        })
      )
      .describe(
        'The list of status checks to require in order to merge into this branch.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdateStatusCheckProtectionParams = z.infer<
    typeof ReposUpdateStatusCheckProtectionParamsSchema
  >

  export const ReposUpdateStatusCheckProtectionResponseSchema =
    StatusCheckPolicySchema
  export type ReposUpdateStatusCheckProtectionResponse = z.infer<
    typeof ReposUpdateStatusCheckProtectionResponseSchema
  >

  export const ReposGetAllStatusCheckContextsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAllStatusCheckContextsParams = z.infer<
    typeof ReposGetAllStatusCheckContextsParamsSchema
  >

  export const ReposGetAllStatusCheckContextsResponseSchema = z.array(
    z.string()
  )
  export type ReposGetAllStatusCheckContextsResponse = z.infer<
    typeof ReposGetAllStatusCheckContextsResponseSchema
  >

  export const ReposAddStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposAddStatusCheckContextsParams = z.infer<
    typeof ReposAddStatusCheckContextsParamsSchema
  >

  export const ReposAddStatusCheckContextsResponseSchema = z.array(z.string())
  export type ReposAddStatusCheckContextsResponse = z.infer<
    typeof ReposAddStatusCheckContextsResponseSchema
  >

  export const ReposSetStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposSetStatusCheckContextsParams = z.infer<
    typeof ReposSetStatusCheckContextsParamsSchema
  >

  export const ReposSetStatusCheckContextsResponseSchema = z.array(z.string())
  export type ReposSetStatusCheckContextsResponse = z.infer<
    typeof ReposSetStatusCheckContextsResponseSchema
  >

  export const ReposRemoveStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposRemoveStatusCheckContextsParams = z.infer<
    typeof ReposRemoveStatusCheckContextsParamsSchema
  >

  export const ReposRemoveStatusCheckContextsResponseSchema = z.array(
    z.string()
  )
  export type ReposRemoveStatusCheckContextsResponse = z.infer<
    typeof ReposRemoveStatusCheckContextsResponseSchema
  >

  export const ReposGetAccessRestrictionsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAccessRestrictionsParams = z.infer<
    typeof ReposGetAccessRestrictionsParamsSchema
  >

  export const ReposGetAccessRestrictionsResponseSchema =
    BranchRestrictionPolicySchema
  export type ReposGetAccessRestrictionsResponse = z.infer<
    typeof ReposGetAccessRestrictionsResponseSchema
  >

  export const ReposDeleteAccessRestrictionsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteAccessRestrictionsParams = z.infer<
    typeof ReposDeleteAccessRestrictionsParamsSchema
  >

  export type ReposDeleteAccessRestrictionsResponse = undefined

  export const ReposGetAppsWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAppsWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetAppsWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetAppsWithAccessToProtectedBranchResponseSchema =
    z.array(IntegrationSchema)
  export type ReposGetAppsWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetAppsWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposAddAppAccessRestrictionsParams = z.infer<
    typeof ReposAddAppAccessRestrictionsParamsSchema
  >

  export const ReposAddAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposAddAppAccessRestrictionsResponse = z.infer<
    typeof ReposAddAppAccessRestrictionsResponseSchema
  >

  export const ReposSetAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetAppAccessRestrictionsParams = z.infer<
    typeof ReposSetAppAccessRestrictionsParamsSchema
  >

  export const ReposSetAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposSetAppAccessRestrictionsResponse = z.infer<
    typeof ReposSetAppAccessRestrictionsResponseSchema
  >

  export const ReposRemoveAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveAppAccessRestrictionsParams = z.infer<
    typeof ReposRemoveAppAccessRestrictionsParamsSchema
  >

  export const ReposRemoveAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposRemoveAppAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveAppAccessRestrictionsResponseSchema
  >

  export const ReposGetTeamsWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetTeamsWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetTeamsWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetTeamsWithAccessToProtectedBranchResponseSchema =
    z.array(TeamSchema)
  export type ReposGetTeamsWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetTeamsWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposAddTeamAccessRestrictionsParams = z.infer<
    typeof ReposAddTeamAccessRestrictionsParamsSchema
  >

  export const ReposAddTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposAddTeamAccessRestrictionsResponse = z.infer<
    typeof ReposAddTeamAccessRestrictionsResponseSchema
  >

  export const ReposSetTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposSetTeamAccessRestrictionsParams = z.infer<
    typeof ReposSetTeamAccessRestrictionsParamsSchema
  >

  export const ReposSetTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposSetTeamAccessRestrictionsResponse = z.infer<
    typeof ReposSetTeamAccessRestrictionsResponseSchema
  >

  export const ReposRemoveTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposRemoveTeamAccessRestrictionsParams = z.infer<
    typeof ReposRemoveTeamAccessRestrictionsParamsSchema
  >

  export const ReposRemoveTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposRemoveTeamAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveTeamAccessRestrictionsResponseSchema
  >

  export const ReposGetUsersWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetUsersWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetUsersWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetUsersWithAccessToProtectedBranchResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposGetUsersWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetUsersWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposAddUserAccessRestrictionsParams = z.infer<
    typeof ReposAddUserAccessRestrictionsParamsSchema
  >

  export const ReposAddUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposAddUserAccessRestrictionsResponse = z.infer<
    typeof ReposAddUserAccessRestrictionsResponseSchema
  >

  export const ReposSetUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetUserAccessRestrictionsParams = z.infer<
    typeof ReposSetUserAccessRestrictionsParamsSchema
  >

  export const ReposSetUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposSetUserAccessRestrictionsResponse = z.infer<
    typeof ReposSetUserAccessRestrictionsResponseSchema
  >

  export const ReposRemoveUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveUserAccessRestrictionsParams = z.infer<
    typeof ReposRemoveUserAccessRestrictionsParamsSchema
  >

  export const ReposRemoveUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposRemoveUserAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveUserAccessRestrictionsResponseSchema
  >

  export const ReposRenameBranchParamsSchema = z.object({
    new_name: z.string().describe('The new name of the branch.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRenameBranchParams = z.infer<
    typeof ReposRenameBranchParamsSchema
  >

  export type ReposRenameBranchResponse = undefined

  export const ChecksCreateParamsSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the check. For example, "code-coverage".'),
      head_sha: z.string().describe('The SHA of the commit.'),
      details_url: z
        .string()
        .describe(
          "The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used."
        )
        .optional(),
      external_id: z
        .string()
        .describe("A reference for the run on the integrator's system.")
        .optional(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
        )
        .default('queued'),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      conclusion: z
        .enum([
          'action_required',
          'cancelled',
          'failure',
          'neutral',
          'success',
          'skipped',
          'stale',
          'timed_out'
        ])
        .describe(
          '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      output: z
        .object({
          title: z.string().describe('The title of the check run.'),
          summary: z
            .string()
            .max(65_535)
            .describe(
              'The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
            ),
          text: z
            .string()
            .max(65_535)
            .describe(
              'The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
            )
            .optional(),
          annotations: z
            .array(
              z.object({
                path: z
                  .string()
                  .describe(
                    'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                  ),
                start_line: z
                  .number()
                  .int()
                  .describe(
                    'The start line of the annotation. Line numbers start at 1.'
                  ),
                end_line: z
                  .number()
                  .int()
                  .describe('The end line of the annotation.'),
                start_column: z
                  .number()
                  .int()
                  .describe(
                    'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                  )
                  .optional(),
                end_column: z
                  .number()
                  .int()
                  .describe(
                    'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                  )
                  .optional(),
                annotation_level: z
                  .enum(['notice', 'warning', 'failure'])
                  .describe('The level of the annotation.'),
                message: z
                  .string()
                  .describe(
                    'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                  ),
                title: z
                  .string()
                  .describe(
                    'The title that represents the annotation. The maximum size is 255 characters.'
                  )
                  .optional(),
                raw_details: z
                  .string()
                  .describe(
                    'Details about this annotation. The maximum size is 64 KB.'
                  )
                  .optional()
              })
            )
            .max(50)
            .describe(
              'Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about how you can view annotations on GitHub, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".'
            )
            .optional(),
          images: z
            .array(
              z.object({
                alt: z.string().describe('The alternative text for the image.'),
                image_url: z.string().describe('The full URL of the image.'),
                caption: z
                  .string()
                  .describe('A short image description.')
                  .optional()
              })
            )
            .describe(
              'Adds images to the output displayed in the GitHub pull request UI.'
            )
            .optional()
        })
        .describe(
          'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.'
        )
        .optional(),
      actions: z
        .array(
          z.object({
            label: z
              .string()
              .max(20)
              .describe(
                'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
              ),
            description: z
              .string()
              .max(40)
              .describe(
                'A short explanation of what this action would do. The maximum size is 40 characters.'
              ),
            identifier: z
              .string()
              .max(20)
              .describe(
                "A reference for the action on the integrator's system. The maximum size is 20 characters."
              )
          })
        )
        .max(3)
        .describe(
          'Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(
      z.union([
        z.object({ status: z.literal('completed') }).catchall(z.any()),
        z
          .object({ status: z.enum(['queued', 'in_progress']).optional() })
          .catchall(z.any())
      ])
    )
  export type ChecksCreateParams = z.infer<typeof ChecksCreateParamsSchema>

  export type ChecksCreateResponse = undefined

  export const ChecksGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.')
  })
  export type ChecksGetParams = z.infer<typeof ChecksGetParamsSchema>

  export const ChecksGetResponseSchema = CheckRunSchema
  export type ChecksGetResponse = z.infer<typeof ChecksGetResponseSchema>

  export const ChecksUpdateParamsSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the check. For example, "code-coverage".')
        .optional(),
      details_url: z
        .string()
        .describe(
          "The URL of the integrator's site that has the full details of the check."
        )
        .optional(),
      external_id: z
        .string()
        .describe("A reference for the run on the integrator's system.")
        .optional(),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
        )
        .optional(),
      conclusion: z
        .enum([
          'action_required',
          'cancelled',
          'failure',
          'neutral',
          'success',
          'skipped',
          'stale',
          'timed_out'
        ])
        .describe(
          '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      output: z
        .object({
          title: z.string().describe('**Required**.').optional(),
          summary: z.string().max(65_535).describe('Can contain Markdown.'),
          text: z
            .string()
            .max(65_535)
            .describe('Can contain Markdown.')
            .optional(),
          annotations: z
            .array(
              z.object({
                path: z
                  .string()
                  .describe(
                    'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                  ),
                start_line: z
                  .number()
                  .int()
                  .describe(
                    'The start line of the annotation. Line numbers start at 1.'
                  ),
                end_line: z
                  .number()
                  .int()
                  .describe('The end line of the annotation.'),
                start_column: z
                  .number()
                  .int()
                  .describe(
                    'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                  )
                  .optional(),
                end_column: z
                  .number()
                  .int()
                  .describe(
                    'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                  )
                  .optional(),
                annotation_level: z
                  .enum(['notice', 'warning', 'failure'])
                  .describe('The level of the annotation.'),
                message: z
                  .string()
                  .describe(
                    'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                  ),
                title: z
                  .string()
                  .describe(
                    'The title that represents the annotation. The maximum size is 255 characters.'
                  )
                  .optional(),
                raw_details: z
                  .string()
                  .describe(
                    'Details about this annotation. The maximum size is 64 KB.'
                  )
                  .optional()
              })
            )
            .max(50)
            .describe(
              'Adds information from your analysis to specific lines of code. Annotations are visible in GitHub\'s pull request UI. Annotations are visible in GitHub\'s pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about annotations in the UI, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".'
            )
            .optional(),
          images: z
            .array(
              z.object({
                alt: z.string().describe('The alternative text for the image.'),
                image_url: z.string().describe('The full URL of the image.'),
                caption: z
                  .string()
                  .describe('A short image description.')
                  .optional()
              })
            )
            .describe(
              'Adds images to the output displayed in the GitHub pull request UI.'
            )
            .optional()
        })
        .describe(
          'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.'
        )
        .optional(),
      actions: z
        .array(
          z.object({
            label: z
              .string()
              .max(20)
              .describe(
                'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
              ),
            description: z
              .string()
              .max(40)
              .describe(
                'A short explanation of what this action would do. The maximum size is 40 characters.'
              ),
            identifier: z
              .string()
              .max(20)
              .describe(
                "A reference for the action on the integrator's system. The maximum size is 20 characters."
              )
          })
        )
        .max(3)
        .describe(
          'Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      check_run_id: z
        .number()
        .int()
        .describe('The unique identifier of the check run.')
    })
    .and(
      z.union([
        z
          .object({ status: z.literal('completed').optional() })
          .catchall(z.any()),
        z
          .object({ status: z.enum(['queued', 'in_progress']).optional() })
          .catchall(z.any())
      ])
    )
  export type ChecksUpdateParams = z.infer<typeof ChecksUpdateParamsSchema>

  export const ChecksUpdateResponseSchema = CheckRunSchema
  export type ChecksUpdateResponse = z.infer<typeof ChecksUpdateResponseSchema>

  export const ChecksListAnnotationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListAnnotationsParams = z.infer<
    typeof ChecksListAnnotationsParamsSchema
  >

  export const ChecksListAnnotationsResponseSchema = z.array(
    CheckAnnotationSchema
  )
  export type ChecksListAnnotationsResponse = z.infer<
    typeof ChecksListAnnotationsResponseSchema
  >

  export const ChecksRerequestRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.')
  })
  export type ChecksRerequestRunParams = z.infer<
    typeof ChecksRerequestRunParamsSchema
  >

  export type ChecksRerequestRunResponse = undefined

  export const ChecksCreateSuiteParamsSchema = z.object({
    head_sha: z.string().describe('The sha of the head commit.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ChecksCreateSuiteParams = z.infer<
    typeof ChecksCreateSuiteParamsSchema
  >

  export const ChecksCreateSuiteResponseSchema = CheckSuiteSchema
  export type ChecksCreateSuiteResponse = z.infer<
    typeof ChecksCreateSuiteResponseSchema
  >

  export const ChecksSetSuitesPreferencesParamsSchema = z.object({
    auto_trigger_checks: z
      .array(
        z.object({
          app_id: z.number().int().describe('The `id` of the GitHub App.'),
          setting: z
            .boolean()
            .describe(
              'Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.'
            )
            .default(true)
        })
      )
      .describe(
        'Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ChecksSetSuitesPreferencesParams = z.infer<
    typeof ChecksSetSuitesPreferencesParamsSchema
  >

  export const ChecksSetSuitesPreferencesResponseSchema =
    CheckSuitePreferenceSchema
  export type ChecksSetSuitesPreferencesResponse = z.infer<
    typeof ChecksSetSuitesPreferencesResponseSchema
  >

  export const ChecksGetSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.')
  })
  export type ChecksGetSuiteParams = z.infer<typeof ChecksGetSuiteParamsSchema>

  export const ChecksGetSuiteResponseSchema = CheckSuiteSchema
  export type ChecksGetSuiteResponse = z.infer<
    typeof ChecksGetSuiteResponseSchema
  >

  export const ChecksListForSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.'),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    status: z
      .enum(['queued', 'in_progress', 'completed'])
      .describe('Returns check runs with the specified `status`.')
      .optional(),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListForSuiteParams = z.infer<
    typeof ChecksListForSuiteParamsSchema
  >

  export const ChecksListForSuiteResponseSchema = z.object({
    total_count: z.number().int(),
    check_runs: z.array(CheckRunSchema)
  })
  export type ChecksListForSuiteResponse = z.infer<
    typeof ChecksListForSuiteResponseSchema
  >

  export const ChecksRerequestSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.')
  })
  export type ChecksRerequestSuiteParams = z.infer<
    typeof ChecksRerequestSuiteParamsSchema
  >

  export type ChecksRerequestSuiteResponse = undefined

  export const CodeScanningListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property by which to sort the results.')
      .default('created'),
    state: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this state will be returned.'
      )
      .optional(),
    severity: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this severity will be returned.'
      )
      .optional()
  })
  export type CodeScanningListAlertsForRepoParams = z.infer<
    typeof CodeScanningListAlertsForRepoParamsSchema
  >

  export const CodeScanningListAlertsForRepoResponseSchema = z.array(
    CodeScanningAlertItemsSchema
  )
  export type CodeScanningListAlertsForRepoResponse = z.infer<
    typeof CodeScanningListAlertsForRepoResponseSchema
  >

  export const CodeScanningGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningGetAlertParams = z.infer<
    typeof CodeScanningGetAlertParamsSchema
  >

  export const CodeScanningGetAlertResponseSchema = CodeScanningAlertSchema
  export type CodeScanningGetAlertResponse = z.infer<
    typeof CodeScanningGetAlertResponseSchema
  >

  export const CodeScanningUpdateAlertParamsSchema = z.object({
    state: CodeScanningAlertSetStateSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema.optional(),
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    create_request: CodeScanningAlertCreateRequestSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningUpdateAlertParams = z.infer<
    typeof CodeScanningUpdateAlertParamsSchema
  >

  export const CodeScanningUpdateAlertResponseSchema = CodeScanningAlertSchema
  export type CodeScanningUpdateAlertResponse = z.infer<
    typeof CodeScanningUpdateAlertResponseSchema
  >

  export const CodeScanningGetAutofixParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningGetAutofixParams = z.infer<
    typeof CodeScanningGetAutofixParamsSchema
  >

  export const CodeScanningGetAutofixResponseSchema = CodeScanningAutofixSchema
  export type CodeScanningGetAutofixResponse = z.infer<
    typeof CodeScanningGetAutofixResponseSchema
  >

  export const CodeScanningCreateAutofixParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningCreateAutofixParams = z.infer<
    typeof CodeScanningCreateAutofixParamsSchema
  >

  export const CodeScanningCreateAutofixResponseSchema =
    CodeScanningAutofixSchema
  export type CodeScanningCreateAutofixResponse = z.infer<
    typeof CodeScanningCreateAutofixResponseSchema
  >

  export const CodeScanningCommitAutofixParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      alert_number: z
        .any()
        .describe(
          'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
        )
    })
    .merge(CodeScanningAutofixCommitsSchema)
  export type CodeScanningCommitAutofixParams = z.infer<
    typeof CodeScanningCommitAutofixParamsSchema
  >

  export type CodeScanningCommitAutofixResponse = undefined

  export const CodeScanningListAlertInstancesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional()
  })
  export type CodeScanningListAlertInstancesParams = z.infer<
    typeof CodeScanningListAlertInstancesParamsSchema
  >

  export const CodeScanningListAlertInstancesResponseSchema = z.array(
    CodeScanningAlertInstanceSchema
  )
  export type CodeScanningListAlertInstancesResponse = z.infer<
    typeof CodeScanningListAlertInstancesResponseSchema
  >

  export const CodeScanningListRecentAnalysesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional(),
    ref: z
      .any()
      .describe(
        'The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    sarif_id: z
      .any()
      .describe('Filter analyses belonging to the same SARIF upload.')
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .literal('created')
      .describe('The property by which to sort the results.')
      .default('created')
  })
  export type CodeScanningListRecentAnalysesParams = z.infer<
    typeof CodeScanningListRecentAnalysesParamsSchema
  >

  export const CodeScanningListRecentAnalysesResponseSchema = z.array(
    CodeScanningAnalysisSchema
  )
  export type CodeScanningListRecentAnalysesResponse = z.infer<
    typeof CodeScanningListRecentAnalysesResponseSchema
  >

  export const CodeScanningGetAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    analysis_id: z
      .number()
      .int()
      .describe(
        'The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.'
      )
  })
  export type CodeScanningGetAnalysisParams = z.infer<
    typeof CodeScanningGetAnalysisParamsSchema
  >

  export const CodeScanningGetAnalysisResponseSchema =
    CodeScanningAnalysisSchema
  export type CodeScanningGetAnalysisResponse = z.infer<
    typeof CodeScanningGetAnalysisResponseSchema
  >

  export const CodeScanningDeleteAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    analysis_id: z
      .number()
      .int()
      .describe(
        'The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.'
      ),
    confirm_delete: z
      .union([z.string(), z.null()])
      .describe(
        "Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`"
      )
      .optional()
  })
  export type CodeScanningDeleteAnalysisParams = z.infer<
    typeof CodeScanningDeleteAnalysisParamsSchema
  >

  export const CodeScanningDeleteAnalysisResponseSchema =
    CodeScanningAnalysisDeletionSchema
  export type CodeScanningDeleteAnalysisResponse = z.infer<
    typeof CodeScanningDeleteAnalysisResponseSchema
  >

  export const CodeScanningListCodeqlDatabasesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningListCodeqlDatabasesParams = z.infer<
    typeof CodeScanningListCodeqlDatabasesParamsSchema
  >

  export const CodeScanningListCodeqlDatabasesResponseSchema = z.array(
    CodeScanningCodeqlDatabaseSchema
  )
  export type CodeScanningListCodeqlDatabasesResponse = z.infer<
    typeof CodeScanningListCodeqlDatabasesResponseSchema
  >

  export const CodeScanningGetCodeqlDatabaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    language: z.string().describe('The language of the CodeQL database.')
  })
  export type CodeScanningGetCodeqlDatabaseParams = z.infer<
    typeof CodeScanningGetCodeqlDatabaseParamsSchema
  >

  export const CodeScanningGetCodeqlDatabaseResponseSchema =
    CodeScanningCodeqlDatabaseSchema
  export type CodeScanningGetCodeqlDatabaseResponse = z.infer<
    typeof CodeScanningGetCodeqlDatabaseResponseSchema
  >

  export const CodeScanningDeleteCodeqlDatabaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    language: z.string().describe('The language of the CodeQL database.')
  })
  export type CodeScanningDeleteCodeqlDatabaseParams = z.infer<
    typeof CodeScanningDeleteCodeqlDatabaseParamsSchema
  >

  export type CodeScanningDeleteCodeqlDatabaseResponse = undefined

  export const CodeScanningCreateVariantAnalysisParamsSchema = z
    .object({
      language: CodeScanningVariantAnalysisLanguageSchema,
      query_pack: z
        .string()
        .describe(
          'A Base64-encoded tarball containing a CodeQL query and all its dependencies'
        ),
      repositories: z
        .array(z.string())
        .describe(
          'List of repository names (in the form `owner/repo-name`) to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      repository_lists: z
        .array(z.string())
        .max(1)
        .describe(
          'List of repository lists to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      repository_owners: z
        .array(z.string())
        .max(1)
        .describe(
          'List of organization or user names whose repositories the query should be run against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any(), z.any()]))
  export type CodeScanningCreateVariantAnalysisParams = z.infer<
    typeof CodeScanningCreateVariantAnalysisParamsSchema
  >

  export type CodeScanningCreateVariantAnalysisResponse = undefined

  export const CodeScanningGetVariantAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    codeql_variant_analysis_id: z
      .number()
      .int()
      .describe('The unique identifier of the variant analysis.')
  })
  export type CodeScanningGetVariantAnalysisParams = z.infer<
    typeof CodeScanningGetVariantAnalysisParamsSchema
  >

  export const CodeScanningGetVariantAnalysisResponseSchema =
    CodeScanningVariantAnalysisSchema
  export type CodeScanningGetVariantAnalysisResponse = z.infer<
    typeof CodeScanningGetVariantAnalysisResponseSchema
  >

  export const CodeScanningGetVariantAnalysisRepoTaskParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z.string().describe('The name of the controller repository.'),
    codeql_variant_analysis_id: z
      .number()
      .int()
      .describe('The ID of the variant analysis.'),
    repo_owner: z
      .string()
      .describe(
        'The account owner of the variant analysis repository. The name is not case sensitive.'
      ),
    repo_name: z
      .string()
      .describe('The name of the variant analysis repository.')
  })
  export type CodeScanningGetVariantAnalysisRepoTaskParams = z.infer<
    typeof CodeScanningGetVariantAnalysisRepoTaskParamsSchema
  >

  export const CodeScanningGetVariantAnalysisRepoTaskResponseSchema =
    CodeScanningVariantAnalysisRepoTaskSchema
  export type CodeScanningGetVariantAnalysisRepoTaskResponse = z.infer<
    typeof CodeScanningGetVariantAnalysisRepoTaskResponseSchema
  >

  export const CodeScanningGetDefaultSetupParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningGetDefaultSetupParams = z.infer<
    typeof CodeScanningGetDefaultSetupParamsSchema
  >

  export const CodeScanningGetDefaultSetupResponseSchema =
    CodeScanningDefaultSetupSchema
  export type CodeScanningGetDefaultSetupResponse = z.infer<
    typeof CodeScanningGetDefaultSetupResponseSchema
  >

  export const CodeScanningUpdateDefaultSetupParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(CodeScanningDefaultSetupUpdateSchema)
  export type CodeScanningUpdateDefaultSetupParams = z.infer<
    typeof CodeScanningUpdateDefaultSetupParamsSchema
  >

  export const CodeScanningUpdateDefaultSetupResponseSchema = EmptyObjectSchema
  export type CodeScanningUpdateDefaultSetupResponse = z.infer<
    typeof CodeScanningUpdateDefaultSetupResponseSchema
  >

  export const CodeScanningUploadSarifParamsSchema = z.object({
    commit_sha: CodeScanningAnalysisCommitShaSchema,
    ref: CodeScanningRefFullSchema,
    sarif: CodeScanningAnalysisSarifFileSchema,
    checkout_uri: z
      .string()
      .url()
      .describe(
        'The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.'
      )
      .optional(),
    started_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    tool_name: z
      .string()
      .describe(
        'The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.'
      )
      .optional(),
    validate: z
      .boolean()
      .describe(
        'Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningUploadSarifParams = z.infer<
    typeof CodeScanningUploadSarifParamsSchema
  >

  export type CodeScanningUploadSarifResponse = undefined

  export const CodeScanningGetSarifParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sarif_id: z.string().describe('The SARIF ID obtained after uploading.')
  })
  export type CodeScanningGetSarifParams = z.infer<
    typeof CodeScanningGetSarifParamsSchema
  >

  export const CodeScanningGetSarifResponseSchema =
    CodeScanningSarifsStatusSchema
  export type CodeScanningGetSarifResponse = z.infer<
    typeof CodeScanningGetSarifResponseSchema
  >

  export const CodeSecurityGetConfigurationForRepositoryParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type CodeSecurityGetConfigurationForRepositoryParams = z.infer<
    typeof CodeSecurityGetConfigurationForRepositoryParamsSchema
  >

  export const CodeSecurityGetConfigurationForRepositoryResponseSchema =
    CodeSecurityConfigurationForRepositorySchema
  export type CodeSecurityGetConfigurationForRepositoryResponse = z.infer<
    typeof CodeSecurityGetConfigurationForRepositoryResponseSchema
  >

  export const ReposCodeownersErrorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        "A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)"
      )
      .optional()
  })
  export type ReposCodeownersErrorsParams = z.infer<
    typeof ReposCodeownersErrorsParamsSchema
  >

  export const ReposCodeownersErrorsResponseSchema = CodeownersErrorsSchema
  export type ReposCodeownersErrorsResponse = z.infer<
    typeof ReposCodeownersErrorsResponseSchema
  >

  export const CodespacesListInRepositoryForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type CodespacesListInRepositoryForAuthenticatedUserParams = z.infer<
    typeof CodespacesListInRepositoryForAuthenticatedUserParamsSchema
  >

  export const CodespacesListInRepositoryForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      codespaces: z.array(CodespaceSchema)
    })
  export type CodespacesListInRepositoryForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListInRepositoryForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateWithRepoForAuthenticatedUserParamsSchema =
    z.object({
      ref: z
        .string()
        .describe('Git ref (typically a branch name) for this codespace')
        .optional(),
      location: z
        .string()
        .describe(
          'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
        )
        .optional(),
      geo: z
        .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
        .describe(
          'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      machine: z
        .string()
        .describe('Machine type to use for this codespace')
        .optional(),
      devcontainer_path: z
        .string()
        .describe('Path to devcontainer.json config to use for this codespace')
        .optional(),
      multi_repo_permissions_opt_out: z
        .boolean()
        .describe(
          'Whether to authorize requested permissions from devcontainer.json'
        )
        .optional(),
      working_directory: z
        .string()
        .describe('Working directory for this codespace')
        .optional(),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe('Time in minutes before codespace stops from inactivity')
        .optional(),
      display_name: z
        .string()
        .describe('Display name for this codespace')
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type CodespacesCreateWithRepoForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateWithRepoForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateWithRepoForAuthenticatedUserResponse = undefined

  export const CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamsSchema
    >

  export const CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      devcontainers: z.array(
        z.object({
          path: z.string(),
          name: z.string().optional(),
          display_name: z.string().optional()
        })
      )
    })
  export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse =
    z.infer<
      typeof CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseSchema
    >

  export const CodespacesRepoMachinesForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      location: z
        .string()
        .describe(
          'The location to check for available machines. Assigned by IP if not provided.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      ref: z
        .string()
        .describe(
          'The branch or commit to check for prebuild availability and devcontainer restrictions.'
        )
        .optional()
    })
  export type CodespacesRepoMachinesForAuthenticatedUserParams = z.infer<
    typeof CodespacesRepoMachinesForAuthenticatedUserParamsSchema
  >

  export const CodespacesRepoMachinesForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      machines: z.array(CodespaceMachineSchema)
    })
  export type CodespacesRepoMachinesForAuthenticatedUserResponse = z.infer<
    typeof CodespacesRepoMachinesForAuthenticatedUserResponseSchema
  >

  export const CodespacesPreFlightWithRepoForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ref: z
        .string()
        .describe(
          'The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe(
          'An alternative IP for default location auto-detection, such as when proxying a request.'
        )
        .optional()
    })
  export type CodespacesPreFlightWithRepoForAuthenticatedUserParams = z.infer<
    typeof CodespacesPreFlightWithRepoForAuthenticatedUserParamsSchema
  >

  export const CodespacesPreFlightWithRepoForAuthenticatedUserResponseSchema =
    z.object({
      billable_owner: SimpleUserSchema.optional(),
      defaults: z
        .object({ location: z.string(), devcontainer_path: z.string() })
        .optional()
    })
  export type CodespacesPreFlightWithRepoForAuthenticatedUserResponse = z.infer<
    typeof CodespacesPreFlightWithRepoForAuthenticatedUserResponseSchema
  >

  export const CodespacesCheckPermissionsForDevcontainerParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ref: z
        .string()
        .describe(
          'The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
        ),
      devcontainer_path: z
        .string()
        .describe(
          'Path to the devcontainer.json configuration to use for the permission check.'
        )
    }
  )
  export type CodespacesCheckPermissionsForDevcontainerParams = z.infer<
    typeof CodespacesCheckPermissionsForDevcontainerParamsSchema
  >

  export const CodespacesCheckPermissionsForDevcontainerResponseSchema =
    CodespacesPermissionsCheckForDevcontainerSchema
  export type CodespacesCheckPermissionsForDevcontainerResponse = z.infer<
    typeof CodespacesCheckPermissionsForDevcontainerResponseSchema
  >

  export const CodespacesListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListRepoSecretsParams = z.infer<
    typeof CodespacesListRepoSecretsParamsSchema
  >

  export const CodespacesListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(RepoCodespacesSecretSchema)
  })
  export type CodespacesListRepoSecretsResponse = z.infer<
    typeof CodespacesListRepoSecretsResponseSchema
  >

  export const CodespacesGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodespacesGetRepoPublicKeyParams = z.infer<
    typeof CodespacesGetRepoPublicKeyParamsSchema
  >

  export const CodespacesGetRepoPublicKeyResponseSchema =
    CodespacesPublicKeySchema
  export type CodespacesGetRepoPublicKeyResponse = z.infer<
    typeof CodespacesGetRepoPublicKeyResponseSchema
  >

  export const CodespacesGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetRepoSecretParams = z.infer<
    typeof CodespacesGetRepoSecretParamsSchema
  >

  export const CodespacesGetRepoSecretResponseSchema =
    RepoCodespacesSecretSchema
  export type CodespacesGetRepoSecretResponse = z.infer<
    typeof CodespacesGetRepoSecretResponseSchema
  >

  export const CodespacesCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesCreateOrUpdateRepoSecretParams = z.infer<
    typeof CodespacesCreateOrUpdateRepoSecretParamsSchema
  >

  export type CodespacesCreateOrUpdateRepoSecretResponse = undefined

  export const CodespacesDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesDeleteRepoSecretParams = z.infer<
    typeof CodespacesDeleteRepoSecretParamsSchema
  >

  export type CodespacesDeleteRepoSecretResponse = undefined

  export const ReposListCollaboratorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    affiliation: z
      .enum(['outside', 'direct', 'all'])
      .describe(
        'Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.'
      )
      .default('all'),
    permission: z
      .enum(['pull', 'triage', 'push', 'maintain', 'admin'])
      .describe(
        'Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCollaboratorsParams = z.infer<
    typeof ReposListCollaboratorsParamsSchema
  >

  export const ReposListCollaboratorsResponseSchema =
    z.array(CollaboratorSchema)
  export type ReposListCollaboratorsResponse = z.infer<
    typeof ReposListCollaboratorsResponseSchema
  >

  export const ReposCheckCollaboratorParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposCheckCollaboratorParams = z.infer<
    typeof ReposCheckCollaboratorParamsSchema
  >

  export type ReposCheckCollaboratorResponse = undefined

  export const ReposAddCollaboratorParamsSchema = z.object({
    permission: z
      .string()
      .describe(
        'The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.'
      )
      .default('push'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposAddCollaboratorParams = z.infer<
    typeof ReposAddCollaboratorParamsSchema
  >

  export type ReposAddCollaboratorResponse = undefined

  export const ReposRemoveCollaboratorParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposRemoveCollaboratorParams = z.infer<
    typeof ReposRemoveCollaboratorParamsSchema
  >

  export type ReposRemoveCollaboratorResponse = undefined

  export const ReposGetCollaboratorPermissionLevelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposGetCollaboratorPermissionLevelParams = z.infer<
    typeof ReposGetCollaboratorPermissionLevelParamsSchema
  >

  export const ReposGetCollaboratorPermissionLevelResponseSchema =
    RepositoryCollaboratorPermissionSchema
  export type ReposGetCollaboratorPermissionLevelResponse = z.infer<
    typeof ReposGetCollaboratorPermissionLevelResponseSchema
  >

  export const ReposListCommitCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitCommentsForRepoParams = z.infer<
    typeof ReposListCommitCommentsForRepoParamsSchema
  >

  export const ReposListCommitCommentsForRepoResponseSchema =
    z.array(CommitCommentSchema)
  export type ReposListCommitCommentsForRepoResponse = z.infer<
    typeof ReposListCommitCommentsForRepoResponseSchema
  >

  export const ReposGetCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposGetCommitCommentParams = z.infer<
    typeof ReposGetCommitCommentParamsSchema
  >

  export const ReposGetCommitCommentResponseSchema = CommitCommentSchema
  export type ReposGetCommitCommentResponse = z.infer<
    typeof ReposGetCommitCommentResponseSchema
  >

  export const ReposDeleteCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposDeleteCommitCommentParams = z.infer<
    typeof ReposDeleteCommitCommentParamsSchema
  >

  export type ReposDeleteCommitCommentResponse = undefined

  export const ReposUpdateCommitCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposUpdateCommitCommentParams = z.infer<
    typeof ReposUpdateCommitCommentParamsSchema
  >

  export const ReposUpdateCommitCommentResponseSchema = CommitCommentSchema
  export type ReposUpdateCommitCommentResponse = z.infer<
    typeof ReposUpdateCommitCommentResponseSchema
  >

  export const ReactionsListForCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForCommitCommentParams = z.infer<
    typeof ReactionsListForCommitCommentParamsSchema
  >

  export const ReactionsListForCommitCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForCommitCommentResponse = z.infer<
    typeof ReactionsListForCommitCommentResponseSchema
  >

  export const ReactionsCreateForCommitCommentParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReactionsCreateForCommitCommentParams = z.infer<
    typeof ReactionsCreateForCommitCommentParamsSchema
  >

  export const ReactionsCreateForCommitCommentResponseSchema = ReactionSchema
  export type ReactionsCreateForCommitCommentResponse = z.infer<
    typeof ReactionsCreateForCommitCommentResponseSchema
  >

  export const ReactionsDeleteForCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForCommitCommentParams = z.infer<
    typeof ReactionsDeleteForCommitCommentParamsSchema
  >

  export type ReactionsDeleteForCommitCommentResponse = undefined

  export const ReposListCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z
      .string()
      .describe(
        'SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).'
      )
      .optional(),
    path: z
      .string()
      .describe('Only commits containing this file path will be returned.')
      .optional(),
    author: z
      .string()
      .describe(
        'GitHub username or email address to use to filter by commit author.'
      )
      .optional(),
    committer: z
      .string()
      .describe(
        'GitHub username or email address to use to filter by commit committer.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.'
      )
      .optional(),
    until: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitsParams = z.infer<
    typeof ReposListCommitsParamsSchema
  >

  export const ReposListCommitsResponseSchema = z.array(CommitSchema)
  export type ReposListCommitsResponse = z.infer<
    typeof ReposListCommitsResponseSchema
  >

  export const ReposListBranchesForHeadCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type ReposListBranchesForHeadCommitParams = z.infer<
    typeof ReposListBranchesForHeadCommitParamsSchema
  >

  export const ReposListBranchesForHeadCommitResponseSchema =
    z.array(BranchShortSchema)
  export type ReposListBranchesForHeadCommitResponse = z.infer<
    typeof ReposListBranchesForHeadCommitResponseSchema
  >

  export const ReposListCommentsForCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommentsForCommitParams = z.infer<
    typeof ReposListCommentsForCommitParamsSchema
  >

  export const ReposListCommentsForCommitResponseSchema =
    z.array(CommitCommentSchema)
  export type ReposListCommentsForCommitResponse = z.infer<
    typeof ReposListCommentsForCommitResponseSchema
  >

  export const ReposCreateCommitCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    path: z
      .string()
      .describe('Relative path of the file to comment on.')
      .optional(),
    position: z
      .number()
      .int()
      .describe('Line index in the diff to comment on.')
      .optional(),
    line: z
      .number()
      .int()
      .describe(
        '**Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type ReposCreateCommitCommentParams = z.infer<
    typeof ReposCreateCommitCommentParamsSchema
  >

  export type ReposCreateCommitCommentResponse = undefined

  export const ReposListPullRequestsAssociatedWithCommitParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      commit_sha: z.string().describe('The SHA of the commit.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ReposListPullRequestsAssociatedWithCommitParams = z.infer<
    typeof ReposListPullRequestsAssociatedWithCommitParamsSchema
  >

  export const ReposListPullRequestsAssociatedWithCommitResponseSchema =
    z.array(PullRequestSimpleSchema)
  export type ReposListPullRequestsAssociatedWithCommitResponse = z.infer<
    typeof ReposListPullRequestsAssociatedWithCommitResponseSchema
  >

  export const ReposGetCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposGetCommitParams = z.infer<typeof ReposGetCommitParamsSchema>

  export const ReposGetCommitResponseSchema = CommitSchema
  export type ReposGetCommitResponse = z.infer<
    typeof ReposGetCommitResponseSchema
  >

  export const ChecksListForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    status: z
      .enum(['queued', 'in_progress', 'completed'])
      .describe('Returns check runs with the specified `status`.')
      .optional(),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    app_id: z.number().int().optional()
  })
  export type ChecksListForRefParams = z.infer<
    typeof ChecksListForRefParamsSchema
  >

  export const ChecksListForRefResponseSchema = z.object({
    total_count: z.number().int(),
    check_runs: z.array(CheckRunSchema)
  })
  export type ChecksListForRefResponse = z.infer<
    typeof ChecksListForRefResponseSchema
  >

  export const ChecksListSuitesForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    app_id: z
      .number()
      .int()
      .describe('Filters check suites by GitHub App `id`.')
      .optional(),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListSuitesForRefParams = z.infer<
    typeof ChecksListSuitesForRefParamsSchema
  >

  export const ChecksListSuitesForRefResponseSchema = z.object({
    total_count: z.number().int(),
    check_suites: z.array(CheckSuiteSchema)
  })
  export type ChecksListSuitesForRefResponse = z.infer<
    typeof ChecksListSuitesForRefResponseSchema
  >

  export const ReposGetCombinedStatusForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetCombinedStatusForRefParams = z.infer<
    typeof ReposGetCombinedStatusForRefParamsSchema
  >

  export const ReposGetCombinedStatusForRefResponseSchema =
    CombinedCommitStatusSchema
  export type ReposGetCombinedStatusForRefResponse = z.infer<
    typeof ReposGetCombinedStatusForRefResponseSchema
  >

  export const ReposListCommitStatusesForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitStatusesForRefParams = z.infer<
    typeof ReposListCommitStatusesForRefParamsSchema
  >

  export const ReposListCommitStatusesForRefResponseSchema =
    z.array(StatusSchema)
  export type ReposListCommitStatusesForRefResponse = z.infer<
    typeof ReposListCommitStatusesForRefResponseSchema
  >

  export const ReposGetCommunityProfileMetricsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCommunityProfileMetricsParams = z.infer<
    typeof ReposGetCommunityProfileMetricsParamsSchema
  >

  export const ReposGetCommunityProfileMetricsResponseSchema =
    CommunityProfileSchema
  export type ReposGetCommunityProfileMetricsResponse = z.infer<
    typeof ReposGetCommunityProfileMetricsResponseSchema
  >

  export const ReposCompareCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    basehead: z
      .string()
      .describe(
        'The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposCompareCommitsParams = z.infer<
    typeof ReposCompareCommitsParamsSchema
  >

  export const ReposCompareCommitsResponseSchema = CommitComparisonSchema
  export type ReposCompareCommitsResponse = z.infer<
    typeof ReposCompareCommitsResponseSchema
  >

  export const ReposGetContentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter'),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetContentParams = z.infer<
    typeof ReposGetContentParamsSchema
  >

  export const ReposGetContentResponseSchema = z.union([
    ContentDirectorySchema,
    ContentFileSchema,
    ContentSymlinkSchema,
    ContentSubmoduleSchema
  ])
  export type ReposGetContentResponse = z.infer<
    typeof ReposGetContentResponseSchema
  >

  export const ReposCreateOrUpdateFileContentsParamsSchema = z.object({
    message: z.string().describe('The commit message.'),
    content: z
      .string()
      .describe('The new file content, using Base64 encoding.'),
    sha: z
      .string()
      .describe(
        '**Required if you are updating a file**. The blob SHA of the file being replaced.'
      )
      .optional(),
    branch: z
      .string()
      .describe('The branch name. Default: the repositorys default branch.')
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe(
            "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
          ),
        email: z
          .string()
          .describe(
            "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
          ),
        date: z.string().optional()
      })
      .describe(
        'The person that committed the file. Default: the authenticated user.'
      )
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe(
            "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
          ),
        email: z
          .string()
          .describe(
            "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
          ),
        date: z.string().optional()
      })
      .describe(
        'The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter')
  })
  export type ReposCreateOrUpdateFileContentsParams = z.infer<
    typeof ReposCreateOrUpdateFileContentsParamsSchema
  >

  export const ReposCreateOrUpdateFileContentsResponseSchema = FileCommitSchema
  export type ReposCreateOrUpdateFileContentsResponse = z.infer<
    typeof ReposCreateOrUpdateFileContentsResponseSchema
  >

  export const ReposDeleteFileParamsSchema = z.object({
    message: z.string().describe('The commit message.'),
    sha: z.string().describe('The blob SHA of the file being deleted.'),
    branch: z
      .string()
      .describe('The branch name. Default: the repositorys default branch')
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional()
      })
      .describe('object containing information about the committer.')
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional()
      })
      .describe('object containing information about the author.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter')
  })
  export type ReposDeleteFileParams = z.infer<
    typeof ReposDeleteFileParamsSchema
  >

  export const ReposDeleteFileResponseSchema = FileCommitSchema
  export type ReposDeleteFileResponse = z.infer<
    typeof ReposDeleteFileResponseSchema
  >

  export const ReposListContributorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    anon: z
      .string()
      .describe(
        'Set to `1` or `true` to include anonymous contributors in results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListContributorsParams = z.infer<
    typeof ReposListContributorsParamsSchema
  >

  export const ReposListContributorsResponseSchema = z.array(ContributorSchema)
  export type ReposListContributorsResponse = z.infer<
    typeof ReposListContributorsResponseSchema
  >

  export const DependabotListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    manifest: z
      .string()
      .describe(
        'A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        '**Closing down notice**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional()
  })
  export type DependabotListAlertsForRepoParams = z.infer<
    typeof DependabotListAlertsForRepoParamsSchema
  >

  export const DependabotListAlertsForRepoResponseSchema = z.array(
    DependabotAlertSchema
  )
  export type DependabotListAlertsForRepoResponse = z.infer<
    typeof DependabotListAlertsForRepoResponseSchema
  >

  export const DependabotGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
      )
  })
  export type DependabotGetAlertParams = z.infer<
    typeof DependabotGetAlertParamsSchema
  >

  export const DependabotGetAlertResponseSchema = DependabotAlertSchema
  export type DependabotGetAlertResponse = z.infer<
    typeof DependabotGetAlertResponseSchema
  >

  export const DependabotUpdateAlertParamsSchema = z.object({
    state: z
      .enum(['dismissed', 'open'])
      .describe(
        'The state of the Dependabot alert.\nA `dismissed_reason` must be provided when setting the state to `dismissed`.'
      ),
    dismissed_reason: z
      .enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
      ])
      .describe(
        '**Required when `state` is `dismissed`.** A reason for dismissing the alert.'
      )
      .optional(),
    dismissed_comment: z
      .string()
      .max(280)
      .describe('An optional comment associated with dismissing the alert.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
      )
  })
  export type DependabotUpdateAlertParams = z.infer<
    typeof DependabotUpdateAlertParamsSchema
  >

  export const DependabotUpdateAlertResponseSchema = DependabotAlertSchema
  export type DependabotUpdateAlertResponse = z.infer<
    typeof DependabotUpdateAlertResponseSchema
  >

  export const DependabotListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type DependabotListRepoSecretsParams = z.infer<
    typeof DependabotListRepoSecretsParamsSchema
  >

  export const DependabotListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(DependabotSecretSchema)
  })
  export type DependabotListRepoSecretsResponse = z.infer<
    typeof DependabotListRepoSecretsResponseSchema
  >

  export const DependabotGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type DependabotGetRepoPublicKeyParams = z.infer<
    typeof DependabotGetRepoPublicKeyParamsSchema
  >

  export const DependabotGetRepoPublicKeyResponseSchema =
    DependabotPublicKeySchema
  export type DependabotGetRepoPublicKeyResponse = z.infer<
    typeof DependabotGetRepoPublicKeyResponseSchema
  >

  export const DependabotGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotGetRepoSecretParams = z.infer<
    typeof DependabotGetRepoSecretParamsSchema
  >

  export const DependabotGetRepoSecretResponseSchema = DependabotSecretSchema
  export type DependabotGetRepoSecretResponse = z.infer<
    typeof DependabotGetRepoSecretResponseSchema
  >

  export const DependabotCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotCreateOrUpdateRepoSecretParams = z.infer<
    typeof DependabotCreateOrUpdateRepoSecretParamsSchema
  >

  export type DependabotCreateOrUpdateRepoSecretResponse = undefined

  export const DependabotDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotDeleteRepoSecretParams = z.infer<
    typeof DependabotDeleteRepoSecretParamsSchema
  >

  export type DependabotDeleteRepoSecretResponse = undefined

  export const DependencyGraphDiffRangeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    basehead: z
      .string()
      .describe(
        'The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.'
      ),
    name: z
      .string()
      .describe(
        'The full path, relative to the repository root, of the dependency manifest file.'
      )
      .optional()
  })
  export type DependencyGraphDiffRangeParams = z.infer<
    typeof DependencyGraphDiffRangeParamsSchema
  >

  export const DependencyGraphDiffRangeResponseSchema =
    DependencyGraphDiffSchema
  export type DependencyGraphDiffRangeResponse = z.infer<
    typeof DependencyGraphDiffRangeResponseSchema
  >

  export const DependencyGraphExportSbomParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type DependencyGraphExportSbomParams = z.infer<
    typeof DependencyGraphExportSbomParamsSchema
  >

  export const DependencyGraphExportSbomResponseSchema =
    DependencyGraphSpdxSbomSchema
  export type DependencyGraphExportSbomResponse = z.infer<
    typeof DependencyGraphExportSbomResponseSchema
  >

  export const DependencyGraphCreateRepositorySnapshotParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(SnapshotSchema)
  export type DependencyGraphCreateRepositorySnapshotParams = z.infer<
    typeof DependencyGraphCreateRepositorySnapshotParamsSchema
  >

  export type DependencyGraphCreateRepositorySnapshotResponse = undefined

  export const ReposListDeploymentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z
      .string()
      .describe('The SHA recorded at creation time.')
      .default('none'),
    ref: z
      .string()
      .describe('The name of the ref. This can be a branch, tag, or SHA.')
      .default('none'),
    task: z
      .string()
      .describe(
        'The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).'
      )
      .default('none'),
    environment: z
      .union([z.string().default('none'), z.null()])
      .describe(
        'The name of the environment that was deployed to (e.g., `staging` or `production`).'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentsParams = z.infer<
    typeof ReposListDeploymentsParamsSchema
  >

  export const ReposListDeploymentsResponseSchema = z.array(DeploymentSchema)
  export type ReposListDeploymentsResponse = z.infer<
    typeof ReposListDeploymentsResponseSchema
  >

  export const ReposCreateDeploymentParamsSchema = z.object({
    ref: z
      .string()
      .describe('The ref to deploy. This can be a branch, tag, or SHA.'),
    task: z
      .string()
      .describe(
        'Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).'
      )
      .default('deploy'),
    auto_merge: z
      .boolean()
      .describe(
        "Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch."
      )
      .default(true),
    required_contexts: z
      .array(z.string())
      .describe(
        'The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.'
      )
      .optional(),
    payload: z
      .union([
        z.record(z.any()),
        z
          .string()
          .describe('JSON payload with extra information about the deployment.')
          .default('')
      ])
      .optional(),
    environment: z
      .string()
      .describe(
        'Name for the target deployment environment (e.g., `production`, `staging`, `qa`).'
      )
      .default('production'),
    description: z
      .string()
      .describe('Short description of the deployment.')
      .default(''),
    transient_environment: z
      .boolean()
      .describe(
        'Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`'
      )
      .default(false),
    production_environment: z
      .boolean()
      .describe(
        'Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeploymentParams = z.infer<
    typeof ReposCreateDeploymentParamsSchema
  >

  export type ReposCreateDeploymentResponse = undefined

  export const ReposGetDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposGetDeploymentParams = z.infer<
    typeof ReposGetDeploymentParamsSchema
  >

  export const ReposGetDeploymentResponseSchema = DeploymentSchema
  export type ReposGetDeploymentResponse = z.infer<
    typeof ReposGetDeploymentResponseSchema
  >

  export const ReposDeleteDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposDeleteDeploymentParams = z.infer<
    typeof ReposDeleteDeploymentParamsSchema
  >

  export type ReposDeleteDeploymentResponse = undefined

  export const ReposListDeploymentStatusesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentStatusesParams = z.infer<
    typeof ReposListDeploymentStatusesParamsSchema
  >

  export const ReposListDeploymentStatusesResponseSchema = z.array(
    DeploymentStatusSchema
  )
  export type ReposListDeploymentStatusesResponse = z.infer<
    typeof ReposListDeploymentStatusesResponseSchema
  >

  export const ReposCreateDeploymentStatusParamsSchema = z.object({
    state: z
      .enum([
        'error',
        'failure',
        'inactive',
        'in_progress',
        'queued',
        'pending',
        'success'
      ])
      .describe(
        'The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.'
      ),
    target_url: z
      .string()
      .describe(
        "The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.\n\n> [!NOTE]\n> It's recommended to use the `log_url` parameter, which replaces `target_url`."
      )
      .default(''),
    log_url: z
      .string()
      .describe(
        'The full URL of the deployment\'s output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`'
      )
      .default(''),
    description: z
      .string()
      .describe(
        'A short description of the status. The maximum description length is 140 characters.'
      )
      .default(''),
    environment: z
      .string()
      .describe(
        'Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.'
      )
      .optional(),
    environment_url: z
      .string()
      .describe('Sets the URL for accessing your environment. Default: `""`')
      .default(''),
    auto_inactive: z
      .boolean()
      .describe(
        "Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`"
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposCreateDeploymentStatusParams = z.infer<
    typeof ReposCreateDeploymentStatusParamsSchema
  >

  export type ReposCreateDeploymentStatusResponse = undefined

  export const ReposGetDeploymentStatusParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter'),
    status_id: z.number().int()
  })
  export type ReposGetDeploymentStatusParams = z.infer<
    typeof ReposGetDeploymentStatusParamsSchema
  >

  export const ReposGetDeploymentStatusResponseSchema = DeploymentStatusSchema
  export type ReposGetDeploymentStatusResponse = z.infer<
    typeof ReposGetDeploymentStatusResponseSchema
  >

  export const ReposCreateDispatchEventParamsSchema = z.object({
    event_type: z
      .string()
      .min(1)
      .max(100)
      .describe(
        'A custom webhook event name. Must be 100 characters or fewer.'
      ),
    client_payload: z
      .record(z.any())
      .describe(
        'JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDispatchEventParams = z.infer<
    typeof ReposCreateDispatchEventParamsSchema
  >

  export type ReposCreateDispatchEventResponse = undefined

  export const ReposGetAllEnvironmentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetAllEnvironmentsParams = z.infer<
    typeof ReposGetAllEnvironmentsParamsSchema
  >

  export const ReposGetAllEnvironmentsResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe('The number of environments in this repository')
      .optional(),
    environments: z.array(EnvironmentSchema).optional()
  })
  export type ReposGetAllEnvironmentsResponse = z.infer<
    typeof ReposGetAllEnvironmentsResponseSchema
  >

  export const ReposGetEnvironmentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposGetEnvironmentParams = z.infer<
    typeof ReposGetEnvironmentParamsSchema
  >

  export const ReposGetEnvironmentResponseSchema = EnvironmentSchema
  export type ReposGetEnvironmentResponse = z.infer<
    typeof ReposGetEnvironmentResponseSchema
  >

  export const ReposCreateOrUpdateEnvironmentParamsSchema = z.object({
    wait_timer: WaitTimerSchema.optional(),
    prevent_self_review: PreventSelfReviewSchema.optional(),
    reviewers: z
      .array(
        z.object({
          type: DeploymentReviewerTypeSchema.optional(),
          id: z
            .number()
            .int()
            .describe(
              'The id of the user or team who can review the deployment'
            )
            .optional()
        })
      )
      .describe(
        'The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
      )
      .optional(),
    deployment_branch_policy: DeploymentBranchPolicySettingsSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposCreateOrUpdateEnvironmentParams = z.infer<
    typeof ReposCreateOrUpdateEnvironmentParamsSchema
  >

  export const ReposCreateOrUpdateEnvironmentResponseSchema = EnvironmentSchema
  export type ReposCreateOrUpdateEnvironmentResponse = z.infer<
    typeof ReposCreateOrUpdateEnvironmentResponseSchema
  >

  export const ReposDeleteAnEnvironmentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposDeleteAnEnvironmentParams = z.infer<
    typeof ReposDeleteAnEnvironmentParamsSchema
  >

  export type ReposDeleteAnEnvironmentResponse = undefined

  export const ReposListDeploymentBranchPoliciesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentBranchPoliciesParams = z.infer<
    typeof ReposListDeploymentBranchPoliciesParamsSchema
  >

  export const ReposListDeploymentBranchPoliciesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The number of deployment branch policies for the environment.'
      ),
    branch_policies: z.array(DeploymentBranchPolicySchema)
  })
  export type ReposListDeploymentBranchPoliciesResponse = z.infer<
    typeof ReposListDeploymentBranchPoliciesResponseSchema
  >

  export const ReposCreateDeploymentBranchPolicyParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        )
    })
    .merge(DeploymentBranchPolicyNamePatternWithTypeSchema)
  export type ReposCreateDeploymentBranchPolicyParams = z.infer<
    typeof ReposCreateDeploymentBranchPolicyParamsSchema
  >

  export const ReposCreateDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposCreateDeploymentBranchPolicyResponse = z.infer<
    typeof ReposCreateDeploymentBranchPolicyResponseSchema
  >

  export const ReposGetDeploymentBranchPolicyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    branch_policy_id: z
      .number()
      .int()
      .describe('The unique identifier of the branch policy.')
  })
  export type ReposGetDeploymentBranchPolicyParams = z.infer<
    typeof ReposGetDeploymentBranchPolicyParamsSchema
  >

  export const ReposGetDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposGetDeploymentBranchPolicyResponse = z.infer<
    typeof ReposGetDeploymentBranchPolicyResponseSchema
  >

  export const ReposUpdateDeploymentBranchPolicyParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        ),
      branch_policy_id: z
        .number()
        .int()
        .describe('The unique identifier of the branch policy.')
    })
    .merge(DeploymentBranchPolicyNamePatternSchema)
  export type ReposUpdateDeploymentBranchPolicyParams = z.infer<
    typeof ReposUpdateDeploymentBranchPolicyParamsSchema
  >

  export const ReposUpdateDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposUpdateDeploymentBranchPolicyResponse = z.infer<
    typeof ReposUpdateDeploymentBranchPolicyResponseSchema
  >

  export const ReposDeleteDeploymentBranchPolicyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    branch_policy_id: z
      .number()
      .int()
      .describe('The unique identifier of the branch policy.')
  })
  export type ReposDeleteDeploymentBranchPolicyParams = z.infer<
    typeof ReposDeleteDeploymentBranchPolicyParamsSchema
  >

  export type ReposDeleteDeploymentBranchPolicyResponse = undefined

  export const ReposGetAllDeploymentProtectionRulesParamsSchema = z.object({
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      )
  })
  export type ReposGetAllDeploymentProtectionRulesParams = z.infer<
    typeof ReposGetAllDeploymentProtectionRulesParamsSchema
  >

  export const ReposGetAllDeploymentProtectionRulesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The number of enabled custom deployment protection rules for this environment'
      )
      .optional(),
    custom_deployment_protection_rules: z
      .array(DeploymentProtectionRuleSchema)
      .optional()
  })
  export type ReposGetAllDeploymentProtectionRulesResponse = z.infer<
    typeof ReposGetAllDeploymentProtectionRulesResponseSchema
  >

  export const ReposCreateDeploymentProtectionRuleParamsSchema = z.object({
    integration_id: z
      .number()
      .int()
      .describe(
        'The ID of the custom app that will be enabled on the environment.'
      )
      .optional(),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeploymentProtectionRuleParams = z.infer<
    typeof ReposCreateDeploymentProtectionRuleParamsSchema
  >

  export type ReposCreateDeploymentProtectionRuleResponse = undefined

  export const ReposListCustomDeploymentRuleIntegrationsParamsSchema = z.object(
    {
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    }
  )
  export type ReposListCustomDeploymentRuleIntegrationsParams = z.infer<
    typeof ReposListCustomDeploymentRuleIntegrationsParamsSchema
  >

  export const ReposListCustomDeploymentRuleIntegrationsResponseSchema =
    z.object({
      total_count: z
        .number()
        .int()
        .describe(
          'The total number of custom deployment protection rule integrations available for this environment.'
        )
        .optional(),
      available_custom_deployment_protection_rule_integrations: z
        .array(CustomDeploymentRuleAppSchema)
        .optional()
    })
  export type ReposListCustomDeploymentRuleIntegrationsResponse = z.infer<
    typeof ReposListCustomDeploymentRuleIntegrationsResponseSchema
  >

  export const ReposGetCustomDeploymentProtectionRuleParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    protection_rule_id: z
      .number()
      .int()
      .describe('The unique identifier of the protection rule.')
  })
  export type ReposGetCustomDeploymentProtectionRuleParams = z.infer<
    typeof ReposGetCustomDeploymentProtectionRuleParamsSchema
  >

  export const ReposGetCustomDeploymentProtectionRuleResponseSchema =
    DeploymentProtectionRuleSchema
  export type ReposGetCustomDeploymentProtectionRuleResponse = z.infer<
    typeof ReposGetCustomDeploymentProtectionRuleResponseSchema
  >

  export const ReposDisableDeploymentProtectionRuleParamsSchema = z.object({
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    protection_rule_id: z
      .number()
      .int()
      .describe('The unique identifier of the protection rule.')
  })
  export type ReposDisableDeploymentProtectionRuleParams = z.infer<
    typeof ReposDisableDeploymentProtectionRuleParamsSchema
  >

  export type ReposDisableDeploymentProtectionRuleResponse = undefined

  export const ActionsListEnvironmentSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListEnvironmentSecretsParams = z.infer<
    typeof ActionsListEnvironmentSecretsParamsSchema
  >

  export const ActionsListEnvironmentSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListEnvironmentSecretsResponse = z.infer<
    typeof ActionsListEnvironmentSecretsResponseSchema
  >

  export const ActionsGetEnvironmentPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsGetEnvironmentPublicKeyParams = z.infer<
    typeof ActionsGetEnvironmentPublicKeyParamsSchema
  >

  export const ActionsGetEnvironmentPublicKeyResponseSchema =
    ActionsPublicKeySchema
  export type ActionsGetEnvironmentPublicKeyResponse = z.infer<
    typeof ActionsGetEnvironmentPublicKeyResponseSchema
  >

  export const ActionsGetEnvironmentSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetEnvironmentSecretParams = z.infer<
    typeof ActionsGetEnvironmentSecretParamsSchema
  >

  export const ActionsGetEnvironmentSecretResponseSchema = ActionsSecretSchema
  export type ActionsGetEnvironmentSecretResponse = z.infer<
    typeof ActionsGetEnvironmentSecretResponseSchema
  >

  export const ActionsCreateOrUpdateEnvironmentSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateEnvironmentSecretParams = z.infer<
    typeof ActionsCreateOrUpdateEnvironmentSecretParamsSchema
  >

  export type ActionsCreateOrUpdateEnvironmentSecretResponse = undefined

  export const ActionsDeleteEnvironmentSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteEnvironmentSecretParams = z.infer<
    typeof ActionsDeleteEnvironmentSecretParamsSchema
  >

  export type ActionsDeleteEnvironmentSecretResponse = undefined

  export const ActionsListEnvironmentVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListEnvironmentVariablesParams = z.infer<
    typeof ActionsListEnvironmentVariablesParamsSchema
  >

  export const ActionsListEnvironmentVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListEnvironmentVariablesResponse = z.infer<
    typeof ActionsListEnvironmentVariablesResponseSchema
  >

  export const ActionsCreateEnvironmentVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsCreateEnvironmentVariableParams = z.infer<
    typeof ActionsCreateEnvironmentVariableParamsSchema
  >

  export type ActionsCreateEnvironmentVariableResponse = undefined

  export const ActionsGetEnvironmentVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetEnvironmentVariableParams = z.infer<
    typeof ActionsGetEnvironmentVariableParamsSchema
  >

  export const ActionsGetEnvironmentVariableResponseSchema =
    ActionsVariableSchema
  export type ActionsGetEnvironmentVariableResponse = z.infer<
    typeof ActionsGetEnvironmentVariableResponseSchema
  >

  export const ActionsDeleteEnvironmentVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.'),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsDeleteEnvironmentVariableParams = z.infer<
    typeof ActionsDeleteEnvironmentVariableParamsSchema
  >

  export type ActionsDeleteEnvironmentVariableResponse = undefined

  export const ActionsUpdateEnvironmentVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsUpdateEnvironmentVariableParams = z.infer<
    typeof ActionsUpdateEnvironmentVariableParamsSchema
  >

  export type ActionsUpdateEnvironmentVariableResponse = undefined

  export const ActivityListRepoEventsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListRepoEventsParams = z.infer<
    typeof ActivityListRepoEventsParamsSchema
  >

  export const ActivityListRepoEventsResponseSchema = z.array(EventSchema)
  export type ActivityListRepoEventsResponse = z.infer<
    typeof ActivityListRepoEventsResponseSchema
  >

  export const ReposListForksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z
      .enum(['newest', 'oldest', 'stargazers', 'watchers'])
      .describe('The sort order. `stargazers` will sort by star count.')
      .default('newest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForksParams = z.infer<typeof ReposListForksParamsSchema>

  export const ReposListForksResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForksResponse = z.infer<
    typeof ReposListForksResponseSchema
  >

  export const ReposCreateForkParamsSchema = z.object({
    organization: z
      .string()
      .describe(
        'Optional parameter to specify the organization name if forking into an organization.'
      )
      .optional(),
    name: z
      .string()
      .describe(
        'When forking from an existing repository, a new name for the fork.'
      )
      .optional(),
    default_branch_only: z
      .boolean()
      .describe(
        'When forking from an existing repository, fork with only the default branch.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateForkParams = z.infer<
    typeof ReposCreateForkParamsSchema
  >

  export type ReposCreateForkResponse = undefined

  export const GitCreateBlobParamsSchema = z.object({
    content: z.string().describe("The new blob's content."),
    encoding: z
      .string()
      .describe(
        'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
      )
      .default('utf-8'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateBlobParams = z.infer<typeof GitCreateBlobParamsSchema>

  export type GitCreateBlobResponse = undefined

  export const GitGetBlobParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    file_sha: z.string()
  })
  export type GitGetBlobParams = z.infer<typeof GitGetBlobParamsSchema>

  export const GitGetBlobResponseSchema = BlobSchema
  export type GitGetBlobResponse = z.infer<typeof GitGetBlobResponseSchema>

  export const GitCreateCommitParamsSchema = z.object({
    message: z.string().describe('The commit message'),
    tree: z
      .string()
      .describe('The SHA of the tree object this commit points to'),
    parents: z
      .array(z.string())
      .describe(
        'The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.'
      )
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit'),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit'),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.'
      )
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional(),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.'
      )
      .optional(),
    signature: z
      .string()
      .describe(
        'The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateCommitParams = z.infer<
    typeof GitCreateCommitParamsSchema
  >

  export type GitCreateCommitResponse = undefined

  export const GitGetCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type GitGetCommitParams = z.infer<typeof GitGetCommitParamsSchema>

  export const GitGetCommitResponseSchema = GitCommitSchema
  export type GitGetCommitResponse = z.infer<typeof GitGetCommitResponseSchema>

  export const GitListMatchingRefsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitListMatchingRefsParams = z.infer<
    typeof GitListMatchingRefsParamsSchema
  >

  export const GitListMatchingRefsResponseSchema = z.array(GitRefSchema)
  export type GitListMatchingRefsResponse = z.infer<
    typeof GitListMatchingRefsResponseSchema
  >

  export const GitGetRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitGetRefParams = z.infer<typeof GitGetRefParamsSchema>

  export const GitGetRefResponseSchema = GitRefSchema
  export type GitGetRefResponse = z.infer<typeof GitGetRefResponseSchema>

  export const GitCreateRefParamsSchema = z.object({
    ref: z
      .string()
      .describe(
        "The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
      ),
    sha: z.string().describe('The SHA1 value for this reference.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateRefParams = z.infer<typeof GitCreateRefParamsSchema>

  export type GitCreateRefResponse = undefined

  export const GitDeleteRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitDeleteRefParams = z.infer<typeof GitDeleteRefParamsSchema>

  export type GitDeleteRefResponse = undefined

  export const GitUpdateRefParamsSchema = z.object({
    sha: z.string().describe('The SHA1 value to set this reference to'),
    force: z
      .boolean()
      .describe(
        "Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work."
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitUpdateRefParams = z.infer<typeof GitUpdateRefParamsSchema>

  export const GitUpdateRefResponseSchema = GitRefSchema
  export type GitUpdateRefResponse = z.infer<typeof GitUpdateRefResponseSchema>

  export const GitCreateTagParamsSchema = z.object({
    tag: z
      .string()
      .describe(
        'The tag\'s name. This is typically a version (e.g., "v0.0.1").'
      ),
    message: z.string().describe('The tag message.'),
    object: z.string().describe('The SHA of the git object this is tagging.'),
    type: z
      .enum(['commit', 'tree', 'blob'])
      .describe(
        "The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`."
      ),
    tagger: z
      .object({
        name: z.string().describe('The name of the author of the tag'),
        email: z.string().describe('The email of the author of the tag'),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'An object with information about the individual creating the tag.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateTagParams = z.infer<typeof GitCreateTagParamsSchema>

  export type GitCreateTagResponse = undefined

  export const GitGetTagParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag_sha: z.string()
  })
  export type GitGetTagParams = z.infer<typeof GitGetTagParamsSchema>

  export const GitGetTagResponseSchema = GitTagSchema
  export type GitGetTagResponse = z.infer<typeof GitGetTagResponseSchema>

  export const GitCreateTreeParamsSchema = z.object({
    tree: z
      .array(
        z.object({
          path: z
            .string()
            .describe('The file referenced in the tree.')
            .optional(),
          mode: z
            .enum(['100644', '100755', '040000', '160000', '120000'])
            .describe(
              'The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.'
            )
            .optional(),
          type: z
            .enum(['blob', 'tree', 'commit'])
            .describe('Either `blob`, `tree`, or `commit`.')
            .optional(),
          sha: z
            .string()
            .describe(
              'The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
            )
            .optional(),
          content: z
            .string()
            .describe(
              'The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
            )
            .optional()
        })
      )
      .describe(
        'Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.'
      ),
    base_tree: z
      .string()
      .describe(
        "The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateTreeParams = z.infer<typeof GitCreateTreeParamsSchema>

  export type GitCreateTreeResponse = undefined

  export const GitGetTreeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tree_sha: z
      .string()
      .describe('The SHA1 value or ref (branch or tag) name of the tree.'),
    recursive: z
      .string()
      .describe(
        'Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.'
      )
      .optional()
  })
  export type GitGetTreeParams = z.infer<typeof GitGetTreeParamsSchema>

  export const GitGetTreeResponseSchema = GitTreeSchema
  export type GitGetTreeResponse = z.infer<typeof GitGetTreeResponseSchema>

  export const ReposListWebhooksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListWebhooksParams = z.infer<
    typeof ReposListWebhooksParamsSchema
  >

  export const ReposListWebhooksResponseSchema = z.array(HookSchema)
  export type ReposListWebhooksResponse = z.infer<
    typeof ReposListWebhooksResponseSchema
  >

  export const ReposCreateWebhookParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.'
      )
      .optional(),
    config: z
      .object({
        url: WebhookConfigUrlSchema.optional(),
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.')
      .optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateWebhookParams = z.infer<
    typeof ReposCreateWebhookParamsSchema
  >

  export type ReposCreateWebhookResponse = undefined

  export const ReposGetWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposGetWebhookParams = z.infer<
    typeof ReposGetWebhookParamsSchema
  >

  export const ReposGetWebhookResponseSchema = HookSchema
  export type ReposGetWebhookResponse = z.infer<
    typeof ReposGetWebhookResponseSchema
  >

  export const ReposDeleteWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposDeleteWebhookParams = z.infer<
    typeof ReposDeleteWebhookParamsSchema
  >

  export type ReposDeleteWebhookResponse = undefined

  export const ReposUpdateWebhookParamsSchema = z.object({
    config: WebhookConfigSchema.optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.'
      )
      .default(['push']),
    add_events: z
      .array(z.string())
      .describe(
        'Determines a list of events to be added to the list of events that the Hook triggers for.'
      )
      .optional(),
    remove_events: z
      .array(z.string())
      .describe(
        'Determines a list of events to be removed from the list of events that the Hook triggers for.'
      )
      .optional(),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposUpdateWebhookParams = z.infer<
    typeof ReposUpdateWebhookParamsSchema
  >

  export const ReposUpdateWebhookResponseSchema = HookSchema
  export type ReposUpdateWebhookResponse = z.infer<
    typeof ReposUpdateWebhookResponseSchema
  >

  export const ReposGetWebhookConfigForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposGetWebhookConfigForRepoParams = z.infer<
    typeof ReposGetWebhookConfigForRepoParamsSchema
  >

  export const ReposGetWebhookConfigForRepoResponseSchema = WebhookConfigSchema
  export type ReposGetWebhookConfigForRepoResponse = z.infer<
    typeof ReposGetWebhookConfigForRepoResponseSchema
  >

  export const ReposUpdateWebhookConfigForRepoParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposUpdateWebhookConfigForRepoParams = z.infer<
    typeof ReposUpdateWebhookConfigForRepoParamsSchema
  >

  export const ReposUpdateWebhookConfigForRepoResponseSchema =
    WebhookConfigSchema
  export type ReposUpdateWebhookConfigForRepoResponse = z.infer<
    typeof ReposUpdateWebhookConfigForRepoResponseSchema
  >

  export const ReposListWebhookDeliveriesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type ReposListWebhookDeliveriesParams = z.infer<
    typeof ReposListWebhookDeliveriesParamsSchema
  >

  export const ReposListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type ReposListWebhookDeliveriesResponse = z.infer<
    typeof ReposListWebhookDeliveriesResponseSchema
  >

  export const ReposGetWebhookDeliveryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type ReposGetWebhookDeliveryParams = z.infer<
    typeof ReposGetWebhookDeliveryParamsSchema
  >

  export const ReposGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type ReposGetWebhookDeliveryResponse = z.infer<
    typeof ReposGetWebhookDeliveryResponseSchema
  >

  export const ReposRedeliverWebhookDeliveryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type ReposRedeliverWebhookDeliveryParams = z.infer<
    typeof ReposRedeliverWebhookDeliveryParamsSchema
  >

  export type ReposRedeliverWebhookDeliveryResponse = undefined

  export const ReposPingWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposPingWebhookParams = z.infer<
    typeof ReposPingWebhookParamsSchema
  >

  export type ReposPingWebhookResponse = undefined

  export const ReposTestPushWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposTestPushWebhookParams = z.infer<
    typeof ReposTestPushWebhookParamsSchema
  >

  export type ReposTestPushWebhookResponse = undefined

  export const MigrationsGetImportStatusParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsGetImportStatusParams = z.infer<
    typeof MigrationsGetImportStatusParamsSchema
  >

  export const MigrationsGetImportStatusResponseSchema = ImportSchema
  export type MigrationsGetImportStatusResponse = z.infer<
    typeof MigrationsGetImportStatusResponseSchema
  >

  export const MigrationsStartImportParamsSchema = z.object({
    vcs_url: z.string().describe('The URL of the originating repository.'),
    vcs: z
      .enum(['subversion', 'git', 'mercurial', 'tfvc'])
      .describe(
        'The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.'
      )
      .optional(),
    vcs_username: z
      .string()
      .describe(
        'If authentication is required, the username to provide to `vcs_url`.'
      )
      .optional(),
    vcs_password: z
      .string()
      .describe(
        'If authentication is required, the password to provide to `vcs_url`.'
      )
      .optional(),
    tfvc_project: z
      .string()
      .describe(
        'For a tfvc import, the name of the project that is being imported.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsStartImportParams = z.infer<
    typeof MigrationsStartImportParamsSchema
  >

  export type MigrationsStartImportResponse = undefined

  export const MigrationsCancelImportParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsCancelImportParams = z.infer<
    typeof MigrationsCancelImportParamsSchema
  >

  export type MigrationsCancelImportResponse = undefined

  export const MigrationsUpdateImportParamsSchema = z.object({
    vcs_username: z
      .string()
      .describe('The username to provide to the originating repository.')
      .optional(),
    vcs_password: z
      .string()
      .describe('The password to provide to the originating repository.')
      .optional(),
    vcs: z
      .enum(['subversion', 'tfvc', 'git', 'mercurial'])
      .describe('The type of version control system you are migrating from.')
      .optional(),
    tfvc_project: z
      .string()
      .describe(
        'For a tfvc import, the name of the project that is being imported.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsUpdateImportParams = z.infer<
    typeof MigrationsUpdateImportParamsSchema
  >

  export const MigrationsUpdateImportResponseSchema = ImportSchema
  export type MigrationsUpdateImportResponse = z.infer<
    typeof MigrationsUpdateImportResponseSchema
  >

  export const MigrationsGetCommitAuthorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    since: z
      .number()
      .int()
      .describe('A user ID. Only return users with an ID greater than this ID.')
      .optional()
  })
  export type MigrationsGetCommitAuthorsParams = z.infer<
    typeof MigrationsGetCommitAuthorsParamsSchema
  >

  export const MigrationsGetCommitAuthorsResponseSchema =
    z.array(PorterAuthorSchema)
  export type MigrationsGetCommitAuthorsResponse = z.infer<
    typeof MigrationsGetCommitAuthorsResponseSchema
  >

  export const MigrationsMapCommitAuthorParamsSchema = z.object({
    email: z.string().describe('The new Git author email.').optional(),
    name: z.string().describe('The new Git author name.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    author_id: z.number().int()
  })
  export type MigrationsMapCommitAuthorParams = z.infer<
    typeof MigrationsMapCommitAuthorParamsSchema
  >

  export const MigrationsMapCommitAuthorResponseSchema = PorterAuthorSchema
  export type MigrationsMapCommitAuthorResponse = z.infer<
    typeof MigrationsMapCommitAuthorResponseSchema
  >

  export const MigrationsGetLargeFilesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsGetLargeFilesParams = z.infer<
    typeof MigrationsGetLargeFilesParamsSchema
  >

  export const MigrationsGetLargeFilesResponseSchema = z.array(
    PorterLargeFileSchema
  )
  export type MigrationsGetLargeFilesResponse = z.infer<
    typeof MigrationsGetLargeFilesResponseSchema
  >

  export const MigrationsSetLfsPreferenceParamsSchema = z.object({
    use_lfs: z
      .enum(['opt_in', 'opt_out'])
      .describe(
        'Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsSetLfsPreferenceParams = z.infer<
    typeof MigrationsSetLfsPreferenceParamsSchema
  >

  export const MigrationsSetLfsPreferenceResponseSchema = ImportSchema
  export type MigrationsSetLfsPreferenceResponse = z.infer<
    typeof MigrationsSetLfsPreferenceResponseSchema
  >

  export const AppsGetRepoInstallationParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type AppsGetRepoInstallationParams = z.infer<
    typeof AppsGetRepoInstallationParamsSchema
  >

  export const AppsGetRepoInstallationResponseSchema = InstallationSchema
  export type AppsGetRepoInstallationResponse = z.infer<
    typeof AppsGetRepoInstallationResponseSchema
  >

  export const InteractionsGetRestrictionsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type InteractionsGetRestrictionsForRepoParams = z.infer<
    typeof InteractionsGetRestrictionsForRepoParamsSchema
  >

  export const InteractionsGetRestrictionsForRepoResponseSchema = z.union([
    InteractionLimitResponseSchema,
    z.object({}).strict()
  ])
  export type InteractionsGetRestrictionsForRepoResponse = z.infer<
    typeof InteractionsGetRestrictionsForRepoResponseSchema
  >

  export const InteractionsSetRestrictionsForRepoParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(InteractionLimitSchema)
  export type InteractionsSetRestrictionsForRepoParams = z.infer<
    typeof InteractionsSetRestrictionsForRepoParamsSchema
  >

  export const InteractionsSetRestrictionsForRepoResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForRepoResponse = z.infer<
    typeof InteractionsSetRestrictionsForRepoResponseSchema
  >

  export const InteractionsRemoveRestrictionsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type InteractionsRemoveRestrictionsForRepoParams = z.infer<
    typeof InteractionsRemoveRestrictionsForRepoParamsSchema
  >

  export type InteractionsRemoveRestrictionsForRepoResponse = undefined

  export const ReposListInvitationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListInvitationsParams = z.infer<
    typeof ReposListInvitationsParamsSchema
  >

  export const ReposListInvitationsResponseSchema = z.array(
    RepositoryInvitationSchema
  )
  export type ReposListInvitationsResponse = z.infer<
    typeof ReposListInvitationsResponseSchema
  >

  export const ReposDeleteInvitationParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type ReposDeleteInvitationParams = z.infer<
    typeof ReposDeleteInvitationParamsSchema
  >

  export type ReposDeleteInvitationResponse = undefined

  export const ReposUpdateInvitationParamsSchema = z.object({
    permissions: z
      .enum(['read', 'write', 'maintain', 'triage', 'admin'])
      .describe(
        'The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type ReposUpdateInvitationParams = z.infer<
    typeof ReposUpdateInvitationParamsSchema
  >

  export const ReposUpdateInvitationResponseSchema = RepositoryInvitationSchema
  export type ReposUpdateInvitationResponse = z.infer<
    typeof ReposUpdateInvitationResponseSchema
  >

  export const IssuesListForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone: z
      .string()
      .describe(
        'If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.'
      )
      .optional(),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    assignee: z
      .string()
      .describe(
        'Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned.'
      )
      .optional(),
    creator: z.string().describe('The user that created the issue.').optional(),
    mentioned: z
      .string()
      .describe("A user that's mentioned in the issue.")
      .optional(),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForRepoParams = z.infer<
    typeof IssuesListForRepoParamsSchema
  >

  export const IssuesListForRepoResponseSchema = z.array(IssueSchema)
  export type IssuesListForRepoResponse = z.infer<
    typeof IssuesListForRepoResponseSchema
  >

  export const IssuesCreateParamsSchema = z.object({
    title: z
      .union([z.string(), z.number().int()])
      .describe('The title of the issue.'),
    body: z.string().describe('The contents of the issue.').optional(),
    assignee: z
      .string()
      .describe(
        'Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_'
      )
      .optional(),
    milestone: z
      .union([
        z.string(),
        z
          .number()
          .int()
          .describe(
            'The `number` of the milestone to associate this issue with. _NOTE: Only users with push access can set the milestone for new issues. The milestone is silently dropped otherwise._'
          )
      ])
      .optional(),
    labels: z
      .array(
        z.union([
          z.string(),
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
            description: z.string().optional(),
            color: z.string().optional()
          })
        ])
      )
      .describe(
        'Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._'
      )
      .optional(),
    assignees: z
      .array(z.string())
      .describe(
        'Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateParams = z.infer<typeof IssuesCreateParamsSchema>

  export type IssuesCreateResponse = undefined

  export const IssuesListCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('Either `asc` or `desc`. Ignored without the `sort` parameter.')
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListCommentsForRepoParams = z.infer<
    typeof IssuesListCommentsForRepoParamsSchema
  >

  export const IssuesListCommentsForRepoResponseSchema =
    z.array(IssueCommentSchema)
  export type IssuesListCommentsForRepoResponse = z.infer<
    typeof IssuesListCommentsForRepoResponseSchema
  >

  export const IssuesGetCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesGetCommentParams = z.infer<
    typeof IssuesGetCommentParamsSchema
  >

  export const IssuesGetCommentResponseSchema = IssueCommentSchema
  export type IssuesGetCommentResponse = z.infer<
    typeof IssuesGetCommentResponseSchema
  >

  export const IssuesDeleteCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesDeleteCommentParams = z.infer<
    typeof IssuesDeleteCommentParamsSchema
  >

  export type IssuesDeleteCommentResponse = undefined

  export const IssuesUpdateCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesUpdateCommentParams = z.infer<
    typeof IssuesUpdateCommentParamsSchema
  >

  export const IssuesUpdateCommentResponseSchema = IssueCommentSchema
  export type IssuesUpdateCommentResponse = z.infer<
    typeof IssuesUpdateCommentResponseSchema
  >

  export const ReactionsListForIssueCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForIssueCommentParams = z.infer<
    typeof ReactionsListForIssueCommentParamsSchema
  >

  export const ReactionsListForIssueCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForIssueCommentResponse = z.infer<
    typeof ReactionsListForIssueCommentResponseSchema
  >

  export const ReactionsCreateForIssueCommentParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReactionsCreateForIssueCommentParams = z.infer<
    typeof ReactionsCreateForIssueCommentParamsSchema
  >

  export const ReactionsCreateForIssueCommentResponseSchema = ReactionSchema
  export type ReactionsCreateForIssueCommentResponse = z.infer<
    typeof ReactionsCreateForIssueCommentResponseSchema
  >

  export const ReactionsDeleteForIssueCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForIssueCommentParams = z.infer<
    typeof ReactionsDeleteForIssueCommentParamsSchema
  >

  export type ReactionsDeleteForIssueCommentResponse = undefined

  export const IssuesListEventsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsForRepoParams = z.infer<
    typeof IssuesListEventsForRepoParamsSchema
  >

  export const IssuesListEventsForRepoResponseSchema = z.array(IssueEventSchema)
  export type IssuesListEventsForRepoResponse = z.infer<
    typeof IssuesListEventsForRepoResponseSchema
  >

  export const IssuesGetEventParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    event_id: z.number().int()
  })
  export type IssuesGetEventParams = z.infer<typeof IssuesGetEventParamsSchema>

  export const IssuesGetEventResponseSchema = IssueEventSchema
  export type IssuesGetEventResponse = z.infer<
    typeof IssuesGetEventResponseSchema
  >

  export const IssuesGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesGetParams = z.infer<typeof IssuesGetParamsSchema>

  export const IssuesGetResponseSchema = IssueSchema
  export type IssuesGetResponse = z.infer<typeof IssuesGetResponseSchema>

  export const IssuesUpdateParamsSchema = z.object({
    title: z
      .union([z.string(), z.number().int()])
      .describe('The title of the issue.')
      .optional(),
    body: z.string().describe('The contents of the issue.').optional(),
    assignee: z
      .string()
      .describe(
        'Username to assign to this issue. **This field is closing down.**'
      )
      .optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('The open or closed state of the issue.')
      .optional(),
    state_reason: z
      .enum(['completed', 'not_planned', 'reopened'])
      .describe(
        'The reason for the state change. Ignored unless `state` is changed.'
      )
      .optional(),
    milestone: z
      .union([
        z.string(),
        z
          .number()
          .int()
          .describe(
            'The `number` of the milestone to associate this issue with or use `null` to remove the current milestone. Only users with push access can set the milestone for issues. Without push access to the repository, milestone changes are silently dropped.'
          )
      ])
      .optional(),
    labels: z
      .array(
        z.union([
          z.string(),
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
            description: z.string().optional(),
            color: z.string().optional()
          })
        ])
      )
      .describe(
        'Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.'
      )
      .optional(),
    assignees: z
      .array(z.string())
      .describe(
        'Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesUpdateParams = z.infer<typeof IssuesUpdateParamsSchema>

  export const IssuesUpdateResponseSchema = IssueSchema
  export type IssuesUpdateResponse = z.infer<typeof IssuesUpdateResponseSchema>

  export const IssuesAddAssigneesParamsSchema = z.object({
    assignees: z
      .array(z.string())
      .describe(
        'Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesAddAssigneesParams = z.infer<
    typeof IssuesAddAssigneesParamsSchema
  >

  export type IssuesAddAssigneesResponse = undefined

  export const IssuesRemoveAssigneesParamsSchema = z.object({
    assignees: z
      .array(z.string())
      .describe(
        'Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveAssigneesParams = z.infer<
    typeof IssuesRemoveAssigneesParamsSchema
  >

  export const IssuesRemoveAssigneesResponseSchema = IssueSchema
  export type IssuesRemoveAssigneesResponse = z.infer<
    typeof IssuesRemoveAssigneesResponseSchema
  >

  export const IssuesCheckUserCanBeAssignedToIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    assignee: z.string()
  })
  export type IssuesCheckUserCanBeAssignedToIssueParams = z.infer<
    typeof IssuesCheckUserCanBeAssignedToIssueParamsSchema
  >

  export type IssuesCheckUserCanBeAssignedToIssueResponse = undefined

  export const IssuesListCommentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListCommentsParams = z.infer<
    typeof IssuesListCommentsParamsSchema
  >

  export const IssuesListCommentsResponseSchema = z.array(IssueCommentSchema)
  export type IssuesListCommentsResponse = z.infer<
    typeof IssuesListCommentsResponseSchema
  >

  export const IssuesCreateCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesCreateCommentParams = z.infer<
    typeof IssuesCreateCommentParamsSchema
  >

  export type IssuesCreateCommentResponse = undefined

  export const IssuesListEventsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsParams = z.infer<
    typeof IssuesListEventsParamsSchema
  >

  export const IssuesListEventsResponseSchema = z.array(
    IssueEventForIssueSchema
  )
  export type IssuesListEventsResponse = z.infer<
    typeof IssuesListEventsResponseSchema
  >

  export const IssuesListLabelsOnIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsOnIssueParams = z.infer<
    typeof IssuesListLabelsOnIssueParamsSchema
  >

  export const IssuesListLabelsOnIssueResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsOnIssueResponse = z.infer<
    typeof IssuesListLabelsOnIssueResponseSchema
  >

  export const IssuesAddLabelsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      issue_number: z
        .number()
        .int()
        .describe('The number that identifies the issue.')
    })
    .and(
      z.union([
        z.object({
          labels: z
            .array(z.string())
            .min(1)
            .describe(
              'The names of the labels to add to the issue\'s existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)."'
            )
            .optional()
        }),
        z.array(z.string()).min(1),
        z.object({
          labels: z
            .array(z.object({ name: z.string() }))
            .min(1)
            .optional()
        }),
        z.array(z.object({ name: z.string() })).min(1),
        z.string()
      ])
    )
  export type IssuesAddLabelsParams = z.infer<
    typeof IssuesAddLabelsParamsSchema
  >

  export const IssuesAddLabelsResponseSchema = z.array(LabelSchema)
  export type IssuesAddLabelsResponse = z.infer<
    typeof IssuesAddLabelsResponseSchema
  >

  export const IssuesSetLabelsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      issue_number: z
        .number()
        .int()
        .describe('The number that identifies the issue.')
    })
    .and(
      z.union([
        z.object({
          labels: z
            .array(z.string())
            .min(1)
            .describe(
              'The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)."'
            )
            .optional()
        }),
        z.array(z.string()).min(1),
        z.object({
          labels: z
            .array(z.object({ name: z.string() }))
            .min(1)
            .optional()
        }),
        z.array(z.object({ name: z.string() })).min(1),
        z.string()
      ])
    )
  export type IssuesSetLabelsParams = z.infer<
    typeof IssuesSetLabelsParamsSchema
  >

  export const IssuesSetLabelsResponseSchema = z.array(LabelSchema)
  export type IssuesSetLabelsResponse = z.infer<
    typeof IssuesSetLabelsResponseSchema
  >

  export const IssuesRemoveAllLabelsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveAllLabelsParams = z.infer<
    typeof IssuesRemoveAllLabelsParamsSchema
  >

  export type IssuesRemoveAllLabelsResponse = undefined

  export const IssuesRemoveLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    name: z.string()
  })
  export type IssuesRemoveLabelParams = z.infer<
    typeof IssuesRemoveLabelParamsSchema
  >

  export const IssuesRemoveLabelResponseSchema = z.array(LabelSchema)
  export type IssuesRemoveLabelResponse = z.infer<
    typeof IssuesRemoveLabelResponseSchema
  >

  export const IssuesLockParamsSchema = z.object({
    lock_reason: z
      .enum(['off-topic', 'too heated', 'resolved', 'spam'])
      .describe(
        "The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  \n * `off-topic`  \n * `too heated`  \n * `resolved`  \n * `spam`"
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesLockParams = z.infer<typeof IssuesLockParamsSchema>

  export type IssuesLockResponse = undefined

  export const IssuesUnlockParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesUnlockParams = z.infer<typeof IssuesUnlockParamsSchema>

  export type IssuesUnlockResponse = undefined

  export const ReactionsListForIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForIssueParams = z.infer<
    typeof ReactionsListForIssueParamsSchema
  >

  export const ReactionsListForIssueResponseSchema = z.array(ReactionSchema)
  export type ReactionsListForIssueResponse = z.infer<
    typeof ReactionsListForIssueResponseSchema
  >

  export const ReactionsCreateForIssueParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type ReactionsCreateForIssueParams = z.infer<
    typeof ReactionsCreateForIssueParamsSchema
  >

  export const ReactionsCreateForIssueResponseSchema = ReactionSchema
  export type ReactionsCreateForIssueResponse = z.infer<
    typeof ReactionsCreateForIssueResponseSchema
  >

  export const ReactionsDeleteForIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForIssueParams = z.infer<
    typeof ReactionsDeleteForIssueParamsSchema
  >

  export type ReactionsDeleteForIssueResponse = undefined

  export const IssuesRemoveSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe('The id of the sub-issue to remove'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveSubIssueParams = z.infer<
    typeof IssuesRemoveSubIssueParamsSchema
  >

  export const IssuesRemoveSubIssueResponseSchema = IssueSchema
  export type IssuesRemoveSubIssueResponse = z.infer<
    typeof IssuesRemoveSubIssueResponseSchema
  >

  export const IssuesListSubIssuesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListSubIssuesParams = z.infer<
    typeof IssuesListSubIssuesParamsSchema
  >

  export const IssuesListSubIssuesResponseSchema = z.array(IssueSchema)
  export type IssuesListSubIssuesResponse = z.infer<
    typeof IssuesListSubIssuesResponseSchema
  >

  export const IssuesAddSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue'
      ),
    replace_parent: z
      .boolean()
      .describe(
        'Option that, when true, instructs the operation to replace the sub-issues current parent issue'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesAddSubIssueParams = z.infer<
    typeof IssuesAddSubIssueParamsSchema
  >

  export type IssuesAddSubIssueResponse = undefined

  export const IssuesReprioritizeSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe('The id of the sub-issue to reprioritize'),
    after_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).'
      )
      .optional(),
    before_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesReprioritizeSubIssueParams = z.infer<
    typeof IssuesReprioritizeSubIssueParamsSchema
  >

  export const IssuesReprioritizeSubIssueResponseSchema = IssueSchema
  export type IssuesReprioritizeSubIssueResponse = z.infer<
    typeof IssuesReprioritizeSubIssueResponseSchema
  >

  export const IssuesListEventsForTimelineParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsForTimelineParams = z.infer<
    typeof IssuesListEventsForTimelineParamsSchema
  >

  export const IssuesListEventsForTimelineResponseSchema = z.array(
    TimelineIssueEventsSchema
  )
  export type IssuesListEventsForTimelineResponse = z.infer<
    typeof IssuesListEventsForTimelineResponseSchema
  >

  export const ReposListDeployKeysParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeployKeysParams = z.infer<
    typeof ReposListDeployKeysParamsSchema
  >

  export const ReposListDeployKeysResponseSchema = z.array(DeployKeySchema)
  export type ReposListDeployKeysResponse = z.infer<
    typeof ReposListDeployKeysResponseSchema
  >

  export const ReposCreateDeployKeyParamsSchema = z.object({
    title: z.string().describe('A name for the key.').optional(),
    key: z.string().describe('The contents of the key.'),
    read_only: z
      .boolean()
      .describe(
        'If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeployKeyParams = z.infer<
    typeof ReposCreateDeployKeyParamsSchema
  >

  export type ReposCreateDeployKeyResponse = undefined

  export const ReposGetDeployKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type ReposGetDeployKeyParams = z.infer<
    typeof ReposGetDeployKeyParamsSchema
  >

  export const ReposGetDeployKeyResponseSchema = DeployKeySchema
  export type ReposGetDeployKeyResponse = z.infer<
    typeof ReposGetDeployKeyResponseSchema
  >

  export const ReposDeleteDeployKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type ReposDeleteDeployKeyParams = z.infer<
    typeof ReposDeleteDeployKeyParamsSchema
  >

  export type ReposDeleteDeployKeyResponse = undefined

  export const IssuesListLabelsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsForRepoParams = z.infer<
    typeof IssuesListLabelsForRepoParamsSchema
  >

  export const IssuesListLabelsForRepoResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsForRepoResponse = z.infer<
    typeof IssuesListLabelsForRepoResponseSchema
  >

  export const IssuesCreateLabelParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
      ),
    color: z
      .string()
      .describe(
        'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
      )
      .optional(),
    description: z
      .string()
      .describe(
        'A short description of the label. Must be 100 characters or fewer.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateLabelParams = z.infer<
    typeof IssuesCreateLabelParamsSchema
  >

  export type IssuesCreateLabelResponse = undefined

  export const IssuesGetLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesGetLabelParams = z.infer<typeof IssuesGetLabelParamsSchema>

  export const IssuesGetLabelResponseSchema = LabelSchema
  export type IssuesGetLabelResponse = z.infer<
    typeof IssuesGetLabelResponseSchema
  >

  export const IssuesDeleteLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesDeleteLabelParams = z.infer<
    typeof IssuesDeleteLabelParamsSchema
  >

  export type IssuesDeleteLabelResponse = undefined

  export const IssuesUpdateLabelParamsSchema = z.object({
    new_name: z
      .string()
      .describe(
        'The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
      )
      .optional(),
    color: z
      .string()
      .describe(
        'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
      )
      .optional(),
    description: z
      .string()
      .describe(
        'A short description of the label. Must be 100 characters or fewer.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesUpdateLabelParams = z.infer<
    typeof IssuesUpdateLabelParamsSchema
  >

  export const IssuesUpdateLabelResponseSchema = LabelSchema
  export type IssuesUpdateLabelResponse = z.infer<
    typeof IssuesUpdateLabelResponseSchema
  >

  export const ReposListLanguagesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListLanguagesParams = z.infer<
    typeof ReposListLanguagesParamsSchema
  >

  export const ReposListLanguagesResponseSchema = LanguageSchema
  export type ReposListLanguagesResponse = z.infer<
    typeof ReposListLanguagesResponseSchema
  >

  export const LicensesGetForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional()
  })
  export type LicensesGetForRepoParams = z.infer<
    typeof LicensesGetForRepoParamsSchema
  >

  export const LicensesGetForRepoResponseSchema = LicenseContentSchema
  export type LicensesGetForRepoResponse = z.infer<
    typeof LicensesGetForRepoResponseSchema
  >

  export const ReposMergeUpstreamParamsSchema = z.object({
    branch: z
      .string()
      .describe(
        'The name of the branch which should be updated to match upstream.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposMergeUpstreamParams = z.infer<
    typeof ReposMergeUpstreamParamsSchema
  >

  export const ReposMergeUpstreamResponseSchema = MergedUpstreamSchema
  export type ReposMergeUpstreamResponse = z.infer<
    typeof ReposMergeUpstreamResponseSchema
  >

  export const ReposMergeParamsSchema = z.object({
    base: z
      .string()
      .describe(
        'The name of the base branch that the head will be merged into.'
      ),
    head: z
      .string()
      .describe(
        'The head to merge. This can be a branch name or a commit SHA1.'
      ),
    commit_message: z
      .string()
      .describe(
        'Commit message to use for the merge commit. If omitted, a default message will be used.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposMergeParams = z.infer<typeof ReposMergeParamsSchema>

  export type ReposMergeResponse = undefined

  export const IssuesListMilestonesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe(
        'The state of the milestone. Either `open`, `closed`, or `all`.'
      )
      .default('open'),
    sort: z
      .enum(['due_on', 'completeness'])
      .describe('What to sort results by. Either `due_on` or `completeness`.')
      .default('due_on'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction of the sort. Either `asc` or `desc`.')
      .default('asc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListMilestonesParams = z.infer<
    typeof IssuesListMilestonesParamsSchema
  >

  export const IssuesListMilestonesResponseSchema = z.array(MilestoneSchema)
  export type IssuesListMilestonesResponse = z.infer<
    typeof IssuesListMilestonesResponseSchema
  >

  export const IssuesCreateMilestoneParamsSchema = z.object({
    title: z.string().describe('The title of the milestone.'),
    state: z
      .enum(['open', 'closed'])
      .describe('The state of the milestone. Either `open` or `closed`.')
      .default('open'),
    description: z
      .string()
      .describe('A description of the milestone.')
      .optional(),
    due_on: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateMilestoneParams = z.infer<
    typeof IssuesCreateMilestoneParamsSchema
  >

  export type IssuesCreateMilestoneResponse = undefined

  export const IssuesGetMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesGetMilestoneParams = z.infer<
    typeof IssuesGetMilestoneParamsSchema
  >

  export const IssuesGetMilestoneResponseSchema = MilestoneSchema
  export type IssuesGetMilestoneResponse = z.infer<
    typeof IssuesGetMilestoneResponseSchema
  >

  export const IssuesDeleteMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesDeleteMilestoneParams = z.infer<
    typeof IssuesDeleteMilestoneParamsSchema
  >

  export type IssuesDeleteMilestoneResponse = undefined

  export const IssuesUpdateMilestoneParamsSchema = z.object({
    title: z.string().describe('The title of the milestone.').optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('The state of the milestone. Either `open` or `closed`.')
      .default('open'),
    description: z
      .string()
      .describe('A description of the milestone.')
      .optional(),
    due_on: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesUpdateMilestoneParams = z.infer<
    typeof IssuesUpdateMilestoneParamsSchema
  >

  export const IssuesUpdateMilestoneResponseSchema = MilestoneSchema
  export type IssuesUpdateMilestoneResponse = z.infer<
    typeof IssuesUpdateMilestoneResponseSchema
  >

  export const IssuesListLabelsForMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsForMilestoneParams = z.infer<
    typeof IssuesListLabelsForMilestoneParamsSchema
  >

  export const IssuesListLabelsForMilestoneResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsForMilestoneResponse = z.infer<
    typeof IssuesListLabelsForMilestoneResponseSchema
  >

  export const ActivityListRepoNotificationsForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      all: z
        .boolean()
        .describe('If `true`, show notifications marked as read.')
        .default(false),
      participating: z
        .boolean()
        .describe(
          'If `true`, only shows notifications in which the user is directly participating or mentioned.'
        )
        .default(false),
      since: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      before: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListRepoNotificationsForAuthenticatedUserParams = z.infer<
    typeof ActivityListRepoNotificationsForAuthenticatedUserParamsSchema
  >

  export const ActivityListRepoNotificationsForAuthenticatedUserResponseSchema =
    z.array(ThreadSchema)
  export type ActivityListRepoNotificationsForAuthenticatedUserResponse =
    z.infer<
      typeof ActivityListRepoNotificationsForAuthenticatedUserResponseSchema
    >

  export const ActivityMarkRepoNotificationsAsReadParamsSchema = z.object({
    last_read_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityMarkRepoNotificationsAsReadParams = z.infer<
    typeof ActivityMarkRepoNotificationsAsReadParamsSchema
  >

  export type ActivityMarkRepoNotificationsAsReadResponse = undefined

  export const ReposGetPagesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPagesParams = z.infer<typeof ReposGetPagesParamsSchema>

  export const ReposGetPagesResponseSchema = PageSchema
  export type ReposGetPagesResponse = z.infer<
    typeof ReposGetPagesResponseSchema
  >

  export const ReposCreatePagesSiteParamsSchema = z
    .object({
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe(
          'The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.'
        )
        .optional(),
      source: z
        .object({
          branch: z
            .string()
            .describe(
              "The repository branch used to publish your site's source files."
            ),
          path: z
            .enum(['/', '/docs'])
            .describe(
              'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`'
            )
            .default('/')
        })
        .describe(
          'The source branch and directory used to publish your Pages site.'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any()]))
  export type ReposCreatePagesSiteParams = z.infer<
    typeof ReposCreatePagesSiteParamsSchema
  >

  export type ReposCreatePagesSiteResponse = undefined

  export const ReposUpdateInformationAboutPagesSiteParamsSchema = z
    .object({
      cname: z
        .string()
        .describe(
          'Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/pages/configuring-a-custom-domain-for-your-github-pages-site)."'
        )
        .optional(),
      https_enforced: z
        .boolean()
        .describe(
          'Specify whether HTTPS should be enforced for the repository.'
        )
        .optional(),
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe(
          'The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.'
        )
        .optional(),
      source: z
        .union([
          z
            .enum(['gh-pages', 'master', 'master /docs'])
            .describe(
              'Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`, `"master"`, and `"master /docs"`.'
            ),
          z
            .object({
              branch: z
                .string()
                .describe(
                  "The repository branch used to publish your site's source files."
                ),
              path: z
                .enum(['/', '/docs'])
                .describe(
                  'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`.'
                )
            })
            .describe(
              'Update the source for the repository. Must include the branch name and path.'
            )
        ])
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any(), z.any(), z.any(), z.any()]))
  export type ReposUpdateInformationAboutPagesSiteParams = z.infer<
    typeof ReposUpdateInformationAboutPagesSiteParamsSchema
  >

  export type ReposUpdateInformationAboutPagesSiteResponse = undefined

  export const ReposDeletePagesSiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDeletePagesSiteParams = z.infer<
    typeof ReposDeletePagesSiteParamsSchema
  >

  export type ReposDeletePagesSiteResponse = undefined

  export const ReposListPagesBuildsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListPagesBuildsParams = z.infer<
    typeof ReposListPagesBuildsParamsSchema
  >

  export const ReposListPagesBuildsResponseSchema = z.array(PageBuildSchema)
  export type ReposListPagesBuildsResponse = z.infer<
    typeof ReposListPagesBuildsResponseSchema
  >

  export const ReposRequestPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposRequestPagesBuildParams = z.infer<
    typeof ReposRequestPagesBuildParamsSchema
  >

  export type ReposRequestPagesBuildResponse = undefined

  export const ReposGetLatestPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetLatestPagesBuildParams = z.infer<
    typeof ReposGetLatestPagesBuildParamsSchema
  >

  export const ReposGetLatestPagesBuildResponseSchema = PageBuildSchema
  export type ReposGetLatestPagesBuildResponse = z.infer<
    typeof ReposGetLatestPagesBuildResponseSchema
  >

  export const ReposGetPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    build_id: z.number().int()
  })
  export type ReposGetPagesBuildParams = z.infer<
    typeof ReposGetPagesBuildParamsSchema
  >

  export const ReposGetPagesBuildResponseSchema = PageBuildSchema
  export type ReposGetPagesBuildResponse = z.infer<
    typeof ReposGetPagesBuildResponseSchema
  >

  export const ReposCreatePagesDeploymentParamsSchema = z.object({
    artifact_id: z
      .number()
      .describe(
        'The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.'
      )
      .optional(),
    artifact_url: z
      .string()
      .describe(
        'The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.'
      )
      .optional(),
    environment: z
      .string()
      .describe('The target environment for this GitHub Pages deployment.')
      .default('github-pages'),
    pages_build_version: z
      .string()
      .describe(
        'A unique string that represents the version of the build for this deployment.'
      )
      .default('GITHUB_SHA'),
    oidc_token: z
      .string()
      .describe(
        'The OIDC token issued by GitHub Actions certifying the origin of the deployment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreatePagesDeploymentParams = z.infer<
    typeof ReposCreatePagesDeploymentParamsSchema
  >

  export const ReposCreatePagesDeploymentResponseSchema = PageDeploymentSchema
  export type ReposCreatePagesDeploymentResponse = z.infer<
    typeof ReposCreatePagesDeploymentResponseSchema
  >

  export const ReposGetPagesDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pages_deployment_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
      )
  })
  export type ReposGetPagesDeploymentParams = z.infer<
    typeof ReposGetPagesDeploymentParamsSchema
  >

  export const ReposGetPagesDeploymentResponseSchema =
    PagesDeploymentStatusSchema
  export type ReposGetPagesDeploymentResponse = z.infer<
    typeof ReposGetPagesDeploymentResponseSchema
  >

  export const ReposCancelPagesDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pages_deployment_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
      )
  })
  export type ReposCancelPagesDeploymentParams = z.infer<
    typeof ReposCancelPagesDeploymentParamsSchema
  >

  export type ReposCancelPagesDeploymentResponse = undefined

  export const ReposGetPagesHealthCheckParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPagesHealthCheckParams = z.infer<
    typeof ReposGetPagesHealthCheckParamsSchema
  >

  export const ReposGetPagesHealthCheckResponseSchema = PagesHealthCheckSchema
  export type ReposGetPagesHealthCheckResponse = z.infer<
    typeof ReposGetPagesHealthCheckResponseSchema
  >

  export const ReposCheckPrivateVulnerabilityReportingParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckPrivateVulnerabilityReportingParams = z.infer<
    typeof ReposCheckPrivateVulnerabilityReportingParamsSchema
  >

  export const ReposCheckPrivateVulnerabilityReportingResponseSchema = z.object(
    {
      enabled: z
        .boolean()
        .describe(
          'Whether or not private vulnerability reporting is enabled for the repository.'
        )
    }
  )
  export type ReposCheckPrivateVulnerabilityReportingResponse = z.infer<
    typeof ReposCheckPrivateVulnerabilityReportingResponseSchema
  >

  export const ReposEnablePrivateVulnerabilityReportingParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnablePrivateVulnerabilityReportingParams = z.infer<
    typeof ReposEnablePrivateVulnerabilityReportingParamsSchema
  >

  export type ReposEnablePrivateVulnerabilityReportingResponse = undefined

  export const ReposDisablePrivateVulnerabilityReportingParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type ReposDisablePrivateVulnerabilityReportingParams = z.infer<
    typeof ReposDisablePrivateVulnerabilityReportingParamsSchema
  >

  export type ReposDisablePrivateVulnerabilityReportingResponse = undefined

  export const ProjectsListForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForRepoParams = z.infer<
    typeof ProjectsListForRepoParamsSchema
  >

  export const ProjectsListForRepoResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForRepoResponse = z.infer<
    typeof ProjectsListForRepoResponseSchema
  >

  export const ProjectsCreateForRepoParamsSchema = z.object({
    name: z.string().describe('The name of the project.'),
    body: z.string().describe('The description of the project.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ProjectsCreateForRepoParams = z.infer<
    typeof ProjectsCreateForRepoParamsSchema
  >

  export type ProjectsCreateForRepoResponse = undefined

  export const ReposGetCustomPropertiesValuesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCustomPropertiesValuesParams = z.infer<
    typeof ReposGetCustomPropertiesValuesParamsSchema
  >

  export const ReposGetCustomPropertiesValuesResponseSchema = z.array(
    CustomPropertyValueSchema
  )
  export type ReposGetCustomPropertiesValuesResponse = z.infer<
    typeof ReposGetCustomPropertiesValuesResponseSchema
  >

  export const ReposCreateOrUpdateCustomPropertiesValuesParamsSchema = z.object(
    {
      properties: z
        .array(CustomPropertyValueSchema)
        .describe(
          'A list of custom property names and associated values to apply to the repositories.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type ReposCreateOrUpdateCustomPropertiesValuesParams = z.infer<
    typeof ReposCreateOrUpdateCustomPropertiesValuesParamsSchema
  >

  export type ReposCreateOrUpdateCustomPropertiesValuesResponse = undefined

  export const PullsListParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Either `open`, `closed`, or `all` to filter by state.')
      .default('open'),
    head: z
      .string()
      .describe(
        'Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.'
      )
      .optional(),
    base: z
      .string()
      .describe('Filter pulls by base branch name. Example: `gh-pages`.')
      .optional(),
    sort: z
      .enum(['created', 'updated', 'popularity', 'long-running'])
      .describe(
        'What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListParams = z.infer<typeof PullsListParamsSchema>

  export const PullsListResponseSchema = z.array(PullRequestSimpleSchema)
  export type PullsListResponse = z.infer<typeof PullsListResponseSchema>

  export const PullsCreateParamsSchema = z.object({
    title: z
      .string()
      .describe(
        'The title of the new pull request. Required unless `issue` is specified.'
      )
      .optional(),
    head: z
      .string()
      .describe(
        'The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.'
      ),
    head_repo: z
      .string()
      .describe(
        'The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.'
      )
      .optional(),
    base: z
      .string()
      .describe(
        'The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.'
      ),
    body: z.string().describe('The contents of the pull request.').optional(),
    maintainer_can_modify: z
      .boolean()
      .describe(
        'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
      )
      .optional(),
    draft: z
      .boolean()
      .describe(
        'Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.'
      )
      .optional(),
    issue: z
      .number()
      .int()
      .describe(
        'An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type PullsCreateParams = z.infer<typeof PullsCreateParamsSchema>

  export type PullsCreateResponse = undefined

  export const PullsListReviewCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z.enum(['created', 'updated', 'created_at']).optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction to sort results. Ignored without `sort` parameter.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewCommentsForRepoParams = z.infer<
    typeof PullsListReviewCommentsForRepoParamsSchema
  >

  export const PullsListReviewCommentsForRepoResponseSchema = z.array(
    PullRequestReviewCommentSchema
  )
  export type PullsListReviewCommentsForRepoResponse = z.infer<
    typeof PullsListReviewCommentsForRepoResponseSchema
  >

  export const PullsGetReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsGetReviewCommentParams = z.infer<
    typeof PullsGetReviewCommentParamsSchema
  >

  export const PullsGetReviewCommentResponseSchema =
    PullRequestReviewCommentSchema
  export type PullsGetReviewCommentResponse = z.infer<
    typeof PullsGetReviewCommentResponseSchema
  >

  export const PullsDeleteReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsDeleteReviewCommentParams = z.infer<
    typeof PullsDeleteReviewCommentParamsSchema
  >

  export type PullsDeleteReviewCommentResponse = undefined

  export const PullsUpdateReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the reply to the review comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsUpdateReviewCommentParams = z.infer<
    typeof PullsUpdateReviewCommentParamsSchema
  >

  export const PullsUpdateReviewCommentResponseSchema =
    PullRequestReviewCommentSchema
  export type PullsUpdateReviewCommentResponse = z.infer<
    typeof PullsUpdateReviewCommentResponseSchema
  >

  export const ReactionsListForPullRequestReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForPullRequestReviewCommentParams = z.infer<
    typeof ReactionsListForPullRequestReviewCommentParamsSchema
  >

  export const ReactionsListForPullRequestReviewCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForPullRequestReviewCommentResponse = z.infer<
    typeof ReactionsListForPullRequestReviewCommentResponseSchema
  >

  export const ReactionsCreateForPullRequestReviewCommentParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      comment_id: z
        .number()
        .int()
        .describe('The unique identifier of the comment.')
    })
  export type ReactionsCreateForPullRequestReviewCommentParams = z.infer<
    typeof ReactionsCreateForPullRequestReviewCommentParamsSchema
  >

  export const ReactionsCreateForPullRequestReviewCommentResponseSchema =
    ReactionSchema
  export type ReactionsCreateForPullRequestReviewCommentResponse = z.infer<
    typeof ReactionsCreateForPullRequestReviewCommentResponseSchema
  >

  export const ReactionsDeleteForPullRequestCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForPullRequestCommentParams = z.infer<
    typeof ReactionsDeleteForPullRequestCommentParamsSchema
  >

  export type ReactionsDeleteForPullRequestCommentResponse = undefined

  export const PullsGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsGetParams = z.infer<typeof PullsGetParamsSchema>

  export const PullsGetResponseSchema = PullRequestSchema
  export type PullsGetResponse = z.infer<typeof PullsGetResponseSchema>

  export const PullsUpdateParamsSchema = z.object({
    title: z.string().describe('The title of the pull request.').optional(),
    body: z.string().describe('The contents of the pull request.').optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('State of this Pull Request. Either `open` or `closed`.')
      .optional(),
    base: z
      .string()
      .describe(
        'The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.'
      )
      .optional(),
    maintainer_can_modify: z
      .boolean()
      .describe(
        'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsUpdateParams = z.infer<typeof PullsUpdateParamsSchema>

  export const PullsUpdateResponseSchema = PullRequestSchema
  export type PullsUpdateResponse = z.infer<typeof PullsUpdateResponseSchema>

  export const CodespacesCreateWithPrForAuthenticatedUserParamsSchema =
    z.object({
      location: z
        .string()
        .describe(
          'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
        )
        .optional(),
      geo: z
        .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
        .describe(
          'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      machine: z
        .string()
        .describe('Machine type to use for this codespace')
        .optional(),
      devcontainer_path: z
        .string()
        .describe('Path to devcontainer.json config to use for this codespace')
        .optional(),
      multi_repo_permissions_opt_out: z
        .boolean()
        .describe(
          'Whether to authorize requested permissions from devcontainer.json'
        )
        .optional(),
      working_directory: z
        .string()
        .describe('Working directory for this codespace')
        .optional(),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe('Time in minutes before codespace stops from inactivity')
        .optional(),
      display_name: z
        .string()
        .describe('Display name for this codespace')
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      pull_number: z
        .number()
        .int()
        .describe('The number that identifies the pull request.')
    })
  export type CodespacesCreateWithPrForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateWithPrForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateWithPrForAuthenticatedUserResponse = undefined

  export const PullsListReviewCommentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction to sort results. Ignored without `sort` parameter.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewCommentsParams = z.infer<
    typeof PullsListReviewCommentsParamsSchema
  >

  export const PullsListReviewCommentsResponseSchema = z.array(
    PullRequestReviewCommentSchema
  )
  export type PullsListReviewCommentsResponse = z.infer<
    typeof PullsListReviewCommentsResponseSchema
  >

  export const PullsCreateReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the review comment.'),
    commit_id: z
      .string()
      .describe(
        'The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.'
      ),
    path: z
      .string()
      .describe('The relative path to the file that necessitates a comment.'),
    position: z
      .number()
      .int()
      .describe(
        '**This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.'
      )
      .optional(),
    side: z
      .enum(['LEFT', 'RIGHT'])
      .describe(
        'In a split diff view, the side of the diff that the pull request\'s changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.'
      )
      .optional(),
    line: z
      .number()
      .int()
      .describe(
        '**Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.'
      )
      .optional(),
    start_line: z
      .number()
      .int()
      .describe(
        '**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.'
      )
      .optional(),
    start_side: z
      .enum(['LEFT', 'RIGHT', 'side'])
      .describe(
        '**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.'
      )
      .optional(),
    in_reply_to: z
      .number()
      .int()
      .describe(
        'The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.'
      )
      .optional(),
    subject_type: z
      .enum(['line', 'file'])
      .describe('The level at which the comment is targeted.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCreateReviewCommentParams = z.infer<
    typeof PullsCreateReviewCommentParamsSchema
  >

  export type PullsCreateReviewCommentResponse = undefined

  export const PullsCreateReplyForReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the review comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsCreateReplyForReviewCommentParams = z.infer<
    typeof PullsCreateReplyForReviewCommentParamsSchema
  >

  export type PullsCreateReplyForReviewCommentResponse = undefined

  export const PullsListCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListCommitsParams = z.infer<
    typeof PullsListCommitsParamsSchema
  >

  export const PullsListCommitsResponseSchema = z.array(CommitSchema)
  export type PullsListCommitsResponse = z.infer<
    typeof PullsListCommitsResponseSchema
  >

  export const PullsListFilesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListFilesParams = z.infer<typeof PullsListFilesParamsSchema>

  export const PullsListFilesResponseSchema = z.array(DiffEntrySchema)
  export type PullsListFilesResponse = z.infer<
    typeof PullsListFilesResponseSchema
  >

  export const PullsCheckIfMergedParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCheckIfMergedParams = z.infer<
    typeof PullsCheckIfMergedParamsSchema
  >

  export type PullsCheckIfMergedResponse = undefined

  export const PullsMergeParamsSchema = z.object({
    commit_title: z
      .string()
      .describe('Title for the automatic commit message.')
      .optional(),
    commit_message: z
      .string()
      .describe('Extra detail to append to automatic commit message.')
      .optional(),
    sha: z
      .string()
      .describe('SHA that pull request head must match to allow merge.')
      .optional(),
    merge_method: z
      .enum(['merge', 'squash', 'rebase'])
      .describe('The merge method to use.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsMergeParams = z.infer<typeof PullsMergeParamsSchema>

  export const PullsMergeResponseSchema = PullRequestMergeResultSchema
  export type PullsMergeResponse = z.infer<typeof PullsMergeResponseSchema>

  export const PullsListRequestedReviewersParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsListRequestedReviewersParams = z.infer<
    typeof PullsListRequestedReviewersParamsSchema
  >

  export const PullsListRequestedReviewersResponseSchema =
    PullRequestReviewRequestSchema
  export type PullsListRequestedReviewersResponse = z.infer<
    typeof PullsListRequestedReviewersResponseSchema
  >

  export const PullsRequestReviewersParamsSchema = z
    .object({
      reviewers: z
        .array(z.string())
        .describe('An array of user `login`s that will be requested.')
        .optional(),
      team_reviewers: z
        .array(z.string())
        .describe('An array of team `slug`s that will be requested.')
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      pull_number: z
        .number()
        .int()
        .describe('The number that identifies the pull request.')
    })
    .and(z.union([z.any(), z.any()]))
  export type PullsRequestReviewersParams = z.infer<
    typeof PullsRequestReviewersParamsSchema
  >

  export type PullsRequestReviewersResponse = undefined

  export const PullsRemoveRequestedReviewersParamsSchema = z.object({
    reviewers: z
      .array(z.string())
      .describe('An array of user `login`s that will be removed.'),
    team_reviewers: z
      .array(z.string())
      .describe('An array of team `slug`s that will be removed.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsRemoveRequestedReviewersParams = z.infer<
    typeof PullsRemoveRequestedReviewersParamsSchema
  >

  export const PullsRemoveRequestedReviewersResponseSchema =
    PullRequestSimpleSchema
  export type PullsRemoveRequestedReviewersResponse = z.infer<
    typeof PullsRemoveRequestedReviewersResponseSchema
  >

  export const PullsListReviewsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewsParams = z.infer<
    typeof PullsListReviewsParamsSchema
  >

  export const PullsListReviewsResponseSchema = z.array(PullRequestReviewSchema)
  export type PullsListReviewsResponse = z.infer<
    typeof PullsListReviewsResponseSchema
  >

  export const PullsCreateReviewParamsSchema = z.object({
    commit_id: z
      .string()
      .describe(
        'The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.'
      )
      .optional(),
    body: z
      .string()
      .describe(
        '**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.'
      )
      .optional(),
    event: z
      .enum(['APPROVE', 'REQUEST_CHANGES', 'COMMENT'])
      .describe(
        'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.'
      )
      .optional(),
    comments: z
      .array(
        z.object({
          path: z
            .string()
            .describe(
              'The relative path to the file that necessitates a review comment.'
            ),
          position: z
            .number()
            .int()
            .describe(
              'The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.'
            )
            .optional(),
          body: z.string().describe('Text of the review comment.'),
          line: z.number().int().optional(),
          side: z.string().optional(),
          start_line: z.number().int().optional(),
          start_side: z.string().optional()
        })
      )
      .describe(
        'Use the following table to specify the location, destination, and contents of the draft review comment.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCreateReviewParams = z.infer<
    typeof PullsCreateReviewParamsSchema
  >

  export const PullsCreateReviewResponseSchema = PullRequestReviewSchema
  export type PullsCreateReviewResponse = z.infer<
    typeof PullsCreateReviewResponseSchema
  >

  export const PullsGetReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsGetReviewParams = z.infer<typeof PullsGetReviewParamsSchema>

  export const PullsGetReviewResponseSchema = PullRequestReviewSchema
  export type PullsGetReviewResponse = z.infer<
    typeof PullsGetReviewResponseSchema
  >

  export const PullsUpdateReviewParamsSchema = z.object({
    body: z.string().describe('The body text of the pull request review.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsUpdateReviewParams = z.infer<
    typeof PullsUpdateReviewParamsSchema
  >

  export const PullsUpdateReviewResponseSchema = PullRequestReviewSchema
  export type PullsUpdateReviewResponse = z.infer<
    typeof PullsUpdateReviewResponseSchema
  >

  export const PullsDeletePendingReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsDeletePendingReviewParams = z.infer<
    typeof PullsDeletePendingReviewParamsSchema
  >

  export const PullsDeletePendingReviewResponseSchema = PullRequestReviewSchema
  export type PullsDeletePendingReviewResponse = z.infer<
    typeof PullsDeletePendingReviewResponseSchema
  >

  export const PullsListCommentsForReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z
      .number()
      .int()
      .describe('The unique identifier of the review.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListCommentsForReviewParams = z.infer<
    typeof PullsListCommentsForReviewParamsSchema
  >

  export const PullsListCommentsForReviewResponseSchema =
    z.array(ReviewCommentSchema)
  export type PullsListCommentsForReviewResponse = z.infer<
    typeof PullsListCommentsForReviewResponseSchema
  >

  export const PullsDismissReviewParamsSchema = z.object({
    message: z
      .string()
      .describe('The message for the pull request review dismissal'),
    event: z.literal('DISMISS').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsDismissReviewParams = z.infer<
    typeof PullsDismissReviewParamsSchema
  >

  export const PullsDismissReviewResponseSchema = PullRequestReviewSchema
  export type PullsDismissReviewResponse = z.infer<
    typeof PullsDismissReviewResponseSchema
  >

  export const PullsSubmitReviewParamsSchema = z.object({
    body: z
      .string()
      .describe('The body text of the pull request review')
      .optional(),
    event: z
      .enum(['APPROVE', 'REQUEST_CHANGES', 'COMMENT'])
      .describe(
        'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsSubmitReviewParams = z.infer<
    typeof PullsSubmitReviewParamsSchema
  >

  export const PullsSubmitReviewResponseSchema = PullRequestReviewSchema
  export type PullsSubmitReviewResponse = z.infer<
    typeof PullsSubmitReviewResponseSchema
  >

  export const PullsUpdateBranchParamsSchema = z.object({
    expected_head_sha: z
      .string()
      .describe(
        "The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/commits/commits#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsUpdateBranchParams = z.infer<
    typeof PullsUpdateBranchParamsSchema
  >

  export type PullsUpdateBranchResponse = undefined

  export const ReposGetReadmeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetReadmeParams = z.infer<typeof ReposGetReadmeParamsSchema>

  export const ReposGetReadmeResponseSchema = ContentFileSchema
  export type ReposGetReadmeResponse = z.infer<
    typeof ReposGetReadmeResponseSchema
  >

  export const ReposGetReadmeInDirectoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    dir: z.string().describe('The alternate path to look for a README file'),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetReadmeInDirectoryParams = z.infer<
    typeof ReposGetReadmeInDirectoryParamsSchema
  >

  export const ReposGetReadmeInDirectoryResponseSchema = ContentFileSchema
  export type ReposGetReadmeInDirectoryResponse = z.infer<
    typeof ReposGetReadmeInDirectoryResponseSchema
  >

  export const ReposListReleasesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListReleasesParams = z.infer<
    typeof ReposListReleasesParamsSchema
  >

  export const ReposListReleasesResponseSchema = z.array(ReleaseSchema)
  export type ReposListReleasesResponse = z.infer<
    typeof ReposListReleasesResponseSchema
  >

  export const ReposCreateReleaseParamsSchema = z.object({
    tag_name: z.string().describe('The name of the tag.'),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch."
      )
      .optional(),
    name: z.string().describe('The name of the release.').optional(),
    body: z
      .string()
      .describe('Text describing the contents of the tag.')
      .optional(),
    draft: z
      .boolean()
      .describe(
        '`true` to create a draft (unpublished) release, `false` to create a published one.'
      )
      .default(false),
    prerelease: z
      .boolean()
      .describe(
        '`true` to identify the release as a prerelease. `false` to identify the release as a full release.'
      )
      .default(false),
    discussion_category_name: z
      .string()
      .describe(
        'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
      )
      .optional(),
    generate_release_notes: z
      .boolean()
      .describe(
        'Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.'
      )
      .default(false),
    make_latest: z
      .enum(['true', 'false', 'legacy'])
      .describe(
        'Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.'
      )
      .default('true'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateReleaseParams = z.infer<
    typeof ReposCreateReleaseParamsSchema
  >

  export type ReposCreateReleaseResponse = undefined

  export const ReposGetReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposGetReleaseAssetParams = z.infer<
    typeof ReposGetReleaseAssetParamsSchema
  >

  export const ReposGetReleaseAssetResponseSchema = ReleaseAssetSchema
  export type ReposGetReleaseAssetResponse = z.infer<
    typeof ReposGetReleaseAssetResponseSchema
  >

  export const ReposDeleteReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposDeleteReleaseAssetParams = z.infer<
    typeof ReposDeleteReleaseAssetParamsSchema
  >

  export type ReposDeleteReleaseAssetResponse = undefined

  export const ReposUpdateReleaseAssetParamsSchema = z.object({
    name: z.string().describe('The file name of the asset.').optional(),
    label: z
      .string()
      .describe(
        'An alternate short description of the asset. Used in place of the filename.'
      )
      .optional(),
    state: z.string().optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposUpdateReleaseAssetParams = z.infer<
    typeof ReposUpdateReleaseAssetParamsSchema
  >

  export const ReposUpdateReleaseAssetResponseSchema = ReleaseAssetSchema
  export type ReposUpdateReleaseAssetResponse = z.infer<
    typeof ReposUpdateReleaseAssetResponseSchema
  >

  export const ReposGenerateReleaseNotesParamsSchema = z.object({
    tag_name: z
      .string()
      .describe(
        'The tag name for the release. This can be an existing tag or a new one.'
      ),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists."
      )
      .optional(),
    previous_tag_name: z
      .string()
      .describe(
        'The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.'
      )
      .optional(),
    configuration_file_path: z
      .string()
      .describe(
        "Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGenerateReleaseNotesParams = z.infer<
    typeof ReposGenerateReleaseNotesParamsSchema
  >

  export const ReposGenerateReleaseNotesResponseSchema =
    ReleaseNotesContentSchema
  export type ReposGenerateReleaseNotesResponse = z.infer<
    typeof ReposGenerateReleaseNotesResponseSchema
  >

  export const ReposGetLatestReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetLatestReleaseParams = z.infer<
    typeof ReposGetLatestReleaseParamsSchema
  >

  export const ReposGetLatestReleaseResponseSchema = ReleaseSchema
  export type ReposGetLatestReleaseResponse = z.infer<
    typeof ReposGetLatestReleaseResponseSchema
  >

  export const ReposGetReleaseByTagParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag: z.string().describe('tag parameter')
  })
  export type ReposGetReleaseByTagParams = z.infer<
    typeof ReposGetReleaseByTagParamsSchema
  >

  export const ReposGetReleaseByTagResponseSchema = ReleaseSchema
  export type ReposGetReleaseByTagResponse = z.infer<
    typeof ReposGetReleaseByTagResponseSchema
  >

  export const ReposGetReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposGetReleaseParams = z.infer<
    typeof ReposGetReleaseParamsSchema
  >

  export const ReposGetReleaseResponseSchema = ReleaseSchema
  export type ReposGetReleaseResponse = z.infer<
    typeof ReposGetReleaseResponseSchema
  >

  export const ReposDeleteReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposDeleteReleaseParams = z.infer<
    typeof ReposDeleteReleaseParamsSchema
  >

  export type ReposDeleteReleaseResponse = undefined

  export const ReposUpdateReleaseParamsSchema = z.object({
    tag_name: z.string().describe('The name of the tag.').optional(),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch."
      )
      .optional(),
    name: z.string().describe('The name of the release.').optional(),
    body: z
      .string()
      .describe('Text describing the contents of the tag.')
      .optional(),
    draft: z
      .boolean()
      .describe(
        '`true` makes the release a draft, and `false` publishes the release.'
      )
      .optional(),
    prerelease: z
      .boolean()
      .describe(
        '`true` to identify the release as a prerelease, `false` to identify the release as a full release.'
      )
      .optional(),
    make_latest: z
      .enum(['true', 'false', 'legacy'])
      .describe(
        'Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.'
      )
      .default('true'),
    discussion_category_name: z
      .string()
      .describe(
        'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposUpdateReleaseParams = z.infer<
    typeof ReposUpdateReleaseParamsSchema
  >

  export const ReposUpdateReleaseResponseSchema = ReleaseSchema
  export type ReposUpdateReleaseResponse = z.infer<
    typeof ReposUpdateReleaseResponseSchema
  >

  export const ReposListReleaseAssetsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListReleaseAssetsParams = z.infer<
    typeof ReposListReleaseAssetsParamsSchema
  >

  export const ReposListReleaseAssetsResponseSchema =
    z.array(ReleaseAssetSchema)
  export type ReposListReleaseAssetsResponse = z.infer<
    typeof ReposListReleaseAssetsResponseSchema
  >

  export const ReposUploadReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    name: z.string(),
    label: z.string().optional()
  })
  export type ReposUploadReleaseAssetParams = z.infer<
    typeof ReposUploadReleaseAssetParamsSchema
  >

  export type ReposUploadReleaseAssetResponse = undefined

  export const ReactionsListForReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    content: z
      .enum(['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes'])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForReleaseParams = z.infer<
    typeof ReactionsListForReleaseParamsSchema
  >

  export const ReactionsListForReleaseResponseSchema = z.array(ReactionSchema)
  export type ReactionsListForReleaseResponse = z.infer<
    typeof ReactionsListForReleaseResponseSchema
  >

  export const ReactionsCreateForReleaseParamsSchema = z.object({
    content: z
      .enum(['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes'])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReactionsCreateForReleaseParams = z.infer<
    typeof ReactionsCreateForReleaseParamsSchema
  >

  export const ReactionsCreateForReleaseResponseSchema = ReactionSchema
  export type ReactionsCreateForReleaseResponse = z.infer<
    typeof ReactionsCreateForReleaseResponseSchema
  >

  export const ReactionsDeleteForReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForReleaseParams = z.infer<
    typeof ReactionsDeleteForReleaseParamsSchema
  >

  export type ReactionsDeleteForReleaseResponse = undefined

  export const ReposGetBranchRulesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetBranchRulesParams = z.infer<
    typeof ReposGetBranchRulesParamsSchema
  >

  export const ReposGetBranchRulesResponseSchema = z.array(
    RepositoryRuleDetailedSchema
  )
  export type ReposGetBranchRulesResponse = z.infer<
    typeof ReposGetBranchRulesResponseSchema
  >

  export const ReposGetRepoRulesetsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    includes_parents: z
      .boolean()
      .describe(
        'Include rulesets configured at higher levels that apply to this repository'
      )
      .default(true),
    targets: z
      .string()
      .describe(
        'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
      )
      .optional()
  })
  export type ReposGetRepoRulesetsParams = z.infer<
    typeof ReposGetRepoRulesetsParamsSchema
  >

  export const ReposGetRepoRulesetsResponseSchema = z.array(
    RepositoryRulesetSchema
  )
  export type ReposGetRepoRulesetsResponse = z.infer<
    typeof ReposGetRepoRulesetsResponseSchema
  >

  export const ReposCreateRepoRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.'),
    target: z
      .enum(['branch', 'tag', 'push'])
      .describe('The target of the ruleset')
      .default('branch'),
    enforcement: RepositoryRuleEnforcementSchema,
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: RepositoryRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateRepoRulesetParams = z.infer<
    typeof ReposCreateRepoRulesetParamsSchema
  >

  export type ReposCreateRepoRulesetResponse = undefined

  export const ReposGetRepoRuleSuitesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
      )
      .optional(),
    time_period: z
      .enum(['hour', 'day', 'week', 'month'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
      )
      .default('day'),
    actor_name: z
      .string()
      .describe(
        'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
      )
      .optional(),
    rule_suite_result: z
      .enum(['pass', 'fail', 'bypass', 'all'])
      .describe(
        'The rule results to filter on. When specified, only suites with this result will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetRepoRuleSuitesParams = z.infer<
    typeof ReposGetRepoRuleSuitesParamsSchema
  >

  export const ReposGetRepoRuleSuitesResponseSchema = RuleSuitesSchema
  export type ReposGetRepoRuleSuitesResponse = z.infer<
    typeof ReposGetRepoRuleSuitesResponseSchema
  >

  export const ReposGetRepoRuleSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    rule_suite_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
      )
  })
  export type ReposGetRepoRuleSuiteParams = z.infer<
    typeof ReposGetRepoRuleSuiteParamsSchema
  >

  export const ReposGetRepoRuleSuiteResponseSchema = RuleSuiteSchema
  export type ReposGetRepoRuleSuiteResponse = z.infer<
    typeof ReposGetRepoRuleSuiteResponseSchema
  >

  export const ReposGetRepoRulesetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    includes_parents: z
      .boolean()
      .describe(
        'Include rulesets configured at higher levels that apply to this repository'
      )
      .default(true)
  })
  export type ReposGetRepoRulesetParams = z.infer<
    typeof ReposGetRepoRulesetParamsSchema
  >

  export const ReposGetRepoRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposGetRepoRulesetResponse = z.infer<
    typeof ReposGetRepoRulesetResponseSchema
  >

  export const ReposUpdateRepoRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.').optional(),
    target: z
      .enum(['branch', 'tag', 'push'])
      .describe('The target of the ruleset')
      .optional(),
    enforcement: RepositoryRuleEnforcementSchema.optional(),
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: RepositoryRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposUpdateRepoRulesetParams = z.infer<
    typeof ReposUpdateRepoRulesetParamsSchema
  >

  export const ReposUpdateRepoRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposUpdateRepoRulesetResponse = z.infer<
    typeof ReposUpdateRepoRulesetResponseSchema
  >

  export const ReposDeleteRepoRulesetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposDeleteRepoRulesetParams = z.infer<
    typeof ReposDeleteRepoRulesetParamsSchema
  >

  export type ReposDeleteRepoRulesetResponse = undefined

  export const ReposGetRepoRulesetHistoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetRepoRulesetHistoryParams = z.infer<
    typeof ReposGetRepoRulesetHistoryParamsSchema
  >

  export const ReposGetRepoRulesetHistoryResponseSchema =
    z.array(RulesetVersionSchema)
  export type ReposGetRepoRulesetHistoryResponse = z.infer<
    typeof ReposGetRepoRulesetHistoryResponseSchema
  >

  export const ReposGetRepoRulesetVersionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    version_id: z.number().int().describe('The ID of the version')
  })
  export type ReposGetRepoRulesetVersionParams = z.infer<
    typeof ReposGetRepoRulesetVersionParamsSchema
  >

  export const ReposGetRepoRulesetVersionResponseSchema =
    RulesetVersionWithStateSchema
  export type ReposGetRepoRulesetVersionResponse = z.infer<
    typeof ReposGetRepoRulesetVersionResponseSchema
  >

  export const SecretScanningListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForRepoParams = z.infer<
    typeof SecretScanningListAlertsForRepoParamsSchema
  >

  export const SecretScanningListAlertsForRepoResponseSchema = z.array(
    SecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForRepoResponse = z.infer<
    typeof SecretScanningListAlertsForRepoResponseSchema
  >

  export const SecretScanningGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type SecretScanningGetAlertParams = z.infer<
    typeof SecretScanningGetAlertParamsSchema
  >

  export const SecretScanningGetAlertResponseSchema = SecretScanningAlertSchema
  export type SecretScanningGetAlertResponse = z.infer<
    typeof SecretScanningGetAlertResponseSchema
  >

  export const SecretScanningUpdateAlertParamsSchema = z.object({
    state: SecretScanningAlertStateSchema,
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolution_comment: SecretScanningAlertResolutionCommentSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type SecretScanningUpdateAlertParams = z.infer<
    typeof SecretScanningUpdateAlertParamsSchema
  >

  export const SecretScanningUpdateAlertResponseSchema =
    SecretScanningAlertSchema
  export type SecretScanningUpdateAlertResponse = z.infer<
    typeof SecretScanningUpdateAlertResponseSchema
  >

  export const SecretScanningListLocationsForAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type SecretScanningListLocationsForAlertParams = z.infer<
    typeof SecretScanningListLocationsForAlertParamsSchema
  >

  export const SecretScanningListLocationsForAlertResponseSchema = z
    .array(SecretScanningLocationSchema)
    .describe('List of locations where the secret was detected')
  export type SecretScanningListLocationsForAlertResponse = z.infer<
    typeof SecretScanningListLocationsForAlertResponseSchema
  >

  export const SecretScanningCreatePushProtectionBypassParamsSchema = z.object({
    reason: SecretScanningPushProtectionBypassReasonSchema,
    placeholder_id: SecretScanningPushProtectionBypassPlaceholderIdSchema,
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type SecretScanningCreatePushProtectionBypassParams = z.infer<
    typeof SecretScanningCreatePushProtectionBypassParamsSchema
  >

  export const SecretScanningCreatePushProtectionBypassResponseSchema =
    SecretScanningPushProtectionBypassSchema
  export type SecretScanningCreatePushProtectionBypassResponse = z.infer<
    typeof SecretScanningCreatePushProtectionBypassResponseSchema
  >

  export const SecretScanningGetScanHistoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type SecretScanningGetScanHistoryParams = z.infer<
    typeof SecretScanningGetScanHistoryParamsSchema
  >

  export const SecretScanningGetScanHistoryResponseSchema =
    SecretScanningScanHistorySchema
  export type SecretScanningGetScanHistoryResponse = z.infer<
    typeof SecretScanningGetScanHistoryResponseSchema
  >

  export const SecurityAdvisoriesListRepositoryAdvisoriesParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      sort: z
        .enum(['created', 'updated', 'published'])
        .describe('The property to sort the results by.')
        .default('created'),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .gte(1)
        .lte(100)
        .describe(
          'The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['triage', 'draft', 'published', 'closed'])
        .describe(
          'Filter by state of the repository advisories. Only advisories of this state will be returned.'
        )
        .optional()
    })
  export type SecurityAdvisoriesListRepositoryAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListRepositoryAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListRepositoryAdvisoriesResponseSchema =
    z.array(RepositoryAdvisorySchema)
  export type SecurityAdvisoriesListRepositoryAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListRepositoryAdvisoriesResponseSchema
  >

  export const SecurityAdvisoriesCreateRepositoryAdvisoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(RepositoryAdvisoryCreateSchema)
  export type SecurityAdvisoriesCreateRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesCreateRepositoryAdvisoryParamsSchema
  >

  export type SecurityAdvisoriesCreateRepositoryAdvisoryResponse = undefined

  export const SecurityAdvisoriesCreatePrivateVulnerabilityReportParamsSchema =
    z
      .object({
        owner: z
          .string()
          .describe(
            'The account owner of the repository. The name is not case sensitive.'
          ),
        repo: z
          .string()
          .describe(
            'The name of the repository without the `.git` extension. The name is not case sensitive.'
          )
      })
      .merge(PrivateVulnerabilityReportCreateSchema)
  export type SecurityAdvisoriesCreatePrivateVulnerabilityReportParams =
    z.infer<
      typeof SecurityAdvisoriesCreatePrivateVulnerabilityReportParamsSchema
    >

  export type SecurityAdvisoriesCreatePrivateVulnerabilityReportResponse =
    undefined

  export const SecurityAdvisoriesGetRepositoryAdvisoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesGetRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesGetRepositoryAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesGetRepositoryAdvisoryResponseSchema =
    RepositoryAdvisorySchema
  export type SecurityAdvisoriesGetRepositoryAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesGetRepositoryAdvisoryResponseSchema
  >

  export const SecurityAdvisoriesUpdateRepositoryAdvisoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ghsa_id: z
        .string()
        .describe(
          'The GHSA (GitHub Security Advisory) identifier of the advisory.'
        )
    })
    .merge(RepositoryAdvisoryUpdateSchema)
  export type SecurityAdvisoriesUpdateRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesUpdateRepositoryAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesUpdateRepositoryAdvisoryResponseSchema =
    RepositoryAdvisorySchema
  export type SecurityAdvisoriesUpdateRepositoryAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesUpdateRepositoryAdvisoryResponseSchema
  >

  export const SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ghsa_id: z
        .string()
        .describe(
          'The GHSA (GitHub Security Advisory) identifier of the advisory.'
        )
    })
  export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParams =
    z.infer<
      typeof SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamsSchema
    >

  export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponse =
    undefined

  export const SecurityAdvisoriesCreateForkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesCreateForkParams = z.infer<
    typeof SecurityAdvisoriesCreateForkParamsSchema
  >

  export type SecurityAdvisoriesCreateForkResponse = undefined

  export const ActivityListStargazersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListStargazersForRepoParams = z.infer<
    typeof ActivityListStargazersForRepoParamsSchema
  >

  export const ActivityListStargazersForRepoResponseSchema = z.union([
    z.array(SimpleUserSchema),
    z.array(StargazerSchema)
  ])
  export type ActivityListStargazersForRepoResponse = z.infer<
    typeof ActivityListStargazersForRepoResponseSchema
  >

  export const ReposGetCodeFrequencyStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCodeFrequencyStatsParams = z.infer<
    typeof ReposGetCodeFrequencyStatsParamsSchema
  >

  export const ReposGetCodeFrequencyStatsResponseSchema = z.array(
    CodeFrequencyStatSchema
  )
  export type ReposGetCodeFrequencyStatsResponse = z.infer<
    typeof ReposGetCodeFrequencyStatsResponseSchema
  >

  export const ReposGetCommitActivityStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCommitActivityStatsParams = z.infer<
    typeof ReposGetCommitActivityStatsParamsSchema
  >

  export const ReposGetCommitActivityStatsResponseSchema =
    z.array(CommitActivitySchema)
  export type ReposGetCommitActivityStatsResponse = z.infer<
    typeof ReposGetCommitActivityStatsResponseSchema
  >

  export const ReposGetContributorsStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetContributorsStatsParams = z.infer<
    typeof ReposGetContributorsStatsParamsSchema
  >

  export const ReposGetContributorsStatsResponseSchema = z.array(
    ContributorActivitySchema
  )
  export type ReposGetContributorsStatsResponse = z.infer<
    typeof ReposGetContributorsStatsResponseSchema
  >

  export const ReposGetParticipationStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetParticipationStatsParams = z.infer<
    typeof ReposGetParticipationStatsParamsSchema
  >

  export const ReposGetParticipationStatsResponseSchema =
    ParticipationStatsSchema
  export type ReposGetParticipationStatsResponse = z.infer<
    typeof ReposGetParticipationStatsResponseSchema
  >

  export const ReposGetPunchCardStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPunchCardStatsParams = z.infer<
    typeof ReposGetPunchCardStatsParamsSchema
  >

  export const ReposGetPunchCardStatsResponseSchema = z.array(
    CodeFrequencyStatSchema
  )
  export type ReposGetPunchCardStatsResponse = z.infer<
    typeof ReposGetPunchCardStatsResponseSchema
  >

  export const ReposCreateCommitStatusParamsSchema = z.object({
    state: z
      .enum(['error', 'failure', 'pending', 'success'])
      .describe('The state of the status.'),
    target_url: z
      .string()
      .describe(
        'The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`'
      )
      .optional(),
    description: z
      .string()
      .describe('A short description of the status.')
      .optional(),
    context: z
      .string()
      .describe(
        'A string label to differentiate this status from the status of other systems. This field is case-insensitive.'
      )
      .default('default'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z.string()
  })
  export type ReposCreateCommitStatusParams = z.infer<
    typeof ReposCreateCommitStatusParamsSchema
  >

  export type ReposCreateCommitStatusResponse = undefined

  export const ActivityListWatchersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListWatchersForRepoParams = z.infer<
    typeof ActivityListWatchersForRepoParamsSchema
  >

  export const ActivityListWatchersForRepoResponseSchema =
    z.array(SimpleUserSchema)
  export type ActivityListWatchersForRepoResponse = z.infer<
    typeof ActivityListWatchersForRepoResponseSchema
  >

  export const ActivityGetRepoSubscriptionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityGetRepoSubscriptionParams = z.infer<
    typeof ActivityGetRepoSubscriptionParamsSchema
  >

  export const ActivityGetRepoSubscriptionResponseSchema =
    RepositorySubscriptionSchema
  export type ActivityGetRepoSubscriptionResponse = z.infer<
    typeof ActivityGetRepoSubscriptionResponseSchema
  >

  export const ActivitySetRepoSubscriptionParamsSchema = z.object({
    subscribed: z
      .boolean()
      .describe(
        'Determines if notifications should be received from this repository.'
      )
      .optional(),
    ignored: z
      .boolean()
      .describe(
        'Determines if all notifications should be blocked from this repository.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivitySetRepoSubscriptionParams = z.infer<
    typeof ActivitySetRepoSubscriptionParamsSchema
  >

  export const ActivitySetRepoSubscriptionResponseSchema =
    RepositorySubscriptionSchema
  export type ActivitySetRepoSubscriptionResponse = z.infer<
    typeof ActivitySetRepoSubscriptionResponseSchema
  >

  export const ActivityDeleteRepoSubscriptionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityDeleteRepoSubscriptionParams = z.infer<
    typeof ActivityDeleteRepoSubscriptionParamsSchema
  >

  export type ActivityDeleteRepoSubscriptionResponse = undefined

  export const ReposListTagsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListTagsParams = z.infer<typeof ReposListTagsParamsSchema>

  export const ReposListTagsResponseSchema = z.array(TagSchema)
  export type ReposListTagsResponse = z.infer<
    typeof ReposListTagsResponseSchema
  >

  export const ReposListTagProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListTagProtectionParams = z.infer<
    typeof ReposListTagProtectionParamsSchema
  >

  export const ReposListTagProtectionResponseSchema =
    z.array(TagProtectionSchema)
  export type ReposListTagProtectionResponse = z.infer<
    typeof ReposListTagProtectionResponseSchema
  >

  export const ReposCreateTagProtectionParamsSchema = z.object({
    pattern: z
      .string()
      .describe(
        'An optional glob pattern to match against when enforcing tag protection.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateTagProtectionParams = z.infer<
    typeof ReposCreateTagProtectionParamsSchema
  >

  export type ReposCreateTagProtectionResponse = undefined

  export const ReposDeleteTagProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag_protection_id: z
      .number()
      .int()
      .describe('The unique identifier of the tag protection.')
  })
  export type ReposDeleteTagProtectionParams = z.infer<
    typeof ReposDeleteTagProtectionParamsSchema
  >

  export type ReposDeleteTagProtectionResponse = undefined

  export const ReposDownloadTarballArchiveParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z.string()
  })
  export type ReposDownloadTarballArchiveParams = z.infer<
    typeof ReposDownloadTarballArchiveParamsSchema
  >

  export type ReposDownloadTarballArchiveResponse = undefined

  export const ReposListTeamsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListTeamsParams = z.infer<typeof ReposListTeamsParamsSchema>

  export const ReposListTeamsResponseSchema = z.array(TeamSchema)
  export type ReposListTeamsResponse = z.infer<
    typeof ReposListTeamsResponseSchema
  >

  export const ReposGetAllTopicsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposGetAllTopicsParams = z.infer<
    typeof ReposGetAllTopicsParamsSchema
  >

  export const ReposGetAllTopicsResponseSchema = TopicSchema
  export type ReposGetAllTopicsResponse = z.infer<
    typeof ReposGetAllTopicsResponseSchema
  >

  export const ReposReplaceAllTopicsParamsSchema = z.object({
    names: z
      .array(z.string())
      .describe(
        'An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposReplaceAllTopicsParams = z.infer<
    typeof ReposReplaceAllTopicsParamsSchema
  >

  export const ReposReplaceAllTopicsResponseSchema = TopicSchema
  export type ReposReplaceAllTopicsResponse = z.infer<
    typeof ReposReplaceAllTopicsResponseSchema
  >

  export const ReposGetClonesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per: z
      .enum(['day', 'week'])
      .describe('The time frame to display results for.')
      .default('day')
  })
  export type ReposGetClonesParams = z.infer<typeof ReposGetClonesParamsSchema>

  export const ReposGetClonesResponseSchema = CloneTrafficSchema
  export type ReposGetClonesResponse = z.infer<
    typeof ReposGetClonesResponseSchema
  >

  export const ReposGetTopPathsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetTopPathsParams = z.infer<
    typeof ReposGetTopPathsParamsSchema
  >

  export const ReposGetTopPathsResponseSchema = z.array(ContentTrafficSchema)
  export type ReposGetTopPathsResponse = z.infer<
    typeof ReposGetTopPathsResponseSchema
  >

  export const ReposGetTopReferrersParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetTopReferrersParams = z.infer<
    typeof ReposGetTopReferrersParamsSchema
  >

  export const ReposGetTopReferrersResponseSchema = z.array(
    ReferrerTrafficSchema
  )
  export type ReposGetTopReferrersResponse = z.infer<
    typeof ReposGetTopReferrersResponseSchema
  >

  export const ReposGetViewsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per: z
      .enum(['day', 'week'])
      .describe('The time frame to display results for.')
      .default('day')
  })
  export type ReposGetViewsParams = z.infer<typeof ReposGetViewsParamsSchema>

  export const ReposGetViewsResponseSchema = ViewTrafficSchema
  export type ReposGetViewsResponse = z.infer<
    typeof ReposGetViewsResponseSchema
  >

  export const ReposTransferParamsSchema = z.object({
    new_owner: z
      .string()
      .describe(
        'The username or organization name the repository will be transferred to.'
      ),
    new_name: z
      .string()
      .describe('The new name to be given to the repository.')
      .optional(),
    team_ids: z
      .array(z.number().int())
      .describe(
        'ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposTransferParams = z.infer<typeof ReposTransferParamsSchema>

  export type ReposTransferResponse = undefined

  export const ReposCheckVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckVulnerabilityAlertsParams = z.infer<
    typeof ReposCheckVulnerabilityAlertsParamsSchema
  >

  export type ReposCheckVulnerabilityAlertsResponse = undefined

  export const ReposEnableVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnableVulnerabilityAlertsParams = z.infer<
    typeof ReposEnableVulnerabilityAlertsParamsSchema
  >

  export type ReposEnableVulnerabilityAlertsResponse = undefined

  export const ReposDisableVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDisableVulnerabilityAlertsParams = z.infer<
    typeof ReposDisableVulnerabilityAlertsParamsSchema
  >

  export type ReposDisableVulnerabilityAlertsResponse = undefined

  export const ReposDownloadZipballArchiveParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z.string()
  })
  export type ReposDownloadZipballArchiveParams = z.infer<
    typeof ReposDownloadZipballArchiveParamsSchema
  >

  export type ReposDownloadZipballArchiveResponse = undefined

  export const ReposCreateUsingTemplateParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.'
      )
      .optional(),
    name: z.string().describe('The name of the new repository.'),
    description: z
      .string()
      .describe('A short description of the new repository.')
      .optional(),
    include_all_branches: z
      .boolean()
      .describe(
        'Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.'
      )
      .default(false),
    private: z
      .boolean()
      .describe(
        'Either `true` to create a new private repository or `false` to create a new public one.'
      )
      .default(false),
    template_owner: z
      .string()
      .describe(
        'The account owner of the template repository. The name is not case sensitive.'
      ),
    template_repo: z
      .string()
      .describe(
        'The name of the template repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateUsingTemplateParams = z.infer<
    typeof ReposCreateUsingTemplateParamsSchema
  >

  export type ReposCreateUsingTemplateResponse = undefined

  export const ReposListPublicParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe(
        'A repository ID. Only return repositories with an ID greater than this ID.'
      )
      .optional()
  })
  export type ReposListPublicParams = z.infer<
    typeof ReposListPublicParamsSchema
  >

  export const ReposListPublicResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListPublicResponse = z.infer<
    typeof ReposListPublicResponseSchema
  >

  export const SearchCodeParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)" for a detailed list of qualifiers.'
      ),
    sort: z
      .literal('indexed')
      .describe(
        '**This field is closing down.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        '**This field is closing down.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. '
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchCodeParams = z.infer<typeof SearchCodeParamsSchema>

  export const SearchCodeResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(CodeSearchResultItemSchema)
  })
  export type SearchCodeResponse = z.infer<typeof SearchCodeResponseSchema>

  export const SearchCommitsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['author-date', 'committer-date'])
      .describe(
        'Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchCommitsParams = z.infer<typeof SearchCommitsParamsSchema>

  export const SearchCommitsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(CommitSearchResultItemSchema)
  })
  export type SearchCommitsResponse = z.infer<
    typeof SearchCommitsResponseSchema
  >

  export const SearchIssuesAndPullRequestsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum([
        'comments',
        'reactions',
        'reactions-+1',
        'reactions--1',
        'reactions-smile',
        'reactions-thinking_face',
        'reactions-heart',
        'reactions-tada',
        'interactions',
        'created',
        'updated'
      ])
      .describe(
        'Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    advanced_search: z
      .string()
      .describe(
        'Set to `true` to use advanced search.\nExample: `http://api.github.com/search/issues?q={query}&advanced_search=true`'
      )
      .optional()
  })
  export type SearchIssuesAndPullRequestsParams = z.infer<
    typeof SearchIssuesAndPullRequestsParamsSchema
  >

  export const SearchIssuesAndPullRequestsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(IssueSearchResultItemSchema)
  })
  export type SearchIssuesAndPullRequestsResponse = z.infer<
    typeof SearchIssuesAndPullRequestsResponseSchema
  >

  export const SearchLabelsParamsSchema = z.object({
    repository_id: z.number().int().describe('The id of the repository.'),
    q: z
      .string()
      .describe(
        'The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).'
      ),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchLabelsParams = z.infer<typeof SearchLabelsParamsSchema>

  export const SearchLabelsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(LabelSearchResultItemSchema)
  })
  export type SearchLabelsResponse = z.infer<typeof SearchLabelsResponseSchema>

  export const SearchReposParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['stars', 'forks', 'help-wanted-issues', 'updated'])
      .describe(
        'Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchReposParams = z.infer<typeof SearchReposParamsSchema>

  export const SearchReposResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(RepoSearchResultItemSchema)
  })
  export type SearchReposResponse = z.infer<typeof SearchReposResponseSchema>

  export const SearchTopicsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchTopicsParams = z.infer<typeof SearchTopicsParamsSchema>

  export const SearchTopicsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(TopicSearchResultItemSchema)
  })
  export type SearchTopicsResponse = z.infer<typeof SearchTopicsResponseSchema>

  export const SearchUsersParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['followers', 'repositories', 'joined'])
      .describe(
        'Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchUsersParams = z.infer<typeof SearchUsersParamsSchema>

  export const SearchUsersResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(UserSearchResultItemSchema)
  })
  export type SearchUsersResponse = z.infer<typeof SearchUsersResponseSchema>

  export const TeamsGetLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsGetLegacyParams = z.infer<typeof TeamsGetLegacyParamsSchema>

  export const TeamsGetLegacyResponseSchema = TeamFullSchema
  export type TeamsGetLegacyResponse = z.infer<
    typeof TeamsGetLegacyResponseSchema
  >

  export const TeamsDeleteLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsDeleteLegacyParams = z.infer<
    typeof TeamsDeleteLegacyParamsSchema
  >

  export type TeamsDeleteLegacyResponse = undefined

  export const TeamsUpdateLegacyParamsSchema = z.object({
    name: z.string().describe('The name of the team.'),
    description: z.string().describe('The description of the team.').optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsUpdateLegacyParams = z.infer<
    typeof TeamsUpdateLegacyParamsSchema
  >

  export const TeamsUpdateLegacyResponseSchema = TeamFullSchema
  export type TeamsUpdateLegacyResponse = z.infer<
    typeof TeamsUpdateLegacyResponseSchema
  >

  export const TeamsListDiscussionsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionsLegacyParams = z.infer<
    typeof TeamsListDiscussionsLegacyParamsSchema
  >

  export const TeamsListDiscussionsLegacyResponseSchema =
    z.array(TeamDiscussionSchema)
  export type TeamsListDiscussionsLegacyResponse = z.infer<
    typeof TeamsListDiscussionsLegacyResponseSchema
  >

  export const TeamsCreateDiscussionLegacyParamsSchema = z.object({
    title: z.string().describe("The discussion post's title."),
    body: z.string().describe("The discussion post's body text."),
    private: z
      .boolean()
      .describe(
        'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.'
      )
      .default(false),
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsCreateDiscussionLegacyParams = z.infer<
    typeof TeamsCreateDiscussionLegacyParamsSchema
  >

  export type TeamsCreateDiscussionLegacyResponse = undefined

  export const TeamsGetDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsGetDiscussionLegacyParams = z.infer<
    typeof TeamsGetDiscussionLegacyParamsSchema
  >

  export const TeamsGetDiscussionLegacyResponseSchema = TeamDiscussionSchema
  export type TeamsGetDiscussionLegacyResponse = z.infer<
    typeof TeamsGetDiscussionLegacyResponseSchema
  >

  export const TeamsDeleteDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsDeleteDiscussionLegacyParams = z.infer<
    typeof TeamsDeleteDiscussionLegacyParamsSchema
  >

  export type TeamsDeleteDiscussionLegacyResponse = undefined

  export const TeamsUpdateDiscussionLegacyParamsSchema = z.object({
    title: z.string().describe("The discussion post's title.").optional(),
    body: z.string().describe("The discussion post's body text.").optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsUpdateDiscussionLegacyParams = z.infer<
    typeof TeamsUpdateDiscussionLegacyParamsSchema
  >

  export const TeamsUpdateDiscussionLegacyResponseSchema = TeamDiscussionSchema
  export type TeamsUpdateDiscussionLegacyResponse = z.infer<
    typeof TeamsUpdateDiscussionLegacyResponseSchema
  >

  export const TeamsListDiscussionCommentsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionCommentsLegacyParams = z.infer<
    typeof TeamsListDiscussionCommentsLegacyParamsSchema
  >

  export const TeamsListDiscussionCommentsLegacyResponseSchema = z.array(
    TeamDiscussionCommentSchema
  )
  export type TeamsListDiscussionCommentsLegacyResponse = z.infer<
    typeof TeamsListDiscussionCommentsLegacyResponseSchema
  >

  export const TeamsCreateDiscussionCommentLegacyParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsCreateDiscussionCommentLegacyParams = z.infer<
    typeof TeamsCreateDiscussionCommentLegacyParamsSchema
  >

  export type TeamsCreateDiscussionCommentLegacyResponse = undefined

  export const TeamsGetDiscussionCommentLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsGetDiscussionCommentLegacyParams = z.infer<
    typeof TeamsGetDiscussionCommentLegacyParamsSchema
  >

  export const TeamsGetDiscussionCommentLegacyResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsGetDiscussionCommentLegacyResponse = z.infer<
    typeof TeamsGetDiscussionCommentLegacyResponseSchema
  >

  export const TeamsDeleteDiscussionCommentLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsDeleteDiscussionCommentLegacyParams = z.infer<
    typeof TeamsDeleteDiscussionCommentLegacyParamsSchema
  >

  export type TeamsDeleteDiscussionCommentLegacyResponse = undefined

  export const TeamsUpdateDiscussionCommentLegacyParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsUpdateDiscussionCommentLegacyParams = z.infer<
    typeof TeamsUpdateDiscussionCommentLegacyParamsSchema
  >

  export const TeamsUpdateDiscussionCommentLegacyResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsUpdateDiscussionCommentLegacyResponse = z.infer<
    typeof TeamsUpdateDiscussionCommentLegacyResponseSchema
  >

  export const ReactionsListForTeamDiscussionCommentLegacyParamsSchema =
    z.object({
      team_id: z.number().int().describe('The unique identifier of the team.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.'),
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ReactionsListForTeamDiscussionCommentLegacyParams = z.infer<
    typeof ReactionsListForTeamDiscussionCommentLegacyParamsSchema
  >

  export const ReactionsListForTeamDiscussionCommentLegacyResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionCommentLegacyResponse = z.infer<
    typeof ReactionsListForTeamDiscussionCommentLegacyResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentLegacyParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.'
        ),
      team_id: z.number().int().describe('The unique identifier of the team.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.')
    })
  export type ReactionsCreateForTeamDiscussionCommentLegacyParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentLegacyParamsSchema
  >

  export type ReactionsCreateForTeamDiscussionCommentLegacyResponse = undefined

  export const ReactionsListForTeamDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForTeamDiscussionLegacyParams = z.infer<
    typeof ReactionsListForTeamDiscussionLegacyParamsSchema
  >

  export const ReactionsListForTeamDiscussionLegacyResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionLegacyResponse = z.infer<
    typeof ReactionsListForTeamDiscussionLegacyResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionLegacyParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.'
      ),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type ReactionsCreateForTeamDiscussionLegacyParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionLegacyParamsSchema
  >

  export type ReactionsCreateForTeamDiscussionLegacyResponse = undefined

  export const TeamsListPendingInvitationsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListPendingInvitationsLegacyParams = z.infer<
    typeof TeamsListPendingInvitationsLegacyParamsSchema
  >

  export const TeamsListPendingInvitationsLegacyResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type TeamsListPendingInvitationsLegacyResponse = z.infer<
    typeof TeamsListPendingInvitationsLegacyResponseSchema
  >

  export const TeamsListMembersLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    role: z
      .enum(['member', 'maintainer', 'all'])
      .describe('Filters members returned by their role in the team.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListMembersLegacyParams = z.infer<
    typeof TeamsListMembersLegacyParamsSchema
  >

  export const TeamsListMembersLegacyResponseSchema = z.array(SimpleUserSchema)
  export type TeamsListMembersLegacyResponse = z.infer<
    typeof TeamsListMembersLegacyResponseSchema
  >

  export const TeamsGetMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMemberLegacyParams = z.infer<
    typeof TeamsGetMemberLegacyParamsSchema
  >

  export type TeamsGetMemberLegacyResponse = undefined

  export const TeamsAddMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddMemberLegacyParams = z.infer<
    typeof TeamsAddMemberLegacyParamsSchema
  >

  export type TeamsAddMemberLegacyResponse = undefined

  export const TeamsRemoveMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMemberLegacyParams = z.infer<
    typeof TeamsRemoveMemberLegacyParamsSchema
  >

  export type TeamsRemoveMemberLegacyResponse = undefined

  export const TeamsGetMembershipForUserLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMembershipForUserLegacyParams = z.infer<
    typeof TeamsGetMembershipForUserLegacyParamsSchema
  >

  export const TeamsGetMembershipForUserLegacyResponseSchema =
    TeamMembershipSchema
  export type TeamsGetMembershipForUserLegacyResponse = z.infer<
    typeof TeamsGetMembershipForUserLegacyResponseSchema
  >

  export const TeamsAddOrUpdateMembershipForUserLegacyParamsSchema = z.object({
    role: z
      .enum(['member', 'maintainer'])
      .describe('The role that this user should have in the team.')
      .default('member'),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddOrUpdateMembershipForUserLegacyParams = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserLegacyParamsSchema
  >

  export const TeamsAddOrUpdateMembershipForUserLegacyResponseSchema =
    TeamMembershipSchema
  export type TeamsAddOrUpdateMembershipForUserLegacyResponse = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserLegacyResponseSchema
  >

  export const TeamsRemoveMembershipForUserLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMembershipForUserLegacyParams = z.infer<
    typeof TeamsRemoveMembershipForUserLegacyParamsSchema
  >

  export type TeamsRemoveMembershipForUserLegacyResponse = undefined

  export const TeamsListProjectsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListProjectsLegacyParams = z.infer<
    typeof TeamsListProjectsLegacyParamsSchema
  >

  export const TeamsListProjectsLegacyResponseSchema =
    z.array(TeamProjectSchema)
  export type TeamsListProjectsLegacyResponse = z.infer<
    typeof TeamsListProjectsLegacyResponseSchema
  >

  export const TeamsCheckPermissionsForProjectLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsCheckPermissionsForProjectLegacyParams = z.infer<
    typeof TeamsCheckPermissionsForProjectLegacyParamsSchema
  >

  export const TeamsCheckPermissionsForProjectLegacyResponseSchema =
    TeamProjectSchema
  export type TeamsCheckPermissionsForProjectLegacyResponse = z.infer<
    typeof TeamsCheckPermissionsForProjectLegacyResponseSchema
  >

  export const TeamsAddOrUpdateProjectPermissionsLegacyParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe(
        'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."'
      )
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsAddOrUpdateProjectPermissionsLegacyParams = z.infer<
    typeof TeamsAddOrUpdateProjectPermissionsLegacyParamsSchema
  >

  export type TeamsAddOrUpdateProjectPermissionsLegacyResponse = undefined

  export const TeamsRemoveProjectLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsRemoveProjectLegacyParams = z.infer<
    typeof TeamsRemoveProjectLegacyParamsSchema
  >

  export type TeamsRemoveProjectLegacyResponse = undefined

  export const TeamsListReposLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListReposLegacyParams = z.infer<
    typeof TeamsListReposLegacyParamsSchema
  >

  export const TeamsListReposLegacyResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type TeamsListReposLegacyResponse = z.infer<
    typeof TeamsListReposLegacyResponseSchema
  >

  export const TeamsCheckPermissionsForRepoLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsCheckPermissionsForRepoLegacyParams = z.infer<
    typeof TeamsCheckPermissionsForRepoLegacyParamsSchema
  >

  export const TeamsCheckPermissionsForRepoLegacyResponseSchema =
    TeamRepositorySchema
  export type TeamsCheckPermissionsForRepoLegacyResponse = z.infer<
    typeof TeamsCheckPermissionsForRepoLegacyResponseSchema
  >

  export const TeamsAddOrUpdateRepoPermissionsLegacyParamsSchema = z.object({
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        "The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."
      )
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsAddOrUpdateRepoPermissionsLegacyParams = z.infer<
    typeof TeamsAddOrUpdateRepoPermissionsLegacyParamsSchema
  >

  export type TeamsAddOrUpdateRepoPermissionsLegacyResponse = undefined

  export const TeamsRemoveRepoLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsRemoveRepoLegacyParams = z.infer<
    typeof TeamsRemoveRepoLegacyParamsSchema
  >

  export type TeamsRemoveRepoLegacyResponse = undefined

  export const TeamsListChildLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListChildLegacyParams = z.infer<
    typeof TeamsListChildLegacyParamsSchema
  >

  export const TeamsListChildLegacyResponseSchema = z.array(TeamSchema)
  export type TeamsListChildLegacyResponse = z.infer<
    typeof TeamsListChildLegacyResponseSchema
  >

  export const UsersGetAuthenticatedParamsSchema = z.object({})
  export type UsersGetAuthenticatedParams = z.infer<
    typeof UsersGetAuthenticatedParamsSchema
  >

  export const UsersGetAuthenticatedResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetAuthenticatedResponse = z.infer<
    typeof UsersGetAuthenticatedResponseSchema
  >

  export const UsersUpdateAuthenticatedParamsSchema = z.object({
    name: z.string().describe('The new name of the user.').optional(),
    email: z
      .string()
      .describe('The publicly visible email address of the user.')
      .optional(),
    blog: z.string().describe('The new blog URL of the user.').optional(),
    twitter_username: z
      .string()
      .describe('The new Twitter username of the user.')
      .optional(),
    company: z.string().describe('The new company of the user.').optional(),
    location: z.string().describe('The new location of the user.').optional(),
    hireable: z
      .boolean()
      .describe('The new hiring availability of the user.')
      .optional(),
    bio: z.string().describe('The new short biography of the user.').optional()
  })
  export type UsersUpdateAuthenticatedParams = z.infer<
    typeof UsersUpdateAuthenticatedParamsSchema
  >

  export const UsersUpdateAuthenticatedResponseSchema = PrivateUserSchema
  export type UsersUpdateAuthenticatedResponse = z.infer<
    typeof UsersUpdateAuthenticatedResponseSchema
  >

  export const UsersListBlockedByAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListBlockedByAuthenticatedUserParams = z.infer<
    typeof UsersListBlockedByAuthenticatedUserParamsSchema
  >

  export const UsersListBlockedByAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListBlockedByAuthenticatedUserResponse = z.infer<
    typeof UsersListBlockedByAuthenticatedUserResponseSchema
  >

  export const UsersCheckBlockedParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersCheckBlockedParams = z.infer<
    typeof UsersCheckBlockedParamsSchema
  >

  export type UsersCheckBlockedResponse = undefined

  export const UsersBlockParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersBlockParams = z.infer<typeof UsersBlockParamsSchema>

  export type UsersBlockResponse = undefined

  export const UsersUnblockParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersUnblockParams = z.infer<typeof UsersUnblockParamsSchema>

  export type UsersUnblockResponse = undefined

  export const CodespacesListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    repository_id: z
      .number()
      .int()
      .describe('ID of the Repository to filter on')
      .optional()
  })
  export type CodespacesListForAuthenticatedUserParams = z.infer<
    typeof CodespacesListForAuthenticatedUserParamsSchema
  >

  export const CodespacesListForAuthenticatedUserResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesListForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z.object({
          repository_id: z
            .number()
            .int()
            .describe('Repository id for this codespace'),
          ref: z
            .string()
            .describe('Git ref (typically a branch name) for this codespace')
            .optional(),
          location: z
            .string()
            .describe(
              'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
            )
            .optional(),
          geo: z
            .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
            .describe(
              'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
            )
            .optional(),
          client_ip: z
            .string()
            .describe('IP for location auto-detection when proxying a request')
            .optional(),
          machine: z
            .string()
            .describe('Machine type to use for this codespace')
            .optional(),
          devcontainer_path: z
            .string()
            .describe(
              'Path to devcontainer.json config to use for this codespace'
            )
            .optional(),
          multi_repo_permissions_opt_out: z
            .boolean()
            .describe(
              'Whether to authorize requested permissions from devcontainer.json'
            )
            .optional(),
          working_directory: z
            .string()
            .describe('Working directory for this codespace')
            .optional(),
          idle_timeout_minutes: z
            .number()
            .int()
            .describe('Time in minutes before codespace stops from inactivity')
            .optional(),
          display_name: z
            .string()
            .describe('Display name for this codespace')
            .optional(),
          retention_period_minutes: z
            .number()
            .int()
            .describe(
              'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
            )
            .optional()
        }),
        z.object({
          pull_request: z
            .object({
              pull_request_number: z
                .number()
                .int()
                .describe('Pull request number'),
              repository_id: z
                .number()
                .int()
                .describe('Repository id for this codespace')
            })
            .describe('Pull request number for this codespace'),
          location: z
            .string()
            .describe(
              'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
            )
            .optional(),
          geo: z
            .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
            .describe(
              'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
            )
            .optional(),
          machine: z
            .string()
            .describe('Machine type to use for this codespace')
            .optional(),
          devcontainer_path: z
            .string()
            .describe(
              'Path to devcontainer.json config to use for this codespace'
            )
            .optional(),
          working_directory: z
            .string()
            .describe('Working directory for this codespace')
            .optional(),
          idle_timeout_minutes: z
            .number()
            .int()
            .describe('Time in minutes before codespace stops from inactivity')
            .optional()
        })
      ])
    )
  export type CodespacesCreateForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateForAuthenticatedUserResponse = undefined

  export const CodespacesListSecretsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type CodespacesListSecretsForAuthenticatedUserParams = z.infer<
    typeof CodespacesListSecretsForAuthenticatedUserParamsSchema
  >

  export const CodespacesListSecretsForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      secrets: z.array(CodespacesSecretSchema)
    })
  export type CodespacesListSecretsForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListSecretsForAuthenticatedUserResponseSchema
  >

  export const CodespacesGetPublicKeyForAuthenticatedUserParamsSchema =
    z.object({})
  export type CodespacesGetPublicKeyForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetPublicKeyForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetPublicKeyForAuthenticatedUserResponseSchema =
    CodespacesUserPublicKeySchema
  export type CodespacesGetPublicKeyForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetPublicKeyForAuthenticatedUserResponseSchema
  >

  export const CodespacesGetSecretForAuthenticatedUserParamsSchema = z.object({
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetSecretForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetSecretForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetSecretForAuthenticatedUserResponseSchema =
    CodespacesSecretSchema
  export type CodespacesGetSecretForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetSecretForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateOrUpdateSecretForAuthenticatedUserParamsSchema =
    z.object({
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint.'
        )
        .optional(),
      key_id: z
        .string()
        .describe('ID of the key you used to encrypt the secret.'),
      selected_repository_ids: z
        .array(z.union([z.number().int(), z.string()]))
        .describe(
          'An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.'
        )
        .optional(),
      secret_name: z.string().describe('The name of the secret.')
    })
  export type CodespacesCreateOrUpdateSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesCreateOrUpdateSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesDeleteSecretForAuthenticatedUserParamsSchema =
    z.object({ secret_name: z.string().describe('The name of the secret.') })
  export type CodespacesDeleteSecretForAuthenticatedUserParams = z.infer<
    typeof CodespacesDeleteSecretForAuthenticatedUserParamsSchema
  >

  export type CodespacesDeleteSecretForAuthenticatedUserResponse = undefined

  export const CodespacesListRepositoriesForSecretForAuthenticatedUserParamsSchema =
    z.object({ secret_name: z.string().describe('The name of the secret.') })
  export type CodespacesListRepositoriesForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesListRepositoriesForSecretForAuthenticatedUserParamsSchema
    >

  export const CodespacesListRepositoriesForSecretForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    })
  export type CodespacesListRepositoriesForSecretForAuthenticatedUserResponse =
    z.infer<
      typeof CodespacesListRepositoriesForSecretForAuthenticatedUserResponseSchema
    >

  export const CodespacesSetRepositoriesForSecretForAuthenticatedUserParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.'
        ),
      secret_name: z.string().describe('The name of the secret.')
    })
  export type CodespacesSetRepositoriesForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesSetRepositoriesForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesAddRepositoryForSecretForAuthenticatedUserParamsSchema =
    z.object({
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    })
  export type CodespacesAddRepositoryForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesAddRepositoryForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesAddRepositoryForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamsSchema =
    z.object({
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    })
  export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesGetForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesGetForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetForAuthenticatedUserResponseSchema = CodespaceSchema
  export type CodespacesGetForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetForAuthenticatedUserResponseSchema
  >

  export const CodespacesDeleteForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesDeleteForAuthenticatedUserParams = z.infer<
    typeof CodespacesDeleteForAuthenticatedUserParamsSchema
  >

  export type CodespacesDeleteForAuthenticatedUserResponse = undefined

  export const CodespacesUpdateForAuthenticatedUserParamsSchema = z.object({
    machine: z
      .string()
      .describe('A valid machine to transition this codespace to.')
      .optional(),
    display_name: z
      .string()
      .describe('Display name for this codespace')
      .optional(),
    recent_folders: z
      .array(z.string())
      .describe(
        'Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.'
      )
      .optional(),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesUpdateForAuthenticatedUserParams = z.infer<
    typeof CodespacesUpdateForAuthenticatedUserParamsSchema
  >

  export const CodespacesUpdateForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesUpdateForAuthenticatedUserResponse = z.infer<
    typeof CodespacesUpdateForAuthenticatedUserResponseSchema
  >

  export const CodespacesExportForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesExportForAuthenticatedUserParams = z.infer<
    typeof CodespacesExportForAuthenticatedUserParamsSchema
  >

  export type CodespacesExportForAuthenticatedUserResponse = undefined

  export const CodespacesGetExportDetailsForAuthenticatedUserParamsSchema =
    z.object({
      codespace_name: z.string().describe('The name of the codespace.'),
      export_id: z
        .string()
        .describe(
          'The ID of the export operation, or `latest`. Currently only `latest` is currently supported.'
        )
    })
  export type CodespacesGetExportDetailsForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetExportDetailsForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetExportDetailsForAuthenticatedUserResponseSchema =
    CodespaceExportDetailsSchema
  export type CodespacesGetExportDetailsForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetExportDetailsForAuthenticatedUserResponseSchema
  >

  export const CodespacesCodespaceMachinesForAuthenticatedUserParamsSchema =
    z.object({
      codespace_name: z.string().describe('The name of the codespace.')
    })
  export type CodespacesCodespaceMachinesForAuthenticatedUserParams = z.infer<
    typeof CodespacesCodespaceMachinesForAuthenticatedUserParamsSchema
  >

  export const CodespacesCodespaceMachinesForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      machines: z.array(CodespaceMachineSchema)
    })
  export type CodespacesCodespaceMachinesForAuthenticatedUserResponse = z.infer<
    typeof CodespacesCodespaceMachinesForAuthenticatedUserResponseSchema
  >

  export const CodespacesPublishForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('A name for the new repository.').optional(),
    private: z
      .boolean()
      .describe('Whether the new repository should be private.')
      .default(false),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesPublishForAuthenticatedUserParams = z.infer<
    typeof CodespacesPublishForAuthenticatedUserParamsSchema
  >

  export type CodespacesPublishForAuthenticatedUserResponse = undefined

  export const CodespacesStartForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStartForAuthenticatedUserParams = z.infer<
    typeof CodespacesStartForAuthenticatedUserParamsSchema
  >

  export const CodespacesStartForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesStartForAuthenticatedUserResponse = z.infer<
    typeof CodespacesStartForAuthenticatedUserResponseSchema
  >

  export const CodespacesStopForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStopForAuthenticatedUserParams = z.infer<
    typeof CodespacesStopForAuthenticatedUserParamsSchema
  >

  export const CodespacesStopForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesStopForAuthenticatedUserResponse = z.infer<
    typeof CodespacesStopForAuthenticatedUserResponseSchema
  >

  export const PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParamsSchema =
    z.object({})
  export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseSchema
    >

  export const UsersSetPrimaryEmailVisibilityForAuthenticatedUserParamsSchema =
    z.object({
      visibility: z
        .enum(['public', 'private'])
        .describe('Denotes whether an email is publicly visible.')
    })
  export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserParams =
    z.infer<
      typeof UsersSetPrimaryEmailVisibilityForAuthenticatedUserParamsSchema
    >

  export const UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse =
    z.infer<
      typeof UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponseSchema
    >

  export const UsersListEmailsForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListEmailsForAuthenticatedUserParams = z.infer<
    typeof UsersListEmailsForAuthenticatedUserParamsSchema
  >

  export const UsersListEmailsForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersListEmailsForAuthenticatedUserResponse = z.infer<
    typeof UsersListEmailsForAuthenticatedUserResponseSchema
  >

  export const UsersAddEmailForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z.object({
          emails: z
            .array(z.string())
            .min(1)
            .describe(
              'Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.'
            )
        }),
        z.array(z.string()).min(1),
        z.string()
      ])
    )
  export type UsersAddEmailForAuthenticatedUserParams = z.infer<
    typeof UsersAddEmailForAuthenticatedUserParamsSchema
  >

  export type UsersAddEmailForAuthenticatedUserResponse = undefined

  export const UsersDeleteEmailForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z
          .object({
            emails: z
              .array(z.string())
              .min(1)
              .describe(
                'Email addresses associated with the GitHub user account.'
              )
          })
          .describe(
            'Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.'
          ),
        z.array(z.string()).min(1),
        z.string()
      ])
    )
  export type UsersDeleteEmailForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteEmailForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteEmailForAuthenticatedUserResponse = undefined

  export const UsersListFollowersForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowersForAuthenticatedUserParams = z.infer<
    typeof UsersListFollowersForAuthenticatedUserParamsSchema
  >

  export const UsersListFollowersForAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowersForAuthenticatedUserResponse = z.infer<
    typeof UsersListFollowersForAuthenticatedUserResponseSchema
  >

  export const UsersListFollowedByAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowedByAuthenticatedUserParams = z.infer<
    typeof UsersListFollowedByAuthenticatedUserParamsSchema
  >

  export const UsersListFollowedByAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowedByAuthenticatedUserResponse = z.infer<
    typeof UsersListFollowedByAuthenticatedUserResponseSchema
  >

  export const UsersCheckPersonIsFollowedByAuthenticatedParamsSchema = z.object(
    { username: z.string().describe('The handle for the GitHub user account.') }
  )
  export type UsersCheckPersonIsFollowedByAuthenticatedParams = z.infer<
    typeof UsersCheckPersonIsFollowedByAuthenticatedParamsSchema
  >

  export type UsersCheckPersonIsFollowedByAuthenticatedResponse = undefined

  export const UsersFollowParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersFollowParams = z.infer<typeof UsersFollowParamsSchema>

  export type UsersFollowResponse = undefined

  export const UsersUnfollowParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersUnfollowParams = z.infer<typeof UsersUnfollowParamsSchema>

  export type UsersUnfollowResponse = undefined

  export const UsersListGpgKeysForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListGpgKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListGpgKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListGpgKeysForAuthenticatedUserResponseSchema =
    z.array(GpgKeySchema)
  export type UsersListGpgKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListGpgKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreateGpgKeyForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('A descriptive name for the new key.').optional(),
    armored_public_key: z
      .string()
      .describe('A GPG key in ASCII-armored format.')
  })
  export type UsersCreateGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreateGpgKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreateGpgKeyForAuthenticatedUserResponse = undefined

  export const UsersGetGpgKeyForAuthenticatedUserParamsSchema = z.object({
    gpg_key_id: z
      .number()
      .int()
      .describe('The unique identifier of the GPG key.')
  })
  export type UsersGetGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetGpgKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetGpgKeyForAuthenticatedUserResponseSchema = GpgKeySchema
  export type UsersGetGpgKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetGpgKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeleteGpgKeyForAuthenticatedUserParamsSchema = z.object({
    gpg_key_id: z
      .number()
      .int()
      .describe('The unique identifier of the GPG key.')
  })
  export type UsersDeleteGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteGpgKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteGpgKeyForAuthenticatedUserResponse = undefined

  export const AppsListInstallationsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type AppsListInstallationsForAuthenticatedUserParams = z.infer<
    typeof AppsListInstallationsForAuthenticatedUserParamsSchema
  >

  export const AppsListInstallationsForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      installations: z.array(InstallationSchema)
    })
  export type AppsListInstallationsForAuthenticatedUserResponse = z.infer<
    typeof AppsListInstallationsForAuthenticatedUserResponseSchema
  >

  export const AppsListInstallationReposForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListInstallationReposForAuthenticatedUserParams = z.infer<
    typeof AppsListInstallationReposForAuthenticatedUserParamsSchema
  >

  export const AppsListInstallationReposForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      repository_selection: z.string().optional(),
      repositories: z.array(RepositorySchema)
    })
  export type AppsListInstallationReposForAuthenticatedUserResponse = z.infer<
    typeof AppsListInstallationReposForAuthenticatedUserResponseSchema
  >

  export const AppsAddRepoToInstallationForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type AppsAddRepoToInstallationForAuthenticatedUserParams = z.infer<
    typeof AppsAddRepoToInstallationForAuthenticatedUserParamsSchema
  >

  export type AppsAddRepoToInstallationForAuthenticatedUserResponse = undefined

  export const AppsRemoveRepoFromInstallationForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type AppsRemoveRepoFromInstallationForAuthenticatedUserParams =
    z.infer<
      typeof AppsRemoveRepoFromInstallationForAuthenticatedUserParamsSchema
    >

  export type AppsRemoveRepoFromInstallationForAuthenticatedUserResponse =
    undefined

  export const InteractionsGetRestrictionsForAuthenticatedUserParamsSchema =
    z.object({})
  export type InteractionsGetRestrictionsForAuthenticatedUserParams = z.infer<
    typeof InteractionsGetRestrictionsForAuthenticatedUserParamsSchema
  >

  export const InteractionsGetRestrictionsForAuthenticatedUserResponseSchema =
    z.union([InteractionLimitResponseSchema, z.object({}).strict()])
  export type InteractionsGetRestrictionsForAuthenticatedUserResponse = z.infer<
    typeof InteractionsGetRestrictionsForAuthenticatedUserResponseSchema
  >

  export const InteractionsSetRestrictionsForAuthenticatedUserParamsSchema = InteractionLimitSchema
  export type InteractionsSetRestrictionsForAuthenticatedUserParams = z.infer<
    typeof InteractionsSetRestrictionsForAuthenticatedUserParamsSchema
  >

  export const InteractionsSetRestrictionsForAuthenticatedUserResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForAuthenticatedUserResponse = z.infer<
    typeof InteractionsSetRestrictionsForAuthenticatedUserResponseSchema
  >

  export const InteractionsRemoveRestrictionsForAuthenticatedUserParamsSchema =
    z.object({})
  export type InteractionsRemoveRestrictionsForAuthenticatedUserParams =
    z.infer<
      typeof InteractionsRemoveRestrictionsForAuthenticatedUserParamsSchema
    >

  export type InteractionsRemoveRestrictionsForAuthenticatedUserResponse =
    undefined

  export const IssuesListForAuthenticatedUserParamsSchema = z.object({
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForAuthenticatedUserParams = z.infer<
    typeof IssuesListForAuthenticatedUserParamsSchema
  >

  export const IssuesListForAuthenticatedUserResponseSchema =
    z.array(IssueSchema)
  export type IssuesListForAuthenticatedUserResponse = z.infer<
    typeof IssuesListForAuthenticatedUserResponseSchema
  >

  export const UsersListPublicSshKeysForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListPublicSshKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListPublicSshKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListPublicSshKeysForAuthenticatedUserResponseSchema =
    z.array(KeySchema)
  export type UsersListPublicSshKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListPublicSshKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreatePublicSshKeyForAuthenticatedUserParamsSchema =
    z.object({
      title: z
        .string()
        .describe('A descriptive name for the new key.')
        .optional(),
      key: z
        .string()
        .regex(
          new RegExp('^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) ')
        )
        .describe('The public SSH key to add to your GitHub account.')
    })
  export type UsersCreatePublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreatePublicSshKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreatePublicSshKeyForAuthenticatedUserResponse = undefined

  export const UsersGetPublicSshKeyForAuthenticatedUserParamsSchema = z.object({
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type UsersGetPublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetPublicSshKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetPublicSshKeyForAuthenticatedUserResponseSchema =
    KeySchema
  export type UsersGetPublicSshKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetPublicSshKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeletePublicSshKeyForAuthenticatedUserParamsSchema =
    z.object({
      key_id: z.number().int().describe('The unique identifier of the key.')
    })
  export type UsersDeletePublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeletePublicSshKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeletePublicSshKeyForAuthenticatedUserResponse = undefined

  export const AppsListSubscriptionsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type AppsListSubscriptionsForAuthenticatedUserParams = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserParamsSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserResponseSchema =
    z.array(UserMarketplacePurchaseSchema)
  export type AppsListSubscriptionsForAuthenticatedUserResponse = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserResponseSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserStubbedParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListSubscriptionsForAuthenticatedUserStubbedParams = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserStubbedParamsSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserStubbedResponseSchema =
    z.array(UserMarketplacePurchaseSchema)
  export type AppsListSubscriptionsForAuthenticatedUserStubbedResponse =
    z.infer<
      typeof AppsListSubscriptionsForAuthenticatedUserStubbedResponseSchema
    >

  export const OrgsListMembershipsForAuthenticatedUserParamsSchema = z.object({
    state: z
      .enum(['active', 'pending'])
      .describe(
        'Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListMembershipsForAuthenticatedUserParams = z.infer<
    typeof OrgsListMembershipsForAuthenticatedUserParamsSchema
  >

  export const OrgsListMembershipsForAuthenticatedUserResponseSchema =
    z.array(OrgMembershipSchema)
  export type OrgsListMembershipsForAuthenticatedUserResponse = z.infer<
    typeof OrgsListMembershipsForAuthenticatedUserResponseSchema
  >

  export const OrgsGetMembershipForAuthenticatedUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsGetMembershipForAuthenticatedUserParamsSchema
  >

  export const OrgsGetMembershipForAuthenticatedUserResponseSchema =
    OrgMembershipSchema
  export type OrgsGetMembershipForAuthenticatedUserResponse = z.infer<
    typeof OrgsGetMembershipForAuthenticatedUserResponseSchema
  >

  export const OrgsUpdateMembershipForAuthenticatedUserParamsSchema = z.object({
    state: z
      .literal('active')
      .describe(
        'The state that the membership should be in. Only `"active"` will be accepted.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdateMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsUpdateMembershipForAuthenticatedUserParamsSchema
  >

  export const OrgsUpdateMembershipForAuthenticatedUserResponseSchema =
    OrgMembershipSchema
  export type OrgsUpdateMembershipForAuthenticatedUserResponse = z.infer<
    typeof OrgsUpdateMembershipForAuthenticatedUserResponseSchema
  >

  export const MigrationsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListForAuthenticatedUserParams = z.infer<
    typeof MigrationsListForAuthenticatedUserParamsSchema
  >

  export const MigrationsListForAuthenticatedUserResponseSchema =
    z.array(MigrationSchema)
  export type MigrationsListForAuthenticatedUserResponse = z.infer<
    typeof MigrationsListForAuthenticatedUserResponseSchema
  >

  export const MigrationsStartForAuthenticatedUserParamsSchema = z.object({
    lock_repositories: z
      .boolean()
      .describe(
        'Lock the repositories being migrated at the start of the migration'
      )
      .optional(),
    exclude_metadata: z
      .boolean()
      .describe(
        'Indicates whether metadata should be excluded and only git source should be included for the migration.'
      )
      .optional(),
    exclude_git_data: z
      .boolean()
      .describe(
        'Indicates whether the repository git data should be excluded from the migration.'
      )
      .optional(),
    exclude_attachments: z
      .boolean()
      .describe('Do not include attachments in the migration')
      .optional(),
    exclude_releases: z
      .boolean()
      .describe('Do not include releases in the migration')
      .optional(),
    exclude_owner_projects: z
      .boolean()
      .describe(
        'Indicates whether projects owned by the organization or users should be excluded.'
      )
      .optional(),
    org_metadata_only: z
      .boolean()
      .describe(
        'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).'
      )
      .default(false),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional(),
    repositories: z.array(
      z.string().describe('Repository path, owner and name')
    )
  })
  export type MigrationsStartForAuthenticatedUserParams = z.infer<
    typeof MigrationsStartForAuthenticatedUserParamsSchema
  >

  export type MigrationsStartForAuthenticatedUserResponse = undefined

  export const MigrationsGetStatusForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    exclude: z.array(z.string()).optional()
  })
  export type MigrationsGetStatusForAuthenticatedUserParams = z.infer<
    typeof MigrationsGetStatusForAuthenticatedUserParamsSchema
  >

  export const MigrationsGetStatusForAuthenticatedUserResponseSchema =
    MigrationSchema
  export type MigrationsGetStatusForAuthenticatedUserResponse = z.infer<
    typeof MigrationsGetStatusForAuthenticatedUserResponseSchema
  >

  export const MigrationsGetArchiveForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsGetArchiveForAuthenticatedUserParams = z.infer<
    typeof MigrationsGetArchiveForAuthenticatedUserParamsSchema
  >

  export type MigrationsGetArchiveForAuthenticatedUserResponse = undefined

  export const MigrationsDeleteArchiveForAuthenticatedUserParamsSchema =
    z.object({
      migration_id: z
        .number()
        .int()
        .describe('The unique identifier of the migration.')
    })
  export type MigrationsDeleteArchiveForAuthenticatedUserParams = z.infer<
    typeof MigrationsDeleteArchiveForAuthenticatedUserParamsSchema
  >

  export type MigrationsDeleteArchiveForAuthenticatedUserResponse = undefined

  export const MigrationsUnlockRepoForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    repo_name: z.string().describe('repo_name parameter')
  })
  export type MigrationsUnlockRepoForAuthenticatedUserParams = z.infer<
    typeof MigrationsUnlockRepoForAuthenticatedUserParamsSchema
  >

  export type MigrationsUnlockRepoForAuthenticatedUserResponse = undefined

  export const MigrationsListReposForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListReposForAuthenticatedUserParams = z.infer<
    typeof MigrationsListReposForAuthenticatedUserParamsSchema
  >

  export const MigrationsListReposForAuthenticatedUserResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type MigrationsListReposForAuthenticatedUserResponse = z.infer<
    typeof MigrationsListReposForAuthenticatedUserResponseSchema
  >

  export const OrgsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListForAuthenticatedUserParams = z.infer<
    typeof OrgsListForAuthenticatedUserParamsSchema
  >

  export const OrgsListForAuthenticatedUserResponseSchema = z.array(
    OrganizationSimpleSchema
  )
  export type OrgsListForAuthenticatedUserResponse = z.infer<
    typeof OrgsListForAuthenticatedUserResponseSchema
  >

  export const PackagesListPackagesForAuthenticatedUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForAuthenticatedUserParams = z.infer<
    typeof PackagesListPackagesForAuthenticatedUserParamsSchema
  >

  export const PackagesListPackagesForAuthenticatedUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForAuthenticatedUserResponse = z.infer<
    typeof PackagesListPackagesForAuthenticatedUserResponseSchema
  >

  export const PackagesGetPackageForAuthenticatedUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.')
  })
  export type PackagesGetPackageForAuthenticatedUserParams = z.infer<
    typeof PackagesGetPackageForAuthenticatedUserParamsSchema
  >

  export const PackagesGetPackageForAuthenticatedUserResponseSchema =
    PackageSchema
  export type PackagesGetPackageForAuthenticatedUserResponse = z.infer<
    typeof PackagesGetPackageForAuthenticatedUserResponseSchema
  >

  export const PackagesDeletePackageForAuthenticatedUserParamsSchema = z.object(
    {
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.')
    }
  )
  export type PackagesDeletePackageForAuthenticatedUserParams = z.infer<
    typeof PackagesDeletePackageForAuthenticatedUserParamsSchema
  >

  export type PackagesDeletePackageForAuthenticatedUserResponse = undefined

  export const PackagesRestorePackageForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      token: z.string().describe('package token').optional()
    })
  export type PackagesRestorePackageForAuthenticatedUserParams = z.infer<
    typeof PackagesRestorePackageForAuthenticatedUserParamsSchema
  >

  export type PackagesRestorePackageForAuthenticatedUserResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['active', 'deleted'])
        .describe('The state of the package, either active or deleted.')
        .default('active')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsSchema
    >

  export const PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseSchema
    >

  export const PackagesGetPackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesGetPackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesGetPackageVersionForAuthenticatedUserParamsSchema
  >

  export const PackagesGetPackageVersionForAuthenticatedUserResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForAuthenticatedUserResponse = z.infer<
    typeof PackagesGetPackageVersionForAuthenticatedUserResponseSchema
  >

  export const PackagesDeletePackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesDeletePackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesDeletePackageVersionForAuthenticatedUserParamsSchema
  >

  export type PackagesDeletePackageVersionForAuthenticatedUserResponse =
    undefined

  export const PackagesRestorePackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesRestorePackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesRestorePackageVersionForAuthenticatedUserParamsSchema
  >

  export type PackagesRestorePackageVersionForAuthenticatedUserResponse =
    undefined

  export const ProjectsCreateForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('Name of the project'),
    body: z.string().describe('Body of the project').optional()
  })
  export type ProjectsCreateForAuthenticatedUserParams = z.infer<
    typeof ProjectsCreateForAuthenticatedUserParamsSchema
  >

  export type ProjectsCreateForAuthenticatedUserResponse = undefined

  export const UsersListPublicEmailsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type UsersListPublicEmailsForAuthenticatedUserParams = z.infer<
    typeof UsersListPublicEmailsForAuthenticatedUserParamsSchema
  >

  export const UsersListPublicEmailsForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersListPublicEmailsForAuthenticatedUserResponse = z.infer<
    typeof UsersListPublicEmailsForAuthenticatedUserResponseSchema
  >

  export const ReposListForAuthenticatedUserParamsSchema = z.object({
    visibility: z
      .enum(['all', 'public', 'private'])
      .describe('Limit results to repositories with the specified visibility.')
      .default('all'),
    affiliation: z
      .string()
      .describe(
        'Comma-separated list of values. Can include:  \n * `owner`: Repositories that are owned by the authenticated user.  \n * `collaborator`: Repositories that the user has been added to as a collaborator.  \n * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.'
      )
      .default('owner,collaborator,organization_member'),
    type: z
      .enum(['all', 'owner', 'public', 'private', 'member'])
      .describe(
        'Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.'
      )
      .default('all'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('full_name'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ReposListForAuthenticatedUserParams = z.infer<
    typeof ReposListForAuthenticatedUserParamsSchema
  >

  export const ReposListForAuthenticatedUserResponseSchema =
    z.array(RepositorySchema)
  export type ReposListForAuthenticatedUserResponse = z.infer<
    typeof ReposListForAuthenticatedUserResponseSchema
  >

  export const ReposCreateForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('The name of the repository.'),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe('Whether the repository is private.')
      .default(false),
    has_issues: z
      .boolean()
      .describe('Whether issues are enabled.')
      .default(true),
    has_projects: z
      .boolean()
      .describe('Whether projects are enabled.')
      .default(true),
    has_wiki: z
      .boolean()
      .describe('Whether the wiki is enabled.')
      .default(true),
    has_discussions: z
      .boolean()
      .describe('Whether discussions are enabled.')
      .default(false),
    team_id: z
      .number()
      .int()
      .describe(
        'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
      )
      .optional(),
    auto_init: z
      .boolean()
      .describe('Whether the repository is initialized with a minimal README.')
      .default(false),
    gitignore_template: z
      .string()
      .describe('The desired language or platform to apply to the .gitignore.')
      .optional(),
    license_template: z
      .string()
      .describe(
        'The license keyword of the open source license for this repository.'
      )
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe('Whether to allow squash merges for pull requests.')
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe('Whether to allow merge commits for pull requests.')
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe('Whether to allow rebase merges for pull requests.')
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe('Whether to allow Auto-merge to be used on pull requests.')
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe('Whether to delete head branches when pull requests are merged')
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    has_downloads: z
      .boolean()
      .describe('Whether downloads are enabled.')
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Whether this repository acts as a template that can be used to generate new repositories.'
      )
      .default(false)
  })
  export type ReposCreateForAuthenticatedUserParams = z.infer<
    typeof ReposCreateForAuthenticatedUserParamsSchema
  >

  export type ReposCreateForAuthenticatedUserResponse = undefined

  export const ReposListInvitationsForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListInvitationsForAuthenticatedUserParams = z.infer<
    typeof ReposListInvitationsForAuthenticatedUserParamsSchema
  >

  export const ReposListInvitationsForAuthenticatedUserResponseSchema = z.array(
    RepositoryInvitationSchema
  )
  export type ReposListInvitationsForAuthenticatedUserResponse = z.infer<
    typeof ReposListInvitationsForAuthenticatedUserResponseSchema
  >

  export const ReposDeclineInvitationForAuthenticatedUserParamsSchema =
    z.object({
      invitation_id: z
        .number()
        .int()
        .describe('The unique identifier of the invitation.')
    })
  export type ReposDeclineInvitationForAuthenticatedUserParams = z.infer<
    typeof ReposDeclineInvitationForAuthenticatedUserParamsSchema
  >

  export type ReposDeclineInvitationForAuthenticatedUserResponse = undefined

  export const ReposAcceptInvitationForAuthenticatedUserParamsSchema = z.object(
    {
      invitation_id: z
        .number()
        .int()
        .describe('The unique identifier of the invitation.')
    }
  )
  export type ReposAcceptInvitationForAuthenticatedUserParams = z.infer<
    typeof ReposAcceptInvitationForAuthenticatedUserParamsSchema
  >

  export type ReposAcceptInvitationForAuthenticatedUserResponse = undefined

  export const UsersListSocialAccountsForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListSocialAccountsForAuthenticatedUserParams = z.infer<
    typeof UsersListSocialAccountsForAuthenticatedUserParamsSchema
  >

  export const UsersListSocialAccountsForAuthenticatedUserResponseSchema =
    z.array(SocialAccountSchema)
  export type UsersListSocialAccountsForAuthenticatedUserResponse = z.infer<
    typeof UsersListSocialAccountsForAuthenticatedUserResponseSchema
  >

  export const UsersAddSocialAccountForAuthenticatedUserParamsSchema = z.object(
    {
      account_urls: z
        .array(z.string())
        .describe('Full URLs for the social media profiles to add.')
    }
  )
  export type UsersAddSocialAccountForAuthenticatedUserParams = z.infer<
    typeof UsersAddSocialAccountForAuthenticatedUserParamsSchema
  >

  export type UsersAddSocialAccountForAuthenticatedUserResponse = undefined

  export const UsersDeleteSocialAccountForAuthenticatedUserParamsSchema =
    z.object({
      account_urls: z
        .array(z.string())
        .describe('Full URLs for the social media profiles to delete.')
    })
  export type UsersDeleteSocialAccountForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteSocialAccountForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteSocialAccountForAuthenticatedUserResponse = undefined

  export const UsersListSshSigningKeysForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListSshSigningKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListSshSigningKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListSshSigningKeysForAuthenticatedUserResponseSchema =
    z.array(SshSigningKeySchema)
  export type UsersListSshSigningKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListSshSigningKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreateSshSigningKeyForAuthenticatedUserParamsSchema =
    z.object({
      title: z
        .string()
        .describe('A descriptive name for the new key.')
        .optional(),
      key: z
        .string()
        .regex(
          new RegExp(
            '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com '
          )
        )
        .describe(
          'The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."'
        )
    })
  export type UsersCreateSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreateSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreateSshSigningKeyForAuthenticatedUserResponse = undefined

  export const UsersGetSshSigningKeyForAuthenticatedUserParamsSchema = z.object(
    {
      ssh_signing_key_id: z
        .number()
        .int()
        .describe('The unique identifier of the SSH signing key.')
    }
  )
  export type UsersGetSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetSshSigningKeyForAuthenticatedUserResponseSchema =
    SshSigningKeySchema
  export type UsersGetSshSigningKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetSshSigningKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeleteSshSigningKeyForAuthenticatedUserParamsSchema =
    z.object({
      ssh_signing_key_id: z
        .number()
        .int()
        .describe('The unique identifier of the SSH signing key.')
    })
  export type UsersDeleteSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteSshSigningKeyForAuthenticatedUserResponse = undefined

  export const ActivityListReposStarredByAuthenticatedUserParamsSchema =
    z.object({
      sort: z
        .enum(['created', 'updated'])
        .describe(
          'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
        )
        .default('created'),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListReposStarredByAuthenticatedUserParams = z.infer<
    typeof ActivityListReposStarredByAuthenticatedUserParamsSchema
  >

  export const ActivityListReposStarredByAuthenticatedUserResponseSchema =
    z.array(RepositorySchema)
  export type ActivityListReposStarredByAuthenticatedUserResponse = z.infer<
    typeof ActivityListReposStarredByAuthenticatedUserResponseSchema
  >

  export const ActivityCheckRepoIsStarredByAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActivityCheckRepoIsStarredByAuthenticatedUserParams = z.infer<
    typeof ActivityCheckRepoIsStarredByAuthenticatedUserParamsSchema
  >

  export type ActivityCheckRepoIsStarredByAuthenticatedUserResponse = undefined

  export const ActivityStarRepoForAuthenticatedUserParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityStarRepoForAuthenticatedUserParams = z.infer<
    typeof ActivityStarRepoForAuthenticatedUserParamsSchema
  >

  export type ActivityStarRepoForAuthenticatedUserResponse = undefined

  export const ActivityUnstarRepoForAuthenticatedUserParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityUnstarRepoForAuthenticatedUserParams = z.infer<
    typeof ActivityUnstarRepoForAuthenticatedUserParamsSchema
  >

  export type ActivityUnstarRepoForAuthenticatedUserResponse = undefined

  export const ActivityListWatchedReposForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListWatchedReposForAuthenticatedUserParams = z.infer<
    typeof ActivityListWatchedReposForAuthenticatedUserParamsSchema
  >

  export const ActivityListWatchedReposForAuthenticatedUserResponseSchema =
    z.array(MinimalRepositorySchema)
  export type ActivityListWatchedReposForAuthenticatedUserResponse = z.infer<
    typeof ActivityListWatchedReposForAuthenticatedUserResponseSchema
  >

  export const TeamsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListForAuthenticatedUserParams = z.infer<
    typeof TeamsListForAuthenticatedUserParamsSchema
  >

  export const TeamsListForAuthenticatedUserResponseSchema =
    z.array(TeamFullSchema)
  export type TeamsListForAuthenticatedUserResponse = z.infer<
    typeof TeamsListForAuthenticatedUserResponseSchema
  >

  export const UsersGetByIdParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type UsersGetByIdParams = z.infer<typeof UsersGetByIdParamsSchema>

  export const UsersGetByIdResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetByIdResponse = z.infer<typeof UsersGetByIdResponseSchema>

  export const UsersListParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe('A user ID. Only return users with an ID greater than this ID.')
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type UsersListParams = z.infer<typeof UsersListParamsSchema>

  export const UsersListResponseSchema = z.array(SimpleUserSchema)
  export type UsersListResponse = z.infer<typeof UsersListResponseSchema>

  export const UsersGetByUsernameParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersGetByUsernameParams = z.infer<
    typeof UsersGetByUsernameParamsSchema
  >

  export const UsersGetByUsernameResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetByUsernameResponse = z.infer<
    typeof UsersGetByUsernameResponseSchema
  >

  export const UsersListAttestationsParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    subject_digest: z.string().describe('Subject Digest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type UsersListAttestationsParams = z.infer<
    typeof UsersListAttestationsParamsSchema
  >

  export const UsersListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type UsersListAttestationsResponse = z.infer<
    typeof UsersListAttestationsResponseSchema
  >

  export const PackagesListDockerMigrationConflictingPackagesForUserParamsSchema =
    z.object({
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type PackagesListDockerMigrationConflictingPackagesForUserParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForUserParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForUserResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForUserResponseSchema
    >

  export const ActivityListEventsForAuthenticatedUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListEventsForAuthenticatedUserParams = z.infer<
    typeof ActivityListEventsForAuthenticatedUserParamsSchema
  >

  export const ActivityListEventsForAuthenticatedUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListEventsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListEventsForAuthenticatedUserResponseSchema
  >

  export const ActivityListOrgEventsForAuthenticatedUserParamsSchema = z.object(
    {
      username: z.string().describe('The handle for the GitHub user account.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ActivityListOrgEventsForAuthenticatedUserParams = z.infer<
    typeof ActivityListOrgEventsForAuthenticatedUserParamsSchema
  >

  export const ActivityListOrgEventsForAuthenticatedUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListOrgEventsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListOrgEventsForAuthenticatedUserResponseSchema
  >

  export const ActivityListPublicEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsForUserParams = z.infer<
    typeof ActivityListPublicEventsForUserParamsSchema
  >

  export const ActivityListPublicEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListPublicEventsForUserResponse = z.infer<
    typeof ActivityListPublicEventsForUserResponseSchema
  >

  export const UsersListFollowersForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowersForUserParams = z.infer<
    typeof UsersListFollowersForUserParamsSchema
  >

  export const UsersListFollowersForUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowersForUserResponse = z.infer<
    typeof UsersListFollowersForUserResponseSchema
  >

  export const UsersListFollowingForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowingForUserParams = z.infer<
    typeof UsersListFollowingForUserParamsSchema
  >

  export const UsersListFollowingForUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowingForUserResponse = z.infer<
    typeof UsersListFollowingForUserResponseSchema
  >

  export const UsersCheckFollowingForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    target_user: z.string()
  })
  export type UsersCheckFollowingForUserParams = z.infer<
    typeof UsersCheckFollowingForUserParamsSchema
  >

  export type UsersCheckFollowingForUserResponse = undefined

  export const GistsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListForUserParams = z.infer<
    typeof GistsListForUserParamsSchema
  >

  export const GistsListForUserResponseSchema = z.array(BaseGistSchema)
  export type GistsListForUserResponse = z.infer<
    typeof GistsListForUserResponseSchema
  >

  export const UsersListGpgKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListGpgKeysForUserParams = z.infer<
    typeof UsersListGpgKeysForUserParamsSchema
  >

  export const UsersListGpgKeysForUserResponseSchema = z.array(GpgKeySchema)
  export type UsersListGpgKeysForUserResponse = z.infer<
    typeof UsersListGpgKeysForUserResponseSchema
  >

  export const UsersGetContextForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    subject_type: z
      .enum(['organization', 'repository', 'issue', 'pull_request'])
      .describe(
        "Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`."
      )
      .optional(),
    subject_id: z
      .string()
      .describe(
        'Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.'
      )
      .optional()
  })
  export type UsersGetContextForUserParams = z.infer<
    typeof UsersGetContextForUserParamsSchema
  >

  export const UsersGetContextForUserResponseSchema = HovercardSchema
  export type UsersGetContextForUserResponse = z.infer<
    typeof UsersGetContextForUserResponseSchema
  >

  export const AppsGetUserInstallationParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type AppsGetUserInstallationParams = z.infer<
    typeof AppsGetUserInstallationParamsSchema
  >

  export const AppsGetUserInstallationResponseSchema = InstallationSchema
  export type AppsGetUserInstallationResponse = z.infer<
    typeof AppsGetUserInstallationResponseSchema
  >

  export const UsersListPublicKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListPublicKeysForUserParams = z.infer<
    typeof UsersListPublicKeysForUserParamsSchema
  >

  export const UsersListPublicKeysForUserResponseSchema =
    z.array(KeySimpleSchema)
  export type UsersListPublicKeysForUserResponse = z.infer<
    typeof UsersListPublicKeysForUserResponseSchema
  >

  export const OrgsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListForUserParams = z.infer<
    typeof OrgsListForUserParamsSchema
  >

  export const OrgsListForUserResponseSchema = z.array(OrganizationSimpleSchema)
  export type OrgsListForUserResponse = z.infer<
    typeof OrgsListForUserResponseSchema
  >

  export const PackagesListPackagesForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForUserParams = z.infer<
    typeof PackagesListPackagesForUserParamsSchema
  >

  export const PackagesListPackagesForUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForUserResponse = z.infer<
    typeof PackagesListPackagesForUserResponseSchema
  >

  export const PackagesGetPackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesGetPackageForUserParams = z.infer<
    typeof PackagesGetPackageForUserParamsSchema
  >

  export const PackagesGetPackageForUserResponseSchema = PackageSchema
  export type PackagesGetPackageForUserResponse = z.infer<
    typeof PackagesGetPackageForUserResponseSchema
  >

  export const PackagesDeletePackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesDeletePackageForUserParams = z.infer<
    typeof PackagesDeletePackageForUserParamsSchema
  >

  export type PackagesDeletePackageForUserResponse = undefined

  export const PackagesRestorePackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    token: z.string().describe('package token').optional()
  })
  export type PackagesRestorePackageForUserParams = z.infer<
    typeof PackagesRestorePackageForUserParamsSchema
  >

  export type PackagesRestorePackageForUserResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByUserParams =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByUserParamsSchema
    >

  export const PackagesGetAllPackageVersionsForPackageOwnedByUserResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByUserResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByUserResponseSchema
    >

  export const PackagesGetPackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesGetPackageVersionForUserParams = z.infer<
    typeof PackagesGetPackageVersionForUserParamsSchema
  >

  export const PackagesGetPackageVersionForUserResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForUserResponse = z.infer<
    typeof PackagesGetPackageVersionForUserResponseSchema
  >

  export const PackagesDeletePackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesDeletePackageVersionForUserParams = z.infer<
    typeof PackagesDeletePackageVersionForUserParamsSchema
  >

  export type PackagesDeletePackageVersionForUserResponse = undefined

  export const PackagesRestorePackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesRestorePackageVersionForUserParams = z.infer<
    typeof PackagesRestorePackageVersionForUserParamsSchema
  >

  export type PackagesRestorePackageVersionForUserResponse = undefined

  export const ProjectsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForUserParams = z.infer<
    typeof ProjectsListForUserParamsSchema
  >

  export const ProjectsListForUserResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForUserResponse = z.infer<
    typeof ProjectsListForUserResponseSchema
  >

  export const ActivityListReceivedEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReceivedEventsForUserParams = z.infer<
    typeof ActivityListReceivedEventsForUserParamsSchema
  >

  export const ActivityListReceivedEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListReceivedEventsForUserResponse = z.infer<
    typeof ActivityListReceivedEventsForUserResponseSchema
  >

  export const ActivityListReceivedPublicEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReceivedPublicEventsForUserParams = z.infer<
    typeof ActivityListReceivedPublicEventsForUserParamsSchema
  >

  export const ActivityListReceivedPublicEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListReceivedPublicEventsForUserResponse = z.infer<
    typeof ActivityListReceivedPublicEventsForUserResponseSchema
  >

  export const ReposListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    type: z
      .enum(['all', 'owner', 'member'])
      .describe('Limit results to repositories of the specified type.')
      .default('owner'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('full_name'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForUserParams = z.infer<
    typeof ReposListForUserParamsSchema
  >

  export const ReposListForUserResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForUserResponse = z.infer<
    typeof ReposListForUserResponseSchema
  >

  export const BillingGetGithubActionsBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetGithubActionsBillingUserParams = z.infer<
    typeof BillingGetGithubActionsBillingUserParamsSchema
  >

  export const BillingGetGithubActionsBillingUserResponseSchema =
    ActionsBillingUsageSchema
  export type BillingGetGithubActionsBillingUserResponse = z.infer<
    typeof BillingGetGithubActionsBillingUserResponseSchema
  >

  export const BillingGetGithubPackagesBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetGithubPackagesBillingUserParams = z.infer<
    typeof BillingGetGithubPackagesBillingUserParamsSchema
  >

  export const BillingGetGithubPackagesBillingUserResponseSchema =
    PackagesBillingUsageSchema
  export type BillingGetGithubPackagesBillingUserResponse = z.infer<
    typeof BillingGetGithubPackagesBillingUserResponseSchema
  >

  export const BillingGetSharedStorageBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetSharedStorageBillingUserParams = z.infer<
    typeof BillingGetSharedStorageBillingUserParamsSchema
  >

  export const BillingGetSharedStorageBillingUserResponseSchema =
    CombinedBillingUsageSchema
  export type BillingGetSharedStorageBillingUserResponse = z.infer<
    typeof BillingGetSharedStorageBillingUserResponseSchema
  >

  export const UsersListSocialAccountsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListSocialAccountsForUserParams = z.infer<
    typeof UsersListSocialAccountsForUserParamsSchema
  >

  export const UsersListSocialAccountsForUserResponseSchema =
    z.array(SocialAccountSchema)
  export type UsersListSocialAccountsForUserResponse = z.infer<
    typeof UsersListSocialAccountsForUserResponseSchema
  >

  export const UsersListSshSigningKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListSshSigningKeysForUserParams = z.infer<
    typeof UsersListSshSigningKeysForUserParamsSchema
  >

  export const UsersListSshSigningKeysForUserResponseSchema =
    z.array(SshSigningKeySchema)
  export type UsersListSshSigningKeysForUserResponse = z.infer<
    typeof UsersListSshSigningKeysForUserResponseSchema
  >

  export const ActivityListReposStarredByUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReposStarredByUserParams = z.infer<
    typeof ActivityListReposStarredByUserParamsSchema
  >

  export const ActivityListReposStarredByUserResponseSchema = z.union([
    z.array(StarredRepositorySchema),
    z.array(RepositorySchema)
  ])
  export type ActivityListReposStarredByUserResponse = z.infer<
    typeof ActivityListReposStarredByUserResponseSchema
  >

  export const ActivityListReposWatchedByUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReposWatchedByUserParams = z.infer<
    typeof ActivityListReposWatchedByUserParamsSchema
  >

  export const ActivityListReposWatchedByUserResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type ActivityListReposWatchedByUserResponse = z.infer<
    typeof ActivityListReposWatchedByUserResponseSchema
  >

  export const MetaGetAllVersionsParamsSchema = z.object({})
  export type MetaGetAllVersionsParams = z.infer<
    typeof MetaGetAllVersionsParamsSchema
  >

  export const MetaGetAllVersionsResponseSchema = z.array(z.string().date())
  export type MetaGetAllVersionsResponse = z.infer<
    typeof MetaGetAllVersionsResponseSchema
  >

  export const MetaGetZenParamsSchema = z.object({})
  export type MetaGetZenParams = z.infer<typeof MetaGetZenParamsSchema>

  export type MetaGetZenResponse = undefined
}
