/* eslint-disable unicorn/no-unreadable-iife */
/* eslint-disable unicorn/no-array-reduce */

/**
 * This file was auto-generated from an OpenAPI spec.
 */

import {
  aiFunction,
  AIFunctionsProvider,
  pick,
  sanitizeSearchParams
} from '@agentic/core'
import defaultKy, { type KyInstance } from 'ky'
import { z } from 'zod'

export namespace github {
  export const apiBaseUrl = 'https://api.github.com'

  // -----------------------------------------------------------------------------
  // Component schemas
  // -----------------------------------------------------------------------------

  export const RootSchema = z.object({
    current_user_url: z.string(),
    current_user_authorizations_html_url: z.string(),
    authorizations_url: z.string(),
    code_search_url: z.string(),
    commit_search_url: z.string(),
    emails_url: z.string(),
    emojis_url: z.string(),
    events_url: z.string(),
    feeds_url: z.string(),
    followers_url: z.string(),
    following_url: z.string(),
    gists_url: z.string(),
    hub_url: z.string().optional(),
    issue_search_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    label_search_url: z.string(),
    notifications_url: z.string(),
    organization_url: z.string(),
    organization_repositories_url: z.string(),
    organization_teams_url: z.string(),
    public_gists_url: z.string(),
    rate_limit_url: z.string(),
    repository_url: z.string(),
    repository_search_url: z.string(),
    current_user_repositories_url: z.string(),
    starred_url: z.string(),
    starred_gists_url: z.string(),
    topic_search_url: z.string().optional(),
    user_url: z.string(),
    user_organizations_url: z.string(),
    user_repositories_url: z.string(),
    user_search_url: z.string()
  })
  export type Root = z.infer<typeof RootSchema>

  export const SecurityAdvisoryEcosystemsSchema = z
    .enum([
      'rubygems',
      'npm',
      'pip',
      'maven',
      'nuget',
      'composer',
      'go',
      'rust',
      'erlang',
      'actions',
      'pub',
      'other',
      'swift'
    ])
    .describe("The package's language or package management ecosystem.")
  export type SecurityAdvisoryEcosystems = z.infer<
    typeof SecurityAdvisoryEcosystemsSchema
  >

  export const CvssSeveritiesSchema = z.object({
    cvss_v3: z
      .object({
        vector_string: z.string().describe('The CVSS 3 vector string.'),
        score: z
          .number()
          .gte(0)
          .lte(10)
          .describe('The CVSS 3 score.')
          .readonly()
      })
      .optional(),
    cvss_v4: z
      .object({
        vector_string: z.string().describe('The CVSS 4 vector string.'),
        score: z
          .number()
          .gte(0)
          .lte(10)
          .describe('The CVSS 4 score.')
          .readonly()
      })
      .optional()
  })
  export type CvssSeverities = z.infer<typeof CvssSeveritiesSchema>

  export const SecurityAdvisoryEpssSchema = z
    .object({
      percentage: z.number().gte(0).lte(100).optional(),
      percentile: z.number().gte(0).lte(100).optional()
    })
    .describe(
      'The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).'
    )
    .readonly()
  export type SecurityAdvisoryEpss = z.infer<typeof SecurityAdvisoryEpssSchema>

  export const SimpleUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('A GitHub user.')
  export type SimpleUser = z.infer<typeof SimpleUserSchema>

  export const SecurityAdvisoryCreditTypesSchema = z
    .enum([
      'analyst',
      'finder',
      'reporter',
      'coordinator',
      'remediation_developer',
      'remediation_reviewer',
      'remediation_verifier',
      'tool',
      'sponsor',
      'other'
    ])
    .describe('The type of credit the user is receiving.')
  export type SecurityAdvisoryCreditTypes = z.infer<
    typeof SecurityAdvisoryCreditTypesSchema
  >

  export const PaginationBeforeSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PaginationBefore = z.infer<typeof PaginationBeforeSchema>

  export const PaginationAfterSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PaginationAfter = z.infer<typeof PaginationAfterSchema>

  export const DirectionSchema = z
    .any()
    .describe('The direction to sort the results by.')
  export type Direction = z.infer<typeof DirectionSchema>

  export const GhsaIdSchema = z
    .any()
    .describe('The GHSA (GitHub Security Advisory) identifier of the advisory.')
  export type GhsaId = z.infer<typeof GhsaIdSchema>

  export const EnterpriseSchema = z
    .any()
    .describe(
      'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
    )
  export type Enterprise = z.infer<typeof EnterpriseSchema>

  export const WebhookConfigUrlSchema = z
    .string()
    .url()
    .describe('The URL to which the payloads will be delivered.')
  export type WebhookConfigUrl = z.infer<typeof WebhookConfigUrlSchema>

  export const WebhookConfigContentTypeSchema = z
    .string()
    .describe(
      'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.'
    )
  export type WebhookConfigContentType = z.infer<
    typeof WebhookConfigContentTypeSchema
  >

  export const WebhookConfigSecretSchema = z
    .string()
    .describe(
      'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).'
    )
  export type WebhookConfigSecret = z.infer<typeof WebhookConfigSecretSchema>

  export const WebhookConfigInsecureSslSchema = z.union([
    z
      .string()
      .describe(
        'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**'
      ),
    z.number()
  ])
  export type WebhookConfigInsecureSsl = z.infer<
    typeof WebhookConfigInsecureSslSchema
  >

  export const HookDeliveryItemSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the webhook delivery.'),
      guid: z
        .string()
        .describe(
          'Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).'
        ),
      delivered_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery occurred.'),
      redelivery: z
        .boolean()
        .describe('Whether the webhook delivery is a redelivery.'),
      duration: z.number().describe('Time spent delivering.'),
      status: z
        .string()
        .describe(
          'Describes the response returned after attempting the delivery.'
        ),
      status_code: z
        .number()
        .int()
        .describe('Status code received when delivery was made.'),
      event: z.string().describe('The event that triggered the delivery.'),
      action: z
        .string()
        .describe(
          'The type of activity for the event that triggered the delivery.'
        ),
      installation_id: z
        .number()
        .int()
        .describe(
          'The id of the GitHub App installation associated with this event.'
        ),
      repository_id: z
        .number()
        .int()
        .describe('The id of the repository associated with this event.'),
      throttled_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery was throttled.')
        .optional()
    })
    .describe(
      'Delivery made by a webhook, without request and response information.'
    )
  export type HookDeliveryItem = z.infer<typeof HookDeliveryItemSchema>

  export const PerPageSchema = z
    .any()
    .describe(
      'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type PerPage = z.infer<typeof PerPageSchema>

  export const CursorSchema = z
    .any()
    .describe(
      'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
    )
  export type Cursor = z.infer<typeof CursorSchema>

  export const HookDeliverySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the delivery.'),
      guid: z
        .string()
        .describe(
          'Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).'
        ),
      delivered_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the delivery was delivered.'),
      redelivery: z.boolean().describe('Whether the delivery is a redelivery.'),
      duration: z.number().describe('Time spent delivering.'),
      status: z
        .string()
        .describe('Description of the status of the attempted delivery'),
      status_code: z
        .number()
        .int()
        .describe('Status code received when delivery was made.'),
      event: z.string().describe('The event that triggered the delivery.'),
      action: z
        .string()
        .describe(
          'The type of activity for the event that triggered the delivery.'
        ),
      installation_id: z
        .number()
        .int()
        .describe(
          'The id of the GitHub App installation associated with this event.'
        ),
      repository_id: z
        .number()
        .int()
        .describe('The id of the repository associated with this event.'),
      throttled_at: z
        .string()
        .datetime({ offset: true })
        .describe('Time when the webhook delivery was throttled.')
        .optional(),
      url: z.string().describe('The URL target of the delivery.').optional(),
      request: z.object({
        headers: z
          .record(z.any())
          .describe('The request headers sent with the webhook delivery.'),
        payload: z.record(z.any()).describe('The webhook payload.')
      }),
      response: z.object({
        headers: z
          .record(z.any())
          .describe(
            'The response headers received when the delivery was made.'
          ),
        payload: z.string().describe('The response payload received.')
      })
    })
    .describe('Delivery made by a webhook.')
  export type HookDelivery = z.infer<typeof HookDeliverySchema>

  export const DeliveryIdSchema = z.any()
  export type DeliveryId = z.infer<typeof DeliveryIdSchema>

  export const PageSchema = z
    .object({
      url: z
        .string()
        .url()
        .describe('The API address for accessing this Page resource.'),
      status: z
        .enum(['built', 'building', 'errored'])
        .describe('The status of the most recent build of the Page.'),
      cname: z.string().describe("The Pages site's custom domain"),
      protected_domain_state: z
        .enum(['pending', 'verified', 'unverified'])
        .describe('The state if the domain is verified')
        .optional(),
      pending_domain_unverified_at: z
        .string()
        .datetime({ offset: true })
        .describe('The timestamp when a pending domain becomes unverified.')
        .optional(),
      custom_404: z
        .boolean()
        .describe('Whether the Page has a custom 404 page.')
        .default(false),
      html_url: z
        .string()
        .url()
        .describe('The web address the Page can be accessed from.')
        .optional(),
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe('The process in which the Page will be built.')
        .optional(),
      source: PagesSourceHashSchema.optional(),
      public: z
        .boolean()
        .describe(
          'Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.'
        ),
      https_certificate: PagesHttpsCertificateSchema.optional(),
      https_enforced: z
        .boolean()
        .describe('Whether https is enabled on the domain')
        .optional()
    })
    .describe('The configuration for GitHub Pages for a repository.')
  export type Page = z.infer<typeof PageSchema>

  export const AppPermissionsSchema = z
    .object({
      actions: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.'
        )
        .optional(),
      administration: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.'
        )
        .optional(),
      checks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for checks on code.'
        )
        .optional(),
      codespaces: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to create, edit, delete, and list Codespaces.'
        )
        .optional(),
      contents: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.'
        )
        .optional(),
      dependabot_secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage Dependabot secrets.'
        )
        .optional(),
      deployments: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for deployments and deployment statuses.'
        )
        .optional(),
      environments: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for managing repository environments.'
        )
        .optional(),
      issues: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.'
        )
        .optional(),
      metadata: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.'
        )
        .optional(),
      packages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for packages published to GitHub Packages.'
        )
        .optional(),
      pages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.'
        )
        .optional(),
      pull_requests: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.'
        )
        .optional(),
      repository_custom_properties: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and edit custom properties for a repository, when allowed by the property.'
        )
        .optional(),
      repository_hooks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the post-receive hooks for a repository.'
        )
        .optional(),
      repository_projects: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token to manage repository projects, columns, and cards.'
        )
        .optional(),
      secret_scanning_alerts: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage secret scanning alerts.'
        )
        .optional(),
      secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage repository secrets.'
        )
        .optional(),
      security_events: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage security events like code scanning alerts.'
        )
        .optional(),
      single_file: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage just a single file.'
        )
        .optional(),
      statuses: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for commit statuses.'
        )
        .optional(),
      vulnerability_alerts: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage Dependabot alerts.'
        )
        .optional(),
      workflows: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token to update GitHub Actions workflow files.'
        )
        .optional(),
      members: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for organization teams and members.'
        )
        .optional(),
      organization_administration: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage access to an organization.'
        )
        .optional(),
      organization_custom_roles: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for custom repository roles management.'
        )
        .optional(),
      organization_custom_org_roles: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for custom organization roles management.'
        )
        .optional(),
      organization_custom_properties: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token for custom property management.'
        )
        .optional(),
      organization_copilot_seat_management: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token for managing access to GitHub Copilot for members of an organization with a Copilot Business subscription. This property is in public preview and is subject to change.'
        )
        .optional(),
      organization_announcement_banners: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage announcement banners for an organization.'
        )
        .optional(),
      organization_events: z
        .literal('read')
        .describe(
          'The level of permission to grant the access token to view events triggered by an activity in an organization.'
        )
        .optional(),
      organization_hooks: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the post-receive hooks for an organization.'
        )
        .optional(),
      organization_personal_access_tokens: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for viewing and managing fine-grained personal access token requests to an organization.'
        )
        .optional(),
      organization_personal_access_token_requests: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for viewing and managing fine-grained personal access tokens that have been approved by an organization.'
        )
        .optional(),
      organization_plan: z
        .literal('read')
        .describe(
          "The level of permission to grant the access token for viewing an organization's plan."
        )
        .optional(),
      organization_projects: z
        .enum(['read', 'write', 'admin'])
        .describe(
          'The level of permission to grant the access token to manage organization projects and projects public preview (where available).'
        )
        .optional(),
      organization_packages: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token for organization packages published to GitHub Packages.'
        )
        .optional(),
      organization_secrets: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage organization secrets.'
        )
        .optional(),
      organization_self_hosted_runners: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.'
        )
        .optional(),
      organization_user_blocking: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage users blocked by the organization.'
        )
        .optional(),
      team_discussions: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage team discussions and related comments.'
        )
        .optional(),
      email_addresses: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the email addresses belonging to a user.'
        )
        .optional(),
      followers: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage the followers belonging to a user.'
        )
        .optional(),
      git_ssh_keys: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to manage git SSH keys.'
        )
        .optional(),
      gpg_keys: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage GPG keys belonging to a user.'
        )
        .optional(),
      interaction_limits: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to view and manage interaction limits on a repository.'
        )
        .optional(),
      profile: z
        .literal('write')
        .describe(
          'The level of permission to grant the access token to manage the profile settings belonging to a user.'
        )
        .optional(),
      starring: z
        .enum(['read', 'write'])
        .describe(
          'The level of permission to grant the access token to list and manage repositories a user is starring.'
        )
        .optional()
    })
    .describe('The permissions granted to the user access token.')
  export type AppPermissions = z.infer<typeof AppPermissionsSchema>

  export const NullableSimpleUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('A GitHub user.')
  export type NullableSimpleUser = z.infer<typeof NullableSimpleUserSchema>

  export const SinceSchema = z
    .any()
    .describe(
      'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type Since = z.infer<typeof SinceSchema>

  export const InstallationIdSchema = z
    .any()
    .describe('The unique identifier of the installation.')
  export type InstallationId = z.infer<typeof InstallationIdSchema>

  export const NullableLicenseSimpleSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      spdx_id: z.string(),
      node_id: z.string(),
      html_url: z.string().url().optional()
    })
    .describe('License Simple')
  export type NullableLicenseSimple = z.infer<
    typeof NullableLicenseSimpleSchema
  >

  export const ClientIdSchema = z
    .any()
    .describe('The client ID of the GitHub app.')
  export type ClientId = z.infer<typeof ClientIdSchema>

  export const AppSlugSchema = z.any()
  export type AppSlug = z.infer<typeof AppSlugSchema>

  export const SimpleClassroomRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique name of the repository.'),
      html_url: z
        .string()
        .url()
        .describe('The URL to view the repository on GitHub.com.'),
      node_id: z.string().describe('The GraphQL identifier of the repository.'),
      private: z.boolean().describe('Whether the repository is private.'),
      default_branch: z
        .string()
        .describe('The default branch for the repository.')
    })
    .describe('A GitHub repository view for Classroom')
  export type SimpleClassroomRepository = z.infer<
    typeof SimpleClassroomRepositorySchema
  >

  export const SimpleClassroomOrganizationSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      node_id: z.string(),
      html_url: z.string().url(),
      name: z.string(),
      avatar_url: z.string()
    })
    .describe('A GitHub organization.')
  export type SimpleClassroomOrganization = z.infer<
    typeof SimpleClassroomOrganizationSchema
  >

  export const AssignmentIdSchema = z
    .any()
    .describe('The unique identifier of the classroom assignment.')
  export type AssignmentId = z.infer<typeof AssignmentIdSchema>

  export const SimpleClassroomUserSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      avatar_url: z.string().url(),
      html_url: z.string().url()
    })
    .describe('A GitHub user simplified for Classroom.')
  export type SimpleClassroomUser = z.infer<typeof SimpleClassroomUserSchema>

  export const SimpleClassroomSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the classroom.'),
      name: z.string().describe('The name of the classroom.'),
      archived: z
        .boolean()
        .describe('Returns whether classroom is archived or not.'),
      url: z.string().describe('The url of the classroom on GitHub Classroom.')
    })
    .describe('A GitHub Classroom classroom')
  export type SimpleClassroom = z.infer<typeof SimpleClassroomSchema>

  export const ClassroomAssignmentGradeSchema = z
    .object({
      assignment_name: z.string().describe('Name of the assignment'),
      assignment_url: z.string().describe('URL of the assignment'),
      starter_code_url: z
        .string()
        .describe('URL of the starter code for the assignment'),
      github_username: z.string().describe('GitHub username of the student'),
      roster_identifier: z
        .string()
        .describe('Roster identifier of the student'),
      student_repository_name: z
        .string()
        .describe("Name of the student's assignment repository"),
      student_repository_url: z
        .string()
        .describe("URL of the student's assignment repository"),
      submission_timestamp: z
        .string()
        .describe("Timestamp of the student's assignment submission"),
      points_awarded: z
        .number()
        .int()
        .describe('Number of points awarded to the student'),
      points_available: z
        .number()
        .int()
        .describe('Number of points available for the assignment'),
      group_name: z
        .string()
        .describe('If a group assignment, name of the group the student is in')
        .optional()
    })
    .describe('Grade for a student or groups GitHub Classroom assignment')
  export type ClassroomAssignmentGrade = z.infer<
    typeof ClassroomAssignmentGradeSchema
  >

  export const ClassroomIdSchema = z
    .any()
    .describe('The unique identifier of the classroom.')
  export type ClassroomId = z.infer<typeof ClassroomIdSchema>

  export const CodeOfConductSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      body: z.string().optional(),
      html_url: z.string().url()
    })
    .describe('Code Of Conduct')
  export type CodeOfConduct = z.infer<typeof CodeOfConductSchema>

  export const CodeSecurityConfigurationSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The ID of the code security configuration')
        .optional(),
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique within the organization.'
        )
        .optional(),
      target_type: z
        .enum(['global', 'organization', 'enterprise'])
        .describe('The type of the code security configuration.')
        .optional(),
      description: z
        .string()
        .describe('A description of the code security configuration')
        .optional(),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe('The enablement status of GitHub Advanced Security')
        .optional(),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .optional(),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .optional(),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .optional()
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .optional(),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .optional(),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .optional(),
      code_scanning_default_setup_options: z
        .object({
          runner_type: z
            .enum(['standard', 'labeled', 'not_set'])
            .describe(
              'Whether to use labeled runners or standard GitHub runners.'
            )
            .optional(),
          runner_label: z
            .string()
            .describe(
              "The label of the runner to use for code scanning when runner_type is 'labeled'."
            )
            .optional()
        })
        .describe('Feature options for code scanning default setup')
        .optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .optional(),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .optional(),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .optional(),
      secret_scanning_delegated_bypass: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning delegated bypass')
        .optional(),
      secret_scanning_delegated_bypass_options: z
        .object({
          reviewers: z
            .array(
              z.object({
                reviewer_id: z
                  .number()
                  .int()
                  .describe(
                    'The ID of the team or role selected as a bypass reviewer'
                  ),
                reviewer_type: z
                  .enum(['TEAM', 'ROLE'])
                  .describe('The type of the bypass reviewer')
              })
            )
            .describe(
              'The bypass reviewers for secret scanning delegated bypass'
            )
            .optional()
        })
        .describe('Feature options for secret scanning delegated bypass')
        .optional(),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .optional(),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non-provider patterns'
        )
        .optional(),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .optional(),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .optional(),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .optional(),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .optional(),
      url: z.string().url().describe('The URL of the configuration').optional(),
      html_url: z
        .string()
        .url()
        .describe('The URL of the configuration')
        .optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A code security configuration')
  export type CodeSecurityConfiguration = z.infer<
    typeof CodeSecurityConfigurationSchema
  >

  export const CodeScanningDefaultSetupOptionsSchema = z
    .object({
      runner_type: z
        .enum(['standard', 'labeled', 'not_set'])
        .describe('Whether to use labeled runners or standard GitHub runners.')
        .optional(),
      runner_label: z
        .string()
        .describe(
          "The label of the runner to use for code scanning default setup when runner_type is 'labeled'."
        )
        .optional()
    })
    .describe('Feature options for code scanning default setup')
  export type CodeScanningDefaultSetupOptions = z.infer<
    typeof CodeScanningDefaultSetupOptionsSchema
  >

  export const ConfigurationIdSchema = z
    .any()
    .describe('The unique identifier of the code security configuration.')
  export type ConfigurationId = z.infer<typeof ConfigurationIdSchema>

  export const AlertNumberSchema = z
    .any()
    .describe(
      'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
    )
  export type AlertNumber = z.infer<typeof AlertNumberSchema>

  export const DependabotAlertPackageSchema = z
    .object({
      ecosystem: z
        .string()
        .describe("The package's language or package management ecosystem.")
        .readonly(),
      name: z
        .string()
        .describe('The unique package name within its ecosystem.')
        .readonly()
    })
    .strict()
    .describe('Details for the vulnerable package.')
    .readonly()
  export type DependabotAlertPackage = z.infer<
    typeof DependabotAlertPackageSchema
  >

  export const AlertUrlSchema = z
    .string()
    .url()
    .describe('The REST API URL of the alert resource.')
    .readonly()
  export type AlertUrl = z.infer<typeof AlertUrlSchema>

  export const AlertHtmlUrlSchema = z
    .string()
    .url()
    .describe('The GitHub URL of the alert resource.')
    .readonly()
  export type AlertHtmlUrl = z.infer<typeof AlertHtmlUrlSchema>

  export const AlertCreatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertCreatedAt = z.infer<typeof AlertCreatedAtSchema>

  export const AlertUpdatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertUpdatedAt = z.infer<typeof AlertUpdatedAtSchema>

  export const AlertDismissedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertDismissedAt = z.infer<typeof AlertDismissedAtSchema>

  export const AlertFixedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertFixedAt = z.infer<typeof AlertFixedAtSchema>

  export const AlertAutoDismissedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type AlertAutoDismissedAt = z.infer<typeof AlertAutoDismissedAtSchema>

  export const DependabotAlertCommaSeparatedStatesSchema = z
    .any()
    .describe(
      'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
    )
  export type DependabotAlertCommaSeparatedStates = z.infer<
    typeof DependabotAlertCommaSeparatedStatesSchema
  >

  export const DependabotAlertCommaSeparatedSeveritiesSchema = z
    .any()
    .describe(
      'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
    )
  export type DependabotAlertCommaSeparatedSeverities = z.infer<
    typeof DependabotAlertCommaSeparatedSeveritiesSchema
  >

  export const DependabotAlertCommaSeparatedEcosystemsSchema = z
    .any()
    .describe(
      'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
    )
  export type DependabotAlertCommaSeparatedEcosystems = z.infer<
    typeof DependabotAlertCommaSeparatedEcosystemsSchema
  >

  export const DependabotAlertCommaSeparatedPackagesSchema = z
    .any()
    .describe(
      'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
    )
  export type DependabotAlertCommaSeparatedPackages = z.infer<
    typeof DependabotAlertCommaSeparatedPackagesSchema
  >

  export const DependabotAlertCommaSeparatedEpssSchema = z
    .any()
    .describe(
      'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
    )
  export type DependabotAlertCommaSeparatedEpss = z.infer<
    typeof DependabotAlertCommaSeparatedEpssSchema
  >

  export const DependabotAlertScopeSchema = z
    .any()
    .describe(
      'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
    )
  export type DependabotAlertScope = z.infer<typeof DependabotAlertScopeSchema>

  export const DependabotAlertSortSchema = z
    .any()
    .describe(
      "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
    )
  export type DependabotAlertSort = z.infer<typeof DependabotAlertSortSchema>

  export const PaginationFirstSchema = z
    .any()
    .describe(
      '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
    )
  export type PaginationFirst = z.infer<typeof PaginationFirstSchema>

  export const PaginationLastSchema = z
    .any()
    .describe(
      '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
    )
  export type PaginationLast = z.infer<typeof PaginationLastSchema>

  export const NullableAlertUpdatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type NullableAlertUpdatedAt = z.infer<
    typeof NullableAlertUpdatedAtSchema
  >

  export const SecretScanningAlertStateSchema = z
    .any()
    .describe(
      'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
    )
  export type SecretScanningAlertState = z.infer<
    typeof SecretScanningAlertStateSchema
  >

  export const SecretScanningAlertResolutionSchema = z
    .any()
    .describe(
      'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
    )
  export type SecretScanningAlertResolution = z.infer<
    typeof SecretScanningAlertResolutionSchema
  >

  export const SecretScanningAlertSecretTypeSchema = z
    .any()
    .describe(
      'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
    )
  export type SecretScanningAlertSecretType = z.infer<
    typeof SecretScanningAlertSecretTypeSchema
  >

  export const SecretScanningAlertSortSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
    )
  export type SecretScanningAlertSort = z.infer<
    typeof SecretScanningAlertSortSchema
  >

  export const SecretScanningAlertValiditySchema = z
    .any()
    .describe(
      'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
    )
  export type SecretScanningAlertValidity = z.infer<
    typeof SecretScanningAlertValiditySchema
  >

  export const SecretScanningAlertPubliclyLeakedSchema = z
    .any()
    .describe(
      'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
    )
  export type SecretScanningAlertPubliclyLeaked = z.infer<
    typeof SecretScanningAlertPubliclyLeakedSchema
  >

  export const SecretScanningAlertMultiRepoSchema = z
    .any()
    .describe(
      'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
    )
  export type SecretScanningAlertMultiRepo = z.infer<
    typeof SecretScanningAlertMultiRepoSchema
  >

  export const ActorSchema = z
    .any()
    .describe(
      "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
    )
  export type Actor = z.infer<typeof ActorSchema>

  export const IssueTypeSchema = z
    .object({
      id: z.number().int().describe('The unique identifier of the issue type.'),
      node_id: z.string().describe('The node identifier of the issue type.'),
      name: z.string().describe('The name of the issue type.'),
      description: z.string().describe('The description of the issue type.'),
      color: z
        .enum([
          'gray',
          'blue',
          'green',
          'yellow',
          'orange',
          'red',
          'pink',
          'purple'
        ])
        .describe('The color of the issue type.')
        .optional(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time the issue type created.')
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time the issue type last updated.')
        .optional(),
      is_enabled: z
        .boolean()
        .describe('The enabled state of the issue type.')
        .optional()
    })
    .describe('The type of issue.')
  export type IssueType = z.infer<typeof IssueTypeSchema>

  export const AuthorAssociationSchema = z
    .enum([
      'COLLABORATOR',
      'CONTRIBUTOR',
      'FIRST_TIMER',
      'FIRST_TIME_CONTRIBUTOR',
      'MANNEQUIN',
      'MEMBER',
      'NONE',
      'OWNER'
    ])
    .describe('How the author is associated with the repository.')
  export type AuthorAssociation = z.infer<typeof AuthorAssociationSchema>

  export const ReactionRollupSchema = z.object({
    url: z.string().url(),
    total_count: z.number().int(),
    '+1': z.number().int(),
    '-1': z.number().int(),
    laugh: z.number().int(),
    confused: z.number().int(),
    heart: z.number().int(),
    hooray: z.number().int(),
    eyes: z.number().int(),
    rocket: z.number().int()
  })
  export type ReactionRollup = z.infer<typeof ReactionRollupSchema>

  export const SubIssuesSummarySchema = z.object({
    total: z.number().int(),
    completed: z.number().int(),
    percent_completed: z.number().int()
  })
  export type SubIssuesSummary = z.infer<typeof SubIssuesSummarySchema>

  export const LinkWithTypeSchema = z
    .object({ href: z.string(), type: z.string() })
    .describe('Hypermedia Link with Type')
  export type LinkWithType = z.infer<typeof LinkWithTypeSchema>

  export const PublicUserSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      user_view_type: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      name: z.string(),
      company: z.string(),
      blog: z.string(),
      location: z.string(),
      email: z.string().email(),
      notification_email: z.string().email().optional(),
      hireable: z.boolean(),
      bio: z.string(),
      twitter_username: z.string().optional(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      plan: z
        .object({
          collaborators: z.number().int(),
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int()
        })
        .optional(),
      private_gists: z.number().int().optional(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z.number().int().optional()
    })
    .strict()
    .describe('Public User')
  export type PublicUser = z.infer<typeof PublicUserSchema>

  export const GistIdSchema = z
    .any()
    .describe('The unique identifier of the gist.')
  export type GistId = z.infer<typeof GistIdSchema>

  export const CommentIdSchema = z
    .any()
    .describe('The unique identifier of the comment.')
  export type CommentId = z.infer<typeof CommentIdSchema>

  export const GitignoreTemplateSchema = z
    .object({ name: z.string(), source: z.string() })
    .describe('Gitignore Template')
  export type GitignoreTemplate = z.infer<typeof GitignoreTemplateSchema>

  export const LabelsSchema = z
    .any()
    .describe('A list of comma separated label names. Example: `bug,ui,@high`')
  export type Labels = z.infer<typeof LabelsSchema>

  export const LicenseSimpleSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      url: z.string().url(),
      spdx_id: z.string(),
      node_id: z.string(),
      html_url: z.string().url().optional()
    })
    .describe('License Simple')
  export type LicenseSimple = z.infer<typeof LicenseSimpleSchema>

  export const LicenseSchema = z
    .object({
      key: z.string(),
      name: z.string(),
      spdx_id: z.string(),
      url: z.string().url(),
      node_id: z.string(),
      html_url: z.string().url(),
      description: z.string(),
      implementation: z.string(),
      permissions: z.array(z.string()),
      conditions: z.array(z.string()),
      limitations: z.array(z.string()),
      body: z.string(),
      featured: z.boolean()
    })
    .describe('License')
  export type License = z.infer<typeof LicenseSchema>

  export const MarketplaceListingPlanSchema = z
    .object({
      url: z.string().url(),
      accounts_url: z.string().url(),
      id: z.number().int(),
      number: z.number().int(),
      name: z.string(),
      description: z.string(),
      monthly_price_in_cents: z.number().int(),
      yearly_price_in_cents: z.number().int(),
      price_model: z.enum(['FREE', 'FLAT_RATE', 'PER_UNIT']),
      has_free_trial: z.boolean(),
      unit_name: z.string(),
      state: z.string(),
      bullets: z.array(z.string())
    })
    .describe('Marketplace Listing Plan')
  export type MarketplaceListingPlan = z.infer<
    typeof MarketplaceListingPlanSchema
  >

  export const AccountIdSchema = z.any().describe('account_id parameter')
  export type AccountId = z.infer<typeof AccountIdSchema>

  export const PlanIdSchema = z
    .any()
    .describe('The unique identifier of the plan.')
  export type PlanId = z.infer<typeof PlanIdSchema>

  export const SortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type Sort = z.infer<typeof SortSchema>

  export const ApiOverviewSchema = z
    .object({
      verifiable_password_authentication: z.boolean(),
      ssh_key_fingerprints: z
        .object({
          SHA256_RSA: z.string().optional(),
          SHA256_DSA: z.string().optional(),
          SHA256_ECDSA: z.string().optional(),
          SHA256_ED25519: z.string().optional()
        })
        .optional(),
      ssh_keys: z.array(z.string()).optional(),
      hooks: z.array(z.string()).optional(),
      github_enterprise_importer: z.array(z.string()).optional(),
      web: z.array(z.string()).optional(),
      api: z.array(z.string()).optional(),
      git: z.array(z.string()).optional(),
      packages: z.array(z.string()).optional(),
      pages: z.array(z.string()).optional(),
      importer: z.array(z.string()).optional(),
      actions: z.array(z.string()).optional(),
      actions_macos: z.array(z.string()).optional(),
      codespaces: z.array(z.string()).optional(),
      dependabot: z.array(z.string()).optional(),
      copilot: z.array(z.string()).optional(),
      domains: z
        .object({
          website: z.array(z.string()).optional(),
          codespaces: z.array(z.string()).optional(),
          copilot: z.array(z.string()).optional(),
          packages: z.array(z.string()).optional(),
          actions: z.array(z.string()).optional(),
          actions_inbound: z
            .object({
              full_domains: z.array(z.string()).optional(),
              wildcard_domains: z.array(z.string()).optional()
            })
            .optional(),
          artifact_attestations: z
            .object({
              trust_domain: z.string().optional(),
              services: z.array(z.string()).optional()
            })
            .optional()
        })
        .optional()
    })
    .describe('Api Overview')
  export type ApiOverview = z.infer<typeof ApiOverviewSchema>

  export const OwnerSchema = z
    .any()
    .describe(
      'The account owner of the repository. The name is not case sensitive.'
    )
  export type Owner = z.infer<typeof OwnerSchema>

  export const RepoSchema = z
    .any()
    .describe(
      'The name of the repository without the `.git` extension. The name is not case sensitive.'
    )
  export type Repo = z.infer<typeof RepoSchema>

  export const SecurityAndAnalysisSchema = z.object({
    advanced_security: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    dependabot_security_updates: z
      .object({
        status: z
          .enum(['enabled', 'disabled'])
          .describe(
            'The enablement status of Dependabot security updates for the repository.'
          )
          .optional()
      })
      .describe(
        'Enable or disable Dependabot security updates for the repository.'
      )
      .optional(),
    secret_scanning: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_push_protection: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_non_provider_patterns: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional(),
    secret_scanning_ai_detection: z
      .object({ status: z.enum(['enabled', 'disabled']).optional() })
      .optional()
  })
  export type SecurityAndAnalysis = z.infer<typeof SecurityAndAnalysisSchema>

  export const AllSchema = z
    .any()
    .describe('If `true`, show notifications marked as read.')
  export type All = z.infer<typeof AllSchema>

  export const ParticipatingSchema = z
    .any()
    .describe(
      'If `true`, only shows notifications in which the user is directly participating or mentioned.'
    )
  export type Participating = z.infer<typeof ParticipatingSchema>

  export const BeforeSchema = z
    .any()
    .describe(
      'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type Before = z.infer<typeof BeforeSchema>

  export const ThreadIdSchema = z
    .any()
    .describe(
      'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
    )
  export type ThreadId = z.infer<typeof ThreadIdSchema>

  export const ThreadSubscriptionSchema = z
    .object({
      subscribed: z.boolean(),
      ignored: z.boolean(),
      reason: z.string(),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      thread_url: z.string().url().optional(),
      repository_url: z.string().url().optional()
    })
    .describe('Thread Subscription')
  export type ThreadSubscription = z.infer<typeof ThreadSubscriptionSchema>

  export const OrganizationSimpleSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string()
    })
    .describe('A GitHub organization.')
  export type OrganizationSimple = z.infer<typeof OrganizationSimpleSchema>

  export const SinceOrgSchema = z
    .any()
    .describe(
      'An organization ID. Only return organizations with an ID greater than this ID.'
    )
  export type SinceOrg = z.infer<typeof SinceOrgSchema>

  export const BillingUsageReportSchema = z.object({
    usageItems: z
      .array(
        z.object({
          date: z.string().describe('Date of the usage line item.'),
          product: z.string().describe('Product name.'),
          sku: z.string().describe('SKU name.'),
          quantity: z
            .number()
            .int()
            .describe('Quantity of the usage line item.'),
          unitType: z.string().describe('Unit type of the usage line item.'),
          pricePerUnit: z
            .number()
            .describe('Price per unit of the usage line item.'),
          grossAmount: z
            .number()
            .describe('Gross amount of the usage line item.'),
          discountAmount: z
            .number()
            .describe('Discount amount of the usage line item.'),
          netAmount: z.number().describe('Net amount of the usage line item.'),
          organizationName: z.string().describe('Name of the organization.'),
          repositoryName: z
            .string()
            .describe('Name of the repository.')
            .optional()
        })
      )
      .optional()
  })
  export type BillingUsageReport = z.infer<typeof BillingUsageReportSchema>

  export const OrgSchema = z
    .any()
    .describe('The organization name. The name is not case sensitive.')
  export type Org = z.infer<typeof OrgSchema>

  export const BillingUsageReportYearSchema = z
    .any()
    .describe(
      'If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.'
    )
  export type BillingUsageReportYear = z.infer<
    typeof BillingUsageReportYearSchema
  >

  export const BillingUsageReportMonthSchema = z
    .any()
    .describe(
      'If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.'
    )
  export type BillingUsageReportMonth = z.infer<
    typeof BillingUsageReportMonthSchema
  >

  export const BillingUsageReportDaySchema = z
    .any()
    .describe(
      'If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.'
    )
  export type BillingUsageReportDay = z.infer<
    typeof BillingUsageReportDaySchema
  >

  export const BillingUsageReportHourSchema = z
    .any()
    .describe(
      'If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.'
    )
  export type BillingUsageReportHour = z.infer<
    typeof BillingUsageReportHourSchema
  >

  export const OrganizationFullSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string(),
      name: z.string().optional(),
      company: z.string().optional(),
      blog: z.string().url().optional(),
      location: z.string().optional(),
      email: z.string().email().optional(),
      twitter_username: z.string().optional(),
      is_verified: z.boolean().optional(),
      has_organization_projects: z.boolean(),
      has_repository_projects: z.boolean(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      html_url: z.string().url(),
      type: z.string(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      private_gists: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z
        .number()
        .int()
        .describe(
          'The number of collaborators on private repositories.\n\nThis field may be null if the number of private repositories is over 50,000.'
        )
        .optional(),
      billing_email: z.string().email().optional(),
      plan: z
        .object({
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int(),
          filled_seats: z.number().int().optional(),
          seats: z.number().int().optional()
        })
        .optional(),
      default_repository_permission: z.string().optional(),
      members_can_create_repositories: z.boolean().optional(),
      two_factor_requirement_enabled: z.boolean().optional(),
      members_allowed_repository_creation_type: z.string().optional(),
      members_can_create_public_repositories: z.boolean().optional(),
      members_can_create_private_repositories: z.boolean().optional(),
      members_can_create_internal_repositories: z.boolean().optional(),
      members_can_create_pages: z.boolean().optional(),
      members_can_create_public_pages: z.boolean().optional(),
      members_can_create_private_pages: z.boolean().optional(),
      members_can_fork_private_repositories: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      advanced_security_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependabot_alerts_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependabot_security_updates_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      dependency_graph_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_push_protection_enabled_for_new_repositories: z
        .boolean()
        .describe(
          '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.'
        )
        .optional(),
      secret_scanning_push_protection_custom_link_enabled: z
        .boolean()
        .describe(
          'Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.'
        )
        .optional(),
      secret_scanning_push_protection_custom_link: z
        .string()
        .describe(
          'An optional URL string to display to contributors who are blocked from pushing a secret.'
        )
        .optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      archived_at: z.string().datetime({ offset: true }),
      deploy_keys_enabled_for_repositories: z
        .boolean()
        .describe(
          'Controls whether or not deploy keys may be added and used for repositories in the organization.'
        )
        .optional()
    })
    .describe('Organization Full')
  export type OrganizationFull = z.infer<typeof OrganizationFullSchema>

  export const ActionsCacheUsageOrgEnterpriseSchema = z.object({
    total_active_caches_count: z
      .number()
      .int()
      .describe(
        'The count of active caches across all repositories of an enterprise or an organization.'
      ),
    total_active_caches_size_in_bytes: z
      .number()
      .int()
      .describe(
        'The total size in bytes of all active cache items across all repositories of an enterprise or an organization.'
      )
  })
  export type ActionsCacheUsageOrgEnterprise = z.infer<
    typeof ActionsCacheUsageOrgEnterpriseSchema
  >

  export const ActionsCacheUsageByRepositorySchema = z
    .object({
      full_name: z
        .string()
        .describe(
          'The repository owner and name for the cache usage being shown.'
        ),
      active_caches_size_in_bytes: z
        .number()
        .int()
        .describe(
          'The sum of the size in bytes of all the active cache items in the repository.'
        ),
      active_caches_count: z
        .number()
        .int()
        .describe('The number of active caches in the repository.')
    })
    .describe('GitHub Actions Cache Usage by repository.')
  export type ActionsCacheUsageByRepository = z.infer<
    typeof ActionsCacheUsageByRepositorySchema
  >

  export const NullableActionsHostedRunnerPoolImageSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.'
        ),
      size_gb: z.number().int().describe('Image size in GB.'),
      display_name: z.string().describe('Display name for this image.'),
      source: z
        .enum(['github', 'partner', 'custom'])
        .describe('The image provider.')
    })
    .describe('Provides details of a hosted runner image')
  export type NullableActionsHostedRunnerPoolImage = z.infer<
    typeof NullableActionsHostedRunnerPoolImageSchema
  >

  export const ActionsHostedRunnerMachineSpecSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID used for the `size` parameter when creating a new runner.'
        ),
      cpu_cores: z.number().int().describe('The number of cores.'),
      memory_gb: z
        .number()
        .int()
        .describe('The available RAM for the machine spec.'),
      storage_gb: z
        .number()
        .int()
        .describe('The available SSD storage for the machine spec.')
    })
    .describe('Provides details of a particular machine spec.')
  export type ActionsHostedRunnerMachineSpec = z.infer<
    typeof ActionsHostedRunnerMachineSpecSchema
  >

  export const PublicIpSchema = z
    .object({
      enabled: z.boolean().describe('Whether public IP is enabled.').optional(),
      prefix: z.string().describe('The prefix for the public IP.').optional(),
      length: z
        .number()
        .int()
        .describe('The length of the IP prefix.')
        .optional()
    })
    .describe(
      'Provides details of Public IP for a GitHub-hosted larger runners'
    )
  export type PublicIp = z.infer<typeof PublicIpSchema>

  export const ActionsHostedRunnerImageSchema = z
    .object({
      id: z
        .string()
        .describe(
          'The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.'
        ),
      platform: z.string().describe('The operating system of the image.'),
      size_gb: z.number().int().describe('Image size in GB.'),
      display_name: z.string().describe('Display name for this image.'),
      source: z
        .enum(['github', 'partner', 'custom'])
        .describe('The image provider.')
    })
    .describe('Provides details of a hosted runner image')
  export type ActionsHostedRunnerImage = z.infer<
    typeof ActionsHostedRunnerImageSchema
  >

  export const ActionsHostedRunnerLimitsSchema = z.object({
    public_ips: z
      .object({
        maximum: z
          .number()
          .int()
          .describe(
            'The maximum number of static public IP addresses that can be used for Hosted Runners.'
          ),
        current_usage: z
          .number()
          .int()
          .describe(
            'The current number of static public IP addresses in use by Hosted Runners.'
          )
      })
      .describe(
        'Provides details of static public IP limits for GitHub-hosted Hosted Runners'
      )
  })
  export type ActionsHostedRunnerLimits = z.infer<
    typeof ActionsHostedRunnerLimitsSchema
  >

  export const HostedRunnerIdSchema = z
    .any()
    .describe('Unique identifier of the GitHub-hosted runner.')
  export type HostedRunnerId = z.infer<typeof HostedRunnerIdSchema>

  export const OidcCustomSubSchema = z
    .object({
      include_claim_keys: z
        .array(z.string())
        .describe(
          'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
        )
    })
    .describe('Actions OIDC Subject customization')
  export type OidcCustomSub = z.infer<typeof OidcCustomSubSchema>

  export const EmptyObjectSchema = z
    .object({})
    .strict()
    .describe('An object without any properties.')
  export type EmptyObject = z.infer<typeof EmptyObjectSchema>

  export const EnabledRepositoriesSchema = z
    .enum(['all', 'none', 'selected'])
    .describe(
      'The policy that controls the repositories in the organization that are allowed to run GitHub Actions.'
    )
  export type EnabledRepositories = z.infer<typeof EnabledRepositoriesSchema>

  export const AllowedActionsSchema = z
    .enum(['all', 'local_only', 'selected'])
    .describe(
      'The permissions policy that controls the actions and reusable workflows that are allowed to run.'
    )
  export type AllowedActions = z.infer<typeof AllowedActionsSchema>

  export const SelectedActionsUrlSchema = z
    .string()
    .describe(
      'The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.'
    )
  export type SelectedActionsUrl = z.infer<typeof SelectedActionsUrlSchema>

  export const RepositoryIdSchema = z
    .any()
    .describe('The unique identifier of the repository.')
  export type RepositoryId = z.infer<typeof RepositoryIdSchema>

  export const SelectedActionsSchema = z.object({
    github_owned_allowed: z
      .boolean()
      .describe(
        'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
      )
      .optional(),
    verified_allowed: z
      .boolean()
      .describe(
        'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
      )
      .optional(),
    patterns_allowed: z
      .array(z.string())
      .describe(
        'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\n\n> [!NOTE]\n> The `patterns_allowed` setting only applies to public repositories.'
      )
      .optional()
  })
  export type SelectedActions = z.infer<typeof SelectedActionsSchema>

  export const ActionsDefaultWorkflowPermissionsSchema = z
    .enum(['read', 'write'])
    .describe(
      'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.'
    )
  export type ActionsDefaultWorkflowPermissions = z.infer<
    typeof ActionsDefaultWorkflowPermissionsSchema
  >

  export const ActionsCanApprovePullRequestReviewsSchema = z
    .boolean()
    .describe(
      'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.'
    )
  export type ActionsCanApprovePullRequestReviews = z.infer<
    typeof ActionsCanApprovePullRequestReviewsSchema
  >

  export const RunnerGroupsOrgSchema = z.object({
    id: z.number(),
    name: z.string(),
    visibility: z.string(),
    default: z.boolean(),
    selected_repositories_url: z
      .string()
      .describe(
        'Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`'
      )
      .optional(),
    runners_url: z.string(),
    hosted_runners_url: z.string().optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    inherited: z.boolean(),
    inherited_allows_public_repositories: z.boolean().optional(),
    allows_public_repositories: z.boolean(),
    workflow_restrictions_read_only: z
      .boolean()
      .describe(
        'If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional()
  })
  export type RunnerGroupsOrg = z.infer<typeof RunnerGroupsOrgSchema>

  export const VisibleToRepositorySchema = z
    .any()
    .describe(
      'Only return runner groups that are allowed to be used by this repository.'
    )
  export type VisibleToRepository = z.infer<typeof VisibleToRepositorySchema>

  export const RunnerGroupIdSchema = z
    .any()
    .describe('Unique identifier of the self-hosted runner group.')
  export type RunnerGroupId = z.infer<typeof RunnerGroupIdSchema>

  export const RunnerLabelSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the label.')
        .optional(),
      name: z.string().describe('Name of the label.'),
      type: z
        .enum(['read-only', 'custom'])
        .describe(
          'The type of label. Read-only labels are applied automatically when the runner is configured.'
        )
        .optional()
    })
    .describe('A label for a self hosted runner')
  export type RunnerLabel = z.infer<typeof RunnerLabelSchema>

  export const RunnerIdSchema = z
    .any()
    .describe('Unique identifier of the self-hosted runner.')
  export type RunnerId = z.infer<typeof RunnerIdSchema>

  export const RunnerApplicationSchema = z
    .object({
      os: z.string(),
      architecture: z.string(),
      download_url: z.string(),
      filename: z.string(),
      temp_download_token: z
        .string()
        .describe(
          'A short lived bearer token used to download the runner, if needed.'
        )
        .optional(),
      sha256_checksum: z.string().optional()
    })
    .describe('Runner Application')
  export type RunnerApplication = z.infer<typeof RunnerApplicationSchema>

  export const RunnerLabelNameSchema = z
    .any()
    .describe("The name of a self-hosted runner's custom label.")
  export type RunnerLabelName = z.infer<typeof RunnerLabelNameSchema>

  export const OrganizationActionsSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a secret'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Secrets for GitHub Actions for an organization.')
  export type OrganizationActionsSecret = z.infer<
    typeof OrganizationActionsSecretSchema
  >

  export const ActionsPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.'),
      id: z.number().int().optional(),
      url: z.string().optional(),
      title: z.string().optional(),
      created_at: z.string().optional()
    })
    .describe('The public key used for setting Actions Secrets.')
  export type ActionsPublicKey = z.infer<typeof ActionsPublicKeySchema>

  export const SecretNameSchema = z.any().describe('The name of the secret.')
  export type SecretName = z.infer<typeof SecretNameSchema>

  export const OrganizationActionsVariableSchema = z
    .object({
      name: z.string().describe('The name of the variable.'),
      value: z.string().describe('The value of the variable.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a variable'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Organization variable for GitHub Actions.')
  export type OrganizationActionsVariable = z.infer<
    typeof OrganizationActionsVariableSchema
  >

  export const VariablesPerPageSchema = z
    .any()
    .describe(
      'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
    )
  export type VariablesPerPage = z.infer<typeof VariablesPerPageSchema>

  export const VariableNameSchema = z
    .any()
    .describe('The name of the variable.')
  export type VariableName = z.infer<typeof VariableNameSchema>

  export const UsernameSchema = z
    .any()
    .describe('The handle for the GitHub user account.')
  export type Username = z.infer<typeof UsernameSchema>

  export const AlertInstancesUrlSchema = z
    .string()
    .url()
    .describe(
      'The REST API URL for fetching the list of instances for an alert.'
    )
    .readonly()
  export type AlertInstancesUrl = z.infer<typeof AlertInstancesUrlSchema>

  export const CodeScanningAlertStateSchema = z
    .enum(['open', 'dismissed', 'fixed'])
    .describe('State of a code scanning alert.')
  export type CodeScanningAlertState = z.infer<
    typeof CodeScanningAlertStateSchema
  >

  export const CodeScanningAlertDismissedReasonSchema = z
    .enum(['false positive', "won't fix", 'used in tests'])
    .describe(
      '**Required when the state is dismissed.** The reason for dismissing or closing the alert.'
    )
  export type CodeScanningAlertDismissedReason = z.infer<
    typeof CodeScanningAlertDismissedReasonSchema
  >

  export const CodeScanningAlertDismissedCommentSchema = z
    .string()
    .max(280)
    .describe(
      'The dismissal comment associated with the dismissal of the alert.'
    )
  export type CodeScanningAlertDismissedComment = z.infer<
    typeof CodeScanningAlertDismissedCommentSchema
  >

  export const CodeScanningAlertRuleSummarySchema = z.object({
    id: z
      .string()
      .describe('A unique identifier for the rule used to detect the alert.')
      .optional(),
    name: z
      .string()
      .describe('The name of the rule used to detect the alert.')
      .optional(),
    severity: z
      .enum(['none', 'note', 'warning', 'error'])
      .describe('The severity of the alert.')
      .optional(),
    security_severity_level: z
      .enum(['low', 'medium', 'high', 'critical'])
      .describe('The security severity of the alert.')
      .optional(),
    description: z
      .string()
      .describe('A short description of the rule used to detect the alert.')
      .optional(),
    full_description: z
      .string()
      .describe('A description of the rule used to detect the alert.')
      .optional(),
    tags: z
      .array(z.string())
      .describe('A set of tags applicable for the rule.')
      .optional(),
    help: z
      .string()
      .describe(
        'Detailed documentation for the rule as GitHub Flavored Markdown.'
      )
      .optional(),
    help_uri: z
      .string()
      .describe(
        'A link to the documentation for the rule used to detect the alert.'
      )
      .optional()
  })
  export type CodeScanningAlertRuleSummary = z.infer<
    typeof CodeScanningAlertRuleSummarySchema
  >

  export const CodeScanningAnalysisToolNameSchema = z
    .string()
    .describe(
      'The name of the tool used to generate the code scanning analysis.'
    )
  export type CodeScanningAnalysisToolName = z.infer<
    typeof CodeScanningAnalysisToolNameSchema
  >

  export const CodeScanningAnalysisToolVersionSchema = z
    .string()
    .describe(
      'The version of the tool used to generate the code scanning analysis.'
    )
  export type CodeScanningAnalysisToolVersion = z.infer<
    typeof CodeScanningAnalysisToolVersionSchema
  >

  export const CodeScanningAnalysisToolGuidSchema = z
    .string()
    .describe(
      'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.'
    )
  export type CodeScanningAnalysisToolGuid = z.infer<
    typeof CodeScanningAnalysisToolGuidSchema
  >

  export const CodeScanningRefSchema = z
    .string()
    .describe(
      'The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.'
    )
  export type CodeScanningRef = z.infer<typeof CodeScanningRefSchema>

  export const CodeScanningAnalysisAnalysisKeySchema = z
    .string()
    .describe(
      'Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.'
    )
  export type CodeScanningAnalysisAnalysisKey = z.infer<
    typeof CodeScanningAnalysisAnalysisKeySchema
  >

  export const CodeScanningAlertEnvironmentSchema = z
    .string()
    .describe(
      'Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.'
    )
  export type CodeScanningAlertEnvironment = z.infer<
    typeof CodeScanningAlertEnvironmentSchema
  >

  export const CodeScanningAnalysisCategorySchema = z
    .string()
    .describe(
      'Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.'
    )
  export type CodeScanningAnalysisCategory = z.infer<
    typeof CodeScanningAnalysisCategorySchema
  >

  export const CodeScanningAlertLocationSchema = z
    .object({
      path: z.string().optional(),
      start_line: z.number().int().optional(),
      end_line: z.number().int().optional(),
      start_column: z.number().int().optional(),
      end_column: z.number().int().optional()
    })
    .describe('Describe a region within a file for the alert.')
  export type CodeScanningAlertLocation = z.infer<
    typeof CodeScanningAlertLocationSchema
  >

  export const CodeScanningAlertClassificationSchema = z
    .enum(['source', 'generated', 'test', 'library'])
    .describe(
      'A classification of the file. For example to identify it as generated.'
    )
  export type CodeScanningAlertClassification = z.infer<
    typeof CodeScanningAlertClassificationSchema
  >

  export const NullableCodespaceMachineSchema = z
    .object({
      name: z.string().describe('The name of the machine.'),
      display_name: z
        .string()
        .describe(
          'The display name of the machine includes cores, memory, and storage.'
        ),
      operating_system: z
        .string()
        .describe('The operating system of the machine.'),
      storage_in_bytes: z
        .number()
        .int()
        .describe('How much storage is available to the codespace.'),
      memory_in_bytes: z
        .number()
        .int()
        .describe('How much memory is available to the codespace.'),
      cpus: z
        .number()
        .int()
        .describe('How many cores are available to the codespace.'),
      prebuild_availability: z
        .enum(['none', 'ready', 'in_progress'])
        .describe(
          'Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.'
        )
    })
    .describe('A description of the machine powering a codespace.')
  export type NullableCodespaceMachine = z.infer<
    typeof NullableCodespaceMachineSchema
  >

  export const CodespacesOrgSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'The type of repositories in the organization that the secret is visible to'
        ),
      selected_repositories_url: z
        .string()
        .url()
        .describe(
          'The API URL at which the list of repositories this secret is visible to can be retrieved'
        )
        .optional()
    })
    .describe('Secrets for a GitHub Codespace.')
  export type CodespacesOrgSecret = z.infer<typeof CodespacesOrgSecretSchema>

  export const CodespacesPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.'),
      id: z.number().int().optional(),
      url: z.string().optional(),
      title: z.string().optional(),
      created_at: z.string().optional()
    })
    .describe('The public key used for setting Codespaces secrets.')
  export type CodespacesPublicKey = z.infer<typeof CodespacesPublicKeySchema>

  export const CopilotOrganizationSeatBreakdownSchema = z
    .object({
      total: z
        .number()
        .int()
        .describe(
          'The total number of seats being billed for the organization as of the current billing cycle.'
        )
        .optional(),
      added_this_cycle: z
        .number()
        .int()
        .describe('Seats added during the current billing cycle.')
        .optional(),
      pending_cancellation: z
        .number()
        .int()
        .describe(
          'The number of seats that are pending cancellation at the end of the current billing cycle.'
        )
        .optional(),
      pending_invitation: z
        .number()
        .int()
        .describe(
          'The number of users who have been invited to receive a Copilot seat through this organization.'
        )
        .optional(),
      active_this_cycle: z
        .number()
        .int()
        .describe(
          'The number of seats that have used Copilot during the current billing cycle.'
        )
        .optional(),
      inactive_this_cycle: z
        .number()
        .int()
        .describe(
          'The number of seats that have not used Copilot during the current billing cycle.'
        )
        .optional()
    })
    .describe('The breakdown of Copilot Business seats for the organization.')
  export type CopilotOrganizationSeatBreakdown = z.infer<
    typeof CopilotOrganizationSeatBreakdownSchema
  >

  export const NullableOrganizationSimpleSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string()
    })
    .describe('A GitHub organization.')
  export type NullableOrganizationSimple = z.infer<
    typeof NullableOrganizationSimpleSchema
  >

  export const NullableTeamSimpleSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      members_url: z.string(),
      name: z.string().describe('Name of the team'),
      description: z.string().describe('Description of the team'),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      privacy: z
        .string()
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .string()
        .describe('The notification setting the team has set')
        .optional(),
      html_url: z.string().url(),
      repositories_url: z.string().url(),
      slug: z.string(),
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type NullableTeamSimple = z.infer<typeof NullableTeamSimpleSchema>

  export const EnterpriseTeamSchema = z
    .object({
      id: z.number().int(),
      name: z.string(),
      slug: z.string(),
      url: z.string().url(),
      sync_to_organizations: z.string(),
      group_id: z.string().optional(),
      group_name: z.string().optional(),
      html_url: z.string().url(),
      members_url: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Group of enterprise owners and/or members')
  export type EnterpriseTeam = z.infer<typeof EnterpriseTeamSchema>

  export const CopilotIdeCodeCompletionsSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'Number of users who accepted at least one Copilot code suggestion, across all active editors. Includes both full and partial acceptances.'
        )
        .optional(),
      languages: z
        .array(
          z
            .object({
              name: z
                .string()
                .describe(
                  'Name of the language used for Copilot code completion suggestions.'
                )
                .optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'Number of users who accepted at least one Copilot code completion suggestion for the given language. Includes both full and partial acceptances.'
                )
                .optional()
            })
            .describe(
              'Usage metrics for a given language for the given editor for Copilot code completions.'
            )
        )
        .describe('Code completion metrics for active languages.')
        .optional(),
      editors: z
        .array(
          z
            .object({
              name: z.string().describe('Name of the given editor.').optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'Number of users who accepted at least one Copilot code completion suggestion for the given editor. Includes both full and partial acceptances.'
                )
                .optional(),
              models: z
                .array(
                  z.object({
                    name: z
                      .string()
                      .describe(
                        "Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'."
                      )
                      .optional(),
                    is_custom_model: z
                      .boolean()
                      .describe(
                        'Indicates whether a model is custom or default.'
                      )
                      .optional(),
                    custom_model_training_date: z
                      .string()
                      .describe('The training date for the custom model.')
                      .optional(),
                    total_engaged_users: z
                      .number()
                      .int()
                      .describe(
                        'Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language and model. Includes both full and partial acceptances.'
                      )
                      .optional(),
                    languages: z
                      .array(
                        z
                          .object({
                            name: z
                              .string()
                              .describe(
                                'Name of the language used for Copilot code completion suggestions, for the given editor.'
                              )
                              .optional(),
                            total_engaged_users: z
                              .number()
                              .int()
                              .describe(
                                'Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language. Includes both full and partial acceptances.'
                              )
                              .optional(),
                            total_code_suggestions: z
                              .number()
                              .int()
                              .describe(
                                'The number of Copilot code suggestions generated for the given editor, for the given language.'
                              )
                              .optional(),
                            total_code_acceptances: z
                              .number()
                              .int()
                              .describe(
                                'The number of Copilot code suggestions accepted for the given editor, for the given language. Includes both full and partial acceptances.'
                              )
                              .optional(),
                            total_code_lines_suggested: z
                              .number()
                              .int()
                              .describe(
                                'The number of lines of code suggested by Copilot code completions for the given editor, for the given language.'
                              )
                              .optional(),
                            total_code_lines_accepted: z
                              .number()
                              .int()
                              .describe(
                                'The number of lines of code accepted from Copilot code suggestions for the given editor, for the given language.'
                              )
                              .optional()
                          })
                          .describe(
                            'Usage metrics for a given language for the given editor for Copilot code completions.'
                          )
                      )
                      .describe(
                        'Code completion metrics for active languages, for the given editor.'
                      )
                      .optional()
                  })
                )
                .describe(
                  'List of model metrics for custom models and the default model.'
                )
                .optional()
            })
            .catchall(z.any())
            .describe('Copilot code completion metrics for active editors.')
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot editor code completions in the IDE.')
  export type CopilotIdeCodeCompletions = z.infer<
    typeof CopilotIdeCodeCompletionsSchema
  >

  export const CopilotIdeChatSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe('Total number of users who prompted Copilot Chat in the IDE.')
        .optional(),
      editors: z
        .array(
          z
            .object({
              name: z.string().describe('Name of the given editor.').optional(),
              total_engaged_users: z
                .number()
                .int()
                .describe(
                  'The number of users who prompted Copilot Chat in the specified editor.'
                )
                .optional(),
              models: z
                .array(
                  z.object({
                    name: z
                      .string()
                      .describe(
                        "Name of the model used for Copilot Chat. If the default model is used will appear as 'default'."
                      )
                      .optional(),
                    is_custom_model: z
                      .boolean()
                      .describe(
                        'Indicates whether a model is custom or default.'
                      )
                      .optional(),
                    custom_model_training_date: z
                      .string()
                      .describe('The training date for the custom model.')
                      .optional(),
                    total_engaged_users: z
                      .number()
                      .int()
                      .describe(
                        'The number of users who prompted Copilot Chat in the given editor and model.'
                      )
                      .optional(),
                    total_chats: z
                      .number()
                      .int()
                      .describe(
                        'The total number of chats initiated by users in the given editor and model.'
                      )
                      .optional(),
                    total_chat_insertion_events: z
                      .number()
                      .int()
                      .describe(
                        "The number of times users accepted a code suggestion from Copilot Chat using the 'Insert Code' UI element, for the given editor."
                      )
                      .optional(),
                    total_chat_copy_events: z
                      .number()
                      .int()
                      .describe(
                        "The number of times users copied a code suggestion from Copilot Chat using the keyboard, or the 'Copy' UI element, for the given editor."
                      )
                      .optional()
                  })
                )
                .describe(
                  'List of model metrics for custom models and the default model.'
                )
                .optional()
            })
            .describe('Copilot Chat metrics, for active editors.')
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot Chat in the IDE.')
  export type CopilotIdeChat = z.infer<typeof CopilotIdeChatSchema>

  export const CopilotDotcomChatSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'Total number of users who prompted Copilot Chat on github.com at least once.'
        )
        .optional(),
      models: z
        .array(
          z.object({
            name: z
              .string()
              .describe(
                "Name of the model used for Copilot Chat. If the default model is used will appear as 'default'."
              )
              .optional(),
            is_custom_model: z
              .boolean()
              .describe('Indicates whether a model is custom or default.')
              .optional(),
            custom_model_training_date: z
              .string()
              .describe(
                'The training date for the custom model (if applicable).'
              )
              .optional(),
            total_engaged_users: z
              .number()
              .int()
              .describe(
                'Total number of users who prompted Copilot Chat on github.com at least once for each model.'
              )
              .optional(),
            total_chats: z
              .number()
              .int()
              .describe(
                'Total number of chats initiated by users on github.com.'
              )
              .optional()
          })
        )
        .describe(
          'List of model metrics for a custom models and the default model.'
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot Chat in GitHub.com')
  export type CopilotDotcomChat = z.infer<typeof CopilotDotcomChatSchema>

  export const CopilotDotcomPullRequestsSchema = z
    .object({
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'The number of users who used Copilot for Pull Requests on github.com to generate a pull request summary at least once.'
        )
        .optional(),
      repositories: z
        .array(
          z.object({
            name: z.string().describe('Repository name').optional(),
            total_engaged_users: z
              .number()
              .int()
              .describe(
                'The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository.'
              )
              .optional(),
            models: z
              .array(
                z.object({
                  name: z
                    .string()
                    .describe(
                      "Name of the model used for Copilot pull request summaries. If the default model is used will appear as 'default'."
                    )
                    .optional(),
                  is_custom_model: z
                    .boolean()
                    .describe('Indicates whether a model is custom or default.')
                    .optional(),
                  custom_model_training_date: z
                    .string()
                    .describe('The training date for the custom model.')
                    .optional(),
                  total_pr_summaries_created: z
                    .number()
                    .int()
                    .describe(
                      'The number of pull request summaries generated using Copilot for Pull Requests in the given repository.'
                    )
                    .optional(),
                  total_engaged_users: z
                    .number()
                    .int()
                    .describe(
                      'The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository and model.'
                    )
                    .optional()
                })
              )
              .describe(
                'List of model metrics for custom models and the default model.'
              )
              .optional()
          })
        )
        .describe(
          'Repositories in which users used Copilot for Pull Requests to generate pull request summaries'
        )
        .optional()
    })
    .catchall(z.any())
    .describe('Usage metrics for Copilot for pull requests.')
  export type CopilotDotcomPullRequests = z.infer<
    typeof CopilotDotcomPullRequestsSchema
  >

  export const CopilotUsageMetricsSchema = z
    .object({
      day: z
        .string()
        .date()
        .describe(
          'The date for which the usage metrics are reported, in `YYYY-MM-DD` format.'
        ),
      total_suggestions_count: z
        .number()
        .int()
        .describe(
          'The total number of Copilot code completion suggestions shown to users.'
        )
        .optional(),
      total_acceptances_count: z
        .number()
        .int()
        .describe(
          'The total number of Copilot code completion suggestions accepted by users.'
        )
        .optional(),
      total_lines_suggested: z
        .number()
        .int()
        .describe(
          'The total number of lines of code completions suggested by Copilot.'
        )
        .optional(),
      total_lines_accepted: z
        .number()
        .int()
        .describe(
          'The total number of lines of code completions accepted by users.'
        )
        .optional(),
      total_active_users: z
        .number()
        .int()
        .describe(
          'The total number of users who were shown Copilot code completion suggestions during the day specified.'
        )
        .optional(),
      total_chat_acceptances: z
        .number()
        .int()
        .describe(
          'The total instances of users who accepted code suggested by Copilot Chat in the IDE (panel and inline).'
        )
        .optional(),
      total_chat_turns: z
        .number()
        .int()
        .describe(
          'The total number of chat turns (prompt and response pairs) sent between users and Copilot Chat in the IDE.'
        )
        .optional(),
      total_active_chat_users: z
        .number()
        .int()
        .describe(
          'The total number of users who interacted with Copilot Chat in the IDE during the day specified.'
        )
        .optional(),
      breakdown: z
        .array(
          z
            .object({
              language: z
                .string()
                .describe(
                  'The language in which Copilot suggestions were shown to users in the specified editor.'
                )
                .optional(),
              editor: z
                .string()
                .describe(
                  'The editor in which Copilot suggestions were shown to users for the specified language.'
                )
                .optional(),
              suggestions_count: z
                .number()
                .int()
                .describe(
                  'The number of Copilot suggestions shown to users in the editor specified during the day specified.'
                )
                .optional(),
              acceptances_count: z
                .number()
                .int()
                .describe(
                  'The number of Copilot suggestions accepted by users in the editor specified during the day specified.'
                )
                .optional(),
              lines_suggested: z
                .number()
                .int()
                .describe(
                  'The number of lines of code suggested by Copilot in the editor specified during the day specified.'
                )
                .optional(),
              lines_accepted: z
                .number()
                .int()
                .describe(
                  'The number of lines of code accepted by users in the editor specified during the day specified.'
                )
                .optional(),
              active_users: z
                .number()
                .int()
                .describe(
                  'The number of users who were shown Copilot completion suggestions in the editor specified during the day specified.'
                )
                .optional()
            })
            .catchall(z.any())
            .describe('Breakdown of Copilot usage by editor for this language')
        )
        .describe(
          'Breakdown of Copilot code completions usage by language and editor'
        )
    })
    .strict()
    .describe('Summary of Copilot usage.')
  export type CopilotUsageMetrics = z.infer<typeof CopilotUsageMetricsSchema>

  export const OrganizationDependabotSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe('Visibility of a secret'),
      selected_repositories_url: z.string().url().optional()
    })
    .describe('Secrets for GitHub Dependabot for an organization.')
  export type OrganizationDependabotSecret = z.infer<
    typeof OrganizationDependabotSecretSchema
  >

  export const DependabotPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.')
    })
    .describe('The public key used for setting Dependabot Secrets.')
  export type DependabotPublicKey = z.infer<typeof DependabotPublicKeySchema>

  export const OrgHookSchema = z
    .object({
      id: z.number().int(),
      url: z.string().url(),
      ping_url: z.string().url(),
      deliveries_url: z.string().url().optional(),
      name: z.string(),
      events: z.array(z.string()),
      active: z.boolean(),
      config: z.object({
        url: z.string().optional(),
        insecure_ssl: z.string().optional(),
        content_type: z.string().optional(),
        secret: z.string().optional()
      }),
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      type: z.string()
    })
    .describe('Org Hook')
  export type OrgHook = z.infer<typeof OrgHookSchema>

  export const HookIdSchema = z
    .any()
    .describe(
      'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
    )
  export type HookId = z.infer<typeof HookIdSchema>

  export const ApiInsightsRouteStatsSchema = z
    .array(
      z.object({
        http_method: z.string().describe('The HTTP method').optional(),
        api_route: z
          .string()
          .describe("The API path's route template")
          .optional(),
        total_request_count: z
          .number()
          .int()
          .describe(
            'The total number of requests within the queried time period'
          )
          .optional(),
        rate_limited_request_count: z
          .number()
          .int()
          .describe(
            'The total number of requests that were rate limited within the queried time period'
          )
          .optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage route stats for an actor')
  export type ApiInsightsRouteStats = z.infer<
    typeof ApiInsightsRouteStatsSchema
  >

  export const ApiInsightsActorTypeSchema = z
    .any()
    .describe('The type of the actor')
  export type ApiInsightsActorType = z.infer<typeof ApiInsightsActorTypeSchema>

  export const ApiInsightsActorIdSchema = z
    .any()
    .describe('The ID of the actor')
  export type ApiInsightsActorId = z.infer<typeof ApiInsightsActorIdSchema>

  export const ApiInsightsMinTimestampSchema = z
    .any()
    .describe(
      'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type ApiInsightsMinTimestamp = z.infer<
    typeof ApiInsightsMinTimestampSchema
  >

  export const ApiInsightsMaxTimestampSchema = z
    .any()
    .describe(
      'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type ApiInsightsMaxTimestamp = z.infer<
    typeof ApiInsightsMaxTimestampSchema
  >

  export const ApiInsightsRouteStatsSortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type ApiInsightsRouteStatsSort = z.infer<
    typeof ApiInsightsRouteStatsSortSchema
  >

  export const ApiInsightsApiRouteSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsApiRouteSubstring = z.infer<
    typeof ApiInsightsApiRouteSubstringSchema
  >

  export const ApiInsightsSubjectStatsSchema = z
    .array(
      z.object({
        subject_type: z.string().optional(),
        subject_name: z.string().optional(),
        subject_id: z.number().int().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage subject stats for an organization')
  export type ApiInsightsSubjectStats = z.infer<
    typeof ApiInsightsSubjectStatsSchema
  >

  export const ApiInsightsSortSchema = z
    .any()
    .describe('The property to sort the results by.')
  export type ApiInsightsSort = z.infer<typeof ApiInsightsSortSchema>

  export const ApiInsightsSubjectNameSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsSubjectNameSubstring = z.infer<
    typeof ApiInsightsSubjectNameSubstringSchema
  >

  export const ApiInsightsSummaryStatsSchema = z
    .object({
      total_request_count: z
        .number()
        .int()
        .describe('The total number of requests within the queried time period')
        .optional(),
      rate_limited_request_count: z
        .number()
        .int()
        .describe(
          'The total number of requests that were rate limited within the queried time period'
        )
        .optional()
    })
    .describe('API Insights usage summary stats for an organization')
  export type ApiInsightsSummaryStats = z.infer<
    typeof ApiInsightsSummaryStatsSchema
  >

  export const ApiInsightsUserIdSchema = z
    .any()
    .describe('The ID of the user to query for stats')
  export type ApiInsightsUserId = z.infer<typeof ApiInsightsUserIdSchema>

  export const ApiInsightsTimeStatsSchema = z
    .array(
      z.object({
        timestamp: z.string().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional()
      })
    )
    .describe('API Insights usage time stats for an organization')
  export type ApiInsightsTimeStats = z.infer<typeof ApiInsightsTimeStatsSchema>

  export const ApiInsightsTimestampIncrementSchema = z
    .any()
    .describe(
      'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
    )
  export type ApiInsightsTimestampIncrement = z.infer<
    typeof ApiInsightsTimestampIncrementSchema
  >

  export const ApiInsightsUserStatsSchema = z
    .array(
      z.object({
        actor_type: z.string().optional(),
        actor_name: z.string().optional(),
        actor_id: z.number().int().optional(),
        integration_id: z.number().int().optional(),
        oauth_application_id: z.number().int().optional(),
        total_request_count: z.number().int().optional(),
        rate_limited_request_count: z.number().int().optional(),
        last_rate_limited_timestamp: z.string().optional(),
        last_request_timestamp: z.string().optional()
      })
    )
    .describe('API Insights usage stats for a user')
  export type ApiInsightsUserStats = z.infer<typeof ApiInsightsUserStatsSchema>

  export const ApiInsightsActorNameSubstringSchema = z
    .any()
    .describe(
      'Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.'
    )
  export type ApiInsightsActorNameSubstring = z.infer<
    typeof ApiInsightsActorNameSubstringSchema
  >

  export const InteractionGroupSchema = z
    .enum(['existing_users', 'contributors_only', 'collaborators_only'])
    .describe(
      'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.'
    )
  export type InteractionGroup = z.infer<typeof InteractionGroupSchema>

  export const InteractionExpirySchema = z
    .enum(['one_day', 'three_days', 'one_week', 'one_month', 'six_months'])
    .describe(
      'The duration of the interaction restriction. Default: `one_day`.'
    )
  export type InteractionExpiry = z.infer<typeof InteractionExpirySchema>

  export const InvitationIdSchema = z
    .any()
    .describe('The unique identifier of the invitation.')
  export type InvitationId = z.infer<typeof InvitationIdSchema>

  export const OrganizationCreateIssueTypeSchema = z.object({
    name: z.string().describe('Name of the issue type.'),
    is_enabled: z
      .boolean()
      .describe(
        'Whether or not the issue type is enabled at the organization level.'
      ),
    is_private: z
      .boolean()
      .describe(
        'Whether or not the issue type is restricted to issues in private repositories.'
      )
      .optional(),
    description: z
      .string()
      .describe('Description of the issue type.')
      .optional(),
    color: z
      .enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
      ])
      .describe('Color for the issue type.')
      .optional()
  })
  export type OrganizationCreateIssueType = z.infer<
    typeof OrganizationCreateIssueTypeSchema
  >

  export const OrganizationUpdateIssueTypeSchema = z.object({
    name: z.string().describe('Name of the issue type.'),
    is_enabled: z
      .boolean()
      .describe(
        'Whether or not the issue type is enabled at the organization level.'
      ),
    is_private: z
      .boolean()
      .describe(
        'Whether or not the issue type is restricted to issues in private repositories.'
      )
      .optional(),
    description: z
      .string()
      .describe('Description of the issue type.')
      .optional(),
    color: z
      .enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
      ])
      .describe('Color for the issue type.')
      .optional()
  })
  export type OrganizationUpdateIssueType = z.infer<
    typeof OrganizationUpdateIssueTypeSchema
  >

  export const IssueTypeIdSchema = z
    .any()
    .describe('The unique identifier of the issue type.')
  export type IssueTypeId = z.infer<typeof IssueTypeIdSchema>

  export const CodespaceNameSchema = z
    .any()
    .describe('The name of the codespace.')
  export type CodespaceName = z.infer<typeof CodespaceNameSchema>

  export const MigrationIdSchema = z
    .any()
    .describe('The unique identifier of the migration.')
  export type MigrationId = z.infer<typeof MigrationIdSchema>

  export const RepoNameSchema = z.any().describe('repo_name parameter')
  export type RepoName = z.infer<typeof RepoNameSchema>

  export const TeamSlugSchema = z.any().describe('The slug of the team name.')
  export type TeamSlug = z.infer<typeof TeamSlugSchema>

  export const RoleIdSchema = z
    .any()
    .describe('The unique identifier of the role.')
  export type RoleId = z.infer<typeof RoleIdSchema>

  export const TeamSimpleSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      members_url: z.string(),
      name: z.string().describe('Name of the team'),
      description: z.string().describe('Description of the team'),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      privacy: z
        .string()
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .string()
        .describe('The notification setting the team has set')
        .optional(),
      html_url: z.string().url(),
      repositories_url: z.string().url(),
      slug: z.string(),
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type TeamSimple = z.infer<typeof TeamSimpleSchema>

  export const PackageVisibilitySchema = z
    .any()
    .describe(
      'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
    )
  export type PackageVisibility = z.infer<typeof PackageVisibilitySchema>

  export const PackageTypeSchema = z
    .any()
    .describe(
      "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
    )
  export type PackageType = z.infer<typeof PackageTypeSchema>

  export const PackageNameSchema = z.any().describe('The name of the package.')
  export type PackageName = z.infer<typeof PackageNameSchema>

  export const PackageVersionSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.'),
      name: z.string().describe('The name of the package version.'),
      url: z.string(),
      package_html_url: z.string(),
      html_url: z.string().optional(),
      license: z.string().optional(),
      description: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      deleted_at: z.string().datetime({ offset: true }).optional(),
      metadata: z
        .object({
          package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
          ]),
          container: z.object({ tags: z.array(z.string()) }).optional(),
          docker: z.object({ tag: z.array(z.string()).optional() }).optional()
        })
        .optional()
    })
    .describe('A version of a software package')
  export type PackageVersion = z.infer<typeof PackageVersionSchema>

  export const PackageVersionIdSchema = z
    .any()
    .describe('Unique identifier of the package version.')
  export type PackageVersionId = z.infer<typeof PackageVersionIdSchema>

  export const PersonalAccessTokenSortSchema = z
    .any()
    .describe('The property by which to sort the results.')
  export type PersonalAccessTokenSort = z.infer<
    typeof PersonalAccessTokenSortSchema
  >

  export const PersonalAccessTokenOwnerSchema = z
    .any()
    .describe('A list of owner usernames to use to filter the results.')
  export type PersonalAccessTokenOwner = z.infer<
    typeof PersonalAccessTokenOwnerSchema
  >

  export const PersonalAccessTokenRepositorySchema = z
    .any()
    .describe('The name of the repository to use to filter the results.')
  export type PersonalAccessTokenRepository = z.infer<
    typeof PersonalAccessTokenRepositorySchema
  >

  export const PersonalAccessTokenPermissionSchema = z
    .any()
    .describe('The permission to use to filter the results.')
  export type PersonalAccessTokenPermission = z.infer<
    typeof PersonalAccessTokenPermissionSchema
  >

  export const PersonalAccessTokenBeforeSchema = z
    .any()
    .describe(
      'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type PersonalAccessTokenBefore = z.infer<
    typeof PersonalAccessTokenBeforeSchema
  >

  export const PersonalAccessTokenAfterSchema = z
    .any()
    .describe(
      'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type PersonalAccessTokenAfter = z.infer<
    typeof PersonalAccessTokenAfterSchema
  >

  export const PersonalAccessTokenTokenIdSchema = z
    .any()
    .describe('The ID of the token')
  export type PersonalAccessTokenTokenId = z.infer<
    typeof PersonalAccessTokenTokenIdSchema
  >

  export const FineGrainedPersonalAccessTokenIdSchema = z
    .any()
    .describe(
      'The unique identifier of the fine-grained personal access token.'
    )
  export type FineGrainedPersonalAccessTokenId = z.infer<
    typeof FineGrainedPersonalAccessTokenIdSchema
  >

  export const OrgPrivateRegistryConfigurationSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the private registry configuration.'),
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry.'
        )
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry.'
        ),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Private registry configuration for an organization')
  export type OrgPrivateRegistryConfiguration = z.infer<
    typeof OrgPrivateRegistryConfigurationSchema
  >

  export const OrgPrivateRegistryConfigurationWithSelectedRepositoriesSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the private registry configuration.'),
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry.'
        )
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        ),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry when `visibility` is set to `selected`.'
        )
        .optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Private registry configuration for an organization')
  export type OrgPrivateRegistryConfigurationWithSelectedRepositories = z.infer<
    typeof OrgPrivateRegistryConfigurationWithSelectedRepositoriesSchema
  >

  export const CustomPropertySchema = z
    .object({
      property_name: z.string().describe('The name of the property'),
      url: z
        .string()
        .url()
        .describe(
          'The URL that can be used to fetch, update, or delete info about this property via the API.'
        )
        .optional(),
      source_type: z
        .enum(['organization', 'enterprise'])
        .describe('The source type of the property')
        .optional(),
      value_type: z
        .enum(['string', 'single_select', 'multi_select', 'true_false'])
        .describe('The type of the value for the property'),
      required: z
        .boolean()
        .describe('Whether the property is required.')
        .optional(),
      default_value: z
        .union([z.string(), z.array(z.string())])
        .describe('Default value of the property')
        .optional(),
      description: z
        .string()
        .describe('Short description of the property')
        .optional(),
      allowed_values: z
        .array(z.string().max(75))
        .max(200)
        .describe(
          'An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.'
        )
        .optional(),
      values_editable_by: z
        .enum(['org_actors', 'org_and_repo_actors'])
        .describe('Who can edit the values of the property')
        .optional()
    })
    .describe('Custom property defined on an organization')
  export type CustomProperty = z.infer<typeof CustomPropertySchema>

  export const CustomPropertyNameSchema = z
    .any()
    .describe('The custom property name')
  export type CustomPropertyName = z.infer<typeof CustomPropertyNameSchema>

  export const CustomPropertySetPayloadSchema = z
    .object({
      value_type: z
        .enum(['string', 'single_select', 'multi_select', 'true_false'])
        .describe('The type of the value for the property'),
      required: z
        .boolean()
        .describe('Whether the property is required.')
        .optional(),
      default_value: z
        .union([z.string(), z.array(z.string())])
        .describe('Default value of the property')
        .optional(),
      description: z
        .string()
        .describe('Short description of the property')
        .optional(),
      allowed_values: z
        .array(z.string().max(75))
        .max(200)
        .describe(
          'An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.'
        )
        .optional(),
      values_editable_by: z
        .enum(['org_actors', 'org_and_repo_actors'])
        .describe('Who can edit the values of the property')
        .optional()
    })
    .describe('Custom property set payload')
  export type CustomPropertySetPayload = z.infer<
    typeof CustomPropertySetPayloadSchema
  >

  export const CustomPropertyValueSchema = z
    .object({
      property_name: z.string().describe('The name of the property'),
      value: z
        .union([z.string(), z.array(z.string())])
        .describe('The value assigned to the property')
    })
    .describe('Custom property name and associated value')
  export type CustomPropertyValue = z.infer<typeof CustomPropertyValueSchema>

  export const CodeOfConductSimpleSchema = z
    .object({
      url: z.string().url(),
      key: z.string(),
      name: z.string(),
      html_url: z.string().url()
    })
    .describe('Code of Conduct Simple')
  export type CodeOfConductSimple = z.infer<typeof CodeOfConductSimpleSchema>

  export const RepositoryRuleEnforcementSchema = z
    .enum(['disabled', 'active', 'evaluate'])
    .describe(
      'The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).'
    )
  export type RepositoryRuleEnforcement = z.infer<
    typeof RepositoryRuleEnforcementSchema
  >

  export const RepositoryRulesetBypassActorSchema = z
    .object({
      actor_id: z
        .number()
        .int()
        .describe(
          'The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.'
        )
        .optional(),
      actor_type: z
        .enum([
          'Integration',
          'OrganizationAdmin',
          'RepositoryRole',
          'Team',
          'DeployKey'
        ])
        .describe('The type of actor that can bypass a ruleset.'),
      bypass_mode: z
        .enum(['always', 'pull_request'])
        .describe(
          'When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.'
        )
        .default('always')
    })
    .describe('An actor that can bypass rules in a ruleset')
  export type RepositoryRulesetBypassActor = z.infer<
    typeof RepositoryRulesetBypassActorSchema
  >

  export const RepositoryRulesetConditionsSchema = z
    .object({
      ref_name: z
        .object({
          include: z
            .array(z.string())
            .describe(
              'Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.'
            )
            .optional(),
          exclude: z
            .array(z.string())
            .describe(
              'Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.'
            )
            .optional()
        })
        .optional()
    })
    .describe('Parameters for a repository ruleset ref name condition')
  export type RepositoryRulesetConditions = z.infer<
    typeof RepositoryRulesetConditionsSchema
  >

  export const RepositoryRulesetConditionsRepositoryNameTargetSchema = z
    .object({
      repository_name: z.object({
        include: z
          .array(z.string())
          .describe(
            'Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.'
          )
          .optional(),
        exclude: z
          .array(z.string())
          .describe(
            'Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.'
          )
          .optional(),
        protected: z
          .boolean()
          .describe('Whether renaming of target repositories is prevented.')
          .optional()
      })
    })
    .describe('Parameters for a repository name condition')
  export type RepositoryRulesetConditionsRepositoryNameTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryNameTargetSchema
  >

  export const RepositoryRulesetConditionsRepositoryIdTargetSchema = z
    .object({
      repository_id: z.object({
        repository_ids: z
          .array(z.number().int())
          .describe(
            'The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.'
          )
          .optional()
      })
    })
    .describe('Parameters for a repository ID condition')
  export type RepositoryRulesetConditionsRepositoryIdTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryIdTargetSchema
  >

  export const RepositoryRulesetConditionsRepositoryPropertySpecSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the repository property to target'),
      property_values: z
        .array(z.string())
        .describe('The values to match for the repository property'),
      source: z
        .enum(['custom', 'system'])
        .describe(
          "The source of the repository property. Defaults to 'custom' if not specified."
        )
        .optional()
    })
    .describe('Parameters for a targeting a repository property')
  export type RepositoryRulesetConditionsRepositoryPropertySpec = z.infer<
    typeof RepositoryRulesetConditionsRepositoryPropertySpecSchema
  >

  export const RepositoryRuleCreationSchema = z
    .object({ type: z.literal('creation') })
    .describe(
      'Only allow users with bypass permission to create matching refs.'
    )
  export type RepositoryRuleCreation = z.infer<
    typeof RepositoryRuleCreationSchema
  >

  export const RepositoryRuleUpdateSchema = z
    .object({
      type: z.literal('update'),
      parameters: z
        .object({
          update_allows_fetch_and_merge: z
            .boolean()
            .describe('Branch can pull changes from its upstream repository')
        })
        .optional()
    })
    .describe(
      'Only allow users with bypass permission to update matching refs.'
    )
  export type RepositoryRuleUpdate = z.infer<typeof RepositoryRuleUpdateSchema>

  export const RepositoryRuleDeletionSchema = z
    .object({ type: z.literal('deletion') })
    .describe(
      'Only allow users with bypass permissions to delete matching refs.'
    )
  export type RepositoryRuleDeletion = z.infer<
    typeof RepositoryRuleDeletionSchema
  >

  export const RepositoryRuleRequiredLinearHistorySchema = z
    .object({ type: z.literal('required_linear_history') })
    .describe('Prevent merge commits from being pushed to matching refs.')
  export type RepositoryRuleRequiredLinearHistory = z.infer<
    typeof RepositoryRuleRequiredLinearHistorySchema
  >

  export const RepositoryRuleMergeQueueSchema = z
    .object({
      type: z.literal('merge_queue'),
      parameters: z
        .object({
          check_response_timeout_minutes: z
            .number()
            .int()
            .gte(1)
            .lte(360)
            .describe(
              'Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed'
            ),
          grouping_strategy: z
            .enum(['ALLGREEN', 'HEADGREEN'])
            .describe(
              'When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.'
            ),
          max_entries_to_build: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'Limit the number of queued pull requests requesting checks and workflow runs at the same time.'
            ),
          max_entries_to_merge: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'The maximum number of PRs that will be merged together in a group.'
            ),
          merge_method: z
            .enum(['MERGE', 'SQUASH', 'REBASE'])
            .describe(
              'Method to use when merging changes from queued pull requests.'
            ),
          min_entries_to_merge: z
            .number()
            .int()
            .gte(0)
            .lte(100)
            .describe(
              'The minimum number of PRs that will be merged together in a group.'
            ),
          min_entries_to_merge_wait_minutes: z
            .number()
            .int()
            .gte(0)
            .lte(360)
            .describe(
              'The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.'
            )
        })
        .optional()
    })
    .describe('Merges must be performed via a merge queue.')
  export type RepositoryRuleMergeQueue = z.infer<
    typeof RepositoryRuleMergeQueueSchema
  >

  export const RepositoryRuleRequiredDeploymentsSchema = z
    .object({
      type: z.literal('required_deployments'),
      parameters: z
        .object({
          required_deployment_environments: z
            .array(z.string())
            .describe(
              'The environments that must be successfully deployed to before branches can be merged.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.'
    )
  export type RepositoryRuleRequiredDeployments = z.infer<
    typeof RepositoryRuleRequiredDeploymentsSchema
  >

  export const RepositoryRuleRequiredSignaturesSchema = z
    .object({ type: z.literal('required_signatures') })
    .describe('Commits pushed to matching refs must have verified signatures.')
  export type RepositoryRuleRequiredSignatures = z.infer<
    typeof RepositoryRuleRequiredSignaturesSchema
  >

  export const RepositoryRulePullRequestSchema = z
    .object({
      type: z.literal('pull_request'),
      parameters: z
        .object({
          allowed_merge_methods: z
            .array(z.enum(['merge', 'squash', 'rebase']))
            .describe(
              'Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.'
            )
            .optional(),
          automatic_copilot_code_review_enabled: z
            .boolean()
            .describe(
              '> [!NOTE]\n> `automatic_copilot_code_review_enabled` is in beta and subject to change.\n\nAutomatically request review from Copilot for new pull requests, if the author has access to Copilot code review.'
            )
            .optional(),
          dismiss_stale_reviews_on_push: z
            .boolean()
            .describe(
              'New, reviewable commits pushed will dismiss previous pull request review approvals.'
            ),
          require_code_owner_review: z
            .boolean()
            .describe(
              'Require an approving review in pull requests that modify files that have a designated code owner.'
            ),
          require_last_push_approval: z
            .boolean()
            .describe(
              'Whether the most recent reviewable push must be approved by someone other than the person who pushed it.'
            ),
          required_approving_review_count: z
            .number()
            .int()
            .gte(0)
            .lte(10)
            .describe(
              'The number of approving reviews that are required before a pull request can be merged.'
            ),
          required_review_thread_resolution: z
            .boolean()
            .describe(
              'All conversations on code must be resolved before a pull request can be merged.'
            )
        })
        .optional()
    })
    .describe(
      'Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.'
    )
  export type RepositoryRulePullRequest = z.infer<
    typeof RepositoryRulePullRequestSchema
  >

  export const RepositoryRuleParamsStatusCheckConfigurationSchema = z
    .object({
      context: z
        .string()
        .describe(
          'The status check context name that must be present on the commit.'
        ),
      integration_id: z
        .number()
        .int()
        .describe(
          'The optional integration ID that this status check must originate from.'
        )
        .optional()
    })
    .describe('Required status check')
  export type RepositoryRuleParamsStatusCheckConfiguration = z.infer<
    typeof RepositoryRuleParamsStatusCheckConfigurationSchema
  >

  export const RepositoryRuleNonFastForwardSchema = z
    .object({ type: z.literal('non_fast_forward') })
    .describe('Prevent users with push access from force pushing to refs.')
  export type RepositoryRuleNonFastForward = z.infer<
    typeof RepositoryRuleNonFastForwardSchema
  >

  export const RepositoryRuleCommitMessagePatternSchema = z
    .object({
      type: z.literal('commit_message_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the commit_message_pattern rule')
  export type RepositoryRuleCommitMessagePattern = z.infer<
    typeof RepositoryRuleCommitMessagePatternSchema
  >

  export const RepositoryRuleCommitAuthorEmailPatternSchema = z
    .object({
      type: z.literal('commit_author_email_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the commit_author_email_pattern rule')
  export type RepositoryRuleCommitAuthorEmailPattern = z.infer<
    typeof RepositoryRuleCommitAuthorEmailPatternSchema
  >

  export const RepositoryRuleCommitterEmailPatternSchema = z
    .object({
      type: z.literal('committer_email_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the committer_email_pattern rule')
  export type RepositoryRuleCommitterEmailPattern = z.infer<
    typeof RepositoryRuleCommitterEmailPatternSchema
  >

  export const RepositoryRuleBranchNamePatternSchema = z
    .object({
      type: z.literal('branch_name_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the branch_name_pattern rule')
  export type RepositoryRuleBranchNamePattern = z.infer<
    typeof RepositoryRuleBranchNamePatternSchema
  >

  export const RepositoryRuleTagNamePatternSchema = z
    .object({
      type: z.literal('tag_name_pattern'),
      parameters: z
        .object({
          name: z
            .string()
            .describe('How this rule will appear to users.')
            .optional(),
          negate: z
            .boolean()
            .describe('If true, the rule will fail if the pattern matches.')
            .optional(),
          operator: z
            .enum(['starts_with', 'ends_with', 'contains', 'regex'])
            .describe('The operator to use for matching.'),
          pattern: z.string().describe('The pattern to match with.')
        })
        .optional()
    })
    .describe('Parameters to be used for the tag_name_pattern rule')
  export type RepositoryRuleTagNamePattern = z.infer<
    typeof RepositoryRuleTagNamePatternSchema
  >

  export const RepositoryRuleFilePathRestrictionSchema = z
    .object({
      type: z.literal('file_path_restriction'),
      parameters: z
        .object({
          restricted_file_paths: z
            .array(z.string())
            .describe(
              'The file paths that are restricted from being pushed to the commit graph.'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.'
    )
  export type RepositoryRuleFilePathRestriction = z.infer<
    typeof RepositoryRuleFilePathRestrictionSchema
  >

  export const RepositoryRuleMaxFilePathLengthSchema = z
    .object({
      type: z.literal('max_file_path_length'),
      parameters: z
        .object({
          max_file_path_length: z
            .number()
            .int()
            .gte(1)
            .lte(256)
            .describe('The maximum amount of characters allowed in file paths.')
        })
        .optional()
    })
    .describe(
      'Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.'
    )
  export type RepositoryRuleMaxFilePathLength = z.infer<
    typeof RepositoryRuleMaxFilePathLengthSchema
  >

  export const RepositoryRuleFileExtensionRestrictionSchema = z
    .object({
      type: z.literal('file_extension_restriction'),
      parameters: z
        .object({
          restricted_file_extensions: z
            .array(z.string())
            .describe(
              'The file extensions that are restricted from being pushed to the commit graph.'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits that include files with specified file extensions from being pushed to the commit graph.'
    )
  export type RepositoryRuleFileExtensionRestriction = z.infer<
    typeof RepositoryRuleFileExtensionRestrictionSchema
  >

  export const RepositoryRuleMaxFileSizeSchema = z
    .object({
      type: z.literal('max_file_size'),
      parameters: z
        .object({
          max_file_size: z
            .number()
            .int()
            .gte(1)
            .lte(100)
            .describe(
              'The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).'
            )
        })
        .optional()
    })
    .describe(
      'Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.'
    )
  export type RepositoryRuleMaxFileSize = z.infer<
    typeof RepositoryRuleMaxFileSizeSchema
  >

  export const RepositoryRuleParamsWorkflowFileReferenceSchema = z
    .object({
      path: z.string().describe('The path to the workflow file'),
      ref: z
        .string()
        .describe('The ref (branch or tag) of the workflow file to use')
        .optional(),
      repository_id: z
        .number()
        .int()
        .describe('The ID of the repository where the workflow is defined'),
      sha: z
        .string()
        .describe('The commit SHA of the workflow file to use')
        .optional()
    })
    .describe('A workflow that must run for this rule to pass')
  export type RepositoryRuleParamsWorkflowFileReference = z.infer<
    typeof RepositoryRuleParamsWorkflowFileReferenceSchema
  >

  export const RepositoryRuleParamsCodeScanningToolSchema = z
    .object({
      alerts_threshold: z
        .enum(['none', 'errors', 'errors_and_warnings', 'all'])
        .describe(
          'The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."'
        ),
      security_alerts_threshold: z
        .enum(['none', 'critical', 'high_or_higher', 'medium_or_higher', 'all'])
        .describe(
          'The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."'
        ),
      tool: z.string().describe('The name of a code scanning tool')
    })
    .describe(
      'A tool that must provide code scanning results for this rule to pass.'
    )
  export type RepositoryRuleParamsCodeScanningTool = z.infer<
    typeof RepositoryRuleParamsCodeScanningToolSchema
  >

  export const RulesetTargetsSchema = z
    .any()
    .describe(
      'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
    )
  export type RulesetTargets = z.infer<typeof RulesetTargetsSchema>

  export const RuleSuitesSchema = z
    .array(
      z.object({
        id: z
          .number()
          .int()
          .describe('The unique identifier of the rule insight.')
          .optional(),
        actor_id: z
          .number()
          .int()
          .describe('The number that identifies the user.')
          .optional(),
        actor_name: z
          .string()
          .describe('The handle for the GitHub user account.')
          .optional(),
        before_sha: z
          .string()
          .describe('The first commit sha before the push evaluation.')
          .optional(),
        after_sha: z
          .string()
          .describe('The last commit sha in the push evaluation.')
          .optional(),
        ref: z
          .string()
          .describe('The ref name that the evaluation ran on.')
          .optional(),
        repository_id: z
          .number()
          .int()
          .describe(
            'The ID of the repository associated with the rule evaluation.'
          )
          .optional(),
        repository_name: z
          .string()
          .describe('The name of the repository without the `.git` extension.')
          .optional(),
        pushed_at: z.string().datetime({ offset: true }).optional(),
        result: z
          .enum(['pass', 'fail', 'bypass'])
          .describe(
            'The result of the rule evaluations for rules with the `active` enforcement status.'
          )
          .optional(),
        evaluation_result: z
          .enum(['pass', 'fail', 'bypass'])
          .describe(
            'The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.'
          )
          .optional()
      })
    )
    .describe('Response')
  export type RuleSuites = z.infer<typeof RuleSuitesSchema>

  export const RefInQuerySchema = z
    .any()
    .describe(
      'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
    )
  export type RefInQuery = z.infer<typeof RefInQuerySchema>

  export const RepositoryNameInQuerySchema = z
    .any()
    .describe('The name of the repository to filter on.')
  export type RepositoryNameInQuery = z.infer<
    typeof RepositoryNameInQuerySchema
  >

  export const TimePeriodSchema = z
    .any()
    .describe(
      'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
    )
  export type TimePeriod = z.infer<typeof TimePeriodSchema>

  export const ActorNameInQuerySchema = z
    .any()
    .describe(
      'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
    )
  export type ActorNameInQuery = z.infer<typeof ActorNameInQuerySchema>

  export const RuleSuiteResultSchema = z
    .any()
    .describe(
      'The rule results to filter on. When specified, only suites with this result will be returned.'
    )
  export type RuleSuiteResult = z.infer<typeof RuleSuiteResultSchema>

  export const RuleSuiteSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the rule insight.')
        .optional(),
      actor_id: z
        .number()
        .int()
        .describe('The number that identifies the user.')
        .optional(),
      actor_name: z
        .string()
        .describe('The handle for the GitHub user account.')
        .optional(),
      before_sha: z
        .string()
        .describe('The first commit sha before the push evaluation.')
        .optional(),
      after_sha: z
        .string()
        .describe('The last commit sha in the push evaluation.')
        .optional(),
      ref: z
        .string()
        .describe('The ref name that the evaluation ran on.')
        .optional(),
      repository_id: z
        .number()
        .int()
        .describe(
          'The ID of the repository associated with the rule evaluation.'
        )
        .optional(),
      repository_name: z
        .string()
        .describe('The name of the repository without the `.git` extension.')
        .optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      result: z
        .enum(['pass', 'fail', 'bypass'])
        .describe(
          'The result of the rule evaluations for rules with the `active` enforcement status.'
        )
        .optional(),
      evaluation_result: z
        .enum(['pass', 'fail', 'bypass'])
        .describe(
          'The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.'
        )
        .optional(),
      rule_evaluations: z
        .array(
          z.object({
            rule_source: z
              .object({
                type: z
                  .string()
                  .describe('The type of rule source.')
                  .optional(),
                id: z
                  .number()
                  .int()
                  .describe('The ID of the rule source.')
                  .optional(),
                name: z
                  .string()
                  .describe('The name of the rule source.')
                  .optional()
              })
              .optional(),
            enforcement: z
              .enum(['active', 'evaluate', 'deleted ruleset'])
              .describe('The enforcement level of this rule source.')
              .optional(),
            result: z
              .enum(['pass', 'fail'])
              .describe('The result of the evaluation of the individual rule.')
              .optional(),
            rule_type: z.string().describe('The type of rule.').optional(),
            details: z
              .string()
              .describe(
                'The detailed failure message for the rule. Null if the rule passed.'
              )
              .optional()
          })
        )
        .describe('Details on the evaluated rules.')
        .optional()
    })
    .describe('Response')
  export type RuleSuite = z.infer<typeof RuleSuiteSchema>

  export const RuleSuiteIdSchema = z
    .any()
    .describe(
      'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
    )
  export type RuleSuiteId = z.infer<typeof RuleSuiteIdSchema>

  export const RulesetVersionSchema = z
    .object({
      version_id: z
        .number()
        .int()
        .describe('The ID of the previous version of the ruleset'),
      actor: z
        .object({
          id: z.number().int().optional(),
          type: z.string().optional()
        })
        .describe('The actor who updated the ruleset'),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('The historical version of a ruleset')
  export type RulesetVersion = z.infer<typeof RulesetVersionSchema>

  export const SecretScanningPaginationBeforeOrgRepoSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
    )
  export type SecretScanningPaginationBeforeOrgRepo = z.infer<
    typeof SecretScanningPaginationBeforeOrgRepoSchema
  >

  export const SecretScanningPaginationAfterOrgRepoSchema = z
    .any()
    .describe(
      'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
    )
  export type SecretScanningPaginationAfterOrgRepo = z.infer<
    typeof SecretScanningPaginationAfterOrgRepoSchema
  >

  export const ActionsBillingUsageSchema = z.object({
    total_minutes_used: z
      .number()
      .int()
      .describe('The sum of the free and paid GitHub Actions minutes used.'),
    total_paid_minutes_used: z
      .number()
      .int()
      .describe('The total paid GitHub Actions minutes used.'),
    included_minutes: z
      .number()
      .int()
      .describe('The amount of free GitHub Actions minutes available.'),
    minutes_used_breakdown: z.object({
      UBUNTU: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu runner machines.')
        .optional(),
      MACOS: z
        .number()
        .int()
        .describe('Total minutes used on macOS runner machines.')
        .optional(),
      WINDOWS: z
        .number()
        .int()
        .describe('Total minutes used on Windows runner machines.')
        .optional(),
      ubuntu_4_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 4 core runner machines.')
        .optional(),
      ubuntu_8_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 8 core runner machines.')
        .optional(),
      ubuntu_16_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 16 core runner machines.')
        .optional(),
      ubuntu_32_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 32 core runner machines.')
        .optional(),
      ubuntu_64_core: z
        .number()
        .int()
        .describe('Total minutes used on Ubuntu 64 core runner machines.')
        .optional(),
      windows_4_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 4 core runner machines.')
        .optional(),
      windows_8_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 8 core runner machines.')
        .optional(),
      windows_16_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 16 core runner machines.')
        .optional(),
      windows_32_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 32 core runner machines.')
        .optional(),
      windows_64_core: z
        .number()
        .int()
        .describe('Total minutes used on Windows 64 core runner machines.')
        .optional(),
      macos_12_core: z
        .number()
        .int()
        .describe('Total minutes used on macOS 12 core runner machines.')
        .optional(),
      total: z
        .number()
        .int()
        .describe('Total minutes used on all runner machines.')
        .optional()
    })
  })
  export type ActionsBillingUsage = z.infer<typeof ActionsBillingUsageSchema>

  export const PackagesBillingUsageSchema = z.object({
    total_gigabytes_bandwidth_used: z
      .number()
      .int()
      .describe(
        'Sum of the free and paid storage space (GB) for GitHuub Packages.'
      ),
    total_paid_gigabytes_bandwidth_used: z
      .number()
      .int()
      .describe('Total paid storage space (GB) for GitHuub Packages.'),
    included_gigabytes_bandwidth: z
      .number()
      .int()
      .describe('Free storage space (GB) for GitHub Packages.')
  })
  export type PackagesBillingUsage = z.infer<typeof PackagesBillingUsageSchema>

  export const CombinedBillingUsageSchema = z.object({
    days_left_in_billing_cycle: z
      .number()
      .int()
      .describe('Numbers of days left in billing cycle.'),
    estimated_paid_storage_for_month: z
      .number()
      .int()
      .describe('Estimated storage space (GB) used in billing cycle.'),
    estimated_storage_for_month: z
      .number()
      .int()
      .describe(
        'Estimated sum of free and paid storage space (GB) used in billing cycle.'
      )
  })
  export type CombinedBillingUsage = z.infer<typeof CombinedBillingUsageSchema>

  export const NetworkConfigurationSchema = z
    .object({
      id: z
        .string()
        .describe('The unique identifier of the network configuration.'),
      name: z.string().describe('The name of the network configuration.'),
      compute_service: z
        .enum(['none', 'actions', 'codespaces'])
        .describe(
          'The hosted compute service the network configuration supports.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .describe(
          'The unique identifier of each network settings in the configuration.'
        )
        .optional(),
      created_on: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time at which the network configuration was created, in ISO 8601 format.'
        )
    })
    .describe('A hosted compute network configuration.')
  export type NetworkConfiguration = z.infer<typeof NetworkConfigurationSchema>

  export const NetworkConfigurationIdSchema = z
    .any()
    .describe('Unique identifier of the hosted compute network configuration.')
  export type NetworkConfigurationId = z.infer<
    typeof NetworkConfigurationIdSchema
  >

  export const NetworkSettingsSchema = z
    .object({
      id: z
        .string()
        .describe('The unique identifier of the network settings resource.'),
      network_configuration_id: z
        .string()
        .describe(
          'The identifier of the network configuration that is using this settings resource.'
        )
        .optional(),
      name: z.string().describe('The name of the network settings resource.'),
      subnet_id: z
        .string()
        .describe(
          'The subnet this network settings resource is configured for.'
        ),
      region: z
        .string()
        .describe(
          'The location of the subnet this network settings resource is configured for.'
        )
    })
    .describe('A hosted compute network settings resource.')
  export type NetworkSettings = z.infer<typeof NetworkSettingsSchema>

  export const NetworkSettingsIdSchema = z
    .any()
    .describe('Unique identifier of the hosted compute network settings.')
  export type NetworkSettingsId = z.infer<typeof NetworkSettingsIdSchema>

  export const TeamOrganizationSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string().url(),
      hooks_url: z.string(),
      issues_url: z.string(),
      members_url: z.string(),
      public_members_url: z.string(),
      avatar_url: z.string(),
      description: z.string(),
      name: z.string().optional(),
      company: z.string().optional(),
      blog: z.string().url().optional(),
      location: z.string().optional(),
      email: z.string().email().optional(),
      twitter_username: z.string().optional(),
      is_verified: z.boolean().optional(),
      has_organization_projects: z.boolean(),
      has_repository_projects: z.boolean(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      type: z.string(),
      total_private_repos: z.number().int().optional(),
      owned_private_repos: z.number().int().optional(),
      private_gists: z.number().int().optional(),
      disk_usage: z.number().int().optional(),
      collaborators: z.number().int().optional(),
      billing_email: z.string().email().optional(),
      plan: z
        .object({
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int(),
          filled_seats: z.number().int().optional(),
          seats: z.number().int().optional()
        })
        .optional(),
      default_repository_permission: z.string().optional(),
      members_can_create_repositories: z.boolean().optional(),
      two_factor_requirement_enabled: z.boolean().optional(),
      members_allowed_repository_creation_type: z.string().optional(),
      members_can_create_public_repositories: z.boolean().optional(),
      members_can_create_private_repositories: z.boolean().optional(),
      members_can_create_internal_repositories: z.boolean().optional(),
      members_can_create_pages: z.boolean().optional(),
      members_can_create_public_pages: z.boolean().optional(),
      members_can_create_private_pages: z.boolean().optional(),
      members_can_fork_private_repositories: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      updated_at: z.string().datetime({ offset: true }),
      archived_at: z.string().datetime({ offset: true })
    })
    .describe('Team Organization')
  export type TeamOrganization = z.infer<typeof TeamOrganizationSchema>

  export const DiscussionNumberSchema = z
    .any()
    .describe('The number that identifies the discussion.')
  export type DiscussionNumber = z.infer<typeof DiscussionNumberSchema>

  export const CommentNumberSchema = z
    .any()
    .describe('The number that identifies the comment.')
  export type CommentNumber = z.infer<typeof CommentNumberSchema>

  export const ReactionIdSchema = z
    .any()
    .describe('The unique identifier of the reaction.')
  export type ReactionId = z.infer<typeof ReactionIdSchema>

  export const TeamMembershipSchema = z
    .object({
      url: z.string().url(),
      role: z
        .enum(['member', 'maintainer'])
        .describe('The role of the user in the team.')
        .default('member'),
      state: z
        .enum(['active', 'pending'])
        .describe("The state of the user's membership in the team.")
    })
    .describe('Team Membership')
  export type TeamMembership = z.infer<typeof TeamMembershipSchema>

  export const ProjectIdSchema = z
    .any()
    .describe('The unique identifier of the project.')
  export type ProjectId = z.infer<typeof ProjectIdSchema>

  export const SecurityProductSchema = z
    .any()
    .describe('The security feature to enable or disable.')
  export type SecurityProduct = z.infer<typeof SecurityProductSchema>

  export const OrgSecurityProductEnablementSchema = z
    .any()
    .describe(
      'The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.'
    )
  export type OrgSecurityProductEnablement = z.infer<
    typeof OrgSecurityProductEnablementSchema
  >

  export const CardIdSchema = z
    .any()
    .describe('The unique identifier of the card.')
  export type CardId = z.infer<typeof CardIdSchema>

  export const ProjectColumnSchema = z
    .object({
      url: z.string().url(),
      project_url: z.string().url(),
      cards_url: z.string().url(),
      id: z
        .number()
        .int()
        .describe('The unique identifier of the project column'),
      node_id: z.string(),
      name: z.string().describe('Name of the project column'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Project columns contain cards of work.')
  export type ProjectColumn = z.infer<typeof ProjectColumnSchema>

  export const ColumnIdSchema = z
    .any()
    .describe('The unique identifier of the column.')
  export type ColumnId = z.infer<typeof ColumnIdSchema>

  export const RateLimitSchema = z.object({
    limit: z.number().int(),
    remaining: z.number().int(),
    reset: z.number().int(),
    used: z.number().int()
  })
  export type RateLimit = z.infer<typeof RateLimitSchema>

  export const ArtifactSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('The name of the artifact.'),
      size_in_bytes: z
        .number()
        .int()
        .describe('The size in bytes of the artifact.'),
      url: z.string(),
      archive_download_url: z.string(),
      expired: z.boolean().describe('Whether or not the artifact has expired.'),
      created_at: z.string().datetime({ offset: true }),
      expires_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      digest: z
        .string()
        .describe(
          'The SHA256 digest of the artifact. This field will only be populated on artifacts uploaded with upload-artifact v4 or newer. For older versions, this field will be null.'
        )
        .optional(),
      workflow_run: z
        .object({
          id: z.number().int().optional(),
          repository_id: z.number().int().optional(),
          head_repository_id: z.number().int().optional(),
          head_branch: z.string().optional(),
          head_sha: z.string().optional()
        })
        .optional()
    })
    .describe('An artifact')
  export type Artifact = z.infer<typeof ArtifactSchema>

  export const ArtifactNameSchema = z
    .any()
    .describe(
      'The name field of an artifact. When specified, only artifacts with this name will be returned.'
    )
  export type ArtifactName = z.infer<typeof ArtifactNameSchema>

  export const ArtifactIdSchema = z
    .any()
    .describe('The unique identifier of the artifact.')
  export type ArtifactId = z.infer<typeof ArtifactIdSchema>

  export const ActionsCacheListSchema = z
    .object({
      total_count: z.number().int().describe('Total number of caches'),
      actions_caches: z
        .array(
          z.object({
            id: z.number().int().optional(),
            ref: z.string().optional(),
            key: z.string().optional(),
            version: z.string().optional(),
            last_accessed_at: z.string().datetime({ offset: true }).optional(),
            created_at: z.string().datetime({ offset: true }).optional(),
            size_in_bytes: z.number().int().optional()
          })
        )
        .describe('Array of caches')
    })
    .describe('Repository actions caches')
  export type ActionsCacheList = z.infer<typeof ActionsCacheListSchema>

  export const ActionsCacheGitRefFullSchema = z
    .any()
    .describe(
      'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
    )
  export type ActionsCacheGitRefFull = z.infer<
    typeof ActionsCacheGitRefFullSchema
  >

  export const ActionsCacheKeySchema = z
    .any()
    .describe('An explicit key or prefix for identifying the cache')
  export type ActionsCacheKey = z.infer<typeof ActionsCacheKeySchema>

  export const ActionsCacheListSortSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.'
    )
  export type ActionsCacheListSort = z.infer<typeof ActionsCacheListSortSchema>

  export const ActionsCacheKeyRequiredSchema = z
    .any()
    .describe('A key for identifying the cache.')
  export type ActionsCacheKeyRequired = z.infer<
    typeof ActionsCacheKeyRequiredSchema
  >

  export const CacheIdSchema = z
    .any()
    .describe('The unique identifier of the GitHub Actions cache.')
  export type CacheId = z.infer<typeof CacheIdSchema>

  export const JobSchema = z
    .object({
      id: z.number().int().describe('The id of the job.'),
      run_id: z
        .number()
        .int()
        .describe('The id of the associated workflow run.'),
      run_url: z.string(),
      run_attempt: z
        .number()
        .int()
        .describe(
          'Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.'
        )
        .optional(),
      node_id: z.string(),
      head_sha: z.string().describe('The SHA of the commit that is being run.'),
      url: z.string(),
      html_url: z.string(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe('The phase of the lifecycle that the job is currently in.'),
      conclusion: z
        .enum([
          'success',
          'failure',
          'neutral',
          'cancelled',
          'skipped',
          'timed_out',
          'action_required'
        ])
        .describe('The outcome of the job.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job created, in ISO 8601 format.'),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job started, in ISO 8601 format.'),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the job finished, in ISO 8601 format.'),
      name: z.string().describe('The name of the job.'),
      steps: z
        .array(
          z.object({
            status: z
              .enum(['queued', 'in_progress', 'completed'])
              .describe(
                'The phase of the lifecycle that the job is currently in.'
              ),
            conclusion: z.string().describe('The outcome of the job.'),
            name: z.string().describe('The name of the job.'),
            number: z.number().int(),
            started_at: z
              .string()
              .datetime({ offset: true })
              .describe('The time that the step started, in ISO 8601 format.')
              .optional(),
            completed_at: z
              .string()
              .datetime({ offset: true })
              .describe('The time that the job finished, in ISO 8601 format.')
              .optional()
          })
        )
        .describe('Steps in this job.')
        .optional(),
      check_run_url: z.string(),
      labels: z
        .array(z.string())
        .describe(
          'Labels for the workflow job. Specified by the "runs_on" attribute in the action\'s workflow file.'
        ),
      runner_id: z
        .number()
        .int()
        .describe(
          "The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_name: z
        .string()
        .describe(
          "The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_group_id: z
        .number()
        .int()
        .describe(
          "The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      runner_group_name: z
        .string()
        .describe(
          "The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"
        ),
      workflow_name: z.string().describe('The name of the workflow.'),
      head_branch: z.string().describe('The name of the current branch.')
    })
    .describe('Information of a job execution in a workflow run')
  export type Job = z.infer<typeof JobSchema>

  export const JobIdSchema = z
    .any()
    .describe('The unique identifier of the job.')
  export type JobId = z.infer<typeof JobIdSchema>

  export const OidcCustomSubRepoSchema = z
    .object({
      use_default: z
        .boolean()
        .describe(
          'Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.'
        ),
      include_claim_keys: z
        .array(z.string())
        .describe(
          'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
        )
        .optional()
    })
    .describe('Actions OIDC subject customization for a repository')
  export type OidcCustomSubRepo = z.infer<typeof OidcCustomSubRepoSchema>

  export const ActionsSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set secrets for GitHub Actions.')
  export type ActionsSecret = z.infer<typeof ActionsSecretSchema>

  export const ActionsVariableSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    created_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        "The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
      ),
    updated_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        "The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
      )
  })
  export type ActionsVariable = z.infer<typeof ActionsVariableSchema>

  export const ActionsEnabledSchema = z
    .boolean()
    .describe('Whether GitHub Actions is enabled on the repository.')
  export type ActionsEnabled = z.infer<typeof ActionsEnabledSchema>

  export const ActionsWorkflowAccessToRepositorySchema = z.object({
    access_level: z
      .enum(['none', 'user', 'organization'])
      .describe(
        'Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository.\n\n`none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.'
      )
  })
  export type ActionsWorkflowAccessToRepository = z.infer<
    typeof ActionsWorkflowAccessToRepositorySchema
  >

  export const ReferencedWorkflowSchema = z
    .object({ path: z.string(), sha: z.string(), ref: z.string().optional() })
    .describe('A workflow referenced/reused by the initial caller workflow')
  export type ReferencedWorkflow = z.infer<typeof ReferencedWorkflowSchema>

  export const PullRequestMinimalSchema = z.object({
    id: z.number().int(),
    number: z.number().int(),
    url: z.string(),
    head: z.object({
      ref: z.string(),
      sha: z.string(),
      repo: z.object({
        id: z.number().int(),
        url: z.string(),
        name: z.string()
      })
    }),
    base: z.object({
      ref: z.string(),
      sha: z.string(),
      repo: z.object({
        id: z.number().int(),
        url: z.string(),
        name: z.string()
      })
    })
  })
  export type PullRequestMinimal = z.infer<typeof PullRequestMinimalSchema>

  export const NullableSimpleCommitSchema = z
    .object({
      id: z.string().describe('SHA for the commit'),
      tree_id: z.string().describe("SHA for the commit's tree"),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of the commit'),
      author: z
        .object({
          name: z.string().describe("Name of the commit's author"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's author")
        })
        .describe('Information about the Git author'),
      committer: z
        .object({
          name: z.string().describe("Name of the commit's committer"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's committer")
        })
        .describe('Information about the Git committer')
    })
    .describe('A commit.')
  export type NullableSimpleCommit = z.infer<typeof NullableSimpleCommitSchema>

  export const WorkflowRunBranchSchema = z
    .any()
    .describe(
      'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
    )
  export type WorkflowRunBranch = z.infer<typeof WorkflowRunBranchSchema>

  export const EventSchema = z
    .object({
      id: z.string(),
      type: z.string(),
      actor: ActorSchema,
      repo: z.object({
        id: z.number().int(),
        name: z.string(),
        url: z.string().url()
      }),
      org: ActorSchema.optional(),
      payload: z.object({
        action: z.string().optional(),
        issue: IssueSchema.optional(),
        comment: IssueCommentSchema.optional(),
        pages: z
          .array(
            z.object({
              page_name: z.string().optional(),
              title: z.string().optional(),
              summary: z.string().optional(),
              action: z.string().optional(),
              sha: z.string().optional(),
              html_url: z.string().optional()
            })
          )
          .optional()
      }),
      public: z.boolean(),
      created_at: z.string().datetime({ offset: true })
    })
    .describe('Event')
  export type Event = z.infer<typeof EventSchema>

  export const WorkflowRunStatusSchema = z
    .any()
    .describe(
      'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
    )
  export type WorkflowRunStatus = z.infer<typeof WorkflowRunStatusSchema>

  export const CreatedSchema = z
    .any()
    .describe(
      'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
    )
  export type Created = z.infer<typeof CreatedSchema>

  export const ExcludePullRequestsSchema = z
    .any()
    .describe(
      'If `true` pull requests are omitted from the response (empty array).'
    )
  export type ExcludePullRequests = z.infer<typeof ExcludePullRequestsSchema>

  export const WorkflowRunCheckSuiteIdSchema = z
    .any()
    .describe(
      'Returns workflow runs with the `check_suite_id` that you specify.'
    )
  export type WorkflowRunCheckSuiteId = z.infer<
    typeof WorkflowRunCheckSuiteIdSchema
  >

  export const WorkflowRunHeadShaSchema = z
    .any()
    .describe(
      'Only returns workflow runs that are associated with the specified `head_sha`.'
    )
  export type WorkflowRunHeadSha = z.infer<typeof WorkflowRunHeadShaSchema>

  export const RunIdSchema = z
    .any()
    .describe('The unique identifier of the workflow run.')
  export type RunId = z.infer<typeof RunIdSchema>

  export const AttemptNumberSchema = z
    .any()
    .describe('The attempt number of the workflow run.')
  export type AttemptNumber = z.infer<typeof AttemptNumberSchema>

  export const ReviewCustomGatesCommentRequiredSchema = z.object({
    environment_name: z
      .string()
      .describe('The name of the environment to approve or reject.'),
    comment: z
      .string()
      .describe(
        'Comment associated with the pending deployment protection rule. **Required when state is not provided.**'
      )
  })
  export type ReviewCustomGatesCommentRequired = z.infer<
    typeof ReviewCustomGatesCommentRequiredSchema
  >

  export const ReviewCustomGatesStateRequiredSchema = z.object({
    environment_name: z
      .string()
      .describe('The name of the environment to approve or reject.'),
    state: z
      .enum(['approved', 'rejected'])
      .describe(
        'Whether to approve or reject deployment to the specified environments.'
      ),
    comment: z
      .string()
      .describe('Optional comment to include with the review.')
      .optional()
  })
  export type ReviewCustomGatesStateRequired = z.infer<
    typeof ReviewCustomGatesStateRequiredSchema
  >

  export const DeploymentReviewerTypeSchema = z
    .enum(['User', 'Team'])
    .describe('The type of reviewer.')
  export type DeploymentReviewerType = z.infer<
    typeof DeploymentReviewerTypeSchema
  >

  export const WorkflowRunUsageSchema = z
    .object({
      billable: z.object({
        UBUNTU: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional(),
        MACOS: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional(),
        WINDOWS: z
          .object({
            total_ms: z.number().int(),
            jobs: z.number().int(),
            job_runs: z
              .array(
                z.object({
                  job_id: z.number().int(),
                  duration_ms: z.number().int()
                })
              )
              .optional()
          })
          .optional()
      }),
      run_duration_ms: z.number().int().optional()
    })
    .describe('Workflow Run Usage')
  export type WorkflowRunUsage = z.infer<typeof WorkflowRunUsageSchema>

  export const WorkflowSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      path: z.string(),
      state: z.enum([
        'active',
        'deleted',
        'disabled_fork',
        'disabled_inactivity',
        'disabled_manually'
      ]),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string(),
      html_url: z.string(),
      badge_url: z.string(),
      deleted_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A GitHub Actions workflow')
  export type Workflow = z.infer<typeof WorkflowSchema>

  export const WorkflowIdSchema = z
    .any()
    .describe(
      'The ID of the workflow. You can also pass the workflow file name as a string.'
    )
  export type WorkflowId = z.infer<typeof WorkflowIdSchema>

  export const WorkflowUsageSchema = z
    .object({
      billable: z.object({
        UBUNTU: z.object({ total_ms: z.number().int().optional() }).optional(),
        MACOS: z.object({ total_ms: z.number().int().optional() }).optional(),
        WINDOWS: z.object({ total_ms: z.number().int().optional() }).optional()
      })
    })
    .describe('Workflow Usage')
  export type WorkflowUsage = z.infer<typeof WorkflowUsageSchema>

  export const AutolinkSchema = z
    .object({
      id: z.number().int(),
      key_prefix: z.string().describe('The prefix of a key that is linkified.'),
      url_template: z
        .string()
        .describe(
          'A template for the target URL that is generated if a key was found.'
        ),
      is_alphanumeric: z
        .boolean()
        .describe(
          'Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.'
        )
    })
    .describe('An autolink reference.')
  export type Autolink = z.infer<typeof AutolinkSchema>

  export const AutolinkIdSchema = z
    .any()
    .describe('The unique identifier of the autolink.')
  export type AutolinkId = z.infer<typeof AutolinkIdSchema>

  export const CheckAutomatedSecurityFixesSchema = z
    .object({
      enabled: z
        .boolean()
        .describe(
          'Whether Dependabot security updates are enabled for the repository.'
        ),
      paused: z
        .boolean()
        .describe(
          'Whether Dependabot security updates are paused for the repository.'
        )
    })
    .describe('Check Dependabot security updates')
  export type CheckAutomatedSecurityFixes = z.infer<
    typeof CheckAutomatedSecurityFixesSchema
  >

  export const ProtectedBranchRequiredStatusCheckSchema = z
    .object({
      url: z.string().optional(),
      enforcement_level: z.string().optional(),
      contexts: z.array(z.string()),
      checks: z.array(
        z.object({ context: z.string(), app_id: z.number().int() })
      ),
      contexts_url: z.string().optional(),
      strict: z.boolean().optional()
    })
    .describe('Protected Branch Required Status Check')
  export type ProtectedBranchRequiredStatusCheck = z.infer<
    typeof ProtectedBranchRequiredStatusCheckSchema
  >

  export const ProtectedBranchAdminEnforcedSchema = z
    .object({ url: z.string().url(), enabled: z.boolean() })
    .describe('Protected Branch Admin Enforced')
  export type ProtectedBranchAdminEnforced = z.infer<
    typeof ProtectedBranchAdminEnforcedSchema
  >

  export const BranchRestrictionPolicySchema = z
    .object({
      url: z.string().url(),
      users_url: z.string().url(),
      teams_url: z.string().url(),
      apps_url: z.string().url(),
      users: z.array(
        z.object({
          login: z.string().optional(),
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          avatar_url: z.string().optional(),
          gravatar_id: z.string().optional(),
          url: z.string().optional(),
          html_url: z.string().optional(),
          followers_url: z.string().optional(),
          following_url: z.string().optional(),
          gists_url: z.string().optional(),
          starred_url: z.string().optional(),
          subscriptions_url: z.string().optional(),
          organizations_url: z.string().optional(),
          repos_url: z.string().optional(),
          events_url: z.string().optional(),
          received_events_url: z.string().optional(),
          type: z.string().optional(),
          site_admin: z.boolean().optional(),
          user_view_type: z.string().optional()
        })
      ),
      teams: z.array(
        z.object({
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          html_url: z.string().optional(),
          name: z.string().optional(),
          slug: z.string().optional(),
          description: z.string().optional(),
          privacy: z.string().optional(),
          notification_setting: z.string().optional(),
          permission: z.string().optional(),
          members_url: z.string().optional(),
          repositories_url: z.string().optional(),
          parent: z.string().optional()
        })
      ),
      apps: z.array(
        z.object({
          id: z.number().int().optional(),
          slug: z.string().optional(),
          node_id: z.string().optional(),
          owner: z
            .object({
              login: z.string().optional(),
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().optional(),
              repos_url: z.string().optional(),
              events_url: z.string().optional(),
              hooks_url: z.string().optional(),
              issues_url: z.string().optional(),
              members_url: z.string().optional(),
              public_members_url: z.string().optional(),
              avatar_url: z.string().optional(),
              description: z.string().optional(),
              gravatar_id: z.string().optional(),
              html_url: z.string().optional(),
              followers_url: z.string().optional(),
              following_url: z.string().optional(),
              gists_url: z.string().optional(),
              starred_url: z.string().optional(),
              subscriptions_url: z.string().optional(),
              organizations_url: z.string().optional(),
              received_events_url: z.string().optional(),
              type: z.string().optional(),
              site_admin: z.boolean().optional(),
              user_view_type: z.string().optional()
            })
            .optional(),
          name: z.string().optional(),
          client_id: z.string().optional(),
          description: z.string().optional(),
          external_url: z.string().optional(),
          html_url: z.string().optional(),
          created_at: z.string().optional(),
          updated_at: z.string().optional(),
          permissions: z
            .object({
              metadata: z.string().optional(),
              contents: z.string().optional(),
              issues: z.string().optional(),
              single_file: z.string().optional()
            })
            .optional(),
          events: z.array(z.string()).optional()
        })
      )
    })
    .describe('Branch Restriction Policy')
  export type BranchRestrictionPolicy = z.infer<
    typeof BranchRestrictionPolicySchema
  >

  export const NullableGitUserSchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      date: z.string().optional()
    })
    .describe('Metaproperties for Git author/committer information.')
  export type NullableGitUser = z.infer<typeof NullableGitUserSchema>

  export const VerificationSchema = z.object({
    verified: z.boolean(),
    reason: z.string(),
    payload: z.string(),
    signature: z.string(),
    verified_at: z.string()
  })
  export type Verification = z.infer<typeof VerificationSchema>

  export const DiffEntrySchema = z
    .object({
      sha: z.string(),
      filename: z.string(),
      status: z.enum([
        'added',
        'removed',
        'modified',
        'renamed',
        'copied',
        'changed',
        'unchanged'
      ]),
      additions: z.number().int(),
      deletions: z.number().int(),
      changes: z.number().int(),
      blob_url: z.string().url(),
      raw_url: z.string().url(),
      contents_url: z.string().url(),
      patch: z.string().optional(),
      previous_filename: z.string().optional()
    })
    .describe('Diff Entry')
  export type DiffEntry = z.infer<typeof DiffEntrySchema>

  export const BranchSchema = z
    .any()
    .describe(
      'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
    )
  export type Branch = z.infer<typeof BranchSchema>

  export const StatusCheckPolicySchema = z
    .object({
      url: z.string().url(),
      strict: z.boolean(),
      contexts: z.array(z.string()),
      checks: z.array(
        z.object({ context: z.string(), app_id: z.number().int() })
      ),
      contexts_url: z.string().url()
    })
    .describe('Status Check Policy')
  export type StatusCheckPolicy = z.infer<typeof StatusCheckPolicySchema>

  export const CheckRunIdSchema = z
    .any()
    .describe('The unique identifier of the check run.')
  export type CheckRunId = z.infer<typeof CheckRunIdSchema>

  export const CheckAnnotationSchema = z
    .object({
      path: z.string(),
      start_line: z.number().int(),
      end_line: z.number().int(),
      start_column: z.number().int(),
      end_column: z.number().int(),
      annotation_level: z.string(),
      title: z.string(),
      message: z.string(),
      raw_details: z.string(),
      blob_href: z.string()
    })
    .describe('Check Annotation')
  export type CheckAnnotation = z.infer<typeof CheckAnnotationSchema>

  export const SimpleCommitSchema = z
    .object({
      id: z.string().describe('SHA for the commit'),
      tree_id: z.string().describe("SHA for the commit's tree"),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of the commit'),
      author: z
        .object({
          name: z.string().describe("Name of the commit's author"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's author")
        })
        .describe('Information about the Git author'),
      committer: z
        .object({
          name: z.string().describe("Name of the commit's committer"),
          email: z
            .string()
            .email()
            .describe("Git email address of the commit's committer")
        })
        .describe('Information about the Git committer')
    })
    .describe('A commit.')
  export type SimpleCommit = z.infer<typeof SimpleCommitSchema>

  export const CheckSuiteIdSchema = z
    .any()
    .describe('The unique identifier of the check suite.')
  export type CheckSuiteId = z.infer<typeof CheckSuiteIdSchema>

  export const CheckNameSchema = z
    .any()
    .describe('Returns check runs with the specified `name`.')
  export type CheckName = z.infer<typeof CheckNameSchema>

  export const StatusSchema = z
    .object({
      url: z.string(),
      avatar_url: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      state: z.string(),
      description: z.string(),
      target_url: z.string(),
      context: z.string(),
      created_at: z.string(),
      updated_at: z.string(),
      creator: NullableSimpleUserSchema
    })
    .describe('The status of a commit.')
  export type Status = z.infer<typeof StatusSchema>

  export const PrAliasSchema = z
    .any()
    .describe(
      'The number of the pull request for the results you want to list.'
    )
  export type PrAlias = z.infer<typeof PrAliasSchema>

  export const CodeScanningAlertRuleSchema = z.object({
    id: z
      .string()
      .describe('A unique identifier for the rule used to detect the alert.')
      .optional(),
    name: z
      .string()
      .describe('The name of the rule used to detect the alert.')
      .optional(),
    severity: z
      .enum(['none', 'note', 'warning', 'error'])
      .describe('The severity of the alert.')
      .optional(),
    security_severity_level: z
      .enum(['low', 'medium', 'high', 'critical'])
      .describe('The security severity of the alert.')
      .optional(),
    description: z
      .string()
      .describe('A short description of the rule used to detect the alert.')
      .optional(),
    full_description: z
      .string()
      .describe('A description of the rule used to detect the alert.')
      .optional(),
    tags: z
      .array(z.string())
      .describe('A set of tags applicable for the rule.')
      .optional(),
    help: z
      .string()
      .describe(
        'Detailed documentation for the rule as GitHub Flavored Markdown.'
      )
      .optional(),
    help_uri: z
      .string()
      .describe(
        'A link to the documentation for the rule used to detect the alert.'
      )
      .optional()
  })
  export type CodeScanningAlertRule = z.infer<
    typeof CodeScanningAlertRuleSchema
  >

  export const CodeScanningAlertSetStateSchema = z
    .enum(['open', 'dismissed'])
    .describe(
      'Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.'
    )
  export type CodeScanningAlertSetState = z.infer<
    typeof CodeScanningAlertSetStateSchema
  >

  export const CodeScanningAlertCreateRequestSchema = z
    .boolean()
    .describe('If `true`, attempt to create an alert dismissal request.')
  export type CodeScanningAlertCreateRequest = z.infer<
    typeof CodeScanningAlertCreateRequestSchema
  >

  export const CodeScanningAutofixStatusSchema = z
    .enum(['pending', 'error', 'success', 'outdated'])
    .describe('The status of an autofix.')
  export type CodeScanningAutofixStatus = z.infer<
    typeof CodeScanningAutofixStatusSchema
  >

  export const CodeScanningAutofixDescriptionSchema = z
    .string()
    .describe('The description of an autofix.')
  export type CodeScanningAutofixDescription = z.infer<
    typeof CodeScanningAutofixDescriptionSchema
  >

  export const CodeScanningAutofixStartedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type CodeScanningAutofixStartedAt = z.infer<
    typeof CodeScanningAutofixStartedAtSchema
  >

  export const CodeScanningAutofixCommitsSchema = z
    .object({
      target_ref: z
        .string()
        .describe(
          'The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
        )
        .optional(),
      message: z.string().describe('Commit message to be used.').optional()
    })
    .describe('Commit an autofix for a code scanning alert')
  export type CodeScanningAutofixCommits = z.infer<
    typeof CodeScanningAutofixCommitsSchema
  >

  export const CodeScanningAutofixCommitsResponseSchema = z.object({
    target_ref: z
      .string()
      .describe(
        'The Git reference of target branch for the commit. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
      .optional(),
    sha: z.string().describe('SHA of commit with autofix.').optional()
  })
  export type CodeScanningAutofixCommitsResponse = z.infer<
    typeof CodeScanningAutofixCommitsResponseSchema
  >

  export const CodeScanningAnalysisCommitShaSchema = z
    .string()
    .regex(new RegExp('^[0-9a-fA-F]+$'))
    .min(40)
    .max(40)
    .describe(
      'The SHA of the commit to which the analysis you are uploading relates.'
    )
  export type CodeScanningAnalysisCommitSha = z.infer<
    typeof CodeScanningAnalysisCommitShaSchema
  >

  export const CodeScanningAnalysisEnvironmentSchema = z
    .string()
    .describe(
      'Identifies the variable values associated with the environment in which this analysis was performed.'
    )
  export type CodeScanningAnalysisEnvironment = z.infer<
    typeof CodeScanningAnalysisEnvironmentSchema
  >

  export const CodeScanningAnalysisCreatedAtSchema = z
    .string()
    .datetime({ offset: true })
    .describe(
      'The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
    .readonly()
  export type CodeScanningAnalysisCreatedAt = z.infer<
    typeof CodeScanningAnalysisCreatedAtSchema
  >

  export const CodeScanningAnalysisUrlSchema = z
    .string()
    .url()
    .describe('The REST API URL of the analysis resource.')
    .readonly()
  export type CodeScanningAnalysisUrl = z.infer<
    typeof CodeScanningAnalysisUrlSchema
  >

  export const CodeScanningAnalysisSarifIdSchema = z
    .string()
    .describe('An identifier for the upload.')
  export type CodeScanningAnalysisSarifId = z.infer<
    typeof CodeScanningAnalysisSarifIdSchema
  >

  export const CodeScanningAnalysisDeletionSchema = z
    .object({
      next_analysis_url: z
        .string()
        .url()
        .describe(
          'Next deletable analysis in chain, without last analysis deletion confirmation'
        )
        .readonly(),
      confirm_delete_url: z
        .string()
        .url()
        .describe(
          'Next deletable analysis in chain, with last analysis deletion confirmation'
        )
        .readonly()
    })
    .describe('Successful deletion of a code scanning analysis')
  export type CodeScanningAnalysisDeletion = z.infer<
    typeof CodeScanningAnalysisDeletionSchema
  >

  export const CodeScanningVariantAnalysisLanguageSchema = z
    .enum([
      'cpp',
      'csharp',
      'go',
      'java',
      'javascript',
      'python',
      'ruby',
      'swift'
    ])
    .describe('The language targeted by the CodeQL query')
  export type CodeScanningVariantAnalysisLanguage = z.infer<
    typeof CodeScanningVariantAnalysisLanguageSchema
  >

  export const CodeScanningVariantAnalysisRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      name: z.string().describe('The name of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique, name of the repository.'),
      private: z.boolean().describe('Whether the repository is private.'),
      stargazers_count: z.number().int(),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Repository Identifier')
  export type CodeScanningVariantAnalysisRepository = z.infer<
    typeof CodeScanningVariantAnalysisRepositorySchema
  >

  export const CodeScanningVariantAnalysisStatusSchema = z
    .enum([
      'pending',
      'in_progress',
      'succeeded',
      'failed',
      'canceled',
      'timed_out'
    ])
    .describe('The new status of the CodeQL variant analysis repository task.')
  export type CodeScanningVariantAnalysisStatus = z.infer<
    typeof CodeScanningVariantAnalysisStatusSchema
  >

  export const CodeScanningDefaultSetupSchema = z
    .object({
      state: z
        .enum(['configured', 'not-configured'])
        .describe('Code scanning default setup has been configured or not.')
        .optional(),
      languages: z
        .array(
          z.enum([
            'actions',
            'c-cpp',
            'csharp',
            'go',
            'java-kotlin',
            'javascript-typescript',
            'javascript',
            'python',
            'ruby',
            'typescript',
            'swift'
          ])
        )
        .describe('Languages to be analyzed.')
        .optional(),
      runner_type: z
        .enum(['standard', 'labeled'])
        .describe('Runner type to be used.')
        .optional(),
      runner_label: z
        .string()
        .describe('Runner label to be used if the runner type is labeled.')
        .optional(),
      query_suite: z
        .enum(['default', 'extended'])
        .describe('CodeQL query suite to be used.')
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('Timestamp of latest configuration update.')
        .optional(),
      schedule: z
        .literal('weekly')
        .describe('The frequency of the periodic analysis.')
        .optional()
    })
    .describe('Configuration for code scanning default setup.')
  export type CodeScanningDefaultSetup = z.infer<
    typeof CodeScanningDefaultSetupSchema
  >

  export const CodeScanningDefaultSetupUpdateSchema = z
    .object({
      state: z
        .enum(['configured', 'not-configured'])
        .describe('The desired state of code scanning default setup.')
        .optional(),
      runner_type: z
        .enum(['standard', 'labeled'])
        .describe('Runner type to be used.')
        .optional(),
      runner_label: z
        .string()
        .describe('Runner label to be used if the runner type is labeled.')
        .optional(),
      query_suite: z
        .enum(['default', 'extended'])
        .describe('CodeQL query suite to be used.')
        .optional(),
      languages: z
        .array(
          z.enum([
            'actions',
            'c-cpp',
            'csharp',
            'go',
            'java-kotlin',
            'javascript-typescript',
            'python',
            'ruby',
            'swift'
          ])
        )
        .describe('CodeQL languages to be analyzed.')
        .optional()
    })
    .strict()
    .describe('Configuration for code scanning default setup.')
  export type CodeScanningDefaultSetupUpdate = z.infer<
    typeof CodeScanningDefaultSetupUpdateSchema
  >

  export const CodeScanningRefFullSchema = z
    .string()
    .regex(new RegExp('^refs/(heads|tags|pull)/.*$'))
    .describe(
      'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.'
    )
  export type CodeScanningRefFull = z.infer<typeof CodeScanningRefFullSchema>

  export const CodeScanningAnalysisSarifFileSchema = z
    .string()
    .describe(
      'A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."'
    )
  export type CodeScanningAnalysisSarifFile = z.infer<
    typeof CodeScanningAnalysisSarifFileSchema
  >

  export const CodeScanningSarifsStatusSchema = z.object({
    processing_status: z
      .enum(['pending', 'complete', 'failed'])
      .describe(
        '`pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.'
      )
      .optional(),
    analyses_url: z
      .string()
      .url()
      .describe(
        'The REST API URL for getting the analyses associated with the upload.'
      )
      .readonly()
      .optional(),
    errors: z
      .array(z.string())
      .describe('Any errors that ocurred during processing of the delivery.')
      .readonly()
      .optional()
  })
  export type CodeScanningSarifsStatus = z.infer<
    typeof CodeScanningSarifsStatusSchema
  >

  export const CodeownersErrorsSchema = z
    .object({
      errors: z.array(
        z.object({
          line: z
            .number()
            .int()
            .describe('The line number where this errors occurs.'),
          column: z
            .number()
            .int()
            .describe('The column number where this errors occurs.'),
          source: z
            .string()
            .describe('The contents of the line where the error occurs.')
            .optional(),
          kind: z.string().describe('The type of error.'),
          suggestion: z
            .string()
            .describe(
              'Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.'
            )
            .optional(),
          message: z
            .string()
            .describe(
              'A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).'
            ),
          path: z
            .string()
            .describe('The path of the file where the error occured.')
        })
      )
    })
    .describe("A list of errors found in a repo's CODEOWNERS file")
  export type CodeownersErrors = z.infer<typeof CodeownersErrorsSchema>

  export const CodespaceMachineSchema = z
    .object({
      name: z.string().describe('The name of the machine.'),
      display_name: z
        .string()
        .describe(
          'The display name of the machine includes cores, memory, and storage.'
        ),
      operating_system: z
        .string()
        .describe('The operating system of the machine.'),
      storage_in_bytes: z
        .number()
        .int()
        .describe('How much storage is available to the codespace.'),
      memory_in_bytes: z
        .number()
        .int()
        .describe('How much memory is available to the codespace.'),
      cpus: z
        .number()
        .int()
        .describe('How many cores are available to the codespace.'),
      prebuild_availability: z
        .enum(['none', 'ready', 'in_progress'])
        .describe(
          'Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.'
        )
    })
    .describe('A description of the machine powering a codespace.')
  export type CodespaceMachine = z.infer<typeof CodespaceMachineSchema>

  export const CodespacesPermissionsCheckForDevcontainerSchema = z
    .object({
      accepted: z
        .boolean()
        .describe(
          'Whether the user has accepted the permissions defined by the devcontainer config'
        )
    })
    .describe('Permission check result for a given devcontainer config.')
  export type CodespacesPermissionsCheckForDevcontainer = z.infer<
    typeof CodespacesPermissionsCheckForDevcontainerSchema
  >

  export const RepoCodespacesSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set repository secrets for GitHub Codespaces.')
  export type RepoCodespacesSecret = z.infer<typeof RepoCodespacesSecretSchema>

  export const CollaboratorSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional(),
          admin: z.boolean()
        })
        .optional(),
      role_name: z.string(),
      user_view_type: z.string().optional()
    })
    .describe('Collaborator')
  export type Collaborator = z.infer<typeof CollaboratorSchema>

  export const NullableCollaboratorSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional(),
          admin: z.boolean()
        })
        .optional(),
      role_name: z.string(),
      user_view_type: z.string().optional()
    })
    .describe('Collaborator')
  export type NullableCollaborator = z.infer<typeof NullableCollaboratorSchema>

  export const BranchShortSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string() }),
      protected: z.boolean()
    })
    .describe('Branch Short')
  export type BranchShort = z.infer<typeof BranchShortSchema>

  export const CommitShaSchema = z.any().describe('The SHA of the commit.')
  export type CommitSha = z.infer<typeof CommitShaSchema>

  export const LinkSchema = z
    .object({ href: z.string() })
    .describe('Hypermedia Link')
  export type Link = z.infer<typeof LinkSchema>

  export const CommitRefSchema = z
    .any()
    .describe(
      'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
    )
  export type CommitRef = z.infer<typeof CommitRefSchema>

  export const SimpleCommitStatusSchema = z.object({
    description: z.string(),
    id: z.number().int(),
    node_id: z.string(),
    state: z.string(),
    context: z.string(),
    target_url: z.string().url(),
    required: z.boolean().optional(),
    avatar_url: z.string().url(),
    url: z.string().url(),
    created_at: z.string().datetime({ offset: true }),
    updated_at: z.string().datetime({ offset: true })
  })
  export type SimpleCommitStatus = z.infer<typeof SimpleCommitStatusSchema>

  export const NullableCodeOfConductSimpleSchema = z
    .object({
      url: z.string().url(),
      key: z.string(),
      name: z.string(),
      html_url: z.string().url()
    })
    .describe('Code of Conduct Simple')
  export type NullableCodeOfConductSimple = z.infer<
    typeof NullableCodeOfConductSimpleSchema
  >

  export const NullableCommunityHealthFileSchema = z.object({
    url: z.string().url(),
    html_url: z.string().url()
  })
  export type NullableCommunityHealthFile = z.infer<
    typeof NullableCommunityHealthFileSchema
  >

  export const ContentDirectorySchema = z
    .array(
      z.object({
        type: z.enum(['dir', 'file', 'submodule', 'symlink']),
        size: z.number().int(),
        name: z.string(),
        path: z.string(),
        content: z.string().optional(),
        sha: z.string(),
        url: z.string().url(),
        git_url: z.string().url(),
        html_url: z.string().url(),
        download_url: z.string().url(),
        _links: z.object({
          git: z.string().url(),
          html: z.string().url(),
          self: z.string().url()
        })
      })
    )
    .describe('A list of directory items')
  export type ContentDirectory = z.infer<typeof ContentDirectorySchema>

  export const ContentFileSchema = z
    .object({
      type: z.literal('file'),
      encoding: z.string(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      content: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      }),
      target: z.string().optional(),
      submodule_git_url: z.string().optional()
    })
    .describe('Content File')
  export type ContentFile = z.infer<typeof ContentFileSchema>

  export const ContentSymlinkSchema = z
    .object({
      type: z.literal('symlink'),
      target: z.string(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      })
    })
    .describe('An object describing a symlink')
  export type ContentSymlink = z.infer<typeof ContentSymlinkSchema>

  export const ContentSubmoduleSchema = z
    .object({
      type: z.literal('submodule'),
      submodule_git_url: z.string().url(),
      size: z.number().int(),
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      download_url: z.string().url(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      })
    })
    .describe('An object describing a submodule')
  export type ContentSubmodule = z.infer<typeof ContentSubmoduleSchema>

  export const FileCommitSchema = z
    .object({
      content: z.object({
        name: z.string().optional(),
        path: z.string().optional(),
        sha: z.string().optional(),
        size: z.number().int().optional(),
        url: z.string().optional(),
        html_url: z.string().optional(),
        git_url: z.string().optional(),
        download_url: z.string().optional(),
        type: z.string().optional(),
        _links: z
          .object({
            self: z.string().optional(),
            git: z.string().optional(),
            html: z.string().optional()
          })
          .optional()
      }),
      commit: z.object({
        sha: z.string().optional(),
        node_id: z.string().optional(),
        url: z.string().optional(),
        html_url: z.string().optional(),
        author: z
          .object({
            date: z.string().optional(),
            name: z.string().optional(),
            email: z.string().optional()
          })
          .optional(),
        committer: z
          .object({
            date: z.string().optional(),
            name: z.string().optional(),
            email: z.string().optional()
          })
          .optional(),
        message: z.string().optional(),
        tree: z
          .object({ url: z.string().optional(), sha: z.string().optional() })
          .optional(),
        parents: z
          .array(
            z.object({
              url: z.string().optional(),
              html_url: z.string().optional(),
              sha: z.string().optional()
            })
          )
          .optional(),
        verification: z
          .object({
            verified: z.boolean().optional(),
            reason: z.string().optional(),
            signature: z.string().optional(),
            payload: z.string().optional(),
            verified_at: z.string().optional()
          })
          .optional()
      })
    })
    .describe('File Commit')
  export type FileCommit = z.infer<typeof FileCommitSchema>

  export const ContributorSchema = z
    .object({
      login: z.string().optional(),
      id: z.number().int().optional(),
      node_id: z.string().optional(),
      avatar_url: z.string().url().optional(),
      gravatar_id: z.string().optional(),
      url: z.string().url().optional(),
      html_url: z.string().url().optional(),
      followers_url: z.string().url().optional(),
      following_url: z.string().optional(),
      gists_url: z.string().optional(),
      starred_url: z.string().optional(),
      subscriptions_url: z.string().url().optional(),
      organizations_url: z.string().url().optional(),
      repos_url: z.string().url().optional(),
      events_url: z.string().optional(),
      received_events_url: z.string().url().optional(),
      type: z.string(),
      site_admin: z.boolean().optional(),
      contributions: z.number().int(),
      email: z.string().optional(),
      name: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('Contributor')
  export type Contributor = z.infer<typeof ContributorSchema>

  export const DependabotAlertCommaSeparatedManifestsSchema = z
    .any()
    .describe(
      'A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.'
    )
  export type DependabotAlertCommaSeparatedManifests = z.infer<
    typeof DependabotAlertCommaSeparatedManifestsSchema
  >

  export const DependabotSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Set secrets for Dependabot.')
  export type DependabotSecret = z.infer<typeof DependabotSecretSchema>

  export const DependencyGraphDiffSchema = z
    .array(
      z.object({
        change_type: z.enum(['added', 'removed']),
        manifest: z.string(),
        ecosystem: z.string(),
        name: z.string(),
        version: z.string(),
        package_url: z.string(),
        license: z.string(),
        source_repository_url: z.string(),
        vulnerabilities: z.array(
          z.object({
            severity: z.string(),
            advisory_ghsa_id: z.string(),
            advisory_summary: z.string(),
            advisory_url: z.string()
          })
        ),
        scope: z
          .enum(['unknown', 'runtime', 'development'])
          .describe(
            'Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.'
          )
      })
    )
    .describe('A diff of the dependencies between two commits.')
  export type DependencyGraphDiff = z.infer<typeof DependencyGraphDiffSchema>

  export const ManifestPathSchema = z
    .any()
    .describe(
      'The full path, relative to the repository root, of the dependency manifest file.'
    )
  export type ManifestPath = z.infer<typeof ManifestPathSchema>

  export const DependencyGraphSpdxSbomSchema = z
    .object({
      sbom: z.object({
        SPDXID: z
          .string()
          .describe('The SPDX identifier for the SPDX document.'),
        spdxVersion: z
          .string()
          .describe(
            'The version of the SPDX specification that this document conforms to.'
          ),
        comment: z
          .string()
          .describe('An optional comment about the SPDX document.')
          .optional(),
        creationInfo: z.object({
          created: z
            .string()
            .describe('The date and time the SPDX document was created.'),
          creators: z
            .array(z.string())
            .describe('The tools that were used to generate the SPDX document.')
        }),
        name: z.string().describe('The name of the SPDX document.'),
        dataLicense: z
          .string()
          .describe('The license under which the SPDX document is licensed.'),
        documentNamespace: z
          .string()
          .describe('The namespace for the SPDX document.'),
        packages: z.array(
          z.object({
            SPDXID: z
              .string()
              .describe('A unique SPDX identifier for the package.')
              .optional(),
            name: z.string().describe('The name of the package.').optional(),
            versionInfo: z
              .string()
              .describe(
                'The version of the package. If the package does not have an exact version specified,\na version range is given.'
              )
              .optional(),
            downloadLocation: z
              .string()
              .describe(
                'The location where the package can be downloaded,\nor NOASSERTION if this has not been determined.'
              )
              .optional(),
            filesAnalyzed: z
              .boolean()
              .describe(
                "Whether the package's file content has been subjected to\nanalysis during the creation of the SPDX document."
              )
              .optional(),
            licenseConcluded: z
              .string()
              .describe(
                'The license of the package as determined while creating the SPDX document.'
              )
              .optional(),
            licenseDeclared: z
              .string()
              .describe(
                'The license of the package as declared by its author, or NOASSERTION if this information\nwas not available when the SPDX document was created.'
              )
              .optional(),
            supplier: z
              .string()
              .describe(
                'The distribution source of this package, or NOASSERTION if this was not determined.'
              )
              .optional(),
            copyrightText: z
              .string()
              .describe(
                'The copyright holders of the package, and any dates present with those notices, if available.'
              )
              .optional(),
            externalRefs: z
              .array(
                z.object({
                  referenceCategory: z
                    .string()
                    .describe(
                      'The category of reference to an external resource this reference refers to.'
                    ),
                  referenceLocator: z
                    .string()
                    .describe(
                      'A locator for the particular external resource this reference refers to.'
                    ),
                  referenceType: z
                    .string()
                    .describe(
                      'The category of reference to an external resource this reference refers to.'
                    )
                })
              )
              .optional()
          })
        ),
        relationships: z
          .array(
            z.object({
              relationshipType: z
                .string()
                .describe(
                  'The type of relationship between the two SPDX elements.'
                )
                .optional(),
              spdxElementId: z
                .string()
                .describe(
                  'The SPDX identifier of the package that is the source of the relationship.'
                )
                .optional(),
              relatedSpdxElement: z
                .string()
                .describe(
                  'The SPDX identifier of the package that is the target of the relationship.'
                )
                .optional()
            })
          )
          .optional()
      })
    })
    .describe(
      'A schema for the SPDX JSON format returned by the Dependency Graph.'
    )
  export type DependencyGraphSpdxSbom = z.infer<
    typeof DependencyGraphSpdxSbomSchema
  >

  export const MetadataSchema = z
    .record(z.union([z.string(), z.number(), z.boolean()]))
    .describe(
      'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.'
    )
  export type Metadata = z.infer<typeof MetadataSchema>

  export const DeploymentIdSchema = z.any().describe('deployment_id parameter')
  export type DeploymentId = z.infer<typeof DeploymentIdSchema>

  export const WaitTimerSchema = z
    .number()
    .int()
    .describe(
      'The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).'
    )
  export type WaitTimer = z.infer<typeof WaitTimerSchema>

  export const DeploymentBranchPolicySettingsSchema = z
    .object({
      protected_branches: z
        .boolean()
        .describe(
          'Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.'
        ),
      custom_branch_policies: z
        .boolean()
        .describe(
          'Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.'
        )
    })
    .describe(
      'The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.'
    )
  export type DeploymentBranchPolicySettings = z.infer<
    typeof DeploymentBranchPolicySettingsSchema
  >

  export const EnvironmentNameSchema = z
    .any()
    .describe(
      'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
    )
  export type EnvironmentName = z.infer<typeof EnvironmentNameSchema>

  export const PreventSelfReviewSchema = z
    .boolean()
    .describe(
      'Whether or not a user who created the job is prevented from approving their own job.'
    )
  export type PreventSelfReview = z.infer<typeof PreventSelfReviewSchema>

  export const DeploymentBranchPolicySchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the branch or tag policy.')
        .optional(),
      node_id: z.string().optional(),
      name: z
        .string()
        .describe(
          'The name pattern that branches or tags must match in order to deploy to the environment.'
        )
        .optional(),
      type: z
        .enum(['branch', 'tag'])
        .describe('Whether this rule targets a branch or tag.')
        .optional()
    })
    .describe('Details of a deployment branch or tag policy.')
  export type DeploymentBranchPolicy = z.infer<
    typeof DeploymentBranchPolicySchema
  >

  export const DeploymentBranchPolicyNamePatternWithTypeSchema = z.object({
    name: z
      .string()
      .describe(
        'The name pattern that branches or tags must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).'
      ),
    type: z
      .enum(['branch', 'tag'])
      .describe('Whether this rule targets a branch or tag')
      .optional()
  })
  export type DeploymentBranchPolicyNamePatternWithType = z.infer<
    typeof DeploymentBranchPolicyNamePatternWithTypeSchema
  >

  export const BranchPolicyIdSchema = z
    .any()
    .describe('The unique identifier of the branch policy.')
  export type BranchPolicyId = z.infer<typeof BranchPolicyIdSchema>

  export const DeploymentBranchPolicyNamePatternSchema = z.object({
    name: z
      .string()
      .describe(
        'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).'
      )
  })
  export type DeploymentBranchPolicyNamePattern = z.infer<
    typeof DeploymentBranchPolicyNamePatternSchema
  >

  export const CustomDeploymentRuleAppSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the deployment protection rule integration.'
        ),
      slug: z
        .string()
        .describe(
          'The slugified name of the deployment protection rule integration.'
        ),
      integration_url: z
        .string()
        .describe('The URL for the endpoint to get details about the app.'),
      node_id: z
        .string()
        .describe('The node ID for the deployment protection rule integration.')
    })
    .describe(
      'A GitHub App that is providing a custom deployment protection rule.'
    )
  export type CustomDeploymentRuleApp = z.infer<
    typeof CustomDeploymentRuleAppSchema
  >

  export const DeploymentProtectionRulesSchema = z.any()
  export type DeploymentProtectionRules = z.infer<
    typeof DeploymentProtectionRulesSchema
  >

  export const ProtectionRuleIdSchema = z
    .any()
    .describe('The unique identifier of the protection rule.')
  export type ProtectionRuleId = z.infer<typeof ProtectionRuleIdSchema>

  export const ShortBlobSchema = z
    .object({ url: z.string(), sha: z.string() })
    .describe('Short Blob')
  export type ShortBlob = z.infer<typeof ShortBlobSchema>

  export const BlobSchema = z
    .object({
      content: z.string(),
      encoding: z.string(),
      url: z.string().url(),
      sha: z.string(),
      size: z.number().int(),
      node_id: z.string(),
      highlighted_content: z.string().optional()
    })
    .describe('Blob')
  export type Blob = z.infer<typeof BlobSchema>

  export const GitCommitSchema = z
    .object({
      sha: z.string().describe('SHA for the commit'),
      node_id: z.string(),
      url: z.string().url(),
      author: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      committer: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      tree: z.object({
        sha: z.string().describe('SHA for the commit'),
        url: z.string().url()
      }),
      parents: z.array(
        z.object({
          sha: z.string().describe('SHA for the commit'),
          url: z.string().url(),
          html_url: z.string().url()
        })
      ),
      verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.string(),
        payload: z.string(),
        verified_at: z.string()
      }),
      html_url: z.string().url()
    })
    .describe('Low-level Git commit operations within a repository')
  export type GitCommit = z.infer<typeof GitCommitSchema>

  export const GitRefSchema = z
    .any()
    .describe(
      'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
    )
  export type GitRef = z.infer<typeof GitRefSchema>

  export const GitRefOnlySchema = z
    .any()
    .describe(
      'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
    )
  export type GitRefOnly = z.infer<typeof GitRefOnlySchema>

  export const GitTreeSchema = z
    .object({
      sha: z.string(),
      url: z.string().url(),
      truncated: z.boolean(),
      tree: z
        .array(
          z.object({
            path: z.string().optional(),
            mode: z.string().optional(),
            type: z.string().optional(),
            sha: z.string().optional(),
            size: z.number().int().optional(),
            url: z.string().optional()
          })
        )
        .describe('Objects specifying a tree structure')
    })
    .describe('The hierarchy between files in a Git repository.')
  export type GitTree = z.infer<typeof GitTreeSchema>

  export const HookResponseSchema = z.object({
    code: z.number().int(),
    status: z.string(),
    message: z.string()
  })
  export type HookResponse = z.infer<typeof HookResponseSchema>

  export const ImportSchema = z
    .object({
      vcs: z.string(),
      use_lfs: z.boolean().optional(),
      vcs_url: z.string().describe('The URL of the originating repository.'),
      svc_root: z.string().optional(),
      tfvc_project: z.string().optional(),
      status: z.enum([
        'auth',
        'error',
        'none',
        'detecting',
        'choose',
        'auth_failed',
        'importing',
        'mapping',
        'waiting_to_push',
        'pushing',
        'complete',
        'setup',
        'unknown',
        'detection_found_multiple',
        'detection_found_nothing',
        'detection_needs_auth'
      ]),
      status_text: z.string().optional(),
      failed_step: z.string().optional(),
      error_message: z.string().optional(),
      import_percent: z.number().int().optional(),
      commit_count: z.number().int().optional(),
      push_percent: z.number().int().optional(),
      has_large_files: z.boolean().optional(),
      large_files_size: z.number().int().optional(),
      large_files_count: z.number().int().optional(),
      project_choices: z
        .array(
          z.object({
            vcs: z.string().optional(),
            tfvc_project: z.string().optional(),
            human_name: z.string().optional()
          })
        )
        .optional(),
      message: z.string().optional(),
      authors_count: z.number().int().optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      authors_url: z.string().url(),
      repository_url: z.string().url(),
      svn_root: z.string().optional()
    })
    .describe('A repository import from an external source.')
  export type Import = z.infer<typeof ImportSchema>

  export const PorterAuthorSchema = z
    .object({
      id: z.number().int(),
      remote_id: z.string(),
      remote_name: z.string(),
      email: z.string(),
      name: z.string(),
      url: z.string().url(),
      import_url: z.string().url()
    })
    .describe('Porter Author')
  export type PorterAuthor = z.infer<typeof PorterAuthorSchema>

  export const SinceUserSchema = z
    .any()
    .describe('A user ID. Only return users with an ID greater than this ID.')
  export type SinceUser = z.infer<typeof SinceUserSchema>

  export const PorterLargeFileSchema = z
    .object({
      ref_name: z.string(),
      path: z.string(),
      oid: z.string(),
      size: z.number().int()
    })
    .describe('Porter Large File')
  export type PorterLargeFile = z.infer<typeof PorterLargeFileSchema>

  export const IssueEventLabelSchema = z
    .object({ name: z.string(), color: z.string() })
    .describe('Issue Event Label')
  export type IssueEventLabel = z.infer<typeof IssueEventLabelSchema>

  export const IssueEventDismissedReviewSchema = z.object({
    state: z.string(),
    review_id: z.number().int(),
    dismissal_message: z.string(),
    dismissal_commit_id: z.string().optional()
  })
  export type IssueEventDismissedReview = z.infer<
    typeof IssueEventDismissedReviewSchema
  >

  export const IssueEventMilestoneSchema = z
    .object({ title: z.string() })
    .describe('Issue Event Milestone')
  export type IssueEventMilestone = z.infer<typeof IssueEventMilestoneSchema>

  export const IssueEventProjectCardSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      project_url: z.string().url(),
      project_id: z.number().int(),
      column_name: z.string(),
      previous_column_name: z.string().optional()
    })
    .describe('Issue Event Project Card')
  export type IssueEventProjectCard = z.infer<
    typeof IssueEventProjectCardSchema
  >

  export const IssueEventRenameSchema = z
    .object({ from: z.string(), to: z.string() })
    .describe('Issue Event Rename')
  export type IssueEventRename = z.infer<typeof IssueEventRenameSchema>

  export const IssueNumberSchema = z
    .any()
    .describe('The number that identifies the issue.')
  export type IssueNumber = z.infer<typeof IssueNumberSchema>

  export const LabelSchema = z
    .object({
      id: z.number().int().describe('Unique identifier for the label.'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the label'),
      name: z.string().describe('The name of the label.'),
      description: z
        .string()
        .describe('Optional description of the label, such as its purpose.'),
      color: z
        .string()
        .describe(
          '6-character hex code, without the leading #, identifying the color'
        ),
      default: z
        .boolean()
        .describe('Whether this label comes by default in a new repository.')
    })
    .describe(
      'Color-coded labels help you categorize and filter your issues (just like labels in Gmail).'
    )
  export type Label = z.infer<typeof LabelSchema>

  export const TimelineCommittedEventSchema = z
    .object({
      event: z.string().optional(),
      sha: z.string().describe('SHA for the commit'),
      node_id: z.string(),
      url: z.string().url(),
      author: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      committer: z
        .object({
          date: z
            .string()
            .datetime({ offset: true })
            .describe('Timestamp of the commit'),
          email: z.string().describe('Git email address of the user'),
          name: z.string().describe('Name of the git user')
        })
        .describe('Identifying information for the git-user'),
      message: z
        .string()
        .describe('Message describing the purpose of the commit'),
      tree: z.object({
        sha: z.string().describe('SHA for the commit'),
        url: z.string().url()
      }),
      parents: z.array(
        z.object({
          sha: z.string().describe('SHA for the commit'),
          url: z.string().url(),
          html_url: z.string().url()
        })
      ),
      verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.string(),
        payload: z.string(),
        verified_at: z.string()
      }),
      html_url: z.string().url()
    })
    .describe('Timeline Committed Event')
  export type TimelineCommittedEvent = z.infer<
    typeof TimelineCommittedEventSchema
  >

  export const DeployKeySchema = z
    .object({
      id: z.number().int(),
      key: z.string(),
      url: z.string(),
      title: z.string(),
      verified: z.boolean(),
      created_at: z.string(),
      read_only: z.boolean(),
      added_by: z.string().optional(),
      last_used: z.string().optional(),
      enabled: z.boolean().optional()
    })
    .describe('An SSH key granting access to a single repository.')
  export type DeployKey = z.infer<typeof DeployKeySchema>

  export const KeyIdSchema = z
    .any()
    .describe('The unique identifier of the key.')
  export type KeyId = z.infer<typeof KeyIdSchema>

  export const LanguageSchema = z.record(z.number().int()).describe('Language')
  export type Language = z.infer<typeof LanguageSchema>

  export const MergedUpstreamSchema = z
    .object({
      message: z.string().optional(),
      merge_type: z.enum(['merge', 'fast-forward', 'none']).optional(),
      base_branch: z.string().optional()
    })
    .describe('Results of a successful merge upstream request')
  export type MergedUpstream = z.infer<typeof MergedUpstreamSchema>

  export const MilestoneNumberSchema = z
    .any()
    .describe('The number that identifies the milestone.')
  export type MilestoneNumber = z.infer<typeof MilestoneNumberSchema>

  export const PagesSourceHashSchema = z.object({
    branch: z.string(),
    path: z.string()
  })
  export type PagesSourceHash = z.infer<typeof PagesSourceHashSchema>

  export const PagesHttpsCertificateSchema = z.object({
    state: z.enum([
      'new',
      'authorization_created',
      'authorization_pending',
      'authorized',
      'authorization_revoked',
      'issued',
      'uploaded',
      'approved',
      'errored',
      'bad_authz',
      'destroy_pending',
      'dns_changed'
    ]),
    description: z.string(),
    domains: z
      .array(z.string())
      .describe(
        'Array of the domain set and its alternate name (if it is configured)'
      ),
    expires_at: z.string().date().optional()
  })
  export type PagesHttpsCertificate = z.infer<
    typeof PagesHttpsCertificateSchema
  >

  export const PageBuildStatusSchema = z
    .object({ url: z.string().url(), status: z.string() })
    .describe('Page Build Status')
  export type PageBuildStatus = z.infer<typeof PageBuildStatusSchema>

  export const PageDeploymentSchema = z
    .object({
      id: z
        .union([z.number().int(), z.string()])
        .describe(
          'The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.'
        ),
      status_url: z
        .string()
        .url()
        .describe('The URI to monitor GitHub Pages deployment status.'),
      page_url: z
        .string()
        .url()
        .describe('The URI to the deployed GitHub Pages.'),
      preview_url: z
        .string()
        .url()
        .describe('The URI to the deployed GitHub Pages preview.')
        .optional()
    })
    .describe('The GitHub Pages deployment status.')
  export type PageDeployment = z.infer<typeof PageDeploymentSchema>

  export const PagesDeploymentStatusSchema = z.object({
    status: z
      .enum([
        'deployment_in_progress',
        'syncing_files',
        'finished_file_sync',
        'updating_pages',
        'purging_cdn',
        'deployment_cancelled',
        'deployment_failed',
        'deployment_content_failed',
        'deployment_attempt_error',
        'deployment_lost',
        'succeed'
      ])
      .describe('The current status of the deployment.')
      .optional()
  })
  export type PagesDeploymentStatus = z.infer<
    typeof PagesDeploymentStatusSchema
  >

  export const PagesDeploymentIdSchema = z
    .any()
    .describe(
      'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
    )
  export type PagesDeploymentId = z.infer<typeof PagesDeploymentIdSchema>

  export const PagesHealthCheckSchema = z
    .object({
      domain: z
        .object({
          host: z.string().optional(),
          uri: z.string().optional(),
          nameservers: z.string().optional(),
          dns_resolves: z.boolean().optional(),
          is_proxied: z.boolean().optional(),
          is_cloudflare_ip: z.boolean().optional(),
          is_fastly_ip: z.boolean().optional(),
          is_old_ip_address: z.boolean().optional(),
          is_a_record: z.boolean().optional(),
          has_cname_record: z.boolean().optional(),
          has_mx_records_present: z.boolean().optional(),
          is_valid_domain: z.boolean().optional(),
          is_apex_domain: z.boolean().optional(),
          should_be_a_record: z.boolean().optional(),
          is_cname_to_github_user_domain: z.boolean().optional(),
          is_cname_to_pages_dot_github_dot_com: z.boolean().optional(),
          is_cname_to_fastly: z.boolean().optional(),
          is_pointed_to_github_pages_ip: z.boolean().optional(),
          is_non_github_pages_ip_present: z.boolean().optional(),
          is_pages_domain: z.boolean().optional(),
          is_served_by_pages: z.boolean().optional(),
          is_valid: z.boolean().optional(),
          reason: z.string().optional(),
          responds_to_https: z.boolean().optional(),
          enforces_https: z.boolean().optional(),
          https_error: z.string().optional(),
          is_https_eligible: z.boolean().optional(),
          caa_error: z.string().optional()
        })
        .optional(),
      alt_domain: z
        .object({
          host: z.string().optional(),
          uri: z.string().optional(),
          nameservers: z.string().optional(),
          dns_resolves: z.boolean().optional(),
          is_proxied: z.boolean().optional(),
          is_cloudflare_ip: z.boolean().optional(),
          is_fastly_ip: z.boolean().optional(),
          is_old_ip_address: z.boolean().optional(),
          is_a_record: z.boolean().optional(),
          has_cname_record: z.boolean().optional(),
          has_mx_records_present: z.boolean().optional(),
          is_valid_domain: z.boolean().optional(),
          is_apex_domain: z.boolean().optional(),
          should_be_a_record: z.boolean().optional(),
          is_cname_to_github_user_domain: z.boolean().optional(),
          is_cname_to_pages_dot_github_dot_com: z.boolean().optional(),
          is_cname_to_fastly: z.boolean().optional(),
          is_pointed_to_github_pages_ip: z.boolean().optional(),
          is_non_github_pages_ip_present: z.boolean().optional(),
          is_pages_domain: z.boolean().optional(),
          is_served_by_pages: z.boolean().optional(),
          is_valid: z.boolean().optional(),
          reason: z.string().optional(),
          responds_to_https: z.boolean().optional(),
          enforces_https: z.boolean().optional(),
          https_error: z.string().optional(),
          is_https_eligible: z.boolean().optional(),
          caa_error: z.string().optional()
        })
        .optional()
    })
    .describe('Pages Health Check Status')
  export type PagesHealthCheck = z.infer<typeof PagesHealthCheckSchema>

  export const PullNumberSchema = z
    .any()
    .describe('The number that identifies the pull request.')
  export type PullNumber = z.infer<typeof PullNumberSchema>

  export const PullRequestMergeResultSchema = z
    .object({ sha: z.string(), merged: z.boolean(), message: z.string() })
    .describe('Pull Request Merge Result')
  export type PullRequestMergeResult = z.infer<
    typeof PullRequestMergeResultSchema
  >

  export const ReviewIdSchema = z
    .any()
    .describe('The unique identifier of the review.')
  export type ReviewId = z.infer<typeof ReviewIdSchema>

  export const AssetIdSchema = z
    .any()
    .describe('The unique identifier of the asset.')
  export type AssetId = z.infer<typeof AssetIdSchema>

  export const ReleaseNotesContentSchema = z
    .object({
      name: z.string().describe('The generated name of the release'),
      body: z
        .string()
        .describe(
          'The generated body describing the contents of the release supporting markdown formatting'
        )
    })
    .describe('Generated name and body describing a release')
  export type ReleaseNotesContent = z.infer<typeof ReleaseNotesContentSchema>

  export const ReleaseIdSchema = z
    .any()
    .describe('The unique identifier of the release.')
  export type ReleaseId = z.infer<typeof ReleaseIdSchema>

  export const RepositoryRuleRulesetInfoSchema = z
    .any()
    .describe(
      'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.'
    )
  export type RepositoryRuleRulesetInfo = z.infer<
    typeof RepositoryRuleRulesetInfoSchema
  >

  export const SecretScanningAlertResolutionCommentSchema = z
    .string()
    .describe(
      'An optional comment when closing an alert. Cannot be updated or deleted. Must be `null` when changing `state` to `open`.'
    )
  export type SecretScanningAlertResolutionComment = z.infer<
    typeof SecretScanningAlertResolutionCommentSchema
  >

  export const SecretScanningLocationCommitSchema = z
    .object({
      path: z.string().describe('The file path in the repository'),
      start_line: z
        .number()
        .describe('Line number at which the secret starts in the file'),
      end_line: z
        .number()
        .describe('Line number at which the secret ends in the file'),
      start_column: z
        .number()
        .describe(
          'The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII'
        ),
      end_column: z
        .number()
        .describe(
          'The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII'
        ),
      blob_sha: z.string().describe('SHA-1 hash ID of the associated blob'),
      blob_url: z
        .string()
        .describe('The API URL to get the associated blob resource'),
      commit_sha: z.string().describe('SHA-1 hash ID of the associated commit'),
      commit_url: z
        .string()
        .describe('The API URL to get the associated commit resource')
    })
    .describe(
      "Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository."
    )
  export type SecretScanningLocationCommit = z.infer<
    typeof SecretScanningLocationCommitSchema
  >

  export const SecretScanningLocationWikiCommitSchema = z
    .object({
      path: z.string().describe('The file path of the wiki page'),
      start_line: z
        .number()
        .describe('Line number at which the secret starts in the file'),
      end_line: z
        .number()
        .describe('Line number at which the secret ends in the file'),
      start_column: z
        .number()
        .describe(
          'The column at which the secret starts within the start line when the file is interpreted as 8-bit ASCII.'
        ),
      end_column: z
        .number()
        .describe(
          'The column at which the secret ends within the end line when the file is interpreted as 8-bit ASCII.'
        ),
      blob_sha: z.string().describe('SHA-1 hash ID of the associated blob'),
      page_url: z
        .string()
        .describe('The GitHub URL to get the associated wiki page'),
      commit_sha: z.string().describe('SHA-1 hash ID of the associated commit'),
      commit_url: z
        .string()
        .describe('The GitHub URL to get the associated wiki commit')
    })
    .describe(
      "Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki."
    )
  export type SecretScanningLocationWikiCommit = z.infer<
    typeof SecretScanningLocationWikiCommitSchema
  >

  export const SecretScanningLocationIssueTitleSchema = z
    .object({
      issue_title_url: z
        .string()
        .url()
        .describe('The API URL to get the issue where the secret was detected.')
    })
    .describe(
      "Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue."
    )
  export type SecretScanningLocationIssueTitle = z.infer<
    typeof SecretScanningLocationIssueTitleSchema
  >

  export const SecretScanningLocationIssueBodySchema = z
    .object({
      issue_body_url: z
        .string()
        .url()
        .describe('The API URL to get the issue where the secret was detected.')
    })
    .describe(
      "Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue."
    )
  export type SecretScanningLocationIssueBody = z.infer<
    typeof SecretScanningLocationIssueBodySchema
  >

  export const SecretScanningLocationIssueCommentSchema = z
    .object({
      issue_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the issue comment where the secret was detected.'
        )
    })
    .describe(
      "Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue."
    )
  export type SecretScanningLocationIssueComment = z.infer<
    typeof SecretScanningLocationIssueCommentSchema
  >

  export const SecretScanningLocationDiscussionTitleSchema = z
    .object({
      discussion_title_url: z
        .string()
        .url()
        .describe('The URL to the discussion where the secret was detected.')
    })
    .describe(
      "Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion."
    )
  export type SecretScanningLocationDiscussionTitle = z.infer<
    typeof SecretScanningLocationDiscussionTitleSchema
  >

  export const SecretScanningLocationDiscussionBodySchema = z
    .object({
      discussion_body_url: z
        .string()
        .url()
        .describe('The URL to the discussion where the secret was detected.')
    })
    .describe(
      "Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion."
    )
  export type SecretScanningLocationDiscussionBody = z.infer<
    typeof SecretScanningLocationDiscussionBodySchema
  >

  export const SecretScanningLocationDiscussionCommentSchema = z
    .object({
      discussion_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the discussion comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion."
    )
  export type SecretScanningLocationDiscussionComment = z.infer<
    typeof SecretScanningLocationDiscussionCommentSchema
  >

  export const SecretScanningLocationPullRequestTitleSchema = z
    .object({
      pull_request_title_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request."
    )
  export type SecretScanningLocationPullRequestTitle = z.infer<
    typeof SecretScanningLocationPullRequestTitleSchema
  >

  export const SecretScanningLocationPullRequestBodySchema = z
    .object({
      pull_request_body_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request."
    )
  export type SecretScanningLocationPullRequestBody = z.infer<
    typeof SecretScanningLocationPullRequestBodySchema
  >

  export const SecretScanningLocationPullRequestCommentSchema = z
    .object({
      pull_request_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request."
    )
  export type SecretScanningLocationPullRequestComment = z.infer<
    typeof SecretScanningLocationPullRequestCommentSchema
  >

  export const SecretScanningLocationPullRequestReviewSchema = z
    .object({
      pull_request_review_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request review where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request."
    )
  export type SecretScanningLocationPullRequestReview = z.infer<
    typeof SecretScanningLocationPullRequestReviewSchema
  >

  export const SecretScanningLocationPullRequestReviewCommentSchema = z
    .object({
      pull_request_review_comment_url: z
        .string()
        .url()
        .describe(
          'The API URL to get the pull request review comment where the secret was detected.'
        )
    })
    .describe(
      "Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request."
    )
  export type SecretScanningLocationPullRequestReviewComment = z.infer<
    typeof SecretScanningLocationPullRequestReviewCommentSchema
  >

  export const SecretScanningPushProtectionBypassReasonSchema = z
    .enum(['false_positive', 'used_in_tests', 'will_fix_later'])
    .describe('The reason for bypassing push protection.')
  export type SecretScanningPushProtectionBypassReason = z.infer<
    typeof SecretScanningPushProtectionBypassReasonSchema
  >

  export const SecretScanningPushProtectionBypassPlaceholderIdSchema = z
    .string()
    .describe(
      'The ID of the push protection bypass placeholder. This value is returned on any push protected routes.'
    )
  export type SecretScanningPushProtectionBypassPlaceholderId = z.infer<
    typeof SecretScanningPushProtectionBypassPlaceholderIdSchema
  >

  export const SecretScanningScanSchema = z
    .object({
      type: z.string().describe('The type of scan').optional(),
      status: z
        .string()
        .describe(
          'The state of the scan. Either "completed", "running", or "pending"'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the scan was completed. Empty if the scan is running'
        )
        .optional(),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the scan was started. Empty if the scan is pending'
        )
        .optional()
    })
    .describe(
      'Information on a single scan performed by secret scanning on the repository'
    )
  export type SecretScanningScan = z.infer<typeof SecretScanningScanSchema>

  export const CodeFrequencyStatSchema = z
    .array(z.number().int())
    .describe('Code Frequency Stat')
  export type CodeFrequencyStat = z.infer<typeof CodeFrequencyStatSchema>

  export const CommitActivitySchema = z
    .object({
      days: z.array(z.number().int()),
      total: z.number().int(),
      week: z.number().int()
    })
    .describe('Commit Activity')
  export type CommitActivity = z.infer<typeof CommitActivitySchema>

  export const ParticipationStatsSchema = z.object({
    all: z.array(z.number().int()),
    owner: z.array(z.number().int())
  })
  export type ParticipationStats = z.infer<typeof ParticipationStatsSchema>

  export const RepositorySubscriptionSchema = z
    .object({
      subscribed: z
        .boolean()
        .describe(
          'Determines if notifications should be received from this repository.'
        ),
      ignored: z
        .boolean()
        .describe(
          'Determines if all notifications should be blocked from this repository.'
        ),
      reason: z.string(),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      repository_url: z.string().url()
    })
    .describe('Repository invitations let you manage who you collaborate with.')
  export type RepositorySubscription = z.infer<
    typeof RepositorySubscriptionSchema
  >

  export const TagSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string().url() }),
      zipball_url: z.string().url(),
      tarball_url: z.string().url(),
      node_id: z.string()
    })
    .describe('Tag')
  export type Tag = z.infer<typeof TagSchema>

  export const TagProtectionSchema = z
    .object({
      id: z.number().int().optional(),
      created_at: z.string().optional(),
      updated_at: z.string().optional(),
      enabled: z.boolean().optional(),
      pattern: z.string()
    })
    .describe('Tag protection')
  export type TagProtection = z.infer<typeof TagProtectionSchema>

  export const TagProtectionIdSchema = z
    .any()
    .describe('The unique identifier of the tag protection.')
  export type TagProtectionId = z.infer<typeof TagProtectionIdSchema>

  export const TopicSchema = z
    .object({ names: z.array(z.string()) })
    .describe('A topic aggregates entities that are related to a subject.')
  export type Topic = z.infer<typeof TopicSchema>

  export const TrafficSchema = z.object({
    timestamp: z.string().datetime({ offset: true }),
    uniques: z.number().int(),
    count: z.number().int()
  })
  export type Traffic = z.infer<typeof TrafficSchema>

  export const PerSchema = z
    .any()
    .describe('The time frame to display results for.')
  export type Per = z.infer<typeof PerSchema>

  export const ContentTrafficSchema = z
    .object({
      path: z.string(),
      title: z.string(),
      count: z.number().int(),
      uniques: z.number().int()
    })
    .describe('Content Traffic')
  export type ContentTraffic = z.infer<typeof ContentTrafficSchema>

  export const ReferrerTrafficSchema = z
    .object({
      referrer: z.string(),
      count: z.number().int(),
      uniques: z.number().int()
    })
    .describe('Referrer Traffic')
  export type ReferrerTraffic = z.infer<typeof ReferrerTrafficSchema>

  export const SinceRepoSchema = z
    .any()
    .describe(
      'A repository ID. Only return repositories with an ID greater than this ID.'
    )
  export type SinceRepo = z.infer<typeof SinceRepoSchema>

  export const SearchResultTextMatchesSchema = z.array(
    z.object({
      object_url: z.string().optional(),
      object_type: z.string().optional(),
      property: z.string().optional(),
      fragment: z.string().optional(),
      matches: z
        .array(
          z.object({
            text: z.string().optional(),
            indices: z.array(z.number().int()).optional()
          })
        )
        .optional()
    })
  )
  export type SearchResultTextMatches = z.infer<
    typeof SearchResultTextMatchesSchema
  >

  export const OrderSchema = z
    .any()
    .describe(
      'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
    )
  export type Order = z.infer<typeof OrderSchema>

  export const IssuesAdvancedSearchSchema = z
    .any()
    .describe(
      'Set to `true` to use advanced search.\nExample: `http://api.github.com/search/issues?q={query}&advanced_search=true`'
    )
  export type IssuesAdvancedSearch = z.infer<typeof IssuesAdvancedSearchSchema>

  export const TeamIdSchema = z
    .any()
    .describe('The unique identifier of the team.')
  export type TeamId = z.infer<typeof TeamIdSchema>

  export const PrivateUserSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      user_view_type: z.string().optional(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      name: z.string(),
      company: z.string(),
      blog: z.string(),
      location: z.string(),
      email: z.string().email(),
      notification_email: z.string().email().optional(),
      hireable: z.boolean(),
      bio: z.string(),
      twitter_username: z.string().optional(),
      public_repos: z.number().int(),
      public_gists: z.number().int(),
      followers: z.number().int(),
      following: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      private_gists: z.number().int(),
      total_private_repos: z.number().int(),
      owned_private_repos: z.number().int(),
      disk_usage: z.number().int(),
      collaborators: z.number().int(),
      two_factor_authentication: z.boolean(),
      plan: z
        .object({
          collaborators: z.number().int(),
          name: z.string(),
          space: z.number().int(),
          private_repos: z.number().int()
        })
        .optional(),
      business_plus: z.boolean().optional(),
      ldap_dn: z.string().optional()
    })
    .describe('Private User')
  export type PrivateUser = z.infer<typeof PrivateUserSchema>

  export const RepositoryIdInQuerySchema = z
    .any()
    .describe('ID of the Repository to filter on')
  export type RepositoryIdInQuery = z.infer<typeof RepositoryIdInQuerySchema>

  export const CodespacesSecretSchema = z
    .object({
      name: z.string().describe('The name of the secret'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the secret was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'The type of repositories in the organization that the secret is visible to'
        ),
      selected_repositories_url: z
        .string()
        .url()
        .describe(
          'The API URL at which the list of repositories this secret is visible to can be retrieved'
        )
    })
    .describe('Secrets for a GitHub Codespace.')
  export type CodespacesSecret = z.infer<typeof CodespacesSecretSchema>

  export const CodespacesUserPublicKeySchema = z
    .object({
      key_id: z.string().describe('The identifier for the key.'),
      key: z.string().describe('The Base64 encoded public key.')
    })
    .describe("The public key used for setting user Codespaces' Secrets.")
  export type CodespacesUserPublicKey = z.infer<
    typeof CodespacesUserPublicKeySchema
  >

  export const CodespaceExportDetailsSchema = z
    .object({
      state: z.string().describe('State of the latest export').optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe('Completion time of the last export operation')
        .optional(),
      branch: z.string().describe('Name of the exported branch').optional(),
      sha: z
        .string()
        .describe('Git commit SHA of the exported branch')
        .optional(),
      id: z.string().describe('Id for the export details').optional(),
      export_url: z
        .string()
        .describe('Url for fetching export details')
        .optional(),
      html_url: z
        .string()
        .describe('Web url for the exported branch')
        .optional()
    })
    .describe(
      'An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest'
    )
  export type CodespaceExportDetails = z.infer<
    typeof CodespaceExportDetailsSchema
  >

  export const ExportIdSchema = z
    .any()
    .describe(
      'The ID of the export operation, or `latest`. Currently only `latest` is currently supported.'
    )
  export type ExportId = z.infer<typeof ExportIdSchema>

  export const EmailSchema = z
    .object({
      email: z.string().email(),
      primary: z.boolean(),
      verified: z.boolean(),
      visibility: z.string()
    })
    .describe('Email')
  export type Email = z.infer<typeof EmailSchema>

  export const GpgKeySchema = z
    .object({
      id: z.number().int(),
      name: z.string().optional(),
      primary_key_id: z.number().int(),
      key_id: z.string(),
      public_key: z.string(),
      emails: z.array(
        z.object({
          email: z.string().optional(),
          verified: z.boolean().optional()
        })
      ),
      subkeys: z.array(
        z.object({
          id: z.number().int().optional(),
          primary_key_id: z.number().int().optional(),
          key_id: z.string().optional(),
          public_key: z.string().optional(),
          emails: z
            .array(
              z.object({
                email: z.string().optional(),
                verified: z.boolean().optional()
              })
            )
            .optional(),
          subkeys: z.array(z.any()).optional(),
          can_sign: z.boolean().optional(),
          can_encrypt_comms: z.boolean().optional(),
          can_encrypt_storage: z.boolean().optional(),
          can_certify: z.boolean().optional(),
          created_at: z.string().optional(),
          expires_at: z.string().optional(),
          raw_key: z.string().optional(),
          revoked: z.boolean().optional()
        })
      ),
      can_sign: z.boolean(),
      can_encrypt_comms: z.boolean(),
      can_encrypt_storage: z.boolean(),
      can_certify: z.boolean(),
      created_at: z.string().datetime({ offset: true }),
      expires_at: z.string().datetime({ offset: true }),
      revoked: z.boolean(),
      raw_key: z.string()
    })
    .describe('A unique encryption key')
  export type GpgKey = z.infer<typeof GpgKeySchema>

  export const GpgKeyIdSchema = z
    .any()
    .describe('The unique identifier of the GPG key.')
  export type GpgKeyId = z.infer<typeof GpgKeyIdSchema>

  export const KeySchema = z
    .object({
      key: z.string(),
      id: z.number().int(),
      url: z.string(),
      title: z.string(),
      created_at: z.string().datetime({ offset: true }),
      verified: z.boolean(),
      read_only: z.boolean()
    })
    .describe('Key')
  export type Key = z.infer<typeof KeySchema>

  export const MarketplaceAccountSchema = z.object({
    url: z.string().url(),
    id: z.number().int(),
    type: z.string(),
    node_id: z.string().optional(),
    login: z.string(),
    email: z.string().email().optional(),
    organization_billing_email: z.string().email().optional()
  })
  export type MarketplaceAccount = z.infer<typeof MarketplaceAccountSchema>

  export const SinceRepoDateSchema = z
    .any()
    .describe(
      'Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type SinceRepoDate = z.infer<typeof SinceRepoDateSchema>

  export const BeforeRepoDateSchema = z
    .any()
    .describe(
      'Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
    )
  export type BeforeRepoDate = z.infer<typeof BeforeRepoDateSchema>

  export const SocialAccountSchema = z
    .object({ provider: z.string(), url: z.string() })
    .describe('Social media account')
  export type SocialAccount = z.infer<typeof SocialAccountSchema>

  export const SshSigningKeySchema = z
    .object({
      key: z.string(),
      id: z.number().int(),
      title: z.string(),
      created_at: z.string().datetime({ offset: true })
    })
    .describe('A public SSH key used to sign Git commits')
  export type SshSigningKey = z.infer<typeof SshSigningKeySchema>

  export const SshSigningKeyIdSchema = z
    .any()
    .describe('The unique identifier of the SSH signing key.')
  export type SshSigningKeyId = z.infer<typeof SshSigningKeyIdSchema>

  export const SortStarredSchema = z
    .any()
    .describe(
      'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
    )
  export type SortStarred = z.infer<typeof SortStarredSchema>

  export const HovercardSchema = z
    .object({
      contexts: z.array(z.object({ message: z.string(), octicon: z.string() }))
    })
    .describe('Hovercard')
  export type Hovercard = z.infer<typeof HovercardSchema>

  export const KeySimpleSchema = z
    .object({ id: z.number().int(), key: z.string() })
    .describe('Key Simple')
  export type KeySimple = z.infer<typeof KeySimpleSchema>

  export const VulnerabilitySchema = z
    .object({
      package: z
        .object({
          ecosystem: SecurityAdvisoryEcosystemsSchema,
          name: z
            .string()
            .describe('The unique package name within its ecosystem.')
        })
        .describe('The name of the package affected by the vulnerability.'),
      vulnerable_version_range: z
        .string()
        .describe(
          'The range of the package versions affected by the vulnerability.'
        ),
      first_patched_version: z
        .string()
        .describe('The package version that resolves the vulnerability.'),
      vulnerable_functions: z
        .array(z.string())
        .describe(
          'The functions in the package that are affected by the vulnerability.'
        )
        .readonly()
    })
    .describe(
      'A vulnerability describing the product and its affected versions within a GitHub Security Advisory.'
    )
  export type Vulnerability = z.infer<typeof VulnerabilitySchema>

  export const ClassroomSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the classroom.'),
      name: z.string().describe('The name of the classroom.'),
      archived: z.boolean().describe('Whether classroom is archived.'),
      organization: SimpleClassroomOrganizationSchema,
      url: z.string().describe('The URL of the classroom on GitHub Classroom.')
    })
    .describe('A GitHub Classroom classroom')
  export type Classroom = z.infer<typeof ClassroomSchema>

  export const SimpleClassroomAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      public_repo: z
        .boolean()
        .describe(
          'Whether an accepted assignment creates a public repository.'
        ),
      title: z.string().describe('Assignment title.'),
      type: z
        .enum(['individual', 'group'])
        .describe("Whether it's a Group Assignment or Individual Assignment."),
      invite_link: z
        .string()
        .describe('The link that a student can use to accept the assignment.'),
      invitations_enabled: z
        .boolean()
        .describe(
          'Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.'
        ),
      slug: z.string().describe('Sluggified name of the assignment.'),
      students_are_repo_admins: z
        .boolean()
        .describe(
          'Whether students are admins on created repository on accepted assignment.'
        ),
      feedback_pull_requests_enabled: z
        .boolean()
        .describe(
          'Whether feedback pull request will be created on assignment acceptance.'
        ),
      max_teams: z
        .number()
        .int()
        .describe('The maximum allowable teams for the assignment.')
        .optional(),
      max_members: z
        .number()
        .int()
        .describe('The maximum allowable members per team.')
        .optional(),
      editor: z.string().describe('The selected editor for the assignment.'),
      accepted: z
        .number()
        .int()
        .describe('The number of students that have accepted the assignment.'),
      submitted: z
        .number()
        .int()
        .describe('The number of students that have submitted the assignment.'),
      passing: z
        .number()
        .int()
        .describe('The number of students that have passed the assignment.'),
      language: z
        .string()
        .describe('The programming language used in the assignment.'),
      deadline: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the assignment is due.'),
      classroom: SimpleClassroomSchema
    })
    .describe('A GitHub Classroom assignment')
  export type SimpleClassroomAssignment = z.infer<
    typeof SimpleClassroomAssignmentSchema
  >

  export const CodeSecurityDefaultConfigurationsSchema = z
    .array(
      z.object({
        default_for_new_repos: z
          .enum(['public', 'private_and_internal', 'all'])
          .describe(
            'The visibility of newly created repositories for which the code security configuration will be applied to by default'
          )
          .optional(),
        configuration: CodeSecurityConfigurationSchema.optional()
      })
    )
    .describe('A list of default code security configurations')
  export type CodeSecurityDefaultConfigurations = z.infer<
    typeof CodeSecurityDefaultConfigurationsSchema
  >

  export const SimpleRepositorySchema = z
    .object({
      id: z.number().int().describe('A unique identifier of the repository.'),
      node_id: z.string().describe('The GraphQL identifier of the repository.'),
      name: z.string().describe('The name of the repository.'),
      full_name: z
        .string()
        .describe('The full, globally unique, name of the repository.'),
      owner: SimpleUserSchema,
      private: z.boolean().describe('Whether the repository is private.'),
      html_url: z
        .string()
        .url()
        .describe('The URL to view the repository on GitHub.com.'),
      description: z.string().describe('The repository description.'),
      fork: z.boolean().describe('Whether the repository is a fork.'),
      url: z
        .string()
        .url()
        .describe(
          'The URL to get more information about the repository from the GitHub API.'
        ),
      archive_url: z
        .string()
        .describe(
          'A template for the API URL to download the repository as an archive.'
        ),
      assignees_url: z
        .string()
        .describe(
          'A template for the API URL to list the available assignees for issues in the repository.'
        ),
      blobs_url: z
        .string()
        .describe(
          'A template for the API URL to create or retrieve a raw Git blob in the repository.'
        ),
      branches_url: z
        .string()
        .describe(
          'A template for the API URL to get information about branches in the repository.'
        ),
      collaborators_url: z
        .string()
        .describe(
          'A template for the API URL to get information about collaborators of the repository.'
        ),
      comments_url: z
        .string()
        .describe(
          'A template for the API URL to get information about comments on the repository.'
        ),
      commits_url: z
        .string()
        .describe(
          'A template for the API URL to get information about commits on the repository.'
        ),
      compare_url: z
        .string()
        .describe('A template for the API URL to compare two commits or refs.'),
      contents_url: z
        .string()
        .describe(
          'A template for the API URL to get the contents of the repository.'
        ),
      contributors_url: z
        .string()
        .url()
        .describe(
          'A template for the API URL to list the contributors to the repository.'
        ),
      deployments_url: z
        .string()
        .url()
        .describe('The API URL to list the deployments of the repository.'),
      downloads_url: z
        .string()
        .url()
        .describe('The API URL to list the downloads on the repository.'),
      events_url: z
        .string()
        .url()
        .describe('The API URL to list the events of the repository.'),
      forks_url: z
        .string()
        .url()
        .describe('The API URL to list the forks of the repository.'),
      git_commits_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git commits of the repository.'
        ),
      git_refs_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git refs of the repository.'
        ),
      git_tags_url: z
        .string()
        .describe(
          'A template for the API URL to get information about Git tags of the repository.'
        ),
      issue_comment_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issue comments on the repository.'
        ),
      issue_events_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issue events on the repository.'
        ),
      issues_url: z
        .string()
        .describe(
          'A template for the API URL to get information about issues on the repository.'
        ),
      keys_url: z
        .string()
        .describe(
          'A template for the API URL to get information about deploy keys on the repository.'
        ),
      labels_url: z
        .string()
        .describe(
          'A template for the API URL to get information about labels of the repository.'
        ),
      languages_url: z
        .string()
        .url()
        .describe(
          'The API URL to get information about the languages of the repository.'
        ),
      merges_url: z
        .string()
        .url()
        .describe('The API URL to merge branches in the repository.'),
      milestones_url: z
        .string()
        .describe(
          'A template for the API URL to get information about milestones of the repository.'
        ),
      notifications_url: z
        .string()
        .describe(
          'A template for the API URL to get information about notifications on the repository.'
        ),
      pulls_url: z
        .string()
        .describe(
          'A template for the API URL to get information about pull requests on the repository.'
        ),
      releases_url: z
        .string()
        .describe(
          'A template for the API URL to get information about releases on the repository.'
        ),
      stargazers_url: z
        .string()
        .url()
        .describe('The API URL to list the stargazers on the repository.'),
      statuses_url: z
        .string()
        .describe(
          'A template for the API URL to get information about statuses of a commit.'
        ),
      subscribers_url: z
        .string()
        .url()
        .describe('The API URL to list the subscribers on the repository.'),
      subscription_url: z
        .string()
        .url()
        .describe(
          'The API URL to subscribe to notifications for this repository.'
        ),
      tags_url: z
        .string()
        .url()
        .describe(
          'The API URL to get information about tags on the repository.'
        ),
      teams_url: z
        .string()
        .url()
        .describe('The API URL to list the teams on the repository.'),
      trees_url: z
        .string()
        .describe(
          'A template for the API URL to create or retrieve a raw Git tree of the repository.'
        ),
      hooks_url: z
        .string()
        .url()
        .describe('The API URL to list the hooks on the repository.')
    })
    .describe('A GitHub repository.')
  export type SimpleRepository = z.infer<typeof SimpleRepositorySchema>

  export const DependabotAlertSecurityVulnerabilitySchema = z
    .object({
      package: DependabotAlertPackageSchema,
      severity: z
        .enum(['low', 'medium', 'high', 'critical'])
        .describe('The severity of the vulnerability.')
        .readonly(),
      vulnerable_version_range: z
        .string()
        .describe(
          "Conditions that identify vulnerable versions of this vulnerability's package."
        )
        .readonly(),
      first_patched_version: z
        .object({
          identifier: z
            .string()
            .describe('The package version that patches this vulnerability.')
            .readonly()
        })
        .strict()
        .describe(
          'Details pertaining to the package version that patches this vulnerability.'
        )
        .readonly()
    })
    .strict()
    .describe(
      'Details pertaining to one vulnerable version range for the advisory.'
    )
    .readonly()
  export type DependabotAlertSecurityVulnerability = z.infer<
    typeof DependabotAlertSecurityVulnerabilitySchema
  >

  export const NullableMilestoneSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      labels_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int().describe('The number of the milestone.'),
      state: z
        .enum(['open', 'closed'])
        .describe('The state of the milestone.')
        .default('open'),
      title: z.string().describe('The title of the milestone.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      open_issues: z.number().int(),
      closed_issues: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      due_on: z.string().datetime({ offset: true })
    })
    .describe('A collection of related issues and pull requests.')
  export type NullableMilestone = z.infer<typeof NullableMilestoneSchema>

  export const FeedSchema = z
    .object({
      timeline_url: z.string(),
      user_url: z.string(),
      current_user_public_url: z.string().optional(),
      current_user_url: z.string().optional(),
      current_user_actor_url: z.string().optional(),
      current_user_organization_url: z.string().optional(),
      current_user_organization_urls: z.array(z.string().url()).optional(),
      security_advisories_url: z.string().optional(),
      repository_discussions_url: z
        .string()
        .describe('A feed of discussions for a given repository.')
        .optional(),
      repository_discussions_category_url: z
        .string()
        .describe('A feed of discussions for a given repository and category.')
        .optional(),
      _links: z.object({
        timeline: LinkWithTypeSchema,
        user: LinkWithTypeSchema,
        security_advisories: LinkWithTypeSchema.optional(),
        current_user: LinkWithTypeSchema.optional(),
        current_user_public: LinkWithTypeSchema.optional(),
        current_user_actor: LinkWithTypeSchema.optional(),
        current_user_organization: LinkWithTypeSchema.optional(),
        current_user_organizations: z.array(LinkWithTypeSchema).optional(),
        repository_discussions: LinkWithTypeSchema.optional(),
        repository_discussions_category: LinkWithTypeSchema.optional()
      })
    })
    .describe('Feed')
  export type Feed = z.infer<typeof FeedSchema>

  export const GistHistorySchema = z
    .object({
      user: NullableSimpleUserSchema.optional(),
      version: z.string().optional(),
      committed_at: z.string().datetime({ offset: true }).optional(),
      change_status: z
        .object({
          total: z.number().int().optional(),
          additions: z.number().int().optional(),
          deletions: z.number().int().optional()
        })
        .optional(),
      url: z.string().url().optional()
    })
    .describe('Gist History')
  export type GistHistory = z.infer<typeof GistHistorySchema>

  export const GistCommitSchema = z
    .object({
      url: z.string().url(),
      version: z.string(),
      user: NullableSimpleUserSchema,
      change_status: z.object({
        total: z.number().int().optional(),
        additions: z.number().int().optional(),
        deletions: z.number().int().optional()
      }),
      committed_at: z.string().datetime({ offset: true })
    })
    .describe('Gist Commit')
  export type GistCommit = z.infer<typeof GistCommitSchema>

  export const MarketplacePurchaseSchema = z
    .object({
      url: z.string(),
      type: z.string(),
      id: z.number().int(),
      login: z.string(),
      organization_billing_email: z.string().optional(),
      email: z.string().optional(),
      marketplace_pending_change: z
        .object({
          is_installed: z.boolean().optional(),
          effective_date: z.string().optional(),
          unit_count: z.number().int().optional(),
          id: z.number().int().optional(),
          plan: MarketplaceListingPlanSchema.optional()
        })
        .optional(),
      marketplace_purchase: z.object({
        billing_cycle: z.string().optional(),
        next_billing_date: z.string().optional(),
        is_installed: z.boolean().optional(),
        unit_count: z.number().int().optional(),
        on_free_trial: z.boolean().optional(),
        free_trial_ends_on: z.string().optional(),
        updated_at: z.string().optional(),
        plan: MarketplaceListingPlanSchema.optional()
      })
    })
    .describe('Marketplace Purchase')
  export type MarketplacePurchase = z.infer<typeof MarketplacePurchaseSchema>

  export const RunnerSchema = z
    .object({
      id: z.number().int().describe('The ID of the runner.'),
      runner_group_id: z
        .number()
        .int()
        .describe('The ID of the runner group.')
        .optional(),
      name: z.string().describe('The name of the runner.'),
      os: z.string().describe('The Operating System of the runner.'),
      status: z.string().describe('The status of the runner.'),
      busy: z.boolean(),
      labels: z.array(RunnerLabelSchema),
      ephemeral: z.boolean().optional()
    })
    .describe('A self hosted runner')
  export type Runner = z.infer<typeof RunnerSchema>

  export const ToolNameSchema = z
    .any()
    .describe(
      'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
    )
  export type ToolName = z.infer<typeof ToolNameSchema>

  export const ToolGuidSchema = z
    .any()
    .describe(
      'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
    )
  export type ToolGuid = z.infer<typeof ToolGuidSchema>

  export const CopilotOrganizationDetailsSchema = z
    .object({
      seat_breakdown: CopilotOrganizationSeatBreakdownSchema,
      public_code_suggestions: z
        .enum(['allow', 'block', 'unconfigured'])
        .describe(
          'The organization policy for allowing or blocking suggestions matching public code (duplication detection filter).'
        ),
      ide_chat: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot Chat in the IDE.'
        )
        .optional(),
      platform_chat: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot features on GitHub.com.'
        )
        .optional(),
      cli: z
        .enum(['enabled', 'disabled', 'unconfigured'])
        .describe(
          'The organization policy for allowing or disallowing Copilot in the CLI.'
        )
        .optional(),
      seat_management_setting: z
        .enum(['assign_all', 'assign_selected', 'disabled', 'unconfigured'])
        .describe('The mode of assigning new seats.'),
      plan_type: z
        .enum(['business', 'enterprise'])
        .describe(
          'The Copilot plan of the organization, or the parent enterprise, when applicable.'
        )
        .optional()
    })
    .catchall(z.any())
    .describe(
      'Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.'
    )
  export type CopilotOrganizationDetails = z.infer<
    typeof CopilotOrganizationDetailsSchema
  >

  export const TeamSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string(),
      privacy: z.string().optional(),
      notification_setting: z.string().optional(),
      permission: z.string(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean(),
          push: z.boolean(),
          maintain: z.boolean(),
          admin: z.boolean()
        })
        .optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type Team = z.infer<typeof TeamSchema>

  export const OrganizationInvitationSchema = z
    .object({
      id: z.number().int(),
      login: z.string(),
      email: z.string(),
      role: z.string(),
      created_at: z.string(),
      failed_at: z.string().optional(),
      failed_reason: z.string().optional(),
      inviter: SimpleUserSchema,
      team_count: z.number().int(),
      node_id: z.string(),
      invitation_teams_url: z.string(),
      invitation_source: z.string().optional()
    })
    .describe('Organization Invitation')
  export type OrganizationInvitation = z.infer<
    typeof OrganizationInvitationSchema
  >

  export const InteractionLimitResponseSchema = z
    .object({
      limit: InteractionGroupSchema,
      origin: z.string(),
      expires_at: z.string().datetime({ offset: true })
    })
    .describe('Interaction limit settings.')
  export type InteractionLimitResponse = z.infer<
    typeof InteractionLimitResponseSchema
  >

  export const OrganizationRoleSchema = z
    .object({
      id: z.number().int().describe('The unique identifier of the role.'),
      name: z.string().describe('The name of the role.'),
      description: z
        .string()
        .describe(
          'A short description about who this role is for or what permissions it grants.'
        )
        .optional(),
      base_role: z
        .enum(['read', 'triage', 'write', 'maintain', 'admin'])
        .describe('The system role from which this role inherits permissions.')
        .optional(),
      source: z
        .enum(['Organization', 'Enterprise', 'Predefined'])
        .describe(
          'Source answers the question, "where did this role come from?"'
        )
        .optional(),
      permissions: z
        .array(z.string())
        .describe('A list of permissions included in this role.'),
      organization: NullableSimpleUserSchema,
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe('The date and time the role was created.'),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe('The date and time the role was last updated.')
    })
    .describe('Organization roles')
  export type OrganizationRole = z.infer<typeof OrganizationRoleSchema>

  export const TeamRoleAssignmentSchema = z
    .object({
      assignment: z
        .enum(['direct', 'indirect', 'mixed'])
        .describe(
          'Determines if the team has a direct, indirect, or mixed relationship to a role'
        )
        .optional(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string(),
      privacy: z.string().optional(),
      notification_setting: z.string().optional(),
      permission: z.string(),
      permissions: z
        .object({
          pull: z.boolean(),
          triage: z.boolean(),
          push: z.boolean(),
          maintain: z.boolean(),
          admin: z.boolean()
        })
        .optional(),
      url: z.string().url(),
      html_url: z.string().url(),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema
    })
    .describe('The Relationship a Team has with a role.')
  export type TeamRoleAssignment = z.infer<typeof TeamRoleAssignmentSchema>

  export const UserRoleAssignmentSchema = z
    .object({
      assignment: z
        .enum(['direct', 'indirect', 'mixed'])
        .describe(
          'Determines if the user has a direct, indirect, or mixed relationship to a role'
        )
        .optional(),
      inherited_from: z
        .array(TeamSimpleSchema)
        .describe('Team the user has gotten the role through')
        .optional(),
      name: z.string().optional(),
      email: z.string().optional(),
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      events_url: z.string(),
      received_events_url: z.string().url(),
      type: z.string(),
      site_admin: z.boolean(),
      starred_at: z.string().optional(),
      user_view_type: z.string().optional()
    })
    .describe('The Relationship a User has with a role.')
  export type UserRoleAssignment = z.infer<typeof UserRoleAssignmentSchema>

  export const OrganizationProgrammaticAccessGrantRequestSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests.'
        ),
      reason: z.string().describe('Reason for requesting access.'),
      owner: SimpleUserSchema,
      repository_selection: z
        .enum(['none', 'all', 'subset'])
        .describe('Type of repository selection requested.'),
      repositories_url: z
        .string()
        .describe(
          'URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`.'
        ),
      permissions: z
        .object({
          organization: z.record(z.string()).optional(),
          repository: z.record(z.string()).optional(),
          other: z.record(z.string()).optional()
        })
        .describe('Permissions requested, categorized by type of permission.'),
      created_at: z
        .string()
        .describe('Date and time when the request for access was created.'),
      token_id: z
        .number()
        .int()
        .describe(
          "Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."
        ),
      token_name: z
        .string()
        .describe(
          "The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."
        ),
      token_expired: z
        .boolean()
        .describe(
          'Whether the associated fine-grained personal access token has expired.'
        ),
      token_expires_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token expires.'
        ),
      token_last_used_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token was last used for authentication.'
        )
    })
    .describe(
      'Minimal representation of an organization programmatic access grant request for enumerations'
    )
  export type OrganizationProgrammaticAccessGrantRequest = z.infer<
    typeof OrganizationProgrammaticAccessGrantRequestSchema
  >

  export const OrganizationProgrammaticAccessGrantSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe(
          'Unique identifier of the fine-grained personal access token grant. The `pat_id` used to get details about an approved fine-grained personal access token.'
        ),
      owner: SimpleUserSchema,
      repository_selection: z
        .enum(['none', 'all', 'subset'])
        .describe('Type of repository selection requested.'),
      repositories_url: z
        .string()
        .describe(
          'URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`.'
        ),
      permissions: z
        .object({
          organization: z.record(z.string()).optional(),
          repository: z.record(z.string()).optional(),
          other: z.record(z.string()).optional()
        })
        .describe('Permissions requested, categorized by type of permission.'),
      access_granted_at: z
        .string()
        .describe(
          'Date and time when the fine-grained personal access token was approved to access the organization.'
        ),
      token_id: z
        .number()
        .int()
        .describe(
          "Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."
        ),
      token_name: z
        .string()
        .describe(
          "The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."
        ),
      token_expired: z
        .boolean()
        .describe(
          'Whether the associated fine-grained personal access token has expired.'
        ),
      token_expires_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token expires.'
        ),
      token_last_used_at: z
        .string()
        .describe(
          'Date and time when the associated fine-grained personal access token was last used for authentication.'
        )
    })
    .describe(
      'Minimal representation of an organization programmatic access grant for enumerations'
    )
  export type OrganizationProgrammaticAccessGrant = z.infer<
    typeof OrganizationProgrammaticAccessGrantSchema
  >

  export const ProjectSchema = z
    .object({
      owner_url: z.string().url(),
      url: z.string().url(),
      html_url: z.string().url(),
      columns_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('Name of the project'),
      body: z.string().describe('Body of the project'),
      number: z.number().int(),
      state: z
        .string()
        .describe("State of the project; either 'open' or 'closed'"),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      organization_permission: z
        .enum(['read', 'write', 'admin', 'none'])
        .describe(
          'The baseline permission that all organization members have on this project. Only present if owner is an organization.'
        )
        .optional(),
      private: z
        .boolean()
        .describe(
          'Whether or not this project can be seen by everyone. Only present if owner is an organization.'
        )
        .optional()
    })
    .describe('Projects are a way to organize columns and cards of work.')
  export type Project = z.infer<typeof ProjectSchema>

  export const OrgRepoCustomPropertyValuesSchema = z
    .object({
      repository_id: z.number().int(),
      repository_name: z.string(),
      repository_full_name: z.string(),
      properties: z
        .array(CustomPropertyValueSchema)
        .describe('List of custom property names and associated values')
    })
    .describe('List of custom property values for a repository')
  export type OrgRepoCustomPropertyValues = z.infer<
    typeof OrgRepoCustomPropertyValuesSchema
  >

  export const RepositoryRulesetConditionsRepositoryPropertyTargetSchema = z
    .object({
      repository_property: z.object({
        include: z
          .array(RepositoryRulesetConditionsRepositoryPropertySpecSchema)
          .describe(
            'The repository properties and values to include. All of these properties must match for the condition to pass.'
          )
          .optional(),
        exclude: z
          .array(RepositoryRulesetConditionsRepositoryPropertySpecSchema)
          .describe(
            'The repository properties and values to exclude. The condition will not pass if any of these properties match.'
          )
          .optional()
      })
    })
    .describe('Parameters for a repository property condition')
  export type RepositoryRulesetConditionsRepositoryPropertyTarget = z.infer<
    typeof RepositoryRulesetConditionsRepositoryPropertyTargetSchema
  >

  export const RepositoryRuleRequiredStatusChecksSchema = z
    .object({
      type: z.literal('required_status_checks'),
      parameters: z
        .object({
          do_not_enforce_on_create: z
            .boolean()
            .describe(
              'Allow repositories and branches to be created if a check would otherwise prohibit it.'
            )
            .optional(),
          required_status_checks: z
            .array(RepositoryRuleParamsStatusCheckConfigurationSchema)
            .describe('Status checks that are required.'),
          strict_required_status_checks_policy: z
            .boolean()
            .describe(
              'Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.'
    )
  export type RepositoryRuleRequiredStatusChecks = z.infer<
    typeof RepositoryRuleRequiredStatusChecksSchema
  >

  export const RepositoryRuleWorkflowsSchema = z
    .object({
      type: z.literal('workflows'),
      parameters: z
        .object({
          do_not_enforce_on_create: z
            .boolean()
            .describe(
              'Allow repositories and branches to be created if a check would otherwise prohibit it.'
            )
            .optional(),
          workflows: z
            .array(RepositoryRuleParamsWorkflowFileReferenceSchema)
            .describe('Workflows that must pass for this rule to pass.')
        })
        .optional()
    })
    .describe(
      'Require all changes made to a targeted branch to pass the specified workflows before they can be merged.'
    )
  export type RepositoryRuleWorkflows = z.infer<
    typeof RepositoryRuleWorkflowsSchema
  >

  export const RepositoryRuleCodeScanningSchema = z
    .object({
      type: z.literal('code_scanning'),
      parameters: z
        .object({
          code_scanning_tools: z
            .array(RepositoryRuleParamsCodeScanningToolSchema)
            .describe(
              'Tools that must provide code scanning results for this rule to pass.'
            )
        })
        .optional()
    })
    .describe(
      'Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.'
    )
  export type RepositoryRuleCodeScanning = z.infer<
    typeof RepositoryRuleCodeScanningSchema
  >

  export const RulesetVersionWithStateSchema = z.intersection(
    RulesetVersionSchema,
    z.object({
      state: z.record(z.any()).describe('The state of the ruleset version')
    })
  )
  export type RulesetVersionWithState = z.infer<
    typeof RulesetVersionWithStateSchema
  >

  export const RepositoryAdvisoryVulnerabilitySchema = z
    .object({
      package: z
        .object({
          ecosystem: SecurityAdvisoryEcosystemsSchema,
          name: z
            .string()
            .describe('The unique package name within its ecosystem.')
        })
        .describe('The name of the package affected by the vulnerability.'),
      vulnerable_version_range: z
        .string()
        .describe(
          'The range of the package versions affected by the vulnerability.'
        ),
      patched_versions: z
        .string()
        .describe('The package version(s) that resolve the vulnerability.'),
      vulnerable_functions: z
        .array(z.string())
        .describe('The functions in the package that are affected.')
    })
    .strict()
    .describe(
      'A product affected by the vulnerability detailed in a repository security advisory.'
    )
  export type RepositoryAdvisoryVulnerability = z.infer<
    typeof RepositoryAdvisoryVulnerabilitySchema
  >

  export const ReactionSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      user: NullableSimpleUserSchema,
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe('The reaction to use'),
      created_at: z.string().datetime({ offset: true })
    })
    .describe(
      'Reactions to conversations provide a way to help people express their feelings more simply and effectively.'
    )
  export type Reaction = z.infer<typeof ReactionSchema>

  export const TeamProjectSchema = z
    .object({
      owner_url: z.string(),
      url: z.string(),
      html_url: z.string(),
      columns_url: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      body: z.string(),
      number: z.number().int(),
      state: z.string(),
      creator: SimpleUserSchema,
      created_at: z.string(),
      updated_at: z.string(),
      organization_permission: z
        .string()
        .describe(
          'The organization permission for this project. Only present when owner is an organization.'
        )
        .optional(),
      private: z
        .boolean()
        .describe(
          'Whether the project is private or not. Only present when owner is an organization.'
        )
        .optional(),
      permissions: z.object({
        read: z.boolean(),
        write: z.boolean(),
        admin: z.boolean()
      })
    })
    .describe("A team's access to a project.")
  export type TeamProject = z.infer<typeof TeamProjectSchema>

  export const ProjectCardSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe("The project card's ID"),
      node_id: z.string(),
      note: z.string(),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      archived: z
        .boolean()
        .describe('Whether or not the card is archived')
        .optional(),
      column_name: z.string().optional(),
      project_id: z.string().optional(),
      column_url: z.string().url(),
      content_url: z.string().url().optional(),
      project_url: z.string().url()
    })
    .describe('Project cards represent a scope of work.')
  export type ProjectCard = z.infer<typeof ProjectCardSchema>

  export const ProjectCollaboratorPermissionSchema = z
    .object({ permission: z.string(), user: NullableSimpleUserSchema })
    .describe('Project Collaborator Permission')
  export type ProjectCollaboratorPermission = z.infer<
    typeof ProjectCollaboratorPermissionSchema
  >

  export const RateLimitOverviewSchema = z
    .object({
      resources: z.object({
        core: RateLimitSchema,
        graphql: RateLimitSchema.optional(),
        search: RateLimitSchema,
        code_search: RateLimitSchema.optional(),
        source_import: RateLimitSchema.optional(),
        integration_manifest: RateLimitSchema.optional(),
        code_scanning_upload: RateLimitSchema.optional(),
        actions_runner_registration: RateLimitSchema.optional(),
        scim: RateLimitSchema.optional(),
        dependency_snapshots: RateLimitSchema.optional(),
        code_scanning_autofix: RateLimitSchema.optional()
      }),
      rate: RateLimitSchema
    })
    .describe('Rate Limit Overview')
  export type RateLimitOverview = z.infer<typeof RateLimitOverviewSchema>

  export const EnvironmentApprovalsSchema = z
    .object({
      environments: z
        .array(
          z.object({
            id: z
              .number()
              .int()
              .describe('The id of the environment.')
              .optional(),
            node_id: z.string().optional(),
            name: z
              .string()
              .describe('The name of the environment.')
              .optional(),
            url: z.string().optional(),
            html_url: z.string().optional(),
            created_at: z
              .string()
              .datetime({ offset: true })
              .describe(
                'The time that the environment was created, in ISO 8601 format.'
              )
              .optional(),
            updated_at: z
              .string()
              .datetime({ offset: true })
              .describe(
                'The time that the environment was last updated, in ISO 8601 format.'
              )
              .optional()
          })
        )
        .describe('The list of environments that were approved or rejected'),
      state: z
        .enum(['approved', 'rejected', 'pending'])
        .describe(
          'Whether deployment to the environment(s) was approved or rejected or pending (with comments)'
        ),
      user: SimpleUserSchema,
      comment: z
        .string()
        .describe('The comment submitted with the deployment review')
    })
    .describe('An entry in the reviews log for environment deployments')
  export type EnvironmentApprovals = z.infer<typeof EnvironmentApprovalsSchema>

  export const ActivitySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      before: z.string().describe('The SHA of the commit before the activity.'),
      after: z.string().describe('The SHA of the commit after the activity.'),
      ref: z
        .string()
        .describe(
          'The full Git reference, formatted as `refs/heads/<branch name>`.'
        ),
      timestamp: z
        .string()
        .datetime({ offset: true })
        .describe('The time when the activity occurred.'),
      activity_type: z
        .enum([
          'push',
          'force_push',
          'branch_deletion',
          'branch_creation',
          'pr_merge',
          'merge_queue_merge'
        ])
        .describe('The type of the activity that was performed.'),
      actor: NullableSimpleUserSchema
    })
    .describe('Activity')
  export type Activity = z.infer<typeof ActivitySchema>

  export const CodeScanningCodeqlDatabaseSchema = z
    .object({
      id: z.number().int().describe('The ID of the CodeQL database.'),
      name: z.string().describe('The name of the CodeQL database.'),
      language: z.string().describe('The language of the CodeQL database.'),
      uploader: SimpleUserSchema,
      content_type: z
        .string()
        .describe('The MIME type of the CodeQL database file.'),
      size: z
        .number()
        .int()
        .describe('The size of the CodeQL database file in bytes.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the CodeQL database was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the CodeQL database was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        ),
      url: z
        .string()
        .url()
        .describe(
          'The URL at which to download the CodeQL database. The `Accept` header must be set to the value of the `content_type` property.'
        ),
      commit_oid: z
        .string()
        .describe(
          'The commit SHA of the repository at the time the CodeQL database was created.'
        )
        .optional()
    })
    .describe('A CodeQL database.')
  export type CodeScanningCodeqlDatabase = z.infer<
    typeof CodeScanningCodeqlDatabaseSchema
  >

  export const CodeScanningVariantAnalysisSkippedRepoGroupSchema = z.object({
    repository_count: z
      .number()
      .int()
      .describe(
        'The total number of repositories that were skipped for this reason.'
      ),
    repositories: z
      .array(CodeScanningVariantAnalysisRepositorySchema)
      .describe(
        'A list of repositories that were skipped. This list may not include all repositories that were skipped. This is only available when the repository was found and the user has access to it.'
      )
  })
  export type CodeScanningVariantAnalysisSkippedRepoGroup = z.infer<
    typeof CodeScanningVariantAnalysisSkippedRepoGroupSchema
  >

  export const CodeSecurityConfigurationForRepositorySchema = z
    .object({
      status: z
        .enum([
          'attached',
          'attaching',
          'detached',
          'removed',
          'enforced',
          'failed',
          'updating',
          'removed_by_enterprise'
        ])
        .describe(
          'The attachment status of the code security configuration on the repository.'
        )
        .optional(),
      configuration: CodeSecurityConfigurationSchema.optional()
    })
    .describe(
      'Code security configuration associated with a repository and attachment status'
    )
  export type CodeSecurityConfigurationForRepository = z.infer<
    typeof CodeSecurityConfigurationForRepositorySchema
  >

  export const RepositoryCollaboratorPermissionSchema = z
    .object({
      permission: z.string(),
      role_name: z.string(),
      user: NullableCollaboratorSchema
    })
    .describe('Repository Collaborator Permission')
  export type RepositoryCollaboratorPermission = z.infer<
    typeof RepositoryCollaboratorPermissionSchema
  >

  export const AutoMergeSchema = z
    .object({
      enabled_by: SimpleUserSchema,
      merge_method: z
        .enum(['merge', 'squash', 'rebase'])
        .describe('The merge method to use.'),
      commit_title: z.string().describe('Title for the merge commit message.'),
      commit_message: z
        .string()
        .describe('Commit message for the merge commit.')
    })
    .describe('The status of auto merging a pull request.')
  export type AutoMerge = z.infer<typeof AutoMergeSchema>

  export const DependabotAlertNumberSchema = z
    .any()
    .describe(
      'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
    )
  export type DependabotAlertNumber = z.infer<
    typeof DependabotAlertNumberSchema
  >

  export const DependencySchema = z
    .object({
      package_url: z
        .string()
        .regex(new RegExp('^pkg'))
        .describe(
          'Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.'
        )
        .optional(),
      metadata: MetadataSchema.optional(),
      relationship: z
        .enum(['direct', 'indirect'])
        .describe(
          'A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.'
        )
        .optional(),
      scope: z
        .enum(['runtime', 'development'])
        .describe(
          'A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.'
        )
        .optional(),
      dependencies: z
        .array(z.string())
        .describe('Array of package-url (PURLs) of direct child dependencies.')
        .optional()
    })
    .strict()
  export type Dependency = z.infer<typeof DependencySchema>

  export const DeploymentProtectionRuleSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier for the deployment protection rule.'),
      node_id: z
        .string()
        .describe('The node ID for the deployment protection rule.'),
      enabled: z
        .boolean()
        .describe(
          'Whether the deployment protection rule is enabled for the environment.'
        ),
      app: CustomDeploymentRuleAppSchema
    })
    .describe('Deployment protection rule')
  export type DeploymentProtectionRule = z.infer<
    typeof DeploymentProtectionRuleSchema
  >

  export const GitTagSchema = z
    .object({
      node_id: z.string(),
      tag: z.string().describe('Name of the tag'),
      sha: z.string(),
      url: z.string().url().describe('URL for the tag'),
      message: z.string().describe('Message describing the purpose of the tag'),
      tagger: z.object({
        date: z.string(),
        email: z.string(),
        name: z.string()
      }),
      object: z.object({
        sha: z.string(),
        type: z.string(),
        url: z.string().url()
      }),
      verification: VerificationSchema.optional()
    })
    .describe('Metadata for a Git tag')
  export type GitTag = z.infer<typeof GitTagSchema>

  export const LicenseContentSchema = z
    .object({
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      size: z.number().int(),
      url: z.string().url(),
      html_url: z.string().url(),
      git_url: z.string().url(),
      download_url: z.string().url(),
      type: z.string(),
      content: z.string(),
      encoding: z.string(),
      _links: z.object({
        git: z.string().url(),
        html: z.string().url(),
        self: z.string().url()
      }),
      license: NullableLicenseSimpleSchema
    })
    .describe('License Content')
  export type LicenseContent = z.infer<typeof LicenseContentSchema>

  export const MilestoneSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      labels_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int().describe('The number of the milestone.'),
      state: z
        .enum(['open', 'closed'])
        .describe('The state of the milestone.')
        .default('open'),
      title: z.string().describe('The title of the milestone.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      open_issues: z.number().int(),
      closed_issues: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      due_on: z.string().datetime({ offset: true })
    })
    .describe('A collection of related issues and pull requests.')
  export type Milestone = z.infer<typeof MilestoneSchema>

  export const PageBuildSchema = z
    .object({
      url: z.string().url(),
      status: z.string(),
      error: z.object({ message: z.string() }),
      pusher: NullableSimpleUserSchema,
      commit: z.string(),
      duration: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('Page Build')
  export type PageBuild = z.infer<typeof PageBuildSchema>

  export const ReleaseAssetSchema = z
    .object({
      url: z.string().url(),
      browser_download_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      name: z.string().describe('The file name of the asset.'),
      label: z.string(),
      state: z
        .enum(['uploaded', 'open'])
        .describe('State of the release asset.'),
      content_type: z.string(),
      size: z.number().int(),
      download_count: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      uploader: NullableSimpleUserSchema
    })
    .describe('Data related to a release.')
  export type ReleaseAsset = z.infer<typeof ReleaseAssetSchema>

  export const SecretScanningPushProtectionBypassSchema = z.object({
    reason: SecretScanningPushProtectionBypassReasonSchema.optional(),
    expire_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the bypass will expire in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_type: z
      .string()
      .describe('The token type this bypass is for.')
      .optional()
  })
  export type SecretScanningPushProtectionBypass = z.infer<
    typeof SecretScanningPushProtectionBypassSchema
  >

  export const SecretScanningScanHistorySchema = z.object({
    incremental_scans: z.array(SecretScanningScanSchema).optional(),
    pattern_update_scans: z.array(SecretScanningScanSchema).optional(),
    backfill_scans: z.array(SecretScanningScanSchema).optional(),
    custom_pattern_backfill_scans: z
      .array(
        z.intersection(
          SecretScanningScanSchema,
          z.object({
            pattern_name: z
              .string()
              .describe('Name of the custom pattern for custom pattern scans')
              .optional(),
            pattern_scope: z
              .string()
              .describe(
                'Level at which the custom pattern is defined, one of "repository", "organization", or "enterprise"'
              )
              .optional()
          })
        )
      )
      .optional()
  })
  export type SecretScanningScanHistory = z.infer<
    typeof SecretScanningScanHistorySchema
  >

  export const PrivateVulnerabilityReportCreateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.'),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'An array of products affected by the vulnerability detailed in a repository security advisory.'
        )
        .optional(),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      start_private_fork: z
        .boolean()
        .describe(
          'Whether to create a temporary private fork of the repository to collaborate on a fix.'
        )
        .default(false)
    })
    .strict()
  export type PrivateVulnerabilityReportCreate = z.infer<
    typeof PrivateVulnerabilityReportCreateSchema
  >

  export const StargazerSchema = z
    .object({
      starred_at: z.string().datetime({ offset: true }),
      user: NullableSimpleUserSchema
    })
    .describe('Stargazer')
  export type Stargazer = z.infer<typeof StargazerSchema>

  export const ContributorActivitySchema = z
    .object({
      author: NullableSimpleUserSchema,
      total: z.number().int(),
      weeks: z.array(
        z.object({
          w: z.number().int().optional(),
          a: z.number().int().optional(),
          d: z.number().int().optional(),
          c: z.number().int().optional()
        })
      )
    })
    .describe('Contributor Activity')
  export type ContributorActivity = z.infer<typeof ContributorActivitySchema>

  export const CloneTrafficSchema = z
    .object({
      count: z.number().int(),
      uniques: z.number().int(),
      clones: z.array(TrafficSchema)
    })
    .describe('Clone Traffic')
  export type CloneTraffic = z.infer<typeof CloneTrafficSchema>

  export const ViewTrafficSchema = z
    .object({
      count: z.number().int(),
      uniques: z.number().int(),
      views: z.array(TrafficSchema)
    })
    .describe('View Traffic')
  export type ViewTraffic = z.infer<typeof ViewTrafficSchema>

  export const LabelSearchResultItemSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      name: z.string(),
      color: z.string(),
      default: z.boolean(),
      description: z.string(),
      score: z.number(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Label Search Result Item')
  export type LabelSearchResultItem = z.infer<
    typeof LabelSearchResultItemSchema
  >

  export const TopicSearchResultItemSchema = z
    .object({
      name: z.string(),
      display_name: z.string(),
      short_description: z.string(),
      description: z.string(),
      created_by: z.string(),
      released: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      featured: z.boolean(),
      curated: z.boolean(),
      score: z.number(),
      repository_count: z.number().int().optional(),
      logo_url: z.string().url().optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      related: z
        .array(
          z.object({
            topic_relation: z
              .object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                topic_id: z.number().int().optional(),
                relation_type: z.string().optional()
              })
              .optional()
          })
        )
        .optional(),
      aliases: z
        .array(
          z.object({
            topic_relation: z
              .object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                topic_id: z.number().int().optional(),
                relation_type: z.string().optional()
              })
              .optional()
          })
        )
        .optional()
    })
    .describe('Topic Search Result Item')
  export type TopicSearchResultItem = z.infer<
    typeof TopicSearchResultItemSchema
  >

  export const UserSearchResultItemSchema = z
    .object({
      login: z.string(),
      id: z.number().int(),
      node_id: z.string(),
      avatar_url: z.string().url(),
      gravatar_id: z.string(),
      url: z.string().url(),
      html_url: z.string().url(),
      followers_url: z.string().url(),
      subscriptions_url: z.string().url(),
      organizations_url: z.string().url(),
      repos_url: z.string().url(),
      received_events_url: z.string().url(),
      type: z.string(),
      score: z.number(),
      following_url: z.string(),
      gists_url: z.string(),
      starred_url: z.string(),
      events_url: z.string(),
      public_repos: z.number().int().optional(),
      public_gists: z.number().int().optional(),
      followers: z.number().int().optional(),
      following: z.number().int().optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      name: z.string().optional(),
      bio: z.string().optional(),
      email: z.string().email().optional(),
      location: z.string().optional(),
      site_admin: z.boolean(),
      hireable: z.boolean().optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      blog: z.string().optional(),
      company: z.string().optional(),
      suspended_at: z.string().datetime({ offset: true }).optional(),
      user_view_type: z.string().optional()
    })
    .describe('User Search Result Item')
  export type UserSearchResultItem = z.infer<typeof UserSearchResultItemSchema>

  export const IntegrationSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the GitHub app'),
      slug: z.string().describe('The slug name of the GitHub app').optional(),
      node_id: z.string(),
      client_id: z.string().optional(),
      owner: z.union([SimpleUserSchema, EnterpriseSchema]),
      name: z.string().describe('The name of the GitHub app'),
      description: z.string(),
      external_url: z.string().url(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          issues: z.string().optional(),
          checks: z.string().optional(),
          metadata: z.string().optional(),
          contents: z.string().optional(),
          deployments: z.string().optional()
        })
        .catchall(z.string())
        .describe('The set of permissions for the GitHub app'),
      events: z
        .array(z.string())
        .describe('The list of events for the GitHub app'),
      installations_count: z
        .number()
        .int()
        .describe('The number of installations associated with the GitHub app')
        .optional(),
      client_secret: z.string().optional(),
      webhook_secret: z.string().optional(),
      pem: z.string().optional()
    })
    .describe(
      'GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.'
    )
  export type Integration = z.infer<typeof IntegrationSchema>

  export const IntegrationInstallationRequestSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the request installation.'),
      node_id: z.string().optional(),
      account: z.union([SimpleUserSchema, EnterpriseSchema]),
      requester: SimpleUserSchema,
      created_at: z.string().datetime({ offset: true })
    })
    .describe('Request to install an integration on a target')
  export type IntegrationInstallationRequest = z.infer<
    typeof IntegrationInstallationRequestSchema
  >

  export const RepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      owner: SimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      has_discussions: z
        .boolean()
        .describe('Whether discussions are enabled.')
        .default(false),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_update_branch: z
        .boolean()
        .describe(
          'Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.'
        )
        .default(false),
      use_squash_pr_title_as_default: z
        .boolean()
        .describe(
          'Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.'
        )
        .default(false),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .optional(),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional(),
      starred_at: z.string().optional(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is enabled for this repository')
        .optional()
    })
    .describe('A repository on GitHub.')
  export type Repository = z.infer<typeof RepositorySchema>

  export const NullableScopedInstallationSchema = z.object({
    permissions: AppPermissionsSchema,
    repository_selection: z
      .enum(['all', 'selected'])
      .describe(
        "Describe whether all repositories have been selected or there's a selection involved"
      ),
    single_file_name: z.string(),
    has_multiple_single_files: z.boolean().optional(),
    single_file_paths: z.array(z.string()).optional(),
    repositories_url: z.string().url(),
    account: SimpleUserSchema
  })
  export type NullableScopedInstallation = z.infer<
    typeof NullableScopedInstallationSchema
  >

  export const CodeSecurityConfigurationRepositoriesSchema = z
    .object({
      status: z
        .enum([
          'attached',
          'attaching',
          'detached',
          'removed',
          'enforced',
          'failed',
          'updating',
          'removed_by_enterprise'
        ])
        .describe(
          'The attachment status of the code security configuration on the repository.'
        )
        .optional(),
      repository: SimpleRepositorySchema.optional()
    })
    .describe(
      'Repositories associated with a code security configuration and attachment status'
    )
  export type CodeSecurityConfigurationRepositories = z.infer<
    typeof CodeSecurityConfigurationRepositoriesSchema
  >

  export const NullableIntegrationSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the GitHub app'),
      slug: z.string().describe('The slug name of the GitHub app').optional(),
      node_id: z.string(),
      client_id: z.string().optional(),
      owner: z.union([SimpleUserSchema, EnterpriseSchema]),
      name: z.string().describe('The name of the GitHub app'),
      description: z.string(),
      external_url: z.string().url(),
      html_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          issues: z.string().optional(),
          checks: z.string().optional(),
          metadata: z.string().optional(),
          contents: z.string().optional(),
          deployments: z.string().optional()
        })
        .catchall(z.string())
        .describe('The set of permissions for the GitHub app'),
      events: z
        .array(z.string())
        .describe('The list of events for the GitHub app'),
      installations_count: z
        .number()
        .int()
        .describe('The number of installations associated with the GitHub app')
        .optional(),
      client_secret: z.string().optional(),
      webhook_secret: z.string().optional(),
      pem: z.string().optional()
    })
    .describe(
      'GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.'
    )
  export type NullableIntegration = z.infer<typeof NullableIntegrationSchema>

  export const BaseGistSchema = z
    .object({
      url: z.string().url(),
      forks_url: z.string().url(),
      commits_url: z.string().url(),
      id: z.string(),
      node_id: z.string(),
      git_pull_url: z.string().url(),
      git_push_url: z.string().url(),
      html_url: z.string().url(),
      files: z.record(
        z.object({
          filename: z.string().optional(),
          type: z.string().optional(),
          language: z.string().optional(),
          raw_url: z.string().optional(),
          size: z.number().int().optional(),
          encoding: z
            .string()
            .describe(
              'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
            )
            .default('utf-8')
        })
      ),
      public: z.boolean(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      description: z.string(),
      comments: z.number().int(),
      comments_enabled: z.boolean().optional(),
      user: NullableSimpleUserSchema,
      comments_url: z.string().url(),
      owner: SimpleUserSchema.optional(),
      truncated: z.boolean().optional(),
      forks: z.array(z.any()).optional(),
      history: z.array(z.any()).optional()
    })
    .describe('Base Gist')
  export type BaseGist = z.infer<typeof BaseGistSchema>

  export const GistCommentSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      body: z.string().max(65_535).describe('The comment text.'),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      author_association: AuthorAssociationSchema
    })
    .describe('A comment made to a gist.')
  export type GistComment = z.infer<typeof GistCommentSchema>

  export const BillingUsageReportOrgSchema = z
    .any()
    .describe('Billing usage report response for an organization')
  export type BillingUsageReportOrg = z.infer<
    typeof BillingUsageReportOrgSchema
  >

  export const ActionsGetDefaultWorkflowPermissionsSchema = z.object({
    default_workflow_permissions: ActionsDefaultWorkflowPermissionsSchema,
    can_approve_pull_request_reviews: ActionsCanApprovePullRequestReviewsSchema
  })
  export type ActionsGetDefaultWorkflowPermissions = z.infer<
    typeof ActionsGetDefaultWorkflowPermissionsSchema
  >

  export const ActionsSetDefaultWorkflowPermissionsSchema = z.object({
    default_workflow_permissions:
      ActionsDefaultWorkflowPermissionsSchema.optional(),
    can_approve_pull_request_reviews:
      ActionsCanApprovePullRequestReviewsSchema.optional()
  })
  export type ActionsSetDefaultWorkflowPermissions = z.infer<
    typeof ActionsSetDefaultWorkflowPermissionsSchema
  >

  export const ActionsRunnerLabelsSchema = z.any().describe('Response')
  export type ActionsRunnerLabels = z.infer<typeof ActionsRunnerLabelsSchema>

  export const ActionsRunnerLabelsReadonlySchema = z.any().describe('Response')
  export type ActionsRunnerLabelsReadonly = z.infer<
    typeof ActionsRunnerLabelsReadonlySchema
  >

  export const InteractionLimitSchema = z
    .object({
      limit: InteractionGroupSchema,
      expiry: InteractionExpirySchema.optional()
    })
    .describe(
      'Limit interactions to a specific type of user for a specified duration'
    )
  export type InteractionLimit = z.infer<typeof InteractionLimitSchema>

  export const OrgMembershipSchema = z
    .object({
      url: z.string().url(),
      state: z
        .enum(['active', 'pending'])
        .describe(
          'The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.'
        ),
      role: z
        .enum(['admin', 'member', 'billing_manager'])
        .describe("The user's membership type in the organization."),
      organization_url: z.string().url(),
      organization: OrganizationSimpleSchema,
      user: NullableSimpleUserSchema,
      permissions: z.object({ can_create_repository: z.boolean() }).optional()
    })
    .describe('Org Membership')
  export type OrgMembership = z.infer<typeof OrgMembershipSchema>

  export const NullableRepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      owner: SimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      has_discussions: z
        .boolean()
        .describe('Whether discussions are enabled.')
        .default(false),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_update_branch: z
        .boolean()
        .describe(
          'Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.'
        )
        .default(false),
      use_squash_pr_title_as_default: z
        .boolean()
        .describe(
          'Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.'
        )
        .default(false),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .optional(),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional(),
      starred_at: z.string().optional(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is enabled for this repository')
        .optional()
    })
    .describe('A repository on GitHub.')
  export type NullableRepository = z.infer<typeof NullableRepositorySchema>

  export const RepositoryAdvisoryCreditSchema = z
    .object({
      user: SimpleUserSchema,
      type: SecurityAdvisoryCreditTypesSchema,
      state: z
        .enum(['accepted', 'declined', 'pending'])
        .describe("The state of the user's acceptance of the credit.")
    })
    .strict()
    .describe('A credit given to a user for a repository security advisory.')
  export type RepositoryAdvisoryCredit = z.infer<
    typeof RepositoryAdvisoryCreditSchema
  >

  export const TeamFullSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the team'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the team'),
      html_url: z.string().url(),
      name: z.string().describe('Name of the team'),
      slug: z.string(),
      description: z.string(),
      privacy: z
        .enum(['closed', 'secret'])
        .describe('The level of privacy this team should have')
        .optional(),
      notification_setting: z
        .enum(['notifications_enabled', 'notifications_disabled'])
        .describe('The notification setting the team has set')
        .optional(),
      permission: z
        .string()
        .describe('Permission that the team will have for its repositories'),
      members_url: z.string(),
      repositories_url: z.string().url(),
      parent: NullableTeamSimpleSchema.optional(),
      members_count: z.number().int(),
      repos_count: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      organization: TeamOrganizationSchema,
      ldap_dn: z
        .string()
        .describe(
          'Distinguished Name (DN) that team maps to within LDAP environment'
        )
        .optional()
    })
    .describe(
      'Groups of organization members that gives permissions on specified repositories.'
    )
  export type TeamFull = z.infer<typeof TeamFullSchema>

  export const TeamDiscussionSchema = z
    .object({
      author: NullableSimpleUserSchema,
      body: z.string().describe('The main text of the discussion.'),
      body_html: z.string(),
      body_version: z
        .string()
        .describe(
          'The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.'
        ),
      comments_count: z.number().int(),
      comments_url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      last_edited_at: z.string().datetime({ offset: true }),
      html_url: z.string().url(),
      node_id: z.string(),
      number: z
        .number()
        .int()
        .describe('The unique sequence number of a team discussion.'),
      pinned: z
        .boolean()
        .describe(
          'Whether or not this discussion should be pinned for easy retrieval.'
        ),
      private: z
        .boolean()
        .describe(
          'Whether or not this discussion should be restricted to team members and organization owners.'
        ),
      team_url: z.string().url(),
      title: z.string().describe('The title of the discussion.'),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe(
      'A team discussion is a persistent record of a free-form conversation within a team.'
    )
  export type TeamDiscussion = z.infer<typeof TeamDiscussionSchema>

  export const TeamDiscussionCommentSchema = z
    .object({
      author: NullableSimpleUserSchema,
      body: z.string().describe('The main text of the comment.'),
      body_html: z.string(),
      body_version: z
        .string()
        .describe(
          'The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.'
        ),
      created_at: z.string().datetime({ offset: true }),
      last_edited_at: z.string().datetime({ offset: true }),
      discussion_url: z.string().url(),
      html_url: z.string().url(),
      node_id: z.string(),
      number: z
        .number()
        .int()
        .describe('The unique sequence number of a team discussion comment.'),
      updated_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('A reply to a discussion within a team.')
  export type TeamDiscussionComment = z.infer<
    typeof TeamDiscussionCommentSchema
  >

  export const TeamRepositorySchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository'),
      node_id: z.string(),
      name: z.string().describe('The name of the repository.'),
      full_name: z.string(),
      license: NullableLicenseSimpleSchema,
      forks: z.number().int(),
      permissions: z
        .object({
          admin: z.boolean(),
          pull: z.boolean(),
          triage: z.boolean().optional(),
          push: z.boolean(),
          maintain: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      owner: NullableSimpleUserSchema,
      private: z
        .boolean()
        .describe('Whether the repository is private or public.')
        .default(false),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z.number().int(),
      default_branch: z
        .string()
        .describe('The default branch of the repository.'),
      open_issues_count: z.number().int(),
      is_template: z
        .boolean()
        .describe(
          'Whether this repository acts as a template that can be used to generate new repositories.'
        )
        .default(false),
      topics: z.array(z.string()).optional(),
      has_issues: z
        .boolean()
        .describe('Whether issues are enabled.')
        .default(true),
      has_projects: z
        .boolean()
        .describe('Whether projects are enabled.')
        .default(true),
      has_wiki: z
        .boolean()
        .describe('Whether the wiki is enabled.')
        .default(true),
      has_pages: z.boolean(),
      has_downloads: z
        .boolean()
        .describe('Whether downloads are enabled.')
        .default(true),
      archived: z
        .boolean()
        .describe('Whether the repository is archived.')
        .default(false),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .default('public'),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      allow_rebase_merge: z
        .boolean()
        .describe('Whether to allow rebase merges for pull requests.')
        .default(true),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z
        .boolean()
        .describe('Whether to allow squash merges for pull requests.')
        .default(true),
      allow_auto_merge: z
        .boolean()
        .describe('Whether to allow Auto-merge to be used on pull requests.')
        .default(false),
      delete_branch_on_merge: z
        .boolean()
        .describe(
          'Whether to delete head branches when pull requests are merged'
        )
        .default(false),
      allow_merge_commit: z
        .boolean()
        .describe('Whether to allow merge commits for pull requests.')
        .default(true),
      allow_forking: z
        .boolean()
        .describe('Whether to allow forking this repo')
        .default(false),
      web_commit_signoff_required: z
        .boolean()
        .describe(
          'Whether to require contributors to sign off on web-based commits'
        )
        .default(false),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      master_branch: z.string().optional()
    })
    .describe("A team's access to a repository.")
  export type TeamRepository = z.infer<typeof TeamRepositorySchema>

  export const ManifestSchema = z
    .object({
      name: z.string().describe('The name of the manifest.'),
      file: z
        .object({
          source_location: z
            .string()
            .describe(
              'The path of the manifest file relative to the root of the Git repository.'
            )
            .optional()
        })
        .strict()
        .optional(),
      metadata: MetadataSchema.optional(),
      resolved: z
        .record(DependencySchema)
        .describe('A collection of resolved package dependencies.')
        .optional()
    })
    .strict()
  export type Manifest = z.infer<typeof ManifestSchema>

  export const TimelineReviewedEventSchema = z
    .object({
      event: z.string(),
      id: z.number().int().describe('Unique identifier of the review'),
      node_id: z.string(),
      user: SimpleUserSchema,
      body: z.string().describe('The text of the review.'),
      state: z.string(),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      _links: z.object({
        html: z.object({ href: z.string() }),
        pull_request: z.object({ href: z.string() })
      }),
      submitted_at: z.string().datetime({ offset: true }).optional(),
      commit_id: z.string().describe('A commit SHA for the review.'),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      author_association: AuthorAssociationSchema
    })
    .describe('Timeline Reviewed Event')
  export type TimelineReviewedEvent = z.infer<
    typeof TimelineReviewedEventSchema
  >

  export const PullRequestReviewSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the review'),
      node_id: z.string(),
      user: NullableSimpleUserSchema,
      body: z.string().describe('The text of the review.'),
      state: z.string(),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      _links: z.object({
        html: z.object({ href: z.string() }),
        pull_request: z.object({ href: z.string() })
      }),
      submitted_at: z.string().datetime({ offset: true }).optional(),
      commit_id: z
        .string()
        .describe(
          'A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.'
        ),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      author_association: AuthorAssociationSchema
    })
    .describe('Pull Request Reviews are reviews on pull requests.')
  export type PullRequestReview = z.infer<typeof PullRequestReviewSchema>

  export const RepositoryAdvisoryCreateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.'),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .optional(),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'A product affected by the vulnerability detailed in a repository security advisory.'
        ),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      credits: z
        .array(
          z
            .object({
              login: z.string().describe('The username of the user credited.'),
              type: SecurityAdvisoryCreditTypesSchema
            })
            .strict()
        )
        .describe(
          'A list of users receiving credit for their participation in the security advisory.'
        )
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      start_private_fork: z
        .boolean()
        .describe(
          'Whether to create a temporary private fork of the repository to collaborate on a fix.'
        )
        .default(false)
    })
    .strict()
  export type RepositoryAdvisoryCreate = z.infer<
    typeof RepositoryAdvisoryCreateSchema
  >

  export const RepositoryAdvisoryUpdateSchema = z
    .object({
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.')
        .optional(),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory impacts.')
        .optional(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .optional(),
      vulnerabilities: z
        .array(
          z
            .object({
              package: z
                .object({
                  ecosystem: SecurityAdvisoryEcosystemsSchema,
                  name: z
                    .string()
                    .describe('The unique package name within its ecosystem.')
                    .optional()
                })
                .describe(
                  'The name of the package affected by the vulnerability.'
                ),
              vulnerable_version_range: z
                .string()
                .describe(
                  'The range of the package versions affected by the vulnerability.'
                )
                .optional(),
              patched_versions: z
                .string()
                .describe(
                  'The package version(s) that resolve the vulnerability.'
                )
                .optional(),
              vulnerable_functions: z
                .array(z.string())
                .describe('The functions in the package that are affected.')
                .optional()
            })
            .strict()
        )
        .describe(
          'A product affected by the vulnerability detailed in a repository security advisory.'
        )
        .optional(),
      cwe_ids: z
        .array(z.string())
        .describe('A list of Common Weakness Enumeration (CWE) IDs.')
        .optional(),
      credits: z
        .array(
          z
            .object({
              login: z.string().describe('The username of the user credited.'),
              type: SecurityAdvisoryCreditTypesSchema
            })
            .strict()
        )
        .describe(
          'A list of users receiving credit for their participation in the security advisory.'
        )
        .optional(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe(
          'The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.'
        )
        .optional(),
      cvss_vector_string: z
        .string()
        .describe(
          'The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.'
        )
        .optional(),
      state: z
        .enum(['published', 'closed', 'draft'])
        .describe('The state of the advisory.')
        .optional(),
      collaborating_users: z
        .array(z.string())
        .describe(
          'A list of usernames who have been granted write access to the advisory.'
        )
        .optional(),
      collaborating_teams: z
        .array(z.string())
        .describe(
          'A list of team slugs which have been granted write access to the advisory.'
        )
        .optional()
    })
    .strict()
  export type RepositoryAdvisoryUpdate = z.infer<
    typeof RepositoryAdvisoryUpdateSchema
  >

  export const UserMarketplacePurchaseSchema = z
    .object({
      billing_cycle: z.string(),
      next_billing_date: z.string().datetime({ offset: true }),
      unit_count: z.number().int(),
      on_free_trial: z.boolean(),
      free_trial_ends_on: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      account: MarketplaceAccountSchema,
      plan: MarketplaceListingPlanSchema
    })
    .describe('User Marketplace Purchase')
  export type UserMarketplacePurchase = z.infer<
    typeof UserMarketplacePurchaseSchema
  >

  export const ClassroomAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      public_repo: z
        .boolean()
        .describe(
          'Whether an accepted assignment creates a public repository.'
        ),
      title: z.string().describe('Assignment title.'),
      type: z
        .enum(['individual', 'group'])
        .describe("Whether it's a group assignment or individual assignment."),
      invite_link: z
        .string()
        .describe('The link that a student can use to accept the assignment.'),
      invitations_enabled: z
        .boolean()
        .describe(
          'Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.'
        ),
      slug: z.string().describe('Sluggified name of the assignment.'),
      students_are_repo_admins: z
        .boolean()
        .describe(
          'Whether students are admins on created repository when a student accepts the assignment.'
        ),
      feedback_pull_requests_enabled: z
        .boolean()
        .describe(
          'Whether feedback pull request will be created when a student accepts the assignment.'
        ),
      max_teams: z
        .number()
        .int()
        .describe('The maximum allowable teams for the assignment.'),
      max_members: z
        .number()
        .int()
        .describe('The maximum allowable members per team.'),
      editor: z.string().describe('The selected editor for the assignment.'),
      accepted: z
        .number()
        .int()
        .describe('The number of students that have accepted the assignment.'),
      submitted: z
        .number()
        .int()
        .describe('The number of students that have submitted the assignment.'),
      passing: z
        .number()
        .int()
        .describe('The number of students that have passed the assignment.'),
      language: z
        .string()
        .describe('The programming language used in the assignment.'),
      deadline: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the assignment is due.'),
      starter_code_repository: SimpleClassroomRepositorySchema,
      classroom: ClassroomSchema
    })
    .describe('A GitHub Classroom assignment')
  export type ClassroomAssignment = z.infer<typeof ClassroomAssignmentSchema>

  export const MinimalRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string().optional(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string().optional(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string().optional(),
      mirror_url: z.string().optional(),
      hooks_url: z.string().url(),
      svn_url: z.string().optional(),
      homepage: z.string().optional(),
      language: z.string().optional(),
      forks_count: z.number().int().optional(),
      stargazers_count: z.number().int().optional(),
      watchers_count: z.number().int().optional(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        )
        .optional(),
      default_branch: z.string().optional(),
      open_issues_count: z.number().int().optional(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean().optional(),
      has_projects: z.boolean().optional(),
      has_wiki: z.boolean().optional(),
      has_pages: z.boolean().optional(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean().optional(),
      disabled: z.boolean().optional(),
      visibility: z.string().optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      permissions: z
        .object({
          admin: z.boolean().optional(),
          maintain: z.boolean().optional(),
          push: z.boolean().optional(),
          triage: z.boolean().optional(),
          pull: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      temp_clone_token: z.string().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      code_of_conduct: CodeOfConductSchema.optional(),
      license: z
        .object({
          key: z.string().optional(),
          name: z.string().optional(),
          spdx_id: z.string().optional(),
          url: z.string().optional(),
          node_id: z.string().optional()
        })
        .optional(),
      forks: z.number().int().optional(),
      open_issues: z.number().int().optional(),
      watchers: z.number().int().optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional()
    })
    .describe('Minimal Repository')
  export type MinimalRepository = z.infer<typeof MinimalRepositorySchema>

  export const ActionsHostedRunnerSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('The unique identifier of the hosted runner.'),
      name: z.string().describe('The name of the hosted runner.'),
      runner_group_id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the group that the hosted runner belongs to.'
        )
        .optional(),
      image_details: NullableActionsHostedRunnerPoolImageSchema,
      machine_size_details: ActionsHostedRunnerMachineSpecSchema,
      status: z
        .enum(['Ready', 'Provisioning', 'Shutdown', 'Deleting', 'Stuck'])
        .describe('The status of the runner.'),
      platform: z.string().describe('The operating system of the image.'),
      maximum_runners: z
        .number()
        .int()
        .describe(
          'The maximum amount of hosted runners. Runners will not scale automatically above this number. Use this setting to limit your cost.'
        )
        .default(10),
      public_ip_enabled: z
        .boolean()
        .describe('Whether public IP is enabled for the hosted runners.'),
      public_ips: z
        .array(PublicIpSchema)
        .describe(
          'The public IP ranges when public IP is enabled for the hosted runners.'
        )
        .optional(),
      last_active_on: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time at which the runner was last used, in ISO 8601 format.'
        )
        .optional()
    })
    .describe('A Github-hosted hosted runner.')
  export type ActionsHostedRunner = z.infer<typeof ActionsHostedRunnerSchema>

  export const ActionsOrganizationPermissionsSchema = z.object({
    enabled_repositories: EnabledRepositoriesSchema,
    selected_repositories_url: z
      .string()
      .describe(
        'The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.'
      )
      .optional(),
    allowed_actions: AllowedActionsSchema.optional(),
    selected_actions_url: SelectedActionsUrlSchema.optional()
  })
  export type ActionsOrganizationPermissions = z.infer<
    typeof ActionsOrganizationPermissionsSchema
  >

  export const ActionsRunnerJitconfigSchema = z.any().describe('Response')
  export type ActionsRunnerJitconfig = z.infer<
    typeof ActionsRunnerJitconfigSchema
  >

  export const AuthenticationTokenSchema = z
    .object({
      token: z.string().describe('The token used for authentication'),
      expires_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time this token expires'),
      permissions: z.record(z.any()).optional(),
      repositories: z
        .array(RepositorySchema)
        .describe('The repositories this token has access to')
        .optional(),
      single_file: z.string().optional(),
      repository_selection: z
        .enum(['all', 'selected'])
        .describe(
          "Describe whether all repositories have been selected or there's a selection involved"
        )
        .optional()
    })
    .describe('Authentication Token')
  export type AuthenticationToken = z.infer<typeof AuthenticationTokenSchema>

  export const CodeScanningAnalysisToolSchema = z.object({
    name: CodeScanningAnalysisToolNameSchema.optional(),
    version: CodeScanningAnalysisToolVersionSchema.optional(),
    guid: CodeScanningAnalysisToolGuidSchema.optional()
  })
  export type CodeScanningAnalysisTool = z.infer<
    typeof CodeScanningAnalysisToolSchema
  >

  export const NullableMinimalRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string().optional(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string().optional(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string().optional(),
      mirror_url: z.string().optional(),
      hooks_url: z.string().url(),
      svn_url: z.string().optional(),
      homepage: z.string().optional(),
      language: z.string().optional(),
      forks_count: z.number().int().optional(),
      stargazers_count: z.number().int().optional(),
      watchers_count: z.number().int().optional(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        )
        .optional(),
      default_branch: z.string().optional(),
      open_issues_count: z.number().int().optional(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean().optional(),
      has_projects: z.boolean().optional(),
      has_wiki: z.boolean().optional(),
      has_pages: z.boolean().optional(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean().optional(),
      disabled: z.boolean().optional(),
      visibility: z.string().optional(),
      pushed_at: z.string().datetime({ offset: true }).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional(),
      permissions: z
        .object({
          admin: z.boolean().optional(),
          maintain: z.boolean().optional(),
          push: z.boolean().optional(),
          triage: z.boolean().optional(),
          pull: z.boolean().optional()
        })
        .optional(),
      role_name: z.string().optional(),
      temp_clone_token: z.string().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      subscribers_count: z.number().int().optional(),
      network_count: z.number().int().optional(),
      code_of_conduct: CodeOfConductSchema.optional(),
      license: z
        .object({
          key: z.string().optional(),
          name: z.string().optional(),
          spdx_id: z.string().optional(),
          url: z.string().optional(),
          node_id: z.string().optional()
        })
        .optional(),
      forks: z.number().int().optional(),
      open_issues: z.number().int().optional(),
      watchers: z.number().int().optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional()
    })
    .describe('Minimal Repository')
  export type NullableMinimalRepository = z.infer<
    typeof NullableMinimalRepositorySchema
  >

  export const ActionsRepositoryPermissionsSchema = z.object({
    enabled: ActionsEnabledSchema,
    allowed_actions: AllowedActionsSchema.optional(),
    selected_actions_url: SelectedActionsUrlSchema.optional()
  })
  export type ActionsRepositoryPermissions = z.infer<
    typeof ActionsRepositoryPermissionsSchema
  >

  export const DeploymentSimpleSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe('Unique identifier of the deployment'),
      node_id: z.string(),
      task: z.string().describe('Parameter to specify a task to execute'),
      original_environment: z.string().optional(),
      environment: z
        .string()
        .describe('Name for the target deployment environment.'),
      description: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      statuses_url: z.string().url(),
      repository_url: z.string().url(),
      transient_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is will no longer exist at some point in the future. Default: false.'
        )
        .optional(),
      production_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is one that end-users directly interact with. Default: false.'
        )
        .optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe(
      'A deployment created as the result of an Actions check run from a workflow that references an environment'
    )
  export type DeploymentSimple = z.infer<typeof DeploymentSimpleSchema>

  export const CodeScanningAutofixSchema = z.object({
    status: CodeScanningAutofixStatusSchema,
    description: CodeScanningAutofixDescriptionSchema,
    started_at: CodeScanningAutofixStartedAtSchema
  })
  export type CodeScanningAutofix = z.infer<typeof CodeScanningAutofixSchema>

  export const CodeScanningVariantAnalysisRepoTaskSchema = z.object({
    repository: SimpleRepositorySchema,
    analysis_status: CodeScanningVariantAnalysisStatusSchema,
    artifact_size_in_bytes: z
      .number()
      .int()
      .describe(
        'The size of the artifact. This is only available for successful analyses.'
      )
      .optional(),
    result_count: z
      .number()
      .int()
      .describe(
        'The number of results in the case of a successful analysis. This is only available for successful analyses.'
      )
      .optional(),
    failure_message: z
      .string()
      .describe(
        'The reason of the failure of this repo task. This is only available if the repository task has failed.'
      )
      .optional(),
    database_commit_sha: z
      .string()
      .describe(
        'The SHA of the commit the CodeQL database was built against. This is only available for successful analyses.'
      )
      .optional(),
    source_location_prefix: z
      .string()
      .describe(
        'The source location prefix to use. This is only available for successful analyses.'
      )
      .optional(),
    artifact_url: z
      .string()
      .describe(
        'The URL of the artifact. This is only available for successful analyses.'
      )
      .optional()
  })
  export type CodeScanningVariantAnalysisRepoTask = z.infer<
    typeof CodeScanningVariantAnalysisRepoTaskSchema
  >

  export const CommitCommentSchema = z
    .object({
      html_url: z.string().url(),
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      body: z.string(),
      path: z.string(),
      position: z.number().int(),
      line: z.number().int(),
      commit_id: z.string(),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Commit Comment')
  export type CommitComment = z.infer<typeof CommitCommentSchema>

  export const CommunityProfileSchema = z
    .object({
      health_percentage: z.number().int(),
      description: z.string(),
      documentation: z.string(),
      files: z.object({
        code_of_conduct: NullableCodeOfConductSimpleSchema,
        code_of_conduct_file: NullableCommunityHealthFileSchema,
        license: NullableLicenseSimpleSchema,
        contributing: NullableCommunityHealthFileSchema,
        readme: NullableCommunityHealthFileSchema,
        issue_template: NullableCommunityHealthFileSchema,
        pull_request_template: NullableCommunityHealthFileSchema
      }),
      updated_at: z.string().datetime({ offset: true }),
      content_reports_enabled: z.boolean().optional()
    })
    .describe('Community Profile')
  export type CommunityProfile = z.infer<typeof CommunityProfileSchema>

  export const SnapshotSchema = z
    .object({
      version: z
        .number()
        .int()
        .describe('The version of the repository snapshot submission.'),
      job: z
        .object({
          id: z.string().describe('The external ID of the job.'),
          correlator: z
            .string()
            .describe(
              'Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository\'s current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you\'re using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you\'re using a build matrix, then you\'ll also need to add additional key(s) to distinguish between each submission inside a matrix variation.'
            ),
          html_url: z.string().describe('The url for the job.').optional()
        })
        .strict(),
      sha: z
        .string()
        .min(40)
        .max(40)
        .describe(
          'The commit SHA associated with this dependency snapshot. Maximum length: 40 characters.'
        ),
      ref: z
        .string()
        .regex(new RegExp('^refs/'))
        .describe('The repository branch that triggered this snapshot.'),
      detector: z
        .object({
          name: z.string().describe('The name of the detector used.'),
          version: z.string().describe('The version of the detector used.'),
          url: z.string().describe('The url of the detector used.')
        })
        .strict()
        .describe('A description of the detector used.'),
      metadata: MetadataSchema.optional(),
      manifests: z
        .record(ManifestSchema)
        .describe(
          'A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.'
        )
        .optional(),
      scanned: z
        .string()
        .datetime({ offset: true })
        .describe('The time at which the snapshot was scanned.')
    })
    .strict()
    .describe("Create a new snapshot of a repository's dependencies.")
  export type Snapshot = z.infer<typeof SnapshotSchema>

  export const LabeledIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      label: z.object({ name: z.string(), color: z.string() })
    })
    .describe('Labeled Issue Event')
  export type LabeledIssueEvent = z.infer<typeof LabeledIssueEventSchema>

  export const UnlabeledIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      label: z.object({ name: z.string(), color: z.string() })
    })
    .describe('Unlabeled Issue Event')
  export type UnlabeledIssueEvent = z.infer<typeof UnlabeledIssueEventSchema>

  export const AssignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: IntegrationSchema,
      assignee: SimpleUserSchema,
      assigner: SimpleUserSchema
    })
    .describe('Assigned Issue Event')
  export type AssignedIssueEvent = z.infer<typeof AssignedIssueEventSchema>

  export const UnassignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema,
      assigner: SimpleUserSchema
    })
    .describe('Unassigned Issue Event')
  export type UnassignedIssueEvent = z.infer<typeof UnassignedIssueEventSchema>

  export const MilestonedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      milestone: z.object({ title: z.string() })
    })
    .describe('Milestoned Issue Event')
  export type MilestonedIssueEvent = z.infer<typeof MilestonedIssueEventSchema>

  export const DemilestonedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      milestone: z.object({ title: z.string() })
    })
    .describe('Demilestoned Issue Event')
  export type DemilestonedIssueEvent = z.infer<
    typeof DemilestonedIssueEventSchema
  >

  export const RenamedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      rename: z.object({ from: z.string(), to: z.string() })
    })
    .describe('Renamed Issue Event')
  export type RenamedIssueEvent = z.infer<typeof RenamedIssueEventSchema>

  export const ReviewDismissedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      dismissed_review: z.object({
        state: z.string(),
        review_id: z.number().int(),
        dismissal_message: z.string(),
        dismissal_commit_id: z.string().optional()
      })
    })
    .describe('Review Dismissed Issue Event')
  export type ReviewDismissedIssueEvent = z.infer<
    typeof ReviewDismissedIssueEventSchema
  >

  export const LockedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      lock_reason: z.string()
    })
    .describe('Locked Issue Event')
  export type LockedIssueEvent = z.infer<typeof LockedIssueEventSchema>

  export const AddedToProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Added to Project Issue Event')
  export type AddedToProjectIssueEvent = z.infer<
    typeof AddedToProjectIssueEventSchema
  >

  export const MovedColumnInProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Moved Column in Project Issue Event')
  export type MovedColumnInProjectIssueEvent = z.infer<
    typeof MovedColumnInProjectIssueEventSchema
  >

  export const RemovedFromProjectIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Removed from Project Issue Event')
  export type RemovedFromProjectIssueEvent = z.infer<
    typeof RemovedFromProjectIssueEventSchema
  >

  export const ConvertedNoteToIssueIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: IntegrationSchema,
      project_card: z
        .object({
          id: z.number().int(),
          url: z.string().url(),
          project_id: z.number().int(),
          project_url: z.string().url(),
          column_name: z.string(),
          previous_column_name: z.string().optional()
        })
        .optional()
    })
    .describe('Converted Note to Issue Issue Event')
  export type ConvertedNoteToIssueIssueEvent = z.infer<
    typeof ConvertedNoteToIssueIssueEventSchema
  >

  export const PullRequestReviewCommentSchema = z
    .object({
      url: z.string().describe('URL for the pull request review comment'),
      pull_request_review_id: z
        .number()
        .int()
        .describe(
          'The ID of the pull request review to which the comment belongs.'
        ),
      id: z
        .number()
        .int()
        .describe('The ID of the pull request review comment.'),
      node_id: z
        .string()
        .describe('The node ID of the pull request review comment.'),
      diff_hunk: z
        .string()
        .describe('The diff of the line that the comment refers to.'),
      path: z
        .string()
        .describe(
          'The relative path of the file to which the comment applies.'
        ),
      position: z
        .number()
        .int()
        .describe(
          'The line index in the diff to which the comment applies. This field is closing down; use `line` instead.'
        )
        .optional(),
      original_position: z
        .number()
        .int()
        .describe(
          'The index of the original line in the diff to which the comment applies. This field is closing down; use `original_line` instead.'
        )
        .optional(),
      commit_id: z
        .string()
        .describe('The SHA of the commit to which the comment applies.'),
      original_commit_id: z
        .string()
        .describe(
          'The SHA of the original commit to which the comment applies.'
        ),
      in_reply_to_id: z
        .number()
        .int()
        .describe('The comment ID to reply to.')
        .optional(),
      user: SimpleUserSchema,
      body: z.string().describe('The text of the comment.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      html_url: z
        .string()
        .url()
        .describe('HTML URL for the pull request review comment.'),
      pull_request_url: z
        .string()
        .url()
        .describe(
          'URL for the pull request that the review comment belongs to.'
        ),
      author_association: AuthorAssociationSchema,
      _links: z.object({
        self: z.object({ href: z.string().url() }),
        html: z.object({ href: z.string().url() }),
        pull_request: z.object({ href: z.string().url() })
      }),
      start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      original_start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      start_side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      original_line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment'
        )
        .default('RIGHT'),
      subject_type: z
        .enum(['line', 'file'])
        .describe(
          'The level at which the comment is targeted, can be a diff line or a file.'
        )
        .optional(),
      reactions: ReactionRollupSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional()
    })
    .describe(
      "Pull Request Review Comments are comments on a portion of the Pull Request's diff."
    )
  export type PullRequestReviewComment = z.infer<
    typeof PullRequestReviewCommentSchema
  >

  export const TimelineAssignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema
    })
    .describe('Timeline Assigned Issue Event')
  export type TimelineAssignedIssueEvent = z.infer<
    typeof TimelineAssignedIssueEventSchema
  >

  export const TimelineUnassignedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      assignee: SimpleUserSchema
    })
    .describe('Timeline Unassigned Issue Event')
  export type TimelineUnassignedIssueEvent = z.infer<
    typeof TimelineUnassignedIssueEventSchema
  >

  export const StateChangeIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      state_reason: z.string().optional()
    })
    .describe('State Change Issue Event')
  export type StateChangeIssueEvent = z.infer<
    typeof StateChangeIssueEventSchema
  >

  export const PullRequestReviewRequestSchema = z
    .object({ users: z.array(SimpleUserSchema), teams: z.array(TeamSchema) })
    .describe('Pull Request Review Request')
  export type PullRequestReviewRequest = z.infer<
    typeof PullRequestReviewRequestSchema
  >

  export const RepoSearchResultItemSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: NullableSimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      pushed_at: z.string().datetime({ offset: true }),
      homepage: z.string().url(),
      size: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      language: z.string(),
      forks_count: z.number().int(),
      open_issues_count: z.number().int(),
      master_branch: z.string().optional(),
      default_branch: z.string(),
      score: z.number(),
      forks_url: z.string().url(),
      keys_url: z.string(),
      collaborators_url: z.string(),
      teams_url: z.string().url(),
      hooks_url: z.string().url(),
      issue_events_url: z.string(),
      events_url: z.string().url(),
      assignees_url: z.string(),
      branches_url: z.string(),
      tags_url: z.string().url(),
      blobs_url: z.string(),
      git_tags_url: z.string(),
      git_refs_url: z.string(),
      trees_url: z.string(),
      statuses_url: z.string(),
      languages_url: z.string().url(),
      stargazers_url: z.string().url(),
      contributors_url: z.string().url(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      commits_url: z.string(),
      git_commits_url: z.string(),
      comments_url: z.string(),
      issue_comment_url: z.string(),
      contents_url: z.string(),
      compare_url: z.string(),
      merges_url: z.string().url(),
      archive_url: z.string(),
      downloads_url: z.string().url(),
      issues_url: z.string(),
      pulls_url: z.string(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      labels_url: z.string(),
      releases_url: z.string(),
      deployments_url: z.string().url(),
      git_url: z.string(),
      ssh_url: z.string(),
      clone_url: z.string(),
      svn_url: z.string().url(),
      forks: z.number().int(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      topics: z.array(z.string()).optional(),
      mirror_url: z.string().url(),
      has_issues: z.boolean(),
      has_projects: z.boolean(),
      has_pages: z.boolean(),
      has_wiki: z.boolean(),
      has_downloads: z.boolean(),
      has_discussions: z.boolean().optional(),
      archived: z.boolean(),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .optional(),
      license: NullableLicenseSimpleSchema,
      permissions: z
        .object({
          admin: z.boolean(),
          maintain: z.boolean().optional(),
          push: z.boolean(),
          triage: z.boolean().optional(),
          pull: z.boolean()
        })
        .optional(),
      text_matches: SearchResultTextMatchesSchema.optional(),
      temp_clone_token: z.string().optional(),
      allow_merge_commit: z.boolean().optional(),
      allow_squash_merge: z.boolean().optional(),
      allow_rebase_merge: z.boolean().optional(),
      allow_auto_merge: z.boolean().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      allow_forking: z.boolean().optional(),
      is_template: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional()
    })
    .describe('Repo Search Result Item')
  export type RepoSearchResultItem = z.infer<typeof RepoSearchResultItemSchema>

  export const StarredRepositorySchema = z
    .object({
      starred_at: z.string().datetime({ offset: true }),
      repo: RepositorySchema
    })
    .describe('Starred Repository')
  export type StarredRepository = z.infer<typeof StarredRepositorySchema>

  export const WebhookConfigSchema = z
    .object({
      url: WebhookConfigUrlSchema.optional(),
      content_type: WebhookConfigContentTypeSchema.optional(),
      secret: WebhookConfigSecretSchema.optional(),
      insecure_ssl: WebhookConfigInsecureSslSchema.optional()
    })
    .describe('Configuration object of the webhook')
  export type WebhookConfig = z.infer<typeof WebhookConfigSchema>

  export const InstallationSchema = z
    .object({
      id: z.number().int().describe('The ID of the installation.'),
      account: z.union([SimpleUserSchema, EnterpriseSchema]),
      repository_selection: z
        .enum(['all', 'selected'])
        .describe(
          "Describe whether all repositories have been selected or there's a selection involved"
        ),
      access_tokens_url: z.string().url(),
      repositories_url: z.string().url(),
      html_url: z.string().url(),
      app_id: z.number().int(),
      target_id: z
        .number()
        .int()
        .describe(
          'The ID of the user or organization this token is being scoped to.'
        ),
      target_type: z.string(),
      permissions: AppPermissionsSchema,
      events: z.array(z.string()),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      single_file_name: z.string(),
      has_multiple_single_files: z.boolean().optional(),
      single_file_paths: z.array(z.string()).optional(),
      app_slug: z.string(),
      suspended_by: NullableSimpleUserSchema,
      suspended_at: z.string().datetime({ offset: true }),
      contact_email: z.string().optional()
    })
    .describe('Installation')
  export type Installation = z.infer<typeof InstallationSchema>

  export const InstallationTokenSchema = z
    .object({
      token: z.string(),
      expires_at: z.string(),
      permissions: AppPermissionsSchema.optional(),
      repository_selection: z.enum(['all', 'selected']).optional(),
      repositories: z.array(RepositorySchema).optional(),
      single_file: z.string().optional(),
      has_multiple_single_files: z.boolean().optional(),
      single_file_paths: z.array(z.string()).optional()
    })
    .describe(
      'Authentication token for a GitHub App installed on a user or org.'
    )
  export type InstallationToken = z.infer<typeof InstallationTokenSchema>

  export const AuthorizationSchema = z
    .object({
      id: z.number().int(),
      url: z.string().url(),
      scopes: z
        .array(z.string())
        .describe('A list of scopes that this authorization is in.'),
      token: z.string(),
      token_last_eight: z.string(),
      hashed_token: z.string(),
      app: z.object({
        client_id: z.string(),
        name: z.string(),
        url: z.string().url()
      }),
      note: z.string(),
      note_url: z.string().url(),
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      fingerprint: z.string(),
      user: NullableSimpleUserSchema.optional(),
      installation: NullableScopedInstallationSchema.optional(),
      expires_at: z.string().datetime({ offset: true })
    })
    .describe(
      'The authorization for an OAuth app, GitHub App, or a Personal Access Token.'
    )
  export type Authorization = z.infer<typeof AuthorizationSchema>

  export const ClassroomAcceptedAssignmentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the repository.'),
      submitted: z
        .boolean()
        .describe('Whether an accepted assignment has been submitted.'),
      passing: z.boolean().describe('Whether a submission passed.'),
      commit_count: z.number().int().describe('Count of student commits.'),
      grade: z.string().describe('Most recent grade.'),
      students: z.array(SimpleClassroomUserSchema),
      repository: SimpleClassroomRepositorySchema,
      assignment: SimpleClassroomAssignmentSchema
    })
    .describe('A GitHub Classroom accepted assignment')
  export type ClassroomAcceptedAssignment = z.infer<
    typeof ClassroomAcceptedAssignmentSchema
  >

  export const DependabotAlertSecurityAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe(
          'The unique GitHub Security Advisory ID assigned to the advisory.'
        )
        .readonly(),
      cve_id: z
        .string()
        .describe('The unique CVE ID assigned to the advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short, plain text summary of the advisory.')
        .readonly(),
      description: z
        .string()
        .describe('A long-form Markdown-supported description of the advisory.')
        .readonly(),
      vulnerabilities: z
        .array(DependabotAlertSecurityVulnerabilitySchema)
        .describe('Vulnerable version range information for the advisory.')
        .readonly(),
      severity: z
        .enum(['low', 'medium', 'high', 'critical'])
        .describe('The severity of the advisory.')
        .readonly(),
      cvss: z
        .object({
          score: z
            .number()
            .gte(0)
            .lte(10)
            .describe('The overall CVSS score of the advisory.')
            .readonly(),
          vector_string: z
            .string()
            .describe('The full CVSS vector string for the advisory.')
            .readonly()
        })
        .strict()
        .describe(
          'Details for the advisory pertaining to the Common Vulnerability Scoring System.'
        )
        .readonly(),
      cvss_severities: CvssSeveritiesSchema.optional(),
      epss: SecurityAdvisoryEpssSchema.optional(),
      cwes: z
        .array(
          z
            .object({
              cwe_id: z.string().describe('The unique CWE ID.').readonly(),
              name: z
                .string()
                .describe('The short, plain text name of the CWE.')
                .readonly()
            })
            .strict()
            .describe('A CWE weakness assigned to the advisory.')
            .readonly()
        )
        .describe(
          'Details for the advisory pertaining to Common Weakness Enumeration.'
        )
        .readonly(),
      identifiers: z
        .array(
          z
            .object({
              type: z
                .enum(['CVE', 'GHSA'])
                .describe('The type of advisory identifier.')
                .readonly(),
              value: z
                .string()
                .describe('The value of the advisory identifer.')
                .readonly()
            })
            .strict()
            .describe('An advisory identifier.')
            .readonly()
        )
        .describe(
          'Values that identify this advisory among security information sources.'
        )
        .readonly(),
      references: z
        .array(
          z
            .object({
              url: z
                .string()
                .url()
                .describe('The URL of the reference.')
                .readonly()
            })
            .strict()
            .describe('A link to additional advisory information.')
            .readonly()
        )
        .describe('Links to additional advisory information.')
        .readonly(),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was published in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was last modified in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the advisory was withdrawn in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .readonly()
    })
    .strict()
    .describe('Details for the GitHub Security Advisory.')
    .readonly()
  export type DependabotAlertSecurityAdvisory = z.infer<
    typeof DependabotAlertSecurityAdvisorySchema
  >

  export const GistSimpleSchema = z
    .object({
      forks: z
        .array(
          z.object({
            id: z.string().optional(),
            url: z.string().url().optional(),
            user: PublicUserSchema.optional(),
            created_at: z.string().datetime({ offset: true }).optional(),
            updated_at: z.string().datetime({ offset: true }).optional()
          })
        )
        .optional(),
      history: z.array(GistHistorySchema).optional(),
      fork_of: z
        .object({
          url: z.string().url(),
          forks_url: z.string().url(),
          commits_url: z.string().url(),
          id: z.string(),
          node_id: z.string(),
          git_pull_url: z.string().url(),
          git_push_url: z.string().url(),
          html_url: z.string().url(),
          files: z.record(
            z.object({
              filename: z.string().optional(),
              type: z.string().optional(),
              language: z.string().optional(),
              raw_url: z.string().optional(),
              size: z.number().int().optional()
            })
          ),
          public: z.boolean(),
          created_at: z.string().datetime({ offset: true }),
          updated_at: z.string().datetime({ offset: true }),
          description: z.string(),
          comments: z.number().int(),
          comments_enabled: z.boolean().optional(),
          user: NullableSimpleUserSchema,
          comments_url: z.string().url(),
          owner: NullableSimpleUserSchema.optional(),
          truncated: z.boolean().optional(),
          forks: z.array(z.any()).optional(),
          history: z.array(z.any()).optional()
        })
        .describe('Gist')
        .optional(),
      url: z.string().optional(),
      forks_url: z.string().optional(),
      commits_url: z.string().optional(),
      id: z.string().optional(),
      node_id: z.string().optional(),
      git_pull_url: z.string().optional(),
      git_push_url: z.string().optional(),
      html_url: z.string().optional(),
      files: z
        .record(
          z.object({
            filename: z.string().optional(),
            type: z.string().optional(),
            language: z.string().optional(),
            raw_url: z.string().optional(),
            size: z.number().int().optional(),
            truncated: z.boolean().optional(),
            content: z.string().optional(),
            encoding: z
              .string()
              .describe(
                'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
              )
              .default('utf-8')
          })
        )
        .optional(),
      public: z.boolean().optional(),
      created_at: z.string().optional(),
      updated_at: z.string().optional(),
      description: z.string().optional(),
      comments: z.number().int().optional(),
      comments_enabled: z.boolean().optional(),
      user: z.string().optional(),
      comments_url: z.string().optional(),
      owner: SimpleUserSchema.optional(),
      truncated: z.boolean().optional()
    })
    .describe('Gist Simple')
  export type GistSimple = z.infer<typeof GistSimpleSchema>

  export const ThreadSchema = z
    .object({
      id: z.string(),
      repository: MinimalRepositorySchema,
      subject: z.object({
        title: z.string(),
        url: z.string(),
        latest_comment_url: z.string(),
        type: z.string()
      }),
      reason: z.string(),
      unread: z.boolean(),
      updated_at: z.string(),
      last_read_at: z.string(),
      url: z.string(),
      subscription_url: z.string()
    })
    .describe('Thread')
  export type Thread = z.infer<typeof ThreadSchema>

  export const CopilotUsageMetricsDaySchema = z
    .object({
      date: z
        .string()
        .date()
        .describe(
          'The date for which the usage metrics are aggregated, in `YYYY-MM-DD` format.'
        ),
      total_active_users: z
        .number()
        .int()
        .describe(
          'The total number of Copilot users with activity belonging to any Copilot feature, globally, for the given day. Includes passive activity such as receiving a code suggestion, as well as engagement activity such as accepting a code suggestion or prompting chat. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.'
        )
        .optional(),
      total_engaged_users: z
        .number()
        .int()
        .describe(
          'The total number of Copilot users who engaged with any Copilot feature, for the given day. Examples include but are not limited to accepting a code suggestion, prompting Copilot chat, or triggering a PR Summary. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.'
        )
        .optional(),
      copilot_ide_code_completions: CopilotIdeCodeCompletionsSchema.optional(),
      copilot_ide_chat: CopilotIdeChatSchema.optional(),
      copilot_dotcom_chat: CopilotDotcomChatSchema.optional(),
      copilot_dotcom_pull_requests: CopilotDotcomPullRequestsSchema.optional()
    })
    .catchall(z.any())
    .describe('Copilot usage metrics for a given day.')
  export type CopilotUsageMetricsDay = z.infer<
    typeof CopilotUsageMetricsDaySchema
  >

  export const MigrationSchema = z
    .object({
      id: z.number().int(),
      owner: NullableSimpleUserSchema,
      guid: z.string(),
      state: z.string(),
      lock_repositories: z.boolean(),
      exclude_metadata: z.boolean(),
      exclude_git_data: z.boolean(),
      exclude_attachments: z.boolean(),
      exclude_releases: z.boolean(),
      exclude_owner_projects: z.boolean(),
      org_metadata_only: z.boolean(),
      repositories: z
        .array(RepositorySchema)
        .describe(
          'The repositories included in the migration. Only returned for export migrations.'
        ),
      url: z.string().url(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      node_id: z.string(),
      archive_url: z.string().url().optional(),
      exclude: z
        .array(
          z
            .string()
            .describe(
              'Allowed values that can be passed to the exclude parameter. The array can include any of: `"repositories"`.'
            )
        )
        .describe(
          'Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.'
        )
        .optional()
    })
    .describe('A migration.')
  export type Migration = z.infer<typeof MigrationSchema>

  export const PendingDeploymentSchema = z
    .object({
      environment: z.object({
        id: z.number().int().describe('The id of the environment.').optional(),
        node_id: z.string().optional(),
        name: z.string().describe('The name of the environment.').optional(),
        url: z.string().optional(),
        html_url: z.string().optional()
      }),
      wait_timer: z
        .number()
        .int()
        .describe('The set duration of the wait timer'),
      wait_timer_started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The time that the wait timer began.'),
      current_user_can_approve: z
        .boolean()
        .describe(
          'Whether the currently authenticated user can approve the deployment'
        ),
      reviewers: z
        .array(
          z.object({
            type: DeploymentReviewerTypeSchema.optional(),
            reviewer: z.union([SimpleUserSchema, TeamSchema]).optional()
          })
        )
        .describe(
          'The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
        )
    })
    .describe(
      'Details of a deployment that is waiting for protection rules to pass'
    )
  export type PendingDeployment = z.infer<typeof PendingDeploymentSchema>

  export const DeploymentSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int().describe('Unique identifier of the deployment'),
      node_id: z.string(),
      sha: z.string(),
      ref: z
        .string()
        .describe('The ref to deploy. This can be a branch, tag, or sha.'),
      task: z.string().describe('Parameter to specify a task to execute'),
      payload: z.union([z.record(z.any()), z.string()]),
      original_environment: z.string().optional(),
      environment: z
        .string()
        .describe('Name for the target deployment environment.'),
      description: z.string(),
      creator: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      statuses_url: z.string().url(),
      repository_url: z.string().url(),
      transient_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is will no longer exist at some point in the future. Default: false.'
        )
        .optional(),
      production_environment: z
        .boolean()
        .describe(
          'Specifies if the given environment is one that end-users directly interact with. Default: false.'
        )
        .optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('A request for a specific ref(branch,sha,tag) to be deployed')
  export type Deployment = z.infer<typeof DeploymentSchema>

  export const CheckSuitePreferenceSchema = z
    .object({
      preferences: z.object({
        auto_trigger_checks: z
          .array(z.object({ app_id: z.number().int(), setting: z.boolean() }))
          .optional()
      }),
      repository: MinimalRepositorySchema
    })
    .describe('Check suite configuration preferences for a repository.')
  export type CheckSuitePreference = z.infer<typeof CheckSuitePreferenceSchema>

  export const DeploymentStatusSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      state: z
        .enum([
          'error',
          'failure',
          'inactive',
          'pending',
          'success',
          'queued',
          'in_progress'
        ])
        .describe('The state of the status.'),
      creator: NullableSimpleUserSchema,
      description: z
        .string()
        .max(140)
        .describe('A short description of the status.')
        .default(''),
      environment: z
        .string()
        .describe('The environment of the deployment that the status is for.')
        .default(''),
      target_url: z
        .string()
        .url()
        .describe('Closing down notice: the URL to associate with this status.')
        .default(''),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      deployment_url: z.string().url(),
      repository_url: z.string().url(),
      environment_url: z
        .string()
        .url()
        .describe('The URL for accessing your environment.')
        .default(''),
      log_url: z
        .string()
        .url()
        .describe('The URL to associate with this status.')
        .default(''),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('The status of a deployment.')
  export type DeploymentStatus = z.infer<typeof DeploymentStatusSchema>

  export const TimelineLineCommentedEventSchema = z
    .object({
      event: z.string().optional(),
      node_id: z.string().optional(),
      comments: z.array(PullRequestReviewCommentSchema).optional()
    })
    .describe('Timeline Line Commented Event')
  export type TimelineLineCommentedEvent = z.infer<
    typeof TimelineLineCommentedEventSchema
  >

  export const TimelineCommitCommentedEventSchema = z
    .object({
      event: z.string().optional(),
      node_id: z.string().optional(),
      commit_id: z.string().optional(),
      comments: z.array(CommitCommentSchema).optional()
    })
    .describe('Timeline Commit Commented Event')
  export type TimelineCommitCommentedEvent = z.infer<
    typeof TimelineCommitCommentedEventSchema
  >

  export const ReviewCommentSchema = z
    .object({
      url: z.string().url(),
      pull_request_review_id: z.number().int(),
      id: z.number().int(),
      node_id: z.string(),
      diff_hunk: z.string(),
      path: z.string(),
      position: z.number().int(),
      original_position: z.number().int(),
      commit_id: z.string(),
      original_commit_id: z.string(),
      in_reply_to_id: z.number().int().optional(),
      user: NullableSimpleUserSchema,
      body: z.string(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      html_url: z.string().url(),
      pull_request_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      _links: z.object({
        self: LinkSchema,
        html: LinkSchema,
        pull_request: LinkSchema
      }),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      reactions: ReactionRollupSchema.optional(),
      side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      start_side: z
        .enum(['LEFT', 'RIGHT'])
        .describe(
          'The side of the first line of the range for a multi-line comment.'
        )
        .default('RIGHT'),
      line: z
        .number()
        .int()
        .describe(
          'The line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      original_line: z
        .number()
        .int()
        .describe(
          'The original line of the blob to which the comment applies. The last line of the range for a multi-line comment'
        )
        .optional(),
      start_line: z
        .number()
        .int()
        .describe('The first line of the range for a multi-line comment.')
        .optional(),
      original_start_line: z
        .number()
        .int()
        .describe(
          'The original first line of the range for a multi-line comment.'
        )
        .optional()
    })
    .describe('Legacy Review Comment')
  export type ReviewComment = z.infer<typeof ReviewCommentSchema>

  export const ReleaseSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      assets_url: z.string().url(),
      upload_url: z.string(),
      tarball_url: z.string().url(),
      zipball_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      tag_name: z.string().describe('The name of the tag.'),
      target_commitish: z
        .string()
        .describe(
          'Specifies the commitish value that determines where the Git tag is created from.'
        ),
      name: z.string(),
      body: z.string().optional(),
      draft: z
        .boolean()
        .describe(
          'true to create a draft (unpublished) release, false to create a published one.'
        ),
      prerelease: z
        .boolean()
        .describe(
          'Whether to identify the release as a prerelease or a full release.'
        ),
      created_at: z.string().datetime({ offset: true }),
      published_at: z.string().datetime({ offset: true }),
      author: SimpleUserSchema,
      assets: z.array(ReleaseAssetSchema),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      mentions_count: z.number().int().optional(),
      discussion_url: z
        .string()
        .url()
        .describe('The URL of the release discussion.')
        .optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('A release.')
  export type Release = z.infer<typeof ReleaseSchema>

  export const CodespaceSchema = z
    .object({
      id: z.number().int(),
      name: z
        .string()
        .describe('Automatically generated name of this codespace.'),
      display_name: z
        .string()
        .describe('Display name for this codespace.')
        .optional(),
      environment_id: z
        .string()
        .describe("UUID identifying this codespace's environment."),
      owner: SimpleUserSchema,
      billable_owner: SimpleUserSchema,
      repository: MinimalRepositorySchema,
      machine: NullableCodespaceMachineSchema,
      devcontainer_path: z
        .string()
        .describe(
          'Path to devcontainer.json from repo root used to create Codespace.'
        )
        .optional(),
      prebuild: z
        .boolean()
        .describe('Whether the codespace was created from a prebuild.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      last_used_at: z
        .string()
        .datetime({ offset: true })
        .describe('Last known time this codespace was started.'),
      state: z
        .enum([
          'Unknown',
          'Created',
          'Queued',
          'Provisioning',
          'Available',
          'Awaiting',
          'Unavailable',
          'Deleted',
          'Moved',
          'Shutdown',
          'Archived',
          'Starting',
          'ShuttingDown',
          'Failed',
          'Exporting',
          'Updating',
          'Rebuilding'
        ])
        .describe('State of this codespace.'),
      url: z.string().url().describe('API URL for this codespace.'),
      git_status: z
        .object({
          ahead: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is ahead of the remote.'
            )
            .optional(),
          behind: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is behind the remote.'
            )
            .optional(),
          has_unpushed_changes: z
            .boolean()
            .describe('Whether the local repository has unpushed changes.')
            .optional(),
          has_uncommitted_changes: z
            .boolean()
            .describe('Whether the local repository has uncommitted changes.')
            .optional(),
          ref: z
            .string()
            .describe(
              'The current branch (or SHA if in detached HEAD state) of the local repository.'
            )
            .optional()
        })
        .describe("Details about the codespace's git repository."),
      location: z
        .enum(['EastUs', 'SouthEastAsia', 'WestEurope', 'WestUs2'])
        .describe('The initally assigned location of a new codespace.'),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe(
          'The number of minutes of inactivity after which this codespace will be automatically stopped.'
        ),
      web_url: z
        .string()
        .url()
        .describe('URL to access this codespace on the web.'),
      machines_url: z
        .string()
        .url()
        .describe(
          'API URL to access available alternate machine types for this codespace.'
        ),
      start_url: z.string().url().describe('API URL to start this codespace.'),
      stop_url: z.string().url().describe('API URL to stop this codespace.'),
      publish_url: z
        .string()
        .url()
        .describe('API URL to publish this codespace to a new repository.')
        .optional(),
      pulls_url: z
        .string()
        .url()
        .describe(
          'API URL for the Pull Request associated with this codespace, if any.'
        ),
      recent_folders: z.array(z.string()),
      runtime_constraints: z
        .object({
          allowed_port_privacy_settings: z
            .array(z.string())
            .describe(
              'The privacy settings a user can select from when forwarding a port.'
            )
            .optional()
        })
        .optional(),
      pending_operation: z
        .boolean()
        .describe(
          'Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.'
        )
        .optional(),
      pending_operation_disabled_reason: z
        .string()
        .describe(
          'Text to show user when codespace is disabled by a pending operation'
        )
        .optional(),
      idle_timeout_notice: z
        .string()
        .describe(
          'Text to show user when codespace idle timeout minutes has been overriden by an organization policy'
        )
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      retention_expires_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'When a codespace will be auto-deleted based on the "retention_period_minutes" and "last_used_at"'
        )
        .optional(),
      last_known_stop_notice: z
        .string()
        .describe(
          'The text to display to a user when a codespace has been stopped for a potentially actionable reason.'
        )
        .optional()
    })
    .describe('A codespace.')
  export type Codespace = z.infer<typeof CodespaceSchema>

  export const CopilotSeatDetailsSchema = z
    .object({
      assignee: SimpleUserSchema,
      organization: NullableOrganizationSimpleSchema.optional(),
      assigning_team: z
        .union([TeamSchema, EnterpriseTeamSchema])
        .describe(
          'The team through which the assignee is granted access to GitHub Copilot, if applicable.'
        )
        .optional(),
      pending_cancellation_date: z
        .string()
        .date()
        .describe(
          "The pending cancellation date for the seat, in `YYYY-MM-DD` format. This will be null unless the assignee's Copilot access has been canceled during the current billing cycle. If the seat has been cancelled, this corresponds to the start of the organization's next billing cycle."
        )
        .optional(),
      last_activity_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "Timestamp of user's last GitHub Copilot activity, in ISO 8601 format."
        )
        .optional(),
      last_activity_editor: z
        .string()
        .describe(
          'Last editor that was used by the user for a GitHub Copilot completion.'
        )
        .optional(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Timestamp of when the assignee was last granted access to GitHub Copilot, in ISO 8601 format.'
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "**Closing down notice:** This field is no longer relevant and is closing down. Use the `created_at` field to determine when the assignee was last granted access to GitHub Copilot. Timestamp of when the assignee's GitHub Copilot access was last updated, in ISO 8601 format."
        )
        .optional(),
      plan_type: z
        .enum(['business', 'enterprise', 'unknown'])
        .describe(
          'The Copilot plan of the organization, or the parent enterprise, when applicable.'
        )
        .optional()
    })
    .strict()
    .describe(
      'Information about a Copilot Business seat assignment for a user, team, or organization.'
    )
  export type CopilotSeatDetails = z.infer<typeof CopilotSeatDetailsSchema>

  export const PackageSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the package.'),
      name: z.string().describe('The name of the package.'),
      package_type: z.enum([
        'npm',
        'maven',
        'rubygems',
        'docker',
        'nuget',
        'container'
      ]),
      url: z.string(),
      html_url: z.string(),
      version_count: z
        .number()
        .int()
        .describe('The number of versions of the package.'),
      visibility: z.enum(['private', 'public']),
      owner: NullableSimpleUserSchema.optional(),
      repository: NullableMinimalRepositorySchema.optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true })
    })
    .describe('A software package')
  export type Package = z.infer<typeof PackageSchema>

  export const OrgRulesetConditionsSchema = z
    .record(z.any())
    .and(
      z.union([
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryNameTargetSchema
            )
          )
          .describe(
            'Conditions to target repositories by name and refs by name'
          ),
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryIdTargetSchema
            )
          )
          .describe('Conditions to target repositories by id and refs by name'),
        z
          .record(z.any())
          .and(
            z.intersection(
              RepositoryRulesetConditionsSchema,
              RepositoryRulesetConditionsRepositoryPropertyTargetSchema
            )
          )
          .describe(
            'Conditions to target repositories by property and refs by name'
          )
      ])
    )
    .describe(
      'Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.'
    )
  export type OrgRulesetConditions = z.infer<typeof OrgRulesetConditionsSchema>

  export const ProtectedBranchPullRequestReviewSchema = z
    .object({
      url: z.string().url().optional(),
      dismissal_restrictions: z
        .object({
          users: z
            .array(SimpleUserSchema)
            .describe('The list of users with review dismissal access.')
            .optional(),
          teams: z
            .array(TeamSchema)
            .describe('The list of teams with review dismissal access.')
            .optional(),
          apps: z
            .array(IntegrationSchema)
            .describe('The list of apps with review dismissal access.')
            .optional(),
          url: z.string().optional(),
          users_url: z.string().optional(),
          teams_url: z.string().optional()
        })
        .optional(),
      bypass_pull_request_allowances: z
        .object({
          users: z
            .array(SimpleUserSchema)
            .describe(
              'The list of users allowed to bypass pull request requirements.'
            )
            .optional(),
          teams: z
            .array(TeamSchema)
            .describe(
              'The list of teams allowed to bypass pull request requirements.'
            )
            .optional(),
          apps: z
            .array(IntegrationSchema)
            .describe(
              'The list of apps allowed to bypass pull request requirements.'
            )
            .optional()
        })
        .describe(
          'Allow specific users, teams, or apps to bypass pull request requirements.'
        )
        .optional(),
      dismiss_stale_reviews: z.boolean(),
      require_code_owner_reviews: z.boolean(),
      required_approving_review_count: z
        .number()
        .int()
        .gte(0)
        .lte(6)
        .optional(),
      require_last_push_approval: z
        .boolean()
        .describe(
          'Whether the most recent push must be approved by someone other than the person who pushed it.'
        )
        .default(false)
    })
    .describe('Protected Branch Pull Request Review')
  export type ProtectedBranchPullRequestReview = z.infer<
    typeof ProtectedBranchPullRequestReviewSchema
  >

  export const CommitSchema = z
    .object({
      url: z.string().url(),
      sha: z.string(),
      node_id: z.string(),
      html_url: z.string().url(),
      comments_url: z.string().url(),
      commit: z.object({
        url: z.string().url(),
        author: NullableGitUserSchema,
        committer: NullableGitUserSchema,
        message: z.string(),
        comment_count: z.number().int(),
        tree: z.object({ sha: z.string(), url: z.string().url() }),
        verification: VerificationSchema.optional()
      }),
      author: z.union([SimpleUserSchema, EmptyObjectSchema]),
      committer: z.union([SimpleUserSchema, EmptyObjectSchema]),
      parents: z.array(
        z.object({
          sha: z.string(),
          url: z.string().url(),
          html_url: z.string().url().optional()
        })
      ),
      stats: z
        .object({
          additions: z.number().int().optional(),
          deletions: z.number().int().optional(),
          total: z.number().int().optional()
        })
        .optional(),
      files: z.array(DiffEntrySchema).optional()
    })
    .describe('Commit')
  export type Commit = z.infer<typeof CommitSchema>

  export const CheckRunSchema = z
    .object({
      id: z.number().int().describe('The id of the check.'),
      head_sha: z
        .string()
        .describe('The SHA of the commit that is being checked.'),
      node_id: z.string(),
      external_id: z.string(),
      url: z.string(),
      html_url: z.string(),
      details_url: z.string(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs.'
        ),
      conclusion: z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required'
      ]),
      started_at: z.string().datetime({ offset: true }),
      completed_at: z.string().datetime({ offset: true }),
      output: z.object({
        title: z.string(),
        summary: z.string(),
        text: z.string(),
        annotations_count: z.number().int(),
        annotations_url: z.string().url()
      }),
      name: z.string().describe('The name of the check.'),
      check_suite: z.object({ id: z.number().int() }),
      app: NullableIntegrationSchema,
      pull_requests: z
        .array(PullRequestMinimalSchema)
        .describe(
          'Pull requests that are open with a `head_sha` or `head_branch` that matches the check. The returned pull requests do not necessarily indicate pull requests that triggered the check.'
        ),
      deployment: DeploymentSimpleSchema.optional()
    })
    .describe('A check performed on the code of a given code change')
  export type CheckRun = z.infer<typeof CheckRunSchema>

  export const RepositoryInvitationSchema = z
    .object({
      id: z
        .number()
        .int()
        .describe('Unique identifier of the repository invitation.'),
      repository: MinimalRepositorySchema,
      invitee: NullableSimpleUserSchema,
      inviter: NullableSimpleUserSchema,
      permissions: z
        .enum(['read', 'write', 'admin', 'triage', 'maintain'])
        .describe('The permission associated with the invitation.'),
      created_at: z.string().datetime({ offset: true }),
      expired: z
        .boolean()
        .describe('Whether or not the invitation has expired')
        .optional(),
      url: z.string().describe('URL for the repository invitation'),
      html_url: z.string(),
      node_id: z.string()
    })
    .describe('Repository invitations let you manage who you collaborate with.')
  export type RepositoryInvitation = z.infer<typeof RepositoryInvitationSchema>

  export const CombinedCommitStatusSchema = z
    .object({
      state: z.string(),
      statuses: z.array(SimpleCommitStatusSchema),
      sha: z.string(),
      total_count: z.number().int(),
      repository: MinimalRepositorySchema,
      commit_url: z.string().url(),
      url: z.string().url()
    })
    .describe('Combined Commit Status')
  export type CombinedCommitStatus = z.infer<typeof CombinedCommitStatusSchema>

  export const ReviewRequestedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      review_requester: SimpleUserSchema,
      requested_team: TeamSchema.optional(),
      requested_reviewer: SimpleUserSchema.optional()
    })
    .describe('Review Requested Issue Event')
  export type ReviewRequestedIssueEvent = z.infer<
    typeof ReviewRequestedIssueEventSchema
  >

  export const ReviewRequestRemovedIssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string(),
      actor: SimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string(),
      performed_via_github_app: NullableIntegrationSchema,
      review_requester: SimpleUserSchema,
      requested_team: TeamSchema.optional(),
      requested_reviewer: SimpleUserSchema.optional()
    })
    .describe('Review Request Removed Issue Event')
  export type ReviewRequestRemovedIssueEvent = z.infer<
    typeof ReviewRequestRemovedIssueEventSchema
  >

  export const TimelineCommentEventSchema = z
    .object({
      event: z.string(),
      actor: SimpleUserSchema,
      id: z.number().int().describe('Unique identifier of the issue comment'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue comment'),
      body: z.string().describe('Contents of the issue comment').optional(),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      html_url: z.string().url(),
      user: SimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      issue_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Timeline Comment Event')
  export type TimelineCommentEvent = z.infer<typeof TimelineCommentEventSchema>

  export const CodeSearchResultItemSchema = z
    .object({
      name: z.string(),
      path: z.string(),
      sha: z.string(),
      url: z.string().url(),
      git_url: z.string().url(),
      html_url: z.string().url(),
      repository: MinimalRepositorySchema,
      score: z.number(),
      file_size: z.number().int().optional(),
      language: z.string().optional(),
      last_modified_at: z.string().datetime({ offset: true }).optional(),
      line_numbers: z.array(z.string()).optional(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Code Search Result Item')
  export type CodeSearchResultItem = z.infer<typeof CodeSearchResultItemSchema>

  export const GlobalAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe('The GitHub Security Advisory ID.')
        .readonly(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.')
        .readonly(),
      url: z.string().describe('The API URL for the advisory.').readonly(),
      html_url: z
        .string()
        .url()
        .describe('The URL for the advisory.')
        .readonly(),
      repository_advisory_url: z
        .string()
        .url()
        .describe('The API URL for the repository advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory entails.'),
      type: z
        .enum(['reviewed', 'unreviewed', 'malware'])
        .describe('The type of advisory.')
        .readonly(),
      severity: z
        .enum(['critical', 'high', 'medium', 'low', 'unknown'])
        .describe('The severity of the advisory.'),
      source_code_location: z
        .string()
        .url()
        .describe("The URL of the advisory's source code."),
      identifiers: z
        .array(
          z.object({
            type: z.enum(['CVE', 'GHSA']).describe('The type of identifier.'),
            value: z.string().describe('The identifier value.')
          })
        )
        .readonly(),
      references: z.array(
        z
          .string()
          .describe('URLs with more information regarding the advisory.')
      ),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was published, in ISO 8601 format.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was last updated, in ISO 8601 format.'
        )
        .readonly(),
      github_reviewed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was reviewed by GitHub, in ISO 8601 format.'
        )
        .readonly(),
      nvd_published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time when the advisory was published in the National Vulnerability Database, in ISO 8601 format.\nThis field is only populated when the advisory is imported from the National Vulnerability Database.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was withdrawn, in ISO 8601 format.'
        )
        .readonly(),
      vulnerabilities: z
        .array(VulnerabilitySchema)
        .describe(
          'The products and respective version ranges affected by the advisory.'
        ),
      cvss: z.object({
        vector_string: z.string().describe('The CVSS vector.'),
        score: z.number().gte(0).lte(10).describe('The CVSS score.').readonly()
      }),
      cvss_severities: CvssSeveritiesSchema.optional(),
      epss: SecurityAdvisoryEpssSchema.optional(),
      cwes: z.array(
        z.object({
          cwe_id: z
            .string()
            .describe('The Common Weakness Enumeration (CWE) identifier.'),
          name: z.string().describe('The name of the CWE.').readonly()
        })
      ),
      credits: z
        .array(
          z.object({
            user: SimpleUserSchema,
            type: SecurityAdvisoryCreditTypesSchema
          })
        )
        .describe('The users who contributed to the advisory.')
        .readonly()
    })
    .strict()
    .describe('A GitHub Security Advisory.')
  export type GlobalAdvisory = z.infer<typeof GlobalAdvisorySchema>

  export const IssueCommentSchema = z
    .object({
      id: z.number().int().describe('Unique identifier of the issue comment'),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue comment'),
      body: z.string().describe('Contents of the issue comment').optional(),
      body_text: z.string().optional(),
      body_html: z.string().optional(),
      html_url: z.string().url(),
      user: NullableSimpleUserSchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      issue_url: z.string().url(),
      author_association: AuthorAssociationSchema,
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Comments provide a way for people to collaborate on an issue.')
  export type IssueComment = z.infer<typeof IssueCommentSchema>

  export const CodeScanningVariantAnalysisSchema = z
    .object({
      id: z.number().int().describe('The ID of the variant analysis.'),
      controller_repo: SimpleRepositorySchema,
      actor: SimpleUserSchema,
      query_language: CodeScanningVariantAnalysisLanguageSchema,
      query_pack_url: z
        .string()
        .describe('The download url for the query pack.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        )
        .optional(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          "The date and time at which the variant analysis was completed, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ. Will be null if the variant analysis has not yet completed or this information is not available."
        )
        .optional(),
      status: z.enum(['in_progress', 'succeeded', 'failed', 'cancelled']),
      actions_workflow_run_id: z
        .number()
        .int()
        .describe(
          'The GitHub Actions workflow run used to execute this variant analysis. This is only available if the workflow run has started.'
        )
        .optional(),
      failure_reason: z
        .enum([
          'no_repos_queried',
          'actions_workflow_run_failed',
          'internal_error'
        ])
        .describe(
          'The reason for a failure of the variant analysis. This is only available if the variant analysis has failed.'
        )
        .optional(),
      scanned_repositories: z
        .array(
          z.object({
            repository: CodeScanningVariantAnalysisRepositorySchema,
            analysis_status: CodeScanningVariantAnalysisStatusSchema,
            result_count: z
              .number()
              .int()
              .describe(
                'The number of results in the case of a successful analysis. This is only available for successful analyses.'
              )
              .optional(),
            artifact_size_in_bytes: z
              .number()
              .int()
              .describe(
                'The size of the artifact. This is only available for successful analyses.'
              )
              .optional(),
            failure_message: z
              .string()
              .describe(
                'The reason of the failure of this repo task. This is only available if the repository task has failed.'
              )
              .optional()
          })
        )
        .optional(),
      skipped_repositories: z
        .object({
          access_mismatch_repos:
            CodeScanningVariantAnalysisSkippedRepoGroupSchema,
          not_found_repos: z.object({
            repository_count: z
              .number()
              .int()
              .describe(
                'The total number of repositories that were skipped for this reason.'
              ),
            repository_full_names: z
              .array(z.string())
              .describe(
                'A list of full repository names that were skipped. This list may not include all repositories that were skipped.'
              )
          }),
          no_codeql_db_repos: CodeScanningVariantAnalysisSkippedRepoGroupSchema,
          over_limit_repos: CodeScanningVariantAnalysisSkippedRepoGroupSchema
        })
        .describe(
          'Information about repositories that were skipped from processing. This information is only available to the user that initiated the variant analysis.'
        )
        .optional()
    })
    .describe('A run of a CodeQL query against one or more repositories.')
  export type CodeScanningVariantAnalysis = z.infer<
    typeof CodeScanningVariantAnalysisSchema
  >

  export const CommitComparisonSchema = z
    .object({
      url: z.string().url(),
      html_url: z.string().url(),
      permalink_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      base_commit: CommitSchema,
      merge_base_commit: CommitSchema,
      status: z.enum(['diverged', 'ahead', 'behind', 'identical']),
      ahead_by: z.number().int(),
      behind_by: z.number().int(),
      total_commits: z.number().int(),
      commits: z.array(CommitSchema),
      files: z.array(DiffEntrySchema).optional()
    })
    .describe('Commit Comparison')
  export type CommitComparison = z.infer<typeof CommitComparisonSchema>

  export const EnvironmentSchema = z
    .object({
      id: z.number().int().describe('The id of the environment.'),
      node_id: z.string(),
      name: z.string().describe('The name of the environment.'),
      url: z.string(),
      html_url: z.string(),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the environment was created, in ISO 8601 format.'
        ),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the environment was last updated, in ISO 8601 format.'
        ),
      protection_rules: z
        .array(
          z.union([
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              type: z.string(),
              wait_timer: WaitTimerSchema.optional()
            }),
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              prevent_self_review: z
                .boolean()
                .describe(
                  'Whether deployments to this environment can be approved by the user who created the deployment.'
                )
                .optional(),
              type: z.string(),
              reviewers: z
                .array(
                  z.object({
                    type: DeploymentReviewerTypeSchema.optional(),
                    reviewer: z.union([SimpleUserSchema, TeamSchema]).optional()
                  })
                )
                .describe(
                  'The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
                )
                .optional()
            }),
            z.object({
              id: z.number().int(),
              node_id: z.string(),
              type: z.string()
            })
          ])
        )
        .describe('Built-in deployment protection rules for the environment.')
        .optional(),
      deployment_branch_policy: DeploymentBranchPolicySettingsSchema.optional()
    })
    .describe('Details of a deployment environment')
  export type Environment = z.infer<typeof EnvironmentSchema>

  export const HookSchema = z
    .object({
      type: z.string(),
      id: z.number().int().describe('Unique identifier of the webhook.'),
      name: z
        .string()
        .describe("The name of a valid service, use 'web' for a webhook."),
      active: z
        .boolean()
        .describe(
          'Determines whether the hook is actually triggered on pushes.'
        ),
      events: z
        .array(z.string())
        .describe(
          "Determines what events the hook is triggered for. Default: ['push']."
        ),
      config: WebhookConfigSchema,
      updated_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      url: z.string().url(),
      test_url: z.string().url(),
      ping_url: z.string().url(),
      deliveries_url: z.string().url().optional(),
      last_response: HookResponseSchema
    })
    .describe('Webhooks for repositories.')
  export type Hook = z.infer<typeof HookSchema>

  export const CodeScanningAlertInstanceSchema = z.object({
    ref: CodeScanningRefSchema.optional(),
    analysis_key: CodeScanningAnalysisAnalysisKeySchema.optional(),
    environment: CodeScanningAlertEnvironmentSchema.optional(),
    category: CodeScanningAnalysisCategorySchema.optional(),
    state: CodeScanningAlertStateSchema.optional(),
    commit_sha: z.string().optional(),
    message: z.object({ text: z.string().optional() }).optional(),
    location: CodeScanningAlertLocationSchema.optional(),
    html_url: z.string().optional(),
    classifications: z
      .array(CodeScanningAlertClassificationSchema)
      .describe(
        'Classifications that have been applied to the file that triggered the alert.\nFor example identifying it as documentation, or a generated file.'
      )
      .optional()
  })
  export type CodeScanningAlertInstance = z.infer<
    typeof CodeScanningAlertInstanceSchema
  >

  export const FullRepositorySchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      name: z.string(),
      full_name: z.string(),
      owner: SimpleUserSchema,
      private: z.boolean(),
      html_url: z.string().url(),
      description: z.string(),
      fork: z.boolean(),
      url: z.string().url(),
      archive_url: z.string(),
      assignees_url: z.string(),
      blobs_url: z.string(),
      branches_url: z.string(),
      collaborators_url: z.string(),
      comments_url: z.string(),
      commits_url: z.string(),
      compare_url: z.string(),
      contents_url: z.string(),
      contributors_url: z.string().url(),
      deployments_url: z.string().url(),
      downloads_url: z.string().url(),
      events_url: z.string().url(),
      forks_url: z.string().url(),
      git_commits_url: z.string(),
      git_refs_url: z.string(),
      git_tags_url: z.string(),
      git_url: z.string(),
      issue_comment_url: z.string(),
      issue_events_url: z.string(),
      issues_url: z.string(),
      keys_url: z.string(),
      labels_url: z.string(),
      languages_url: z.string().url(),
      merges_url: z.string().url(),
      milestones_url: z.string(),
      notifications_url: z.string(),
      pulls_url: z.string(),
      releases_url: z.string(),
      ssh_url: z.string(),
      stargazers_url: z.string().url(),
      statuses_url: z.string(),
      subscribers_url: z.string().url(),
      subscription_url: z.string().url(),
      tags_url: z.string().url(),
      teams_url: z.string().url(),
      trees_url: z.string(),
      clone_url: z.string(),
      mirror_url: z.string().url(),
      hooks_url: z.string().url(),
      svn_url: z.string().url(),
      homepage: z.string().url(),
      language: z.string(),
      forks_count: z.number().int(),
      stargazers_count: z.number().int(),
      watchers_count: z.number().int(),
      size: z
        .number()
        .int()
        .describe(
          'The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.'
        ),
      default_branch: z.string(),
      open_issues_count: z.number().int(),
      is_template: z.boolean().optional(),
      topics: z.array(z.string()).optional(),
      has_issues: z.boolean(),
      has_projects: z.boolean(),
      has_wiki: z.boolean(),
      has_pages: z.boolean(),
      has_downloads: z.boolean().optional(),
      has_discussions: z.boolean(),
      archived: z.boolean(),
      disabled: z
        .boolean()
        .describe('Returns whether or not this repository disabled.'),
      visibility: z
        .string()
        .describe('The repository visibility: public, private, or internal.')
        .optional(),
      pushed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      permissions: z
        .object({
          admin: z.boolean(),
          maintain: z.boolean().optional(),
          push: z.boolean(),
          triage: z.boolean().optional(),
          pull: z.boolean()
        })
        .optional(),
      allow_rebase_merge: z.boolean().optional(),
      template_repository: NullableRepositorySchema.optional(),
      temp_clone_token: z.string().optional(),
      allow_squash_merge: z.boolean().optional(),
      allow_auto_merge: z.boolean().optional(),
      delete_branch_on_merge: z.boolean().optional(),
      allow_merge_commit: z.boolean().optional(),
      allow_update_branch: z.boolean().optional(),
      use_squash_pr_title_as_default: z.boolean().optional(),
      squash_merge_commit_title: z
        .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
        .describe(
          "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
        )
        .optional(),
      squash_merge_commit_message: z
        .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
        .describe(
          "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      merge_commit_title: z
        .enum(['PR_TITLE', 'MERGE_MESSAGE'])
        .describe(
          "The default value for a merge commit title.\n\n  - `PR_TITLE` - default to the pull request's title.\n  - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
        )
        .optional(),
      merge_commit_message: z
        .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
        .describe(
          "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
        )
        .optional(),
      allow_forking: z.boolean().optional(),
      web_commit_signoff_required: z.boolean().optional(),
      subscribers_count: z.number().int(),
      network_count: z.number().int(),
      license: NullableLicenseSimpleSchema,
      organization: NullableSimpleUserSchema.optional(),
      parent: RepositorySchema.optional(),
      source: RepositorySchema.optional(),
      forks: z.number().int(),
      master_branch: z.string().optional(),
      open_issues: z.number().int(),
      watchers: z.number().int(),
      anonymous_access_enabled: z
        .boolean()
        .describe('Whether anonymous git access is allowed.')
        .default(true),
      code_of_conduct: CodeOfConductSimpleSchema.optional(),
      security_and_analysis: SecurityAndAnalysisSchema.optional(),
      custom_properties: z
        .record(z.any())
        .describe(
          'The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.'
        )
        .optional()
    })
    .describe('Full Repository')
  export type FullRepository = z.infer<typeof FullRepositorySchema>

  export const WorkflowRunSchema = z
    .object({
      id: z.number().int().describe('The ID of the workflow run.'),
      name: z.string().describe('The name of the workflow run.').optional(),
      node_id: z.string(),
      check_suite_id: z
        .number()
        .int()
        .describe('The ID of the associated check suite.')
        .optional(),
      check_suite_node_id: z
        .string()
        .describe('The node ID of the associated check suite.')
        .optional(),
      head_branch: z.string(),
      head_sha: z
        .string()
        .describe(
          'The SHA of the head commit that points to the version of the workflow being run.'
        ),
      path: z.string().describe('The full path of the workflow'),
      run_number: z
        .number()
        .int()
        .describe('The auto incrementing run number for the workflow run.'),
      run_attempt: z
        .number()
        .int()
        .describe(
          'Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.'
        )
        .optional(),
      referenced_workflows: z.array(ReferencedWorkflowSchema).optional(),
      event: z.string(),
      status: z.string(),
      conclusion: z.string(),
      workflow_id: z.number().int().describe('The ID of the parent workflow.'),
      url: z.string().describe('The URL to the workflow run.'),
      html_url: z.string(),
      pull_requests: z
        .array(PullRequestMinimalSchema)
        .describe(
          'Pull requests that are open with a `head_sha` or `head_branch` that matches the workflow run. The returned pull requests do not necessarily indicate pull requests that triggered the run.'
        ),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      actor: SimpleUserSchema.optional(),
      triggering_actor: SimpleUserSchema.optional(),
      run_started_at: z
        .string()
        .datetime({ offset: true })
        .describe('The start time of the latest run. Resets on re-run.')
        .optional(),
      jobs_url: z
        .string()
        .describe('The URL to the jobs for the workflow run.'),
      logs_url: z
        .string()
        .describe('The URL to download the logs for the workflow run.'),
      check_suite_url: z
        .string()
        .describe('The URL to the associated check suite.'),
      artifacts_url: z
        .string()
        .describe('The URL to the artifacts for the workflow run.'),
      cancel_url: z.string().describe('The URL to cancel the workflow run.'),
      rerun_url: z.string().describe('The URL to rerun the workflow run.'),
      previous_attempt_url: z
        .string()
        .describe(
          'The URL to the previous attempted run of this workflow, if one exists.'
        )
        .optional(),
      workflow_url: z.string().describe('The URL to the workflow.'),
      head_commit: NullableSimpleCommitSchema,
      repository: MinimalRepositorySchema,
      head_repository: MinimalRepositorySchema,
      head_repository_id: z.number().int().optional(),
      display_title: z
        .string()
        .describe(
          'The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.'
        )
    })
    .describe('An invocation of a workflow')
  export type WorkflowRun = z.infer<typeof WorkflowRunSchema>

  export const ProtectedBranchSchema = z
    .object({
      url: z.string().url(),
      required_status_checks: StatusCheckPolicySchema.optional(),
      required_pull_request_reviews: z
        .object({
          url: z.string().url(),
          dismiss_stale_reviews: z.boolean().optional(),
          require_code_owner_reviews: z.boolean().optional(),
          required_approving_review_count: z.number().int().optional(),
          require_last_push_approval: z
            .boolean()
            .describe(
              'Whether the most recent push must be approved by someone other than the person who pushed it.'
            )
            .default(false),
          dismissal_restrictions: z
            .object({
              url: z.string().url(),
              users_url: z.string().url(),
              teams_url: z.string().url(),
              users: z.array(SimpleUserSchema),
              teams: z.array(TeamSchema),
              apps: z.array(IntegrationSchema).optional()
            })
            .optional(),
          bypass_pull_request_allowances: z
            .object({
              users: z.array(SimpleUserSchema),
              teams: z.array(TeamSchema),
              apps: z.array(IntegrationSchema).optional()
            })
            .optional()
        })
        .optional(),
      required_signatures: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .optional(),
      enforce_admins: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .strict()
        .optional(),
      required_linear_history: z
        .object({ enabled: z.boolean() })
        .strict()
        .optional(),
      allow_force_pushes: z
        .object({ enabled: z.boolean() })
        .strict()
        .optional(),
      allow_deletions: z.object({ enabled: z.boolean() }).strict().optional(),
      restrictions: BranchRestrictionPolicySchema.optional(),
      required_conversation_resolution: z
        .object({ enabled: z.boolean().optional() })
        .strict()
        .optional(),
      block_creations: z.object({ enabled: z.boolean() }).strict().optional(),
      lock_branch: z
        .object({ enabled: z.boolean().default(false) })
        .strict()
        .describe(
          'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.'
        )
        .optional(),
      allow_fork_syncing: z
        .object({ enabled: z.boolean().default(false) })
        .strict()
        .describe(
          'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.'
        )
        .optional()
    })
    .describe('Branch protections protect branches')
  export type ProtectedBranch = z.infer<typeof ProtectedBranchSchema>

  export const CheckSuiteSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      head_branch: z.string(),
      head_sha: z
        .string()
        .describe('The SHA of the head commit that is being checked.'),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.'
        ),
      conclusion: z.union([
        z.literal('success'),
        z.literal('failure'),
        z.literal('neutral'),
        z.literal('cancelled'),
        z.literal('skipped'),
        z.literal('timed_out'),
        z.literal('action_required'),
        z.literal('startup_failure'),
        z.literal('stale'),
        z.literal(null)
      ]),
      url: z.string(),
      before: z.string(),
      after: z.string(),
      pull_requests: z.array(PullRequestMinimalSchema),
      app: NullableIntegrationSchema,
      repository: MinimalRepositorySchema,
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      head_commit: SimpleCommitSchema,
      latest_check_runs_count: z.number().int(),
      check_runs_url: z.string(),
      rerequestable: z.boolean().optional(),
      runs_rerequestable: z.boolean().optional()
    })
    .describe('A suite of checks performed on the code of a given code change')
  export type CheckSuite = z.infer<typeof CheckSuiteSchema>

  export const SecretScanningAlertSchema = z.object({
    number: AlertNumberSchema.optional(),
    created_at: AlertCreatedAtSchema.optional(),
    updated_at: NullableAlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema.optional(),
    html_url: AlertHtmlUrlSchema.optional(),
    locations_url: z
      .string()
      .url()
      .describe('The REST API URL of the code locations for this alert.')
      .optional(),
    state: SecretScanningAlertStateSchema.optional(),
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolved_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    resolved_by: NullableSimpleUserSchema.optional(),
    resolution_comment: z
      .string()
      .describe('An optional comment to resolve an alert.')
      .optional(),
    secret_type: z
      .string()
      .describe('The type of secret that secret scanning detected.')
      .optional(),
    secret_type_display_name: z
      .string()
      .describe(
        'User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
      )
      .optional(),
    secret: z.string().describe('The secret that was detected.').optional(),
    push_protection_bypassed: z
      .boolean()
      .describe('Whether push protection was bypassed for the detected secret.')
      .optional(),
    push_protection_bypassed_by: NullableSimpleUserSchema.optional(),
    push_protection_bypassed_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    push_protection_bypass_request_reviewer:
      NullableSimpleUserSchema.optional(),
    push_protection_bypass_request_reviewer_comment: z
      .string()
      .describe('An optional comment when reviewing a push protection bypass.')
      .optional(),
    push_protection_bypass_request_comment: z
      .string()
      .describe('An optional comment when requesting a push protection bypass.')
      .optional(),
    push_protection_bypass_request_html_url: z
      .string()
      .url()
      .describe('The URL to a push protection bypass request.')
      .optional(),
    validity: z
      .enum(['active', 'inactive', 'unknown'])
      .describe('The token status as of the latest validity check.')
      .optional(),
    publicly_leaked: z
      .boolean()
      .describe('Whether the detected secret was publicly leaked.')
      .optional(),
    multi_repo: z
      .boolean()
      .describe(
        'Whether the detected secret was found in multiple repositories under the same organization or enterprise.'
      )
      .optional(),
    is_base64_encoded: z
      .boolean()
      .describe(
        'A boolean value representing whether or not alert is base64 encoded'
      )
      .optional()
  })
  export type SecretScanningAlert = z.infer<typeof SecretScanningAlertSchema>

  export const CommitSearchResultItemSchema = z
    .object({
      url: z.string().url(),
      sha: z.string(),
      html_url: z.string().url(),
      comments_url: z.string().url(),
      commit: z.object({
        author: z.object({
          name: z.string(),
          email: z.string(),
          date: z.string().datetime({ offset: true })
        }),
        committer: NullableGitUserSchema,
        comment_count: z.number().int(),
        message: z.string(),
        tree: z.object({ sha: z.string(), url: z.string().url() }),
        url: z.string().url(),
        verification: VerificationSchema.optional()
      }),
      author: NullableSimpleUserSchema,
      committer: NullableGitUserSchema,
      parents: z.array(
        z.object({
          url: z.string().optional(),
          html_url: z.string().optional(),
          sha: z.string().optional()
        })
      ),
      repository: MinimalRepositorySchema,
      score: z.number(),
      node_id: z.string(),
      text_matches: SearchResultTextMatchesSchema.optional()
    })
    .describe('Commit Search Result Item')
  export type CommitSearchResultItem = z.infer<
    typeof CommitSearchResultItemSchema
  >

  export const RepositoryAdvisorySchema = z
    .object({
      ghsa_id: z
        .string()
        .describe('The GitHub Security Advisory ID.')
        .readonly(),
      cve_id: z
        .string()
        .describe('The Common Vulnerabilities and Exposures (CVE) ID.'),
      url: z
        .string()
        .url()
        .describe('The API URL for the advisory.')
        .readonly(),
      html_url: z
        .string()
        .url()
        .describe('The URL for the advisory.')
        .readonly(),
      summary: z
        .string()
        .max(1024)
        .describe('A short summary of the advisory.'),
      description: z
        .string()
        .max(65_535)
        .describe('A detailed description of what the advisory entails.'),
      severity: z
        .enum(['critical', 'high', 'medium', 'low'])
        .describe('The severity of the advisory.'),
      author: SimpleUserSchema.describe(
        'The author of the advisory.'
      ).readonly(),
      publisher: SimpleUserSchema.describe(
        'The publisher of the advisory.'
      ).readonly(),
      identifiers: z
        .array(
          z.object({
            type: z.enum(['CVE', 'GHSA']).describe('The type of identifier.'),
            value: z.string().describe('The identifier value.')
          })
        )
        .readonly(),
      state: z
        .enum(['published', 'closed', 'withdrawn', 'draft', 'triage'])
        .describe('The state of the advisory.'),
      created_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was created, in ISO 8601 format.'
        )
        .readonly(),
      updated_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was last updated, in ISO 8601 format.'
        )
        .readonly(),
      published_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was published, in ISO 8601 format.'
        )
        .readonly(),
      closed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was closed, in ISO 8601 format.'
        )
        .readonly(),
      withdrawn_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The date and time of when the advisory was withdrawn, in ISO 8601 format.'
        )
        .readonly(),
      submission: z
        .object({
          accepted: z
            .boolean()
            .describe(
              "Whether a private vulnerability report was accepted by the repository's administrators."
            )
            .readonly()
        })
        .readonly(),
      vulnerabilities: z.array(RepositoryAdvisoryVulnerabilitySchema),
      cvss: z.object({
        vector_string: z.string().describe('The CVSS vector.'),
        score: z.number().gte(0).lte(10).describe('The CVSS score.').readonly()
      }),
      cvss_severities: CvssSeveritiesSchema.optional(),
      cwes: z
        .array(
          z.object({
            cwe_id: z
              .string()
              .describe('The Common Weakness Enumeration (CWE) identifier.'),
            name: z.string().describe('The name of the CWE.').readonly()
          })
        )
        .readonly(),
      cwe_ids: z.array(z.string()).describe('A list of only the CWE IDs.'),
      credits: z.array(
        z.object({
          login: z
            .string()
            .describe('The username of the user credited.')
            .optional(),
          type: SecurityAdvisoryCreditTypesSchema.optional()
        })
      ),
      credits_detailed: z.array(RepositoryAdvisoryCreditSchema).readonly(),
      collaborating_users: z
        .array(SimpleUserSchema)
        .describe('A list of users that collaborate on the advisory.'),
      collaborating_teams: z
        .array(TeamSchema)
        .describe('A list of teams that collaborate on the advisory.'),
      private_fork: SimpleRepositorySchema.describe(
        "A temporary private fork of the advisory's repository for collaborating on a fix."
      ).readonly()
    })
    .strict()
    .describe('A repository security advisory.')
  export type RepositoryAdvisory = z.infer<typeof RepositoryAdvisorySchema>

  export const BranchProtectionSchema = z
    .object({
      url: z.string().optional(),
      enabled: z.boolean().optional(),
      required_status_checks:
        ProtectedBranchRequiredStatusCheckSchema.optional(),
      enforce_admins: ProtectedBranchAdminEnforcedSchema.optional(),
      required_pull_request_reviews:
        ProtectedBranchPullRequestReviewSchema.optional(),
      restrictions: BranchRestrictionPolicySchema.optional(),
      required_linear_history: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      allow_force_pushes: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      allow_deletions: z.object({ enabled: z.boolean().optional() }).optional(),
      block_creations: z.object({ enabled: z.boolean().optional() }).optional(),
      required_conversation_resolution: z
        .object({ enabled: z.boolean().optional() })
        .optional(),
      name: z.string().optional(),
      protection_url: z.string().optional(),
      required_signatures: z
        .object({ url: z.string().url(), enabled: z.boolean() })
        .optional(),
      lock_branch: z
        .object({ enabled: z.boolean().default(false) })
        .describe(
          'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.'
        )
        .optional(),
      allow_fork_syncing: z
        .object({ enabled: z.boolean().default(false) })
        .describe(
          'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.'
        )
        .optional()
    })
    .describe('Branch Protection')
  export type BranchProtection = z.infer<typeof BranchProtectionSchema>

  export const PullRequestSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      html_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      issue_url: z.string().url(),
      commits_url: z.string().url(),
      review_comments_url: z.string().url(),
      review_comment_url: z.string(),
      comments_url: z.string().url(),
      statuses_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the pull request within its repository.'
        ),
      state: z
        .enum(['open', 'closed'])
        .describe('State of this Pull Request. Either `open` or `closed`.'),
      locked: z.boolean(),
      title: z.string().describe('The title of the pull request.'),
      user: SimpleUserSchema,
      body: z.string(),
      labels: z.array(
        z.object({
          id: z.number().int(),
          node_id: z.string(),
          url: z.string(),
          name: z.string(),
          description: z.string(),
          color: z.string(),
          default: z.boolean()
        })
      ),
      milestone: NullableMilestoneSchema,
      active_lock_reason: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      merged_at: z.string().datetime({ offset: true }),
      merge_commit_sha: z.string(),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      requested_reviewers: z.array(SimpleUserSchema).optional(),
      requested_teams: z.array(TeamSimpleSchema).optional(),
      head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: SimpleUserSchema
      }),
      base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: SimpleUserSchema
      }),
      _links: z.object({
        comments: LinkSchema,
        commits: LinkSchema,
        statuses: LinkSchema,
        html: LinkSchema,
        issue: LinkSchema,
        review_comments: LinkSchema,
        review_comment: LinkSchema,
        self: LinkSchema
      }),
      author_association: AuthorAssociationSchema,
      auto_merge: AutoMergeSchema,
      draft: z
        .boolean()
        .describe('Indicates whether or not the pull request is a draft.')
        .optional(),
      merged: z.boolean(),
      mergeable: z.boolean(),
      rebaseable: z.boolean().optional(),
      mergeable_state: z.string(),
      merged_by: NullableSimpleUserSchema,
      comments: z.number().int(),
      review_comments: z.number().int(),
      maintainer_can_modify: z
        .boolean()
        .describe('Indicates whether maintainers can modify the pull request.'),
      commits: z.number().int(),
      additions: z.number().int(),
      deletions: z.number().int(),
      changed_files: z.number().int()
    })
    .describe(
      "Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary."
    )
  export type PullRequest = z.infer<typeof PullRequestSchema>

  export const CodespaceWithFullRepositorySchema = z
    .object({
      id: z.number().int(),
      name: z
        .string()
        .describe('Automatically generated name of this codespace.'),
      display_name: z
        .string()
        .describe('Display name for this codespace.')
        .optional(),
      environment_id: z
        .string()
        .describe("UUID identifying this codespace's environment."),
      owner: SimpleUserSchema,
      billable_owner: SimpleUserSchema,
      repository: FullRepositorySchema,
      machine: NullableCodespaceMachineSchema,
      devcontainer_path: z
        .string()
        .describe(
          'Path to devcontainer.json from repo root used to create Codespace.'
        )
        .optional(),
      prebuild: z
        .boolean()
        .describe('Whether the codespace was created from a prebuild.'),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      last_used_at: z
        .string()
        .datetime({ offset: true })
        .describe('Last known time this codespace was started.'),
      state: z
        .enum([
          'Unknown',
          'Created',
          'Queued',
          'Provisioning',
          'Available',
          'Awaiting',
          'Unavailable',
          'Deleted',
          'Moved',
          'Shutdown',
          'Archived',
          'Starting',
          'ShuttingDown',
          'Failed',
          'Exporting',
          'Updating',
          'Rebuilding'
        ])
        .describe('State of this codespace.'),
      url: z.string().url().describe('API URL for this codespace.'),
      git_status: z
        .object({
          ahead: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is ahead of the remote.'
            )
            .optional(),
          behind: z
            .number()
            .int()
            .describe(
              'The number of commits the local repository is behind the remote.'
            )
            .optional(),
          has_unpushed_changes: z
            .boolean()
            .describe('Whether the local repository has unpushed changes.')
            .optional(),
          has_uncommitted_changes: z
            .boolean()
            .describe('Whether the local repository has uncommitted changes.')
            .optional(),
          ref: z
            .string()
            .describe(
              'The current branch (or SHA if in detached HEAD state) of the local repository.'
            )
            .optional()
        })
        .describe("Details about the codespace's git repository."),
      location: z
        .enum(['EastUs', 'SouthEastAsia', 'WestEurope', 'WestUs2'])
        .describe('The initally assigned location of a new codespace.'),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe(
          'The number of minutes of inactivity after which this codespace will be automatically stopped.'
        ),
      web_url: z
        .string()
        .url()
        .describe('URL to access this codespace on the web.'),
      machines_url: z
        .string()
        .url()
        .describe(
          'API URL to access available alternate machine types for this codespace.'
        ),
      start_url: z.string().url().describe('API URL to start this codespace.'),
      stop_url: z.string().url().describe('API URL to stop this codespace.'),
      publish_url: z
        .string()
        .url()
        .describe('API URL to publish this codespace to a new repository.')
        .optional(),
      pulls_url: z
        .string()
        .url()
        .describe(
          'API URL for the Pull Request associated with this codespace, if any.'
        ),
      recent_folders: z.array(z.string()),
      runtime_constraints: z
        .object({
          allowed_port_privacy_settings: z
            .array(z.string())
            .describe(
              'The privacy settings a user can select from when forwarding a port.'
            )
            .optional()
        })
        .optional(),
      pending_operation: z
        .boolean()
        .describe(
          'Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.'
        )
        .optional(),
      pending_operation_disabled_reason: z
        .string()
        .describe(
          'Text to show user when codespace is disabled by a pending operation'
        )
        .optional(),
      idle_timeout_notice: z
        .string()
        .describe(
          'Text to show user when codespace idle timeout minutes has been overriden by an organization policy'
        )
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      retention_expires_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'When a codespace will be auto-deleted based on the "retention_period_minutes" and "last_used_at"'
        )
        .optional()
    })
    .describe('A codespace.')
  export type CodespaceWithFullRepository = z.infer<
    typeof CodespaceWithFullRepositorySchema
  >

  export const OrganizationSecretScanningAlertSchema = z.object({
    number: AlertNumberSchema.optional(),
    created_at: AlertCreatedAtSchema.optional(),
    updated_at: NullableAlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema.optional(),
    html_url: AlertHtmlUrlSchema.optional(),
    locations_url: z
      .string()
      .url()
      .describe('The REST API URL of the code locations for this alert.')
      .optional(),
    state: SecretScanningAlertStateSchema.optional(),
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolved_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    resolved_by: NullableSimpleUserSchema.optional(),
    secret_type: z
      .string()
      .describe('The type of secret that secret scanning detected.')
      .optional(),
    secret_type_display_name: z
      .string()
      .describe(
        'User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
      )
      .optional(),
    secret: z.string().describe('The secret that was detected.').optional(),
    repository: SimpleRepositorySchema.optional(),
    push_protection_bypassed: z
      .boolean()
      .describe('Whether push protection was bypassed for the detected secret.')
      .optional(),
    push_protection_bypassed_by: NullableSimpleUserSchema.optional(),
    push_protection_bypassed_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    push_protection_bypass_request_reviewer:
      NullableSimpleUserSchema.optional(),
    push_protection_bypass_request_reviewer_comment: z
      .string()
      .describe('An optional comment when reviewing a push protection bypass.')
      .optional(),
    push_protection_bypass_request_comment: z
      .string()
      .describe('An optional comment when requesting a push protection bypass.')
      .optional(),
    push_protection_bypass_request_html_url: z
      .string()
      .url()
      .describe('The URL to a push protection bypass request.')
      .optional(),
    resolution_comment: z
      .string()
      .describe(
        'The comment that was optionally added when this alert was closed'
      )
      .optional(),
    validity: z
      .enum(['active', 'inactive', 'unknown'])
      .describe('The token status as of the latest validity check.')
      .optional(),
    publicly_leaked: z
      .boolean()
      .describe('Whether the secret was publicly leaked.')
      .optional(),
    multi_repo: z
      .boolean()
      .describe(
        'Whether the detected secret was found in multiple repositories in the same organization or enterprise.'
      )
      .optional(),
    is_base64_encoded: z
      .boolean()
      .describe(
        'A boolean value representing whether or not alert is base64 encoded'
      )
      .optional()
  })
  export type OrganizationSecretScanningAlert = z.infer<
    typeof OrganizationSecretScanningAlertSchema
  >

  export const ShortBranchSchema = z
    .object({
      name: z.string(),
      commit: z.object({ sha: z.string(), url: z.string().url() }),
      protected: z.boolean(),
      protection: BranchProtectionSchema.optional(),
      protection_url: z.string().url().optional()
    })
    .describe('Short Branch')
  export type ShortBranch = z.infer<typeof ShortBranchSchema>

  export const PullRequestSimpleSchema = z
    .object({
      url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      html_url: z.string().url(),
      diff_url: z.string().url(),
      patch_url: z.string().url(),
      issue_url: z.string().url(),
      commits_url: z.string().url(),
      review_comments_url: z.string().url(),
      review_comment_url: z.string(),
      comments_url: z.string().url(),
      statuses_url: z.string().url(),
      number: z.number().int(),
      state: z.string(),
      locked: z.boolean(),
      title: z.string(),
      user: NullableSimpleUserSchema,
      body: z.string(),
      labels: z.array(
        z.object({
          id: z.number().int(),
          node_id: z.string(),
          url: z.string(),
          name: z.string(),
          description: z.string(),
          color: z.string(),
          default: z.boolean()
        })
      ),
      milestone: NullableMilestoneSchema,
      active_lock_reason: z.string().optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      merged_at: z.string().datetime({ offset: true }),
      merge_commit_sha: z.string(),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      requested_reviewers: z.array(SimpleUserSchema).optional(),
      requested_teams: z.array(TeamSchema).optional(),
      head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: NullableSimpleUserSchema
      }),
      base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: RepositorySchema,
        sha: z.string(),
        user: NullableSimpleUserSchema
      }),
      _links: z.object({
        comments: LinkSchema,
        commits: LinkSchema,
        statuses: LinkSchema,
        html: LinkSchema,
        issue: LinkSchema,
        review_comments: LinkSchema,
        review_comment: LinkSchema,
        self: LinkSchema
      }),
      author_association: AuthorAssociationSchema,
      auto_merge: AutoMergeSchema,
      draft: z
        .boolean()
        .describe('Indicates whether or not the pull request is a draft.')
        .optional()
    })
    .describe('Pull Request Simple')
  export type PullRequestSimple = z.infer<typeof PullRequestSimpleSchema>

  export const IssueSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue'),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the issue within its repository'
        ),
      state: z
        .string()
        .describe("State of the issue; either 'open' or 'closed'"),
      state_reason: z
        .enum(['completed', 'reopened', 'not_planned'])
        .describe('The reason for the current state')
        .optional(),
      title: z.string().describe('Title of the issue'),
      body: z.string().describe('Contents of the issue').optional(),
      user: NullableSimpleUserSchema,
      labels: z
        .array(
          z.union([
            z.string(),
            z.object({
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().url().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
              color: z.string().optional(),
              default: z.boolean().optional()
            })
          ])
        )
        .describe(
          'Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository'
        ),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      milestone: NullableMilestoneSchema,
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      comments: z.number().int(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      closed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      draft: z.boolean().optional(),
      closed_by: NullableSimpleUserSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      repository: RepositorySchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional(),
      sub_issues_summary: SubIssuesSummarySchema.optional()
    })
    .describe(
      'Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.'
    )
  export type Issue = z.infer<typeof IssueSchema>

  export const NullableIssueSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url().describe('URL for the issue'),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      number: z
        .number()
        .int()
        .describe(
          'Number uniquely identifying the issue within its repository'
        ),
      state: z
        .string()
        .describe("State of the issue; either 'open' or 'closed'"),
      state_reason: z
        .enum(['completed', 'reopened', 'not_planned'])
        .describe('The reason for the current state')
        .optional(),
      title: z.string().describe('Title of the issue'),
      body: z.string().describe('Contents of the issue').optional(),
      user: NullableSimpleUserSchema,
      labels: z
        .array(
          z.union([
            z.string(),
            z.object({
              id: z.number().int().optional(),
              node_id: z.string().optional(),
              url: z.string().url().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
              color: z.string().optional(),
              default: z.boolean().optional()
            })
          ])
        )
        .describe(
          'Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository'
        ),
      assignee: NullableSimpleUserSchema,
      assignees: z.array(SimpleUserSchema).optional(),
      milestone: NullableMilestoneSchema,
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      comments: z.number().int(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      closed_at: z.string().datetime({ offset: true }),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      draft: z.boolean().optional(),
      closed_by: NullableSimpleUserSchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      repository: RepositorySchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      author_association: AuthorAssociationSchema,
      reactions: ReactionRollupSchema.optional(),
      sub_issues_summary: SubIssuesSummarySchema.optional()
    })
    .describe(
      'Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.'
    )
  export type NullableIssue = z.infer<typeof NullableIssueSchema>

  export const IssueSearchResultItemSchema = z
    .object({
      url: z.string().url(),
      repository_url: z.string().url(),
      labels_url: z.string(),
      comments_url: z.string().url(),
      events_url: z.string().url(),
      html_url: z.string().url(),
      id: z.number().int(),
      node_id: z.string(),
      number: z.number().int(),
      title: z.string(),
      locked: z.boolean(),
      active_lock_reason: z.string().optional(),
      assignees: z.array(SimpleUserSchema).optional(),
      user: NullableSimpleUserSchema,
      labels: z.array(
        z.object({
          id: z.number().int().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          name: z.string().optional(),
          color: z.string().optional(),
          default: z.boolean().optional(),
          description: z.string().optional()
        })
      ),
      sub_issues_summary: z
        .object({
          total: z.number().int(),
          completed: z.number().int(),
          percent_completed: z.number().int()
        })
        .optional(),
      state: z.string(),
      state_reason: z.string().optional(),
      assignee: NullableSimpleUserSchema,
      milestone: NullableMilestoneSchema,
      comments: z.number().int(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      closed_at: z.string().datetime({ offset: true }),
      text_matches: SearchResultTextMatchesSchema.optional(),
      pull_request: z
        .object({
          merged_at: z.string().datetime({ offset: true }).optional(),
          diff_url: z.string().url(),
          html_url: z.string().url(),
          patch_url: z.string().url(),
          url: z.string().url()
        })
        .optional(),
      body: z.string().optional(),
      score: z.number(),
      author_association: AuthorAssociationSchema,
      draft: z.boolean().optional(),
      repository: RepositorySchema.optional(),
      body_html: z.string().optional(),
      body_text: z.string().optional(),
      timeline_url: z.string().url().optional(),
      type: IssueTypeSchema.optional(),
      performed_via_github_app: NullableIntegrationSchema.optional(),
      reactions: ReactionRollupSchema.optional()
    })
    .describe('Issue Search Result Item')
  export type IssueSearchResultItem = z.infer<
    typeof IssueSearchResultItemSchema
  >

  export const CodeScanningAnalysisSchema = z.object({
    ref: CodeScanningRefSchema,
    commit_sha: CodeScanningAnalysisCommitShaSchema,
    analysis_key: CodeScanningAnalysisAnalysisKeySchema,
    environment: CodeScanningAnalysisEnvironmentSchema,
    category: CodeScanningAnalysisCategorySchema.optional(),
    error: z.string(),
    created_at: CodeScanningAnalysisCreatedAtSchema,
    results_count: z
      .number()
      .int()
      .describe('The total number of results in the analysis.'),
    rules_count: z
      .number()
      .int()
      .describe('The total number of rules used in the analysis.'),
    id: z.number().int().describe('Unique identifier for this analysis.'),
    url: CodeScanningAnalysisUrlSchema,
    sarif_id: CodeScanningAnalysisSarifIdSchema,
    tool: CodeScanningAnalysisToolSchema,
    deletable: z.boolean(),
    warning: z
      .string()
      .describe('Warning generated when processing the analysis')
  })
  export type CodeScanningAnalysis = z.infer<typeof CodeScanningAnalysisSchema>

  export const TimelineCrossReferencedEventSchema = z
    .object({
      event: z.string(),
      actor: SimpleUserSchema.optional(),
      created_at: z.string().datetime({ offset: true }),
      updated_at: z.string().datetime({ offset: true }),
      source: z.object({
        type: z.string().optional(),
        issue: IssueSchema.optional()
      })
    })
    .describe('Timeline Cross Referenced Event')
  export type TimelineCrossReferencedEvent = z.infer<
    typeof TimelineCrossReferencedEventSchema
  >

  export const SecretScanningLocationSchema = z.object({
    type: z
      .enum([
        'commit',
        'wiki_commit',
        'issue_title',
        'issue_body',
        'issue_comment',
        'discussion_title',
        'discussion_body',
        'discussion_comment',
        'pull_request_title',
        'pull_request_body',
        'pull_request_comment',
        'pull_request_review',
        'pull_request_review_comment'
      ])
      .describe(
        'The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.'
      )
      .optional(),
    details: z
      .union([
        SecretScanningLocationCommitSchema,
        SecretScanningLocationWikiCommitSchema,
        SecretScanningLocationIssueTitleSchema,
        SecretScanningLocationIssueBodySchema,
        SecretScanningLocationIssueCommentSchema,
        SecretScanningLocationDiscussionTitleSchema,
        SecretScanningLocationDiscussionBodySchema,
        SecretScanningLocationDiscussionCommentSchema,
        SecretScanningLocationPullRequestTitleSchema,
        SecretScanningLocationPullRequestBodySchema,
        SecretScanningLocationPullRequestCommentSchema,
        SecretScanningLocationPullRequestReviewSchema,
        SecretScanningLocationPullRequestReviewCommentSchema
      ])
      .optional()
  })
  export type SecretScanningLocation = z.infer<
    typeof SecretScanningLocationSchema
  >

  export const DependabotAlertSchema = z
    .object({
      number: AlertNumberSchema,
      state: z
        .enum(['auto_dismissed', 'dismissed', 'fixed', 'open'])
        .describe('The state of the Dependabot alert.')
        .readonly(),
      dependency: z
        .object({
          package: DependabotAlertPackageSchema.optional(),
          manifest_path: z
            .string()
            .describe(
              'The full path to the dependency manifest file, relative to the root of the repository.'
            )
            .readonly()
            .optional(),
          scope: z
            .enum(['development', 'runtime'])
            .describe('The execution scope of the vulnerable dependency.')
            .readonly()
            .optional(),
          relationship: z
            .enum(['unknown', 'direct', 'transitive'])
            .describe(
              'The vulnerable dependency\'s relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be "unknown" for all dependencies in unsupported ecosystems.\n'
            )
            .readonly()
            .optional()
        })
        .describe('Details for the vulnerable dependency.')
        .readonly(),
      security_advisory: DependabotAlertSecurityAdvisorySchema,
      security_vulnerability: DependabotAlertSecurityVulnerabilitySchema,
      url: AlertUrlSchema,
      html_url: AlertHtmlUrlSchema,
      created_at: AlertCreatedAtSchema,
      updated_at: AlertUpdatedAtSchema,
      dismissed_at: AlertDismissedAtSchema,
      dismissed_by: NullableSimpleUserSchema,
      dismissed_reason: z
        .enum([
          'fix_started',
          'inaccurate',
          'no_bandwidth',
          'not_used',
          'tolerable_risk'
        ])
        .describe('The reason that the alert was dismissed.'),
      dismissed_comment: z
        .string()
        .max(280)
        .describe("An optional comment associated with the alert's dismissal."),
      fixed_at: AlertFixedAtSchema,
      auto_dismissed_at: AlertAutoDismissedAtSchema.optional()
    })
    .strict()
    .describe('A Dependabot alert.')
  export type DependabotAlert = z.infer<typeof DependabotAlertSchema>

  export const BranchWithProtectionSchema = z
    .object({
      name: z.string(),
      commit: CommitSchema,
      _links: z.object({ html: z.string(), self: z.string().url() }),
      protected: z.boolean(),
      protection: BranchProtectionSchema,
      protection_url: z.string().url(),
      pattern: z.string().optional(),
      required_approving_review_count: z.number().int().optional()
    })
    .describe('Branch With Protection')
  export type BranchWithProtection = z.infer<typeof BranchWithProtectionSchema>

  export const DependabotAlertWithRepositorySchema = z
    .object({
      number: AlertNumberSchema,
      state: z
        .enum(['auto_dismissed', 'dismissed', 'fixed', 'open'])
        .describe('The state of the Dependabot alert.')
        .readonly(),
      dependency: z
        .object({
          package: DependabotAlertPackageSchema.optional(),
          manifest_path: z
            .string()
            .describe(
              'The full path to the dependency manifest file, relative to the root of the repository.'
            )
            .readonly()
            .optional(),
          scope: z
            .enum(['development', 'runtime'])
            .describe('The execution scope of the vulnerable dependency.')
            .readonly()
            .optional(),
          relationship: z
            .enum(['unknown', 'direct', 'transitive'])
            .describe(
              'The vulnerable dependency\'s relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be "unknown" for all dependencies in unsupported ecosystems.\n'
            )
            .readonly()
            .optional()
        })
        .describe('Details for the vulnerable dependency.')
        .readonly(),
      security_advisory: DependabotAlertSecurityAdvisorySchema,
      security_vulnerability: DependabotAlertSecurityVulnerabilitySchema,
      url: AlertUrlSchema,
      html_url: AlertHtmlUrlSchema,
      created_at: AlertCreatedAtSchema,
      updated_at: AlertUpdatedAtSchema,
      dismissed_at: AlertDismissedAtSchema,
      dismissed_by: NullableSimpleUserSchema,
      dismissed_reason: z
        .enum([
          'fix_started',
          'inaccurate',
          'no_bandwidth',
          'not_used',
          'tolerable_risk'
        ])
        .describe('The reason that the alert was dismissed.'),
      dismissed_comment: z
        .string()
        .max(280)
        .describe("An optional comment associated with the alert's dismissal."),
      fixed_at: AlertFixedAtSchema,
      auto_dismissed_at: AlertAutoDismissedAtSchema.optional(),
      repository: SimpleRepositorySchema
    })
    .strict()
    .describe('A Dependabot alert.')
  export type DependabotAlertWithRepository = z.infer<
    typeof DependabotAlertWithRepositorySchema
  >

  export const IssueEventSchema = z
    .object({
      id: z.number().int(),
      node_id: z.string(),
      url: z.string().url(),
      actor: NullableSimpleUserSchema,
      event: z.string(),
      commit_id: z.string(),
      commit_url: z.string(),
      created_at: z.string().datetime({ offset: true }),
      issue: NullableIssueSchema.optional(),
      label: IssueEventLabelSchema.optional(),
      assignee: NullableSimpleUserSchema.optional(),
      assigner: NullableSimpleUserSchema.optional(),
      review_requester: NullableSimpleUserSchema.optional(),
      requested_reviewer: NullableSimpleUserSchema.optional(),
      requested_team: TeamSchema.optional(),
      dismissed_review: IssueEventDismissedReviewSchema.optional(),
      milestone: IssueEventMilestoneSchema.optional(),
      project_card: IssueEventProjectCardSchema.optional(),
      rename: IssueEventRenameSchema.optional(),
      author_association: AuthorAssociationSchema.optional(),
      lock_reason: z.string().optional(),
      performed_via_github_app: NullableIntegrationSchema.optional()
    })
    .describe('Issue Event')
  export type IssueEvent = z.infer<typeof IssueEventSchema>

  export const IssueEventForIssueSchema = z
    .union([
      LabeledIssueEventSchema,
      UnlabeledIssueEventSchema,
      AssignedIssueEventSchema,
      UnassignedIssueEventSchema,
      MilestonedIssueEventSchema,
      DemilestonedIssueEventSchema,
      RenamedIssueEventSchema,
      ReviewRequestedIssueEventSchema,
      ReviewRequestRemovedIssueEventSchema,
      ReviewDismissedIssueEventSchema,
      LockedIssueEventSchema,
      AddedToProjectIssueEventSchema,
      MovedColumnInProjectIssueEventSchema,
      RemovedFromProjectIssueEventSchema,
      ConvertedNoteToIssueIssueEventSchema
    ])
    .describe('Issue Event for Issue')
  export type IssueEventForIssue = z.infer<typeof IssueEventForIssueSchema>

  export const RepositoryRuleSchema = z
    .record(z.any())
    .and(
      z.union([
        RepositoryRuleCreationSchema,
        RepositoryRuleUpdateSchema,
        RepositoryRuleDeletionSchema,
        RepositoryRuleRequiredLinearHistorySchema,
        RepositoryRuleMergeQueueSchema,
        RepositoryRuleRequiredDeploymentsSchema,
        RepositoryRuleRequiredSignaturesSchema,
        RepositoryRulePullRequestSchema,
        RepositoryRuleRequiredStatusChecksSchema,
        RepositoryRuleNonFastForwardSchema,
        RepositoryRuleCommitMessagePatternSchema,
        RepositoryRuleCommitAuthorEmailPatternSchema,
        RepositoryRuleCommitterEmailPatternSchema,
        RepositoryRuleBranchNamePatternSchema,
        RepositoryRuleTagNamePatternSchema,
        RepositoryRuleFilePathRestrictionSchema,
        RepositoryRuleMaxFilePathLengthSchema,
        RepositoryRuleFileExtensionRestrictionSchema,
        RepositoryRuleMaxFileSizeSchema,
        RepositoryRuleWorkflowsSchema,
        RepositoryRuleCodeScanningSchema
      ])
    )
    .describe('A repository rule.')
  export type RepositoryRule = z.infer<typeof RepositoryRuleSchema>

  export const CodeScanningAlertItemsSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSummarySchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningAlertItems = z.infer<
    typeof CodeScanningAlertItemsSchema
  >

  export const CodeScanningAlertSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningAlert = z.infer<typeof CodeScanningAlertSchema>

  export const RepositoryRuleDetailedSchema = z
    .record(z.any())
    .and(
      z.union([
        z.intersection(
          RepositoryRuleCreationSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleUpdateSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleDeletionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredLinearHistorySchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMergeQueueSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredDeploymentsSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredSignaturesSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRulePullRequestSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleRequiredStatusChecksSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleNonFastForwardSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitMessagePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitAuthorEmailPatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCommitterEmailPatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleBranchNamePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleTagNamePatternSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleFilePathRestrictionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMaxFilePathLengthSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleFileExtensionRestrictionSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleMaxFileSizeSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleWorkflowsSchema,
          RepositoryRuleRulesetInfoSchema
        ),
        z.intersection(
          RepositoryRuleCodeScanningSchema,
          RepositoryRuleRulesetInfoSchema
        )
      ])
    )
    .describe('A repository rule with ruleset details.')
  export type RepositoryRuleDetailed = z.infer<
    typeof RepositoryRuleDetailedSchema
  >

  export const CodeScanningOrganizationAlertItemsSchema = z.object({
    number: AlertNumberSchema,
    created_at: AlertCreatedAtSchema,
    updated_at: AlertUpdatedAtSchema.optional(),
    url: AlertUrlSchema,
    html_url: AlertHtmlUrlSchema,
    instances_url: AlertInstancesUrlSchema,
    state: CodeScanningAlertStateSchema,
    fixed_at: AlertFixedAtSchema.optional(),
    dismissed_by: NullableSimpleUserSchema,
    dismissed_at: AlertDismissedAtSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema,
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    rule: CodeScanningAlertRuleSummarySchema,
    tool: CodeScanningAnalysisToolSchema,
    most_recent_instance: CodeScanningAlertInstanceSchema,
    repository: SimpleRepositorySchema,
    dismissal_approved_by: NullableSimpleUserSchema.optional()
  })
  export type CodeScanningOrganizationAlertItems = z.infer<
    typeof CodeScanningOrganizationAlertItemsSchema
  >

  export const RepositoryRulesetSchema = z
    .object({
      id: z.number().int().describe('The ID of the ruleset'),
      name: z.string().describe('The name of the ruleset'),
      target: z
        .enum(['branch', 'tag', 'push', 'repository'])
        .describe('The target of the ruleset')
        .optional(),
      source_type: z
        .enum(['Repository', 'Organization', 'Enterprise'])
        .describe('The type of the source of the ruleset')
        .optional(),
      source: z.string().describe('The name of the source'),
      enforcement: RepositoryRuleEnforcementSchema,
      bypass_actors: z
        .array(RepositoryRulesetBypassActorSchema)
        .describe('The actors that can bypass the rules in this ruleset')
        .optional(),
      current_user_can_bypass: z
        .enum(['always', 'pull_requests_only', 'never'])
        .describe(
          'The bypass type of the user making the API request for this ruleset. This field is only returned when\nquerying the repository-level endpoint.'
        )
        .optional(),
      node_id: z.string().optional(),
      _links: z
        .object({
          self: z
            .object({
              href: z.string().describe('The URL of the ruleset').optional()
            })
            .optional(),
          html: z
            .object({
              href: z
                .string()
                .describe('The html URL of the ruleset')
                .optional()
            })
            .optional()
        })
        .optional(),
      conditions: z
        .union([RepositoryRulesetConditionsSchema, OrgRulesetConditionsSchema])
        .optional(),
      rules: z.array(RepositoryRuleSchema).optional(),
      created_at: z.string().datetime({ offset: true }).optional(),
      updated_at: z.string().datetime({ offset: true }).optional()
    })
    .describe('A set of rules to apply when specified conditions are met.')
  export type RepositoryRuleset = z.infer<typeof RepositoryRulesetSchema>

  export const TimelineIssueEventsSchema = z
    .record(z.any())
    .and(
      z.union([
        LabeledIssueEventSchema,
        UnlabeledIssueEventSchema,
        MilestonedIssueEventSchema,
        DemilestonedIssueEventSchema,
        RenamedIssueEventSchema,
        ReviewRequestedIssueEventSchema,
        ReviewRequestRemovedIssueEventSchema,
        ReviewDismissedIssueEventSchema,
        LockedIssueEventSchema,
        AddedToProjectIssueEventSchema,
        MovedColumnInProjectIssueEventSchema,
        RemovedFromProjectIssueEventSchema,
        ConvertedNoteToIssueIssueEventSchema,
        TimelineCommentEventSchema,
        TimelineCrossReferencedEventSchema,
        TimelineCommittedEventSchema,
        TimelineReviewedEventSchema,
        TimelineLineCommentedEventSchema,
        TimelineCommitCommentedEventSchema,
        TimelineAssignedIssueEventSchema,
        TimelineUnassignedIssueEventSchema,
        StateChangeIssueEventSchema
      ])
    )
    .describe('Timeline Event')
  export type TimelineIssueEvents = z.infer<typeof TimelineIssueEventsSchema>

  // -----------------------------------------------------------------------------
  // Operation schemas
  // -----------------------------------------------------------------------------

  export const MetaRootParamsSchema = z.object({})
  export type MetaRootParams = z.infer<typeof MetaRootParamsSchema>

  export const MetaRootResponseSchema = RootSchema
  export type MetaRootResponse = z.infer<typeof MetaRootResponseSchema>

  export const SecurityAdvisoriesListGlobalAdvisoriesParamsSchema = z.object({
    ghsa_id: z
      .string()
      .describe(
        'If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.'
      )
      .optional(),
    type: z
      .enum(['reviewed', 'malware', 'unreviewed'])
      .describe(
        'If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.'
      )
      .default('reviewed'),
    cve_id: z
      .string()
      .describe(
        'If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.'
      )
      .optional(),
    ecosystem: z
      .any()
      .describe(
        'If specified, only advisories for these ecosystems will be returned.'
      )
      .optional(),
    severity: z
      .enum(['unknown', 'low', 'medium', 'high', 'critical'])
      .describe(
        'If specified, only advisories with these severities will be returned.'
      )
      .optional(),
    cwes: z
      .union([z.string(), z.array(z.string())])
      .describe(
        'If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.\n\nExample: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`'
      )
      .optional(),
    is_withdrawn: z
      .boolean()
      .describe('Whether to only return advisories that have been withdrawn.')
      .optional(),
    affects: z
      .union([z.string(), z.array(z.string()).max(1000)])
      .describe(
        'If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified.\nIf the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.\n\nExample: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`'
      )
      .optional(),
    published: z
      .string()
      .describe(
        'If specified, only return advisories that were published on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    updated: z
      .string()
      .describe(
        'If specified, only return advisories that were updated on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    modified: z
      .string()
      .describe(
        'If specified, only show advisories that were updated or published on a date or date range.\n\nFor more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'If specified, only return advisories that have an EPSS percentage score that matches the provided value.\nThe EPSS percentage represents the likelihood of a CVE being exploited.'
      )
      .optional(),
    epss_percentile: z
      .string()
      .describe(
        "If specified, only return advisories that have an EPSS percentile score that matches the provided value.\nThe EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs."
      )
      .optional(),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    sort: z
      .enum(['updated', 'published', 'epss_percentage', 'epss_percentile'])
      .describe('The property to sort the results by.')
      .default('published')
  })
  export type SecurityAdvisoriesListGlobalAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListGlobalAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListGlobalAdvisoriesResponseSchema =
    z.array(GlobalAdvisorySchema)
  export type SecurityAdvisoriesListGlobalAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListGlobalAdvisoriesResponseSchema
  >

  export const SecurityAdvisoriesGetGlobalAdvisoryParamsSchema = z.object({
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesGetGlobalAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesGetGlobalAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesGetGlobalAdvisoryResponseSchema =
    GlobalAdvisorySchema
  export type SecurityAdvisoriesGetGlobalAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesGetGlobalAdvisoryResponseSchema
  >

  export const AppsGetAuthenticatedParamsSchema = z.object({})
  export type AppsGetAuthenticatedParams = z.infer<
    typeof AppsGetAuthenticatedParamsSchema
  >

  export const AppsGetAuthenticatedResponseSchema = IntegrationSchema
  export type AppsGetAuthenticatedResponse = z.infer<
    typeof AppsGetAuthenticatedResponseSchema
  >

  export const AppsCreateFromManifestParamsSchema = z.object({
    code: z.string()
  })
  export type AppsCreateFromManifestParams = z.infer<
    typeof AppsCreateFromManifestParamsSchema
  >

  export type AppsCreateFromManifestResponse = undefined

  export const AppsGetWebhookConfigForAppParamsSchema = z.object({})
  export type AppsGetWebhookConfigForAppParams = z.infer<
    typeof AppsGetWebhookConfigForAppParamsSchema
  >

  export const AppsGetWebhookConfigForAppResponseSchema = WebhookConfigSchema
  export type AppsGetWebhookConfigForAppResponse = z.infer<
    typeof AppsGetWebhookConfigForAppResponseSchema
  >

  export const AppsUpdateWebhookConfigForAppParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional()
  })
  export type AppsUpdateWebhookConfigForAppParams = z.infer<
    typeof AppsUpdateWebhookConfigForAppParamsSchema
  >

  export const AppsUpdateWebhookConfigForAppResponseSchema = WebhookConfigSchema
  export type AppsUpdateWebhookConfigForAppResponse = z.infer<
    typeof AppsUpdateWebhookConfigForAppResponseSchema
  >

  export const AppsListWebhookDeliveriesParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type AppsListWebhookDeliveriesParams = z.infer<
    typeof AppsListWebhookDeliveriesParamsSchema
  >

  export const AppsListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type AppsListWebhookDeliveriesResponse = z.infer<
    typeof AppsListWebhookDeliveriesResponseSchema
  >

  export const AppsGetWebhookDeliveryParamsSchema = z.object({
    delivery_id: z.number().int()
  })
  export type AppsGetWebhookDeliveryParams = z.infer<
    typeof AppsGetWebhookDeliveryParamsSchema
  >

  export const AppsGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type AppsGetWebhookDeliveryResponse = z.infer<
    typeof AppsGetWebhookDeliveryResponseSchema
  >

  export const AppsRedeliverWebhookDeliveryParamsSchema = z.object({
    delivery_id: z.number().int()
  })
  export type AppsRedeliverWebhookDeliveryParams = z.infer<
    typeof AppsRedeliverWebhookDeliveryParamsSchema
  >

  export type AppsRedeliverWebhookDeliveryResponse = undefined

  export const AppsListInstallationRequestsForAuthenticatedAppParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListInstallationRequestsForAuthenticatedAppParams = z.infer<
    typeof AppsListInstallationRequestsForAuthenticatedAppParamsSchema
  >

  export const AppsListInstallationRequestsForAuthenticatedAppResponseSchema =
    z.array(IntegrationInstallationRequestSchema)
  export type AppsListInstallationRequestsForAuthenticatedAppResponse = z.infer<
    typeof AppsListInstallationRequestsForAuthenticatedAppResponseSchema
  >

  export const AppsListInstallationsParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    outdated: z.string().optional()
  })
  export type AppsListInstallationsParams = z.infer<
    typeof AppsListInstallationsParamsSchema
  >

  export const AppsListInstallationsResponseSchema = z.array(InstallationSchema)
  export type AppsListInstallationsResponse = z.infer<
    typeof AppsListInstallationsResponseSchema
  >

  export const AppsGetInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsGetInstallationParams = z.infer<
    typeof AppsGetInstallationParamsSchema
  >

  export const AppsGetInstallationResponseSchema = InstallationSchema
  export type AppsGetInstallationResponse = z.infer<
    typeof AppsGetInstallationResponseSchema
  >

  export const AppsDeleteInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsDeleteInstallationParams = z.infer<
    typeof AppsDeleteInstallationParamsSchema
  >

  export type AppsDeleteInstallationResponse = undefined

  export const AppsCreateInstallationAccessTokenParamsSchema = z.object({
    repositories: z
      .array(z.string())
      .describe('List of repository names that the token should have access to')
      .optional(),
    repository_ids: z
      .array(z.number().int())
      .describe('List of repository IDs that the token should have access to')
      .optional(),
    permissions: AppPermissionsSchema.optional(),
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsCreateInstallationAccessTokenParams = z.infer<
    typeof AppsCreateInstallationAccessTokenParamsSchema
  >

  export type AppsCreateInstallationAccessTokenResponse = undefined

  export const AppsSuspendInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsSuspendInstallationParams = z.infer<
    typeof AppsSuspendInstallationParamsSchema
  >

  export type AppsSuspendInstallationResponse = undefined

  export const AppsUnsuspendInstallationParamsSchema = z.object({
    installation_id: z
      .number()
      .int()
      .describe('The unique identifier of the installation.')
  })
  export type AppsUnsuspendInstallationParams = z.infer<
    typeof AppsUnsuspendInstallationParamsSchema
  >

  export type AppsUnsuspendInstallationResponse = undefined

  export const AppsDeleteAuthorizationParamsSchema = z.object({
    access_token: z
      .string()
      .describe(
        'The OAuth access token used to authenticate to the GitHub API.'
      ),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsDeleteAuthorizationParams = z.infer<
    typeof AppsDeleteAuthorizationParamsSchema
  >

  export type AppsDeleteAuthorizationResponse = undefined

  export const AppsCheckTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access_token of the OAuth or GitHub application.'),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsCheckTokenParams = z.infer<typeof AppsCheckTokenParamsSchema>

  export const AppsCheckTokenResponseSchema = AuthorizationSchema
  export type AppsCheckTokenResponse = z.infer<
    typeof AppsCheckTokenResponseSchema
  >

  export const AppsDeleteTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe(
        'The OAuth access token used to authenticate to the GitHub API.'
      ),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsDeleteTokenParams = z.infer<
    typeof AppsDeleteTokenParamsSchema
  >

  export type AppsDeleteTokenResponse = undefined

  export const AppsResetTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access_token of the OAuth or GitHub application.'),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsResetTokenParams = z.infer<typeof AppsResetTokenParamsSchema>

  export const AppsResetTokenResponseSchema = AuthorizationSchema
  export type AppsResetTokenResponse = z.infer<
    typeof AppsResetTokenResponseSchema
  >

  export const AppsScopeTokenParamsSchema = z.object({
    access_token: z
      .string()
      .describe('The access token used to authenticate to the GitHub API.'),
    target: z
      .string()
      .describe(
        'The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified.'
      )
      .optional(),
    target_id: z
      .number()
      .int()
      .describe(
        'The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified.'
      )
      .optional(),
    repositories: z
      .array(z.string())
      .describe(
        'The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.'
      )
      .optional(),
    repository_ids: z
      .array(z.number().int())
      .describe(
        'The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified.'
      )
      .optional(),
    permissions: AppPermissionsSchema.optional(),
    client_id: z.string().describe('The client ID of the GitHub app.')
  })
  export type AppsScopeTokenParams = z.infer<typeof AppsScopeTokenParamsSchema>

  export const AppsScopeTokenResponseSchema = AuthorizationSchema
  export type AppsScopeTokenResponse = z.infer<
    typeof AppsScopeTokenResponseSchema
  >

  export const AppsGetBySlugParamsSchema = z.object({ app_slug: z.string() })
  export type AppsGetBySlugParams = z.infer<typeof AppsGetBySlugParamsSchema>

  export const AppsGetBySlugResponseSchema = IntegrationSchema
  export type AppsGetBySlugResponse = z.infer<
    typeof AppsGetBySlugResponseSchema
  >

  export const ClassroomGetAnAssignmentParamsSchema = z.object({
    assignment_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom assignment.')
  })
  export type ClassroomGetAnAssignmentParams = z.infer<
    typeof ClassroomGetAnAssignmentParamsSchema
  >

  export const ClassroomGetAnAssignmentResponseSchema =
    ClassroomAssignmentSchema
  export type ClassroomGetAnAssignmentResponse = z.infer<
    typeof ClassroomGetAnAssignmentResponseSchema
  >

  export const ClassroomListAcceptedAssignmentsForAnAssignmentParamsSchema =
    z.object({
      assignment_id: z
        .number()
        .int()
        .describe('The unique identifier of the classroom assignment.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    })
  export type ClassroomListAcceptedAssignmentsForAnAssignmentParams = z.infer<
    typeof ClassroomListAcceptedAssignmentsForAnAssignmentParamsSchema
  >

  export const ClassroomListAcceptedAssignmentsForAnAssignmentResponseSchema =
    z.array(ClassroomAcceptedAssignmentSchema)
  export type ClassroomListAcceptedAssignmentsForAnAssignmentResponse = z.infer<
    typeof ClassroomListAcceptedAssignmentsForAnAssignmentResponseSchema
  >

  export const ClassroomGetAssignmentGradesParamsSchema = z.object({
    assignment_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom assignment.')
  })
  export type ClassroomGetAssignmentGradesParams = z.infer<
    typeof ClassroomGetAssignmentGradesParamsSchema
  >

  export const ClassroomGetAssignmentGradesResponseSchema = z.array(
    ClassroomAssignmentGradeSchema
  )
  export type ClassroomGetAssignmentGradesResponse = z.infer<
    typeof ClassroomGetAssignmentGradesResponseSchema
  >

  export const ClassroomListClassroomsParamsSchema = z.object({
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ClassroomListClassroomsParams = z.infer<
    typeof ClassroomListClassroomsParamsSchema
  >

  export const ClassroomListClassroomsResponseSchema = z.array(
    SimpleClassroomSchema
  )
  export type ClassroomListClassroomsResponse = z.infer<
    typeof ClassroomListClassroomsResponseSchema
  >

  export const ClassroomGetAclassroomParamsSchema = z.object({
    classroom_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom.')
  })
  export type ClassroomGetAclassroomParams = z.infer<
    typeof ClassroomGetAclassroomParamsSchema
  >

  export const ClassroomGetAclassroomResponseSchema = ClassroomSchema
  export type ClassroomGetAclassroomResponse = z.infer<
    typeof ClassroomGetAclassroomResponseSchema
  >

  export const ClassroomListAssignmentsForAclassroomParamsSchema = z.object({
    classroom_id: z
      .number()
      .int()
      .describe('The unique identifier of the classroom.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ClassroomListAssignmentsForAclassroomParams = z.infer<
    typeof ClassroomListAssignmentsForAclassroomParamsSchema
  >

  export const ClassroomListAssignmentsForAclassroomResponseSchema = z.array(
    SimpleClassroomAssignmentSchema
  )
  export type ClassroomListAssignmentsForAclassroomResponse = z.infer<
    typeof ClassroomListAssignmentsForAclassroomResponseSchema
  >

  export const CodesOfConductGetAllCodesOfConductParamsSchema = z.object({})
  export type CodesOfConductGetAllCodesOfConductParams = z.infer<
    typeof CodesOfConductGetAllCodesOfConductParamsSchema
  >

  export const CodesOfConductGetAllCodesOfConductResponseSchema =
    z.array(CodeOfConductSchema)
  export type CodesOfConductGetAllCodesOfConductResponse = z.infer<
    typeof CodesOfConductGetAllCodesOfConductResponseSchema
  >

  export const CodesOfConductGetConductCodeParamsSchema = z.object({
    key: z.string()
  })
  export type CodesOfConductGetConductCodeParams = z.infer<
    typeof CodesOfConductGetConductCodeParamsSchema
  >

  export const CodesOfConductGetConductCodeResponseSchema = CodeOfConductSchema
  export type CodesOfConductGetConductCodeResponse = z.infer<
    typeof CodesOfConductGetConductCodeResponseSchema
  >

  export const EmojisGetParamsSchema = z.object({})
  export type EmojisGetParams = z.infer<typeof EmojisGetParamsSchema>

  export const EmojisGetResponseSchema = z.record(z.string())
  export type EmojisGetResponse = z.infer<typeof EmojisGetResponseSchema>

  export const CodeSecurityGetConfigurationsForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional()
    })
  export type CodeSecurityGetConfigurationsForEnterpriseParams = z.infer<
    typeof CodeSecurityGetConfigurationsForEnterpriseParamsSchema
  >

  export const CodeSecurityGetConfigurationsForEnterpriseResponseSchema =
    z.array(CodeSecurityConfigurationSchema)
  export type CodeSecurityGetConfigurationsForEnterpriseResponse = z.infer<
    typeof CodeSecurityGetConfigurationsForEnterpriseResponseSchema
  >

  export const CodeSecurityCreateConfigurationForEnterpriseParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique within the enterprise.'
        ),
      description: z
        .string()
        .max(255)
        .describe('A description of the code security configuration'),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe('The enablement status of GitHub Advanced Security')
        .default('disabled'),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .default('enabled'),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .default('disabled'),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .default(false)
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .default('disabled'),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .default('disabled'),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .default('disabled'),
      code_scanning_default_setup_options:
        CodeScanningDefaultSetupOptionsSchema.optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .default('disabled'),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .default('disabled'),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .default('disabled'),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .default('disabled'),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non provider patterns'
        )
        .default('disabled'),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .default('disabled'),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .default('disabled'),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .default('disabled'),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .default('enforced'),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        )
    })
  export type CodeSecurityCreateConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityCreateConfigurationForEnterpriseParamsSchema
  >

  export type CodeSecurityCreateConfigurationForEnterpriseResponse = undefined

  export const CodeSecurityGetDefaultConfigurationsForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        )
    })
  export type CodeSecurityGetDefaultConfigurationsForEnterpriseParams = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsForEnterpriseParamsSchema
  >

  export const CodeSecurityGetDefaultConfigurationsForEnterpriseResponseSchema =
    CodeSecurityDefaultConfigurationsSchema
  export type CodeSecurityGetDefaultConfigurationsForEnterpriseResponse =
    z.infer<
      typeof CodeSecurityGetDefaultConfigurationsForEnterpriseResponseSchema
    >

  export const CodeSecurityGetSingleConfigurationForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecurityGetSingleConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityGetSingleConfigurationForEnterpriseParamsSchema
  >

  export const CodeSecurityGetSingleConfigurationForEnterpriseResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityGetSingleConfigurationForEnterpriseResponse = z.infer<
    typeof CodeSecurityGetSingleConfigurationForEnterpriseResponseSchema
  >

  export const CodeSecurityDeleteConfigurationForEnterpriseParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecurityDeleteConfigurationForEnterpriseParams = z.infer<
    typeof CodeSecurityDeleteConfigurationForEnterpriseParamsSchema
  >

  export type CodeSecurityDeleteConfigurationForEnterpriseResponse = undefined

  export const CodeSecurityUpdateEnterpriseConfigurationParamsSchema = z.object(
    {
      name: z
        .string()
        .describe(
          'The name of the code security configuration. Must be unique across the enterprise.'
        )
        .optional(),
      description: z
        .string()
        .max(255)
        .describe('A description of the code security configuration')
        .optional(),
      advanced_security: z
        .enum(['enabled', 'disabled'])
        .describe(
          'The enablement status of GitHub Advanced Security. Must be set to enabled if you want to enable any GHAS settings.'
        )
        .optional(),
      dependency_graph: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependency Graph')
        .optional(),
      dependency_graph_autosubmit_action: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Automatic dependency submission')
        .optional(),
      dependency_graph_autosubmit_action_options: z
        .object({
          labeled_runners: z
            .boolean()
            .describe(
              "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
            )
            .optional()
        })
        .describe('Feature options for Automatic dependency submission')
        .optional(),
      dependabot_alerts: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot alerts')
        .optional(),
      dependabot_security_updates: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Dependabot security updates')
        .optional(),
      code_scanning_default_setup: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of code scanning default setup')
        .optional(),
      code_scanning_default_setup_options:
        CodeScanningDefaultSetupOptionsSchema.optional(),
      code_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of code scanning delegated alert dismissal'
        )
        .default('disabled'),
      secret_scanning: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning')
        .optional(),
      secret_scanning_push_protection: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning push protection')
        .optional(),
      secret_scanning_validity_checks: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of secret scanning validity checks')
        .optional(),
      secret_scanning_non_provider_patterns: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning non-provider patterns'
        )
        .optional(),
      secret_scanning_generic_secrets: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of Copilot secret scanning')
        .default('disabled'),
      secret_scanning_delegated_alert_dismissal: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe(
          'The enablement status of secret scanning delegated alert dismissal'
        )
        .default('disabled'),
      private_vulnerability_reporting: z
        .enum(['enabled', 'disabled', 'not_set'])
        .describe('The enablement status of private vulnerability reporting')
        .optional(),
      enforcement: z
        .enum(['enforced', 'unenforced'])
        .describe('The enforcement status for a security configuration')
        .optional(),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    }
  )
  export type CodeSecurityUpdateEnterpriseConfigurationParams = z.infer<
    typeof CodeSecurityUpdateEnterpriseConfigurationParamsSchema
  >

  export const CodeSecurityUpdateEnterpriseConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityUpdateEnterpriseConfigurationResponse = z.infer<
    typeof CodeSecurityUpdateEnterpriseConfigurationResponseSchema
  >

  export const CodeSecurityAttachEnterpriseConfigurationParamsSchema = z.object(
    {
      scope: z
        .enum(['all', 'all_without_configurations'])
        .describe('The type of repositories to attach the configuration to.'),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    }
  )
  export type CodeSecurityAttachEnterpriseConfigurationParams = z.infer<
    typeof CodeSecurityAttachEnterpriseConfigurationParamsSchema
  >

  export type CodeSecurityAttachEnterpriseConfigurationResponse = undefined

  export const CodeSecuritySetConfigurationAsDefaultForEnterpriseParamsSchema =
    z.object({
      default_for_new_repos: z
        .enum(['all', 'none', 'private_and_internal', 'public'])
        .describe(
          'Specify which types of repository this security configuration should be applied to by default.'
        )
        .optional(),
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.')
    })
  export type CodeSecuritySetConfigurationAsDefaultForEnterpriseParams =
    z.infer<
      typeof CodeSecuritySetConfigurationAsDefaultForEnterpriseParamsSchema
    >

  export const CodeSecuritySetConfigurationAsDefaultForEnterpriseResponseSchema =
    z.object({
      default_for_new_repos: z
        .enum(['all', 'none', 'private_and_internal', 'public'])
        .describe(
          'Specifies which types of repository this security configuration is applied to by default.'
        )
        .optional(),
      configuration: CodeSecurityConfigurationSchema.optional()
    })
  export type CodeSecuritySetConfigurationAsDefaultForEnterpriseResponse =
    z.infer<
      typeof CodeSecuritySetConfigurationAsDefaultForEnterpriseResponseSchema
    >

  export const CodeSecurityGetRepositoriesForEnterpriseConfigurationParamsSchema =
    z.object({
      enterprise: z
        .string()
        .describe(
          'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
        ),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      status: z
        .string()
        .describe(
          'A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`'
        )
        .default('all')
    })
  export type CodeSecurityGetRepositoriesForEnterpriseConfigurationParams =
    z.infer<
      typeof CodeSecurityGetRepositoriesForEnterpriseConfigurationParamsSchema
    >

  export const CodeSecurityGetRepositoriesForEnterpriseConfigurationResponseSchema =
    z.array(CodeSecurityConfigurationRepositoriesSchema)
  export type CodeSecurityGetRepositoriesForEnterpriseConfigurationResponse =
    z.infer<
      typeof CodeSecurityGetRepositoriesForEnterpriseConfigurationResponseSchema
    >

  export const DependabotListAlertsForEnterpriseParamsSchema = z.object({
    enterprise: z
      .string()
      .describe(
        'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
      ),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListAlertsForEnterpriseParams = z.infer<
    typeof DependabotListAlertsForEnterpriseParamsSchema
  >

  export const DependabotListAlertsForEnterpriseResponseSchema = z.array(
    DependabotAlertWithRepositorySchema
  )
  export type DependabotListAlertsForEnterpriseResponse = z.infer<
    typeof DependabotListAlertsForEnterpriseResponseSchema
  >

  export const SecretScanningListAlertsForEnterpriseParamsSchema = z.object({
    enterprise: z
      .string()
      .describe(
        'The slug version of the enterprise name. You can also substitute this value with the enterprise id.'
      ),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForEnterpriseParams = z.infer<
    typeof SecretScanningListAlertsForEnterpriseParamsSchema
  >

  export const SecretScanningListAlertsForEnterpriseResponseSchema = z.array(
    OrganizationSecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForEnterpriseResponse = z.infer<
    typeof SecretScanningListAlertsForEnterpriseResponseSchema
  >

  export const ActivityListPublicEventsParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsParams = z.infer<
    typeof ActivityListPublicEventsParamsSchema
  >

  export const ActivityListPublicEventsResponseSchema = z.array(EventSchema)
  export type ActivityListPublicEventsResponse = z.infer<
    typeof ActivityListPublicEventsResponseSchema
  >

  export const ActivityGetFeedsParamsSchema = z.object({})
  export type ActivityGetFeedsParams = z.infer<
    typeof ActivityGetFeedsParamsSchema
  >

  export const ActivityGetFeedsResponseSchema = FeedSchema
  export type ActivityGetFeedsResponse = z.infer<
    typeof ActivityGetFeedsResponseSchema
  >

  export const GistsListParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListParams = z.infer<typeof GistsListParamsSchema>

  export const GistsListResponseSchema = z.array(BaseGistSchema)
  export type GistsListResponse = z.infer<typeof GistsListResponseSchema>

  export const GistsCreateParamsSchema = z.object({
    description: z.string().describe('Description of the gist').optional(),
    files: z
      .record(z.object({ content: z.string().describe('Content of the file') }))
      .describe('Names and content for the files that make up the gist'),
    public: z
      .union([
        z
          .boolean()
          .describe('Flag indicating whether the gist is public')
          .default(false),
        z.enum(['true', 'false']).default('false')
      ])
      .optional()
  })
  export type GistsCreateParams = z.infer<typeof GistsCreateParamsSchema>

  export type GistsCreateResponse = undefined

  export const GistsListPublicParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListPublicParams = z.infer<
    typeof GistsListPublicParamsSchema
  >

  export const GistsListPublicResponseSchema = z.array(BaseGistSchema)
  export type GistsListPublicResponse = z.infer<
    typeof GistsListPublicResponseSchema
  >

  export const GistsListStarredParamsSchema = z.object({
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListStarredParams = z.infer<
    typeof GistsListStarredParamsSchema
  >

  export const GistsListStarredResponseSchema = z.array(BaseGistSchema)
  export type GistsListStarredResponse = z.infer<
    typeof GistsListStarredResponseSchema
  >

  export const GistsGetParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsGetParams = z.infer<typeof GistsGetParamsSchema>

  export const GistsGetResponseSchema = GistSimpleSchema
  export type GistsGetResponse = z.infer<typeof GistsGetResponseSchema>

  export const GistsDeleteParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsDeleteParams = z.infer<typeof GistsDeleteParamsSchema>

  export type GistsDeleteResponse = undefined

  export const GistsUpdateParamsSchema = z.object({
    description: z.string().describe('The description of the gist.').optional(),
    files: z
      .record(
        z.object({
          content: z
            .string()
            .describe('The new content of the file.')
            .optional(),
          filename: z
            .string()
            .describe('The new filename for the file.')
            .optional()
        })
      )
      .describe(
        'The gist files to be updated, renamed, or deleted. Each `key` must match the current filename\n(including extension) of the targeted gist file. For example: `hello.py`.\n\nTo delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be\ndeleted if the specified object does not contain at least one of `content` or `filename`.'
      )
      .optional(),
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsUpdateParams = z.infer<typeof GistsUpdateParamsSchema>

  export const GistsUpdateResponseSchema = GistSimpleSchema
  export type GistsUpdateResponse = z.infer<typeof GistsUpdateResponseSchema>

  export const GistsListCommentsParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListCommentsParams = z.infer<
    typeof GistsListCommentsParamsSchema
  >

  export const GistsListCommentsResponseSchema = z.array(GistCommentSchema)
  export type GistsListCommentsResponse = z.infer<
    typeof GistsListCommentsResponseSchema
  >

  export const GistsCreateCommentParamsSchema = z.object({
    body: z.string().max(65_535).describe('The comment text.'),
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsCreateCommentParams = z.infer<
    typeof GistsCreateCommentParamsSchema
  >

  export type GistsCreateCommentResponse = undefined

  export const GistsGetCommentParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsGetCommentParams = z.infer<
    typeof GistsGetCommentParamsSchema
  >

  export const GistsGetCommentResponseSchema = GistCommentSchema
  export type GistsGetCommentResponse = z.infer<
    typeof GistsGetCommentResponseSchema
  >

  export const GistsDeleteCommentParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsDeleteCommentParams = z.infer<
    typeof GistsDeleteCommentParamsSchema
  >

  export type GistsDeleteCommentResponse = undefined

  export const GistsUpdateCommentParamsSchema = z.object({
    body: z.string().max(65_535).describe('The comment text.'),
    gist_id: z.string().describe('The unique identifier of the gist.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type GistsUpdateCommentParams = z.infer<
    typeof GistsUpdateCommentParamsSchema
  >

  export const GistsUpdateCommentResponseSchema = GistCommentSchema
  export type GistsUpdateCommentResponse = z.infer<
    typeof GistsUpdateCommentResponseSchema
  >

  export const GistsListCommitsParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListCommitsParams = z.infer<
    typeof GistsListCommitsParamsSchema
  >

  export const GistsListCommitsResponseSchema = z.array(GistCommitSchema)
  export type GistsListCommitsResponse = z.infer<
    typeof GistsListCommitsResponseSchema
  >

  export const GistsListForksParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListForksParams = z.infer<typeof GistsListForksParamsSchema>

  export const GistsListForksResponseSchema = z.array(GistSimpleSchema)
  export type GistsListForksResponse = z.infer<
    typeof GistsListForksResponseSchema
  >

  export const GistsForkParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsForkParams = z.infer<typeof GistsForkParamsSchema>

  export type GistsForkResponse = undefined

  export const GistsCheckIsStarredParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsCheckIsStarredParams = z.infer<
    typeof GistsCheckIsStarredParamsSchema
  >

  export type GistsCheckIsStarredResponse = undefined

  export const GistsStarParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsStarParams = z.infer<typeof GistsStarParamsSchema>

  export type GistsStarResponse = undefined

  export const GistsUnstarParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.')
  })
  export type GistsUnstarParams = z.infer<typeof GistsUnstarParamsSchema>

  export type GistsUnstarResponse = undefined

  export const GistsGetRevisionParamsSchema = z.object({
    gist_id: z.string().describe('The unique identifier of the gist.'),
    sha: z.string()
  })
  export type GistsGetRevisionParams = z.infer<
    typeof GistsGetRevisionParamsSchema
  >

  export const GistsGetRevisionResponseSchema = GistSimpleSchema
  export type GistsGetRevisionResponse = z.infer<
    typeof GistsGetRevisionResponseSchema
  >

  export const GitignoreGetAllTemplatesParamsSchema = z.object({})
  export type GitignoreGetAllTemplatesParams = z.infer<
    typeof GitignoreGetAllTemplatesParamsSchema
  >

  export const GitignoreGetAllTemplatesResponseSchema = z.array(z.string())
  export type GitignoreGetAllTemplatesResponse = z.infer<
    typeof GitignoreGetAllTemplatesResponseSchema
  >

  export const GitignoreGetTemplateParamsSchema = z.object({ name: z.string() })
  export type GitignoreGetTemplateParams = z.infer<
    typeof GitignoreGetTemplateParamsSchema
  >

  export const GitignoreGetTemplateResponseSchema = GitignoreTemplateSchema
  export type GitignoreGetTemplateResponse = z.infer<
    typeof GitignoreGetTemplateResponseSchema
  >

  export const AppsListReposAccessibleToInstallationParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListReposAccessibleToInstallationParams = z.infer<
    typeof AppsListReposAccessibleToInstallationParamsSchema
  >

  export const AppsListReposAccessibleToInstallationResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(RepositorySchema),
    repository_selection: z.string().optional()
  })
  export type AppsListReposAccessibleToInstallationResponse = z.infer<
    typeof AppsListReposAccessibleToInstallationResponseSchema
  >

  export const AppsRevokeInstallationAccessTokenParamsSchema = z.object({})
  export type AppsRevokeInstallationAccessTokenParams = z.infer<
    typeof AppsRevokeInstallationAccessTokenParamsSchema
  >

  export type AppsRevokeInstallationAccessTokenResponse = undefined

  export const IssuesListParamsSchema = z.object({
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    collab: z.boolean().optional(),
    orgs: z.boolean().optional(),
    owned: z.boolean().optional(),
    pulls: z.boolean().optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListParams = z.infer<typeof IssuesListParamsSchema>

  export const IssuesListResponseSchema = z.array(IssueSchema)
  export type IssuesListResponse = z.infer<typeof IssuesListResponseSchema>

  export const LicensesGetAllCommonlyUsedParamsSchema = z.object({
    featured: z.boolean().optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type LicensesGetAllCommonlyUsedParams = z.infer<
    typeof LicensesGetAllCommonlyUsedParamsSchema
  >

  export const LicensesGetAllCommonlyUsedResponseSchema =
    z.array(LicenseSimpleSchema)
  export type LicensesGetAllCommonlyUsedResponse = z.infer<
    typeof LicensesGetAllCommonlyUsedResponseSchema
  >

  export const LicensesGetParamsSchema = z.object({ license: z.string() })
  export type LicensesGetParams = z.infer<typeof LicensesGetParamsSchema>

  export const LicensesGetResponseSchema = LicenseSchema
  export type LicensesGetResponse = z.infer<typeof LicensesGetResponseSchema>

  export const MarkdownRenderParamsSchema = z.object({
    text: z.string().describe('The Markdown text to render in HTML.'),
    mode: z
      .enum(['markdown', 'gfm'])
      .describe('The rendering mode.')
      .default('markdown'),
    context: z
      .string()
      .describe(
        'The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.'
      )
      .optional()
  })
  export type MarkdownRenderParams = z.infer<typeof MarkdownRenderParamsSchema>

  export type MarkdownRenderResponse = undefined

  export const MarkdownRenderRawParamsSchema = z.object({})
  export type MarkdownRenderRawParams = z.infer<
    typeof MarkdownRenderRawParamsSchema
  >

  export type MarkdownRenderRawResponse = undefined

  export const AppsGetSubscriptionPlanForAccountParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type AppsGetSubscriptionPlanForAccountParams = z.infer<
    typeof AppsGetSubscriptionPlanForAccountParamsSchema
  >

  export const AppsGetSubscriptionPlanForAccountResponseSchema =
    MarketplacePurchaseSchema
  export type AppsGetSubscriptionPlanForAccountResponse = z.infer<
    typeof AppsGetSubscriptionPlanForAccountResponseSchema
  >

  export const AppsListPlansParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListPlansParams = z.infer<typeof AppsListPlansParamsSchema>

  export const AppsListPlansResponseSchema = z.array(
    MarketplaceListingPlanSchema
  )
  export type AppsListPlansResponse = z.infer<
    typeof AppsListPlansResponseSchema
  >

  export const AppsListAccountsForPlanParamsSchema = z.object({
    plan_id: z.number().int().describe('The unique identifier of the plan.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListAccountsForPlanParams = z.infer<
    typeof AppsListAccountsForPlanParamsSchema
  >

  export const AppsListAccountsForPlanResponseSchema = z.array(
    MarketplacePurchaseSchema
  )
  export type AppsListAccountsForPlanResponse = z.infer<
    typeof AppsListAccountsForPlanResponseSchema
  >

  export const AppsGetSubscriptionPlanForAccountStubbedParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type AppsGetSubscriptionPlanForAccountStubbedParams = z.infer<
    typeof AppsGetSubscriptionPlanForAccountStubbedParamsSchema
  >

  export const AppsGetSubscriptionPlanForAccountStubbedResponseSchema =
    MarketplacePurchaseSchema
  export type AppsGetSubscriptionPlanForAccountStubbedResponse = z.infer<
    typeof AppsGetSubscriptionPlanForAccountStubbedResponseSchema
  >

  export const AppsListPlansStubbedParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListPlansStubbedParams = z.infer<
    typeof AppsListPlansStubbedParamsSchema
  >

  export const AppsListPlansStubbedResponseSchema = z.array(
    MarketplaceListingPlanSchema
  )
  export type AppsListPlansStubbedResponse = z.infer<
    typeof AppsListPlansStubbedResponseSchema
  >

  export const AppsListAccountsForPlanStubbedParamsSchema = z.object({
    plan_id: z.number().int().describe('The unique identifier of the plan.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type AppsListAccountsForPlanStubbedParams = z.infer<
    typeof AppsListAccountsForPlanStubbedParamsSchema
  >

  export const AppsListAccountsForPlanStubbedResponseSchema = z.array(
    MarketplacePurchaseSchema
  )
  export type AppsListAccountsForPlanStubbedResponse = z.infer<
    typeof AppsListAccountsForPlanStubbedResponseSchema
  >

  export const MetaGetParamsSchema = z.object({})
  export type MetaGetParams = z.infer<typeof MetaGetParamsSchema>

  export const MetaGetResponseSchema = ApiOverviewSchema
  export type MetaGetResponse = z.infer<typeof MetaGetResponseSchema>

  export const ActivityListPublicEventsForRepoNetworkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsForRepoNetworkParams = z.infer<
    typeof ActivityListPublicEventsForRepoNetworkParamsSchema
  >

  export const ActivityListPublicEventsForRepoNetworkResponseSchema =
    z.array(EventSchema)
  export type ActivityListPublicEventsForRepoNetworkResponse = z.infer<
    typeof ActivityListPublicEventsForRepoNetworkResponseSchema
  >

  export const ActivityListNotificationsForAuthenticatedUserParamsSchema =
    z.object({
      all: z
        .boolean()
        .describe('If `true`, show notifications marked as read.')
        .default(false),
      participating: z
        .boolean()
        .describe(
          'If `true`, only shows notifications in which the user is directly participating or mentioned.'
        )
        .default(false),
      since: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      before: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 50). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(50)
    })
  export type ActivityListNotificationsForAuthenticatedUserParams = z.infer<
    typeof ActivityListNotificationsForAuthenticatedUserParamsSchema
  >

  export const ActivityListNotificationsForAuthenticatedUserResponseSchema =
    z.array(ThreadSchema)
  export type ActivityListNotificationsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListNotificationsForAuthenticatedUserResponseSchema
  >

  export const ActivityMarkNotificationsAsReadParamsSchema = z.object({
    last_read_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
      )
      .optional(),
    read: z
      .boolean()
      .describe('Whether the notification has been read.')
      .optional()
  })
  export type ActivityMarkNotificationsAsReadParams = z.infer<
    typeof ActivityMarkNotificationsAsReadParamsSchema
  >

  export type ActivityMarkNotificationsAsReadResponse = undefined

  export const ActivityGetThreadParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityGetThreadParams = z.infer<
    typeof ActivityGetThreadParamsSchema
  >

  export const ActivityGetThreadResponseSchema = ThreadSchema
  export type ActivityGetThreadResponse = z.infer<
    typeof ActivityGetThreadResponseSchema
  >

  export const ActivityMarkThreadAsDoneParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityMarkThreadAsDoneParams = z.infer<
    typeof ActivityMarkThreadAsDoneParamsSchema
  >

  export type ActivityMarkThreadAsDoneResponse = undefined

  export const ActivityMarkThreadAsReadParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityMarkThreadAsReadParams = z.infer<
    typeof ActivityMarkThreadAsReadParamsSchema
  >

  export type ActivityMarkThreadAsReadResponse = undefined

  export const ActivityGetThreadSubscriptionForAuthenticatedUserParamsSchema =
    z.object({
      thread_id: z
        .number()
        .int()
        .describe(
          'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
        )
    })
  export type ActivityGetThreadSubscriptionForAuthenticatedUserParams = z.infer<
    typeof ActivityGetThreadSubscriptionForAuthenticatedUserParamsSchema
  >

  export const ActivityGetThreadSubscriptionForAuthenticatedUserResponseSchema =
    ThreadSubscriptionSchema
  export type ActivityGetThreadSubscriptionForAuthenticatedUserResponse =
    z.infer<
      typeof ActivityGetThreadSubscriptionForAuthenticatedUserResponseSchema
    >

  export const ActivitySetThreadSubscriptionParamsSchema = z.object({
    ignored: z
      .boolean()
      .describe('Whether to block all notifications from a thread.')
      .default(false),
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivitySetThreadSubscriptionParams = z.infer<
    typeof ActivitySetThreadSubscriptionParamsSchema
  >

  export const ActivitySetThreadSubscriptionResponseSchema =
    ThreadSubscriptionSchema
  export type ActivitySetThreadSubscriptionResponse = z.infer<
    typeof ActivitySetThreadSubscriptionResponseSchema
  >

  export const ActivityDeleteThreadSubscriptionParamsSchema = z.object({
    thread_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).'
      )
  })
  export type ActivityDeleteThreadSubscriptionParams = z.infer<
    typeof ActivityDeleteThreadSubscriptionParamsSchema
  >

  export type ActivityDeleteThreadSubscriptionResponse = undefined

  export const MetaGetOctocatParamsSchema = z.object({
    s: z
      .string()
      .describe("The words to show in Octocat's speech bubble")
      .optional()
  })
  export type MetaGetOctocatParams = z.infer<typeof MetaGetOctocatParamsSchema>

  export type MetaGetOctocatResponse = undefined

  export const OrgsListParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe(
        'An organization ID. Only return organizations with an ID greater than this ID.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type OrgsListParams = z.infer<typeof OrgsListParamsSchema>

  export const OrgsListResponseSchema = z.array(OrganizationSimpleSchema)
  export type OrgsListResponse = z.infer<typeof OrgsListResponseSchema>

  export const BillingGetGithubBillingUsageReportOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    year: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.'
      )
      .optional(),
    month: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.'
      )
      .optional(),
    day: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.'
      )
      .optional(),
    hour: z
      .number()
      .int()
      .describe(
        'If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.'
      )
      .optional()
  })
  export type BillingGetGithubBillingUsageReportOrgParams = z.infer<
    typeof BillingGetGithubBillingUsageReportOrgParamsSchema
  >

  export const BillingGetGithubBillingUsageReportOrgResponseSchema =
    BillingUsageReportSchema
  export type BillingGetGithubBillingUsageReportOrgResponse = z.infer<
    typeof BillingGetGithubBillingUsageReportOrgResponseSchema
  >

  export const OrgsGetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetParams = z.infer<typeof OrgsGetParamsSchema>

  export const OrgsGetResponseSchema = OrganizationFullSchema
  export type OrgsGetResponse = z.infer<typeof OrgsGetResponseSchema>

  export const OrgsDeleteParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsDeleteParams = z.infer<typeof OrgsDeleteParamsSchema>

  export type OrgsDeleteResponse = undefined

  export const OrgsUpdateParamsSchema = z.object({
    billing_email: z
      .string()
      .describe('Billing email address. This address is not publicized.')
      .optional(),
    company: z.string().describe('The company name.').optional(),
    email: z
      .string()
      .describe('The publicly visible email address.')
      .optional(),
    twitter_username: z
      .string()
      .describe('The Twitter username of the company.')
      .optional(),
    location: z.string().describe('The location.').optional(),
    name: z.string().describe('The shorthand name of the company.').optional(),
    description: z
      .string()
      .describe(
        'The description of the company. The maximum size is 160 characters.'
      )
      .optional(),
    has_organization_projects: z
      .boolean()
      .describe('Whether an organization can use organization projects.')
      .optional(),
    has_repository_projects: z
      .boolean()
      .describe(
        'Whether repositories that belong to the organization can use repository projects.'
      )
      .optional(),
    default_repository_permission: z
      .enum(['read', 'write', 'admin', 'none'])
      .describe(
        'Default permission level members have for organization repositories.'
      )
      .default('read'),
    members_can_create_repositories: z
      .boolean()
      .describe(
        'Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.'
      )
      .default(true),
    members_can_create_internal_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_can_create_private_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_can_create_public_repositories: z
      .boolean()
      .describe(
        'Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
      )
      .optional(),
    members_allowed_repository_creation_type: z
      .enum(['all', 'private', 'none'])
      .describe(
        'Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. \n**Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.'
      )
      .optional(),
    members_can_create_pages: z
      .boolean()
      .describe(
        'Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_create_public_pages: z
      .boolean()
      .describe(
        'Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_create_private_pages: z
      .boolean()
      .describe(
        'Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.'
      )
      .default(true),
    members_can_fork_private_repositories: z
      .boolean()
      .describe(
        'Whether organization members can fork private organization repositories.'
      )
      .default(false),
    web_commit_signoff_required: z
      .boolean()
      .describe(
        "Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface."
      )
      .default(false),
    blog: z.string().optional(),
    advanced_security_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependabot_alerts_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependabot_security_updates_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    dependency_graph_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_push_protection_enabled_for_new_repositories: z
      .boolean()
      .describe(
        '**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
      )
      .optional(),
    secret_scanning_push_protection_custom_link_enabled: z
      .boolean()
      .describe(
        'Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.'
      )
      .optional(),
    secret_scanning_push_protection_custom_link: z
      .string()
      .describe(
        'If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.'
      )
      .optional(),
    deploy_keys_enabled_for_repositories: z
      .boolean()
      .describe(
        'Controls whether or not deploy keys may be added and used for repositories in the organization.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdateParams = z.infer<typeof OrgsUpdateParamsSchema>

  export const OrgsUpdateResponseSchema = OrganizationFullSchema
  export type OrgsUpdateResponse = z.infer<typeof OrgsUpdateResponseSchema>

  export const ActionsGetActionsCacheUsageForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetActionsCacheUsageForOrgParams = z.infer<
    typeof ActionsGetActionsCacheUsageForOrgParamsSchema
  >

  export const ActionsGetActionsCacheUsageForOrgResponseSchema =
    ActionsCacheUsageOrgEnterpriseSchema
  export type ActionsGetActionsCacheUsageForOrgResponse = z.infer<
    typeof ActionsGetActionsCacheUsageForOrgResponseSchema
  >

  export const ActionsGetActionsCacheUsageByRepoForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsGetActionsCacheUsageByRepoForOrgParams = z.infer<
    typeof ActionsGetActionsCacheUsageByRepoForOrgParamsSchema
  >

  export const ActionsGetActionsCacheUsageByRepoForOrgResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repository_cache_usages: z.array(ActionsCacheUsageByRepositorySchema)
    }
  )
  export type ActionsGetActionsCacheUsageByRepoForOrgResponse = z.infer<
    typeof ActionsGetActionsCacheUsageByRepoForOrgResponseSchema
  >

  export const ActionsListHostedRunnersForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListHostedRunnersForOrgParams = z.infer<
    typeof ActionsListHostedRunnersForOrgParamsSchema
  >

  export const ActionsListHostedRunnersForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(ActionsHostedRunnerSchema)
  })
  export type ActionsListHostedRunnersForOrgResponse = z.infer<
    typeof ActionsListHostedRunnersForOrgResponseSchema
  >

  export const ActionsCreateHostedRunnerForOrgParamsSchema = z.object({
    name: z
      .string()
      .describe(
        "Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
      ),
    image: z
      .object({
        id: z
          .string()
          .describe('The unique identifier of the runner image.')
          .optional(),
        source: z
          .enum(['github', 'partner', 'custom'])
          .describe('The source of the runner image.')
          .optional()
      })
      .describe(
        'The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`.'
      ),
    size: z
      .string()
      .describe(
        'The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`'
      ),
    runner_group_id: z
      .number()
      .int()
      .describe('The existing runner group to add this runner to.'),
    maximum_runners: z
      .number()
      .int()
      .describe(
        'The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.'
      )
      .optional(),
    enable_static_ip: z
      .boolean()
      .describe(
        'Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateHostedRunnerForOrgParams = z.infer<
    typeof ActionsCreateHostedRunnerForOrgParamsSchema
  >

  export type ActionsCreateHostedRunnerForOrgResponse = undefined

  export const ActionsGetHostedRunnersGithubOwnedImagesForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetHostedRunnersGithubOwnedImagesForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersGithubOwnedImagesForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersGithubOwnedImagesForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      images: z.array(ActionsHostedRunnerImageSchema)
    })
  export type ActionsGetHostedRunnersGithubOwnedImagesForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersGithubOwnedImagesForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersPartnerImagesForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetHostedRunnersPartnerImagesForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersPartnerImagesForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersPartnerImagesForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      images: z.array(ActionsHostedRunnerImageSchema)
    })
  export type ActionsGetHostedRunnersPartnerImagesForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersPartnerImagesForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersLimitsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetHostedRunnersLimitsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersLimitsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersLimitsForOrgResponseSchema =
    ActionsHostedRunnerLimitsSchema
  export type ActionsGetHostedRunnersLimitsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersLimitsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersMachineSpecsForOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    }
  )
  export type ActionsGetHostedRunnersMachineSpecsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersMachineSpecsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersMachineSpecsForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      machine_specs: z.array(ActionsHostedRunnerMachineSpecSchema)
    })
  export type ActionsGetHostedRunnersMachineSpecsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersMachineSpecsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnersPlatformsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetHostedRunnersPlatformsForOrgParams = z.infer<
    typeof ActionsGetHostedRunnersPlatformsForOrgParamsSchema
  >

  export const ActionsGetHostedRunnersPlatformsForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    platforms: z.array(z.string())
  })
  export type ActionsGetHostedRunnersPlatformsForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnersPlatformsForOrgResponseSchema
  >

  export const ActionsGetHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsGetHostedRunnerForOrgParams = z.infer<
    typeof ActionsGetHostedRunnerForOrgParamsSchema
  >

  export const ActionsGetHostedRunnerForOrgResponseSchema =
    ActionsHostedRunnerSchema
  export type ActionsGetHostedRunnerForOrgResponse = z.infer<
    typeof ActionsGetHostedRunnerForOrgResponseSchema
  >

  export const ActionsDeleteHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsDeleteHostedRunnerForOrgParams = z.infer<
    typeof ActionsDeleteHostedRunnerForOrgParamsSchema
  >

  export type ActionsDeleteHostedRunnerForOrgResponse = undefined

  export const ActionsUpdateHostedRunnerForOrgParamsSchema = z.object({
    name: z
      .string()
      .describe(
        "Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
      )
      .optional(),
    runner_group_id: z
      .number()
      .int()
      .describe('The existing runner group to add this runner to.')
      .optional(),
    maximum_runners: z
      .number()
      .int()
      .describe(
        'The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.'
      )
      .optional(),
    enable_static_ip: z
      .boolean()
      .describe(
        'Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hosted_runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the GitHub-hosted runner.')
  })
  export type ActionsUpdateHostedRunnerForOrgParams = z.infer<
    typeof ActionsUpdateHostedRunnerForOrgParamsSchema
  >

  export const ActionsUpdateHostedRunnerForOrgResponseSchema =
    ActionsHostedRunnerSchema
  export type ActionsUpdateHostedRunnerForOrgResponse = z.infer<
    typeof ActionsUpdateHostedRunnerForOrgResponseSchema
  >

  export const OidcGetOidcCustomSubTemplateForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OidcGetOidcCustomSubTemplateForOrgParams = z.infer<
    typeof OidcGetOidcCustomSubTemplateForOrgParamsSchema
  >

  export const OidcGetOidcCustomSubTemplateForOrgResponseSchema =
    OidcCustomSubSchema
  export type OidcGetOidcCustomSubTemplateForOrgResponse = z.infer<
    typeof OidcGetOidcCustomSubTemplateForOrgResponseSchema
  >

  export const OidcUpdateOidcCustomSubTemplateForOrgParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(OidcCustomSubSchema)
  export type OidcUpdateOidcCustomSubTemplateForOrgParams = z.infer<
    typeof OidcUpdateOidcCustomSubTemplateForOrgParamsSchema
  >

  export type OidcUpdateOidcCustomSubTemplateForOrgResponse = undefined

  export const ActionsGetGithubActionsPermissionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetGithubActionsPermissionsOrganizationParams = z.infer<
    typeof ActionsGetGithubActionsPermissionsOrganizationParamsSchema
  >

  export const ActionsGetGithubActionsPermissionsOrganizationResponseSchema =
    ActionsOrganizationPermissionsSchema
  export type ActionsGetGithubActionsPermissionsOrganizationResponse = z.infer<
    typeof ActionsGetGithubActionsPermissionsOrganizationResponseSchema
  >

  export const ActionsSetGithubActionsPermissionsOrganizationParamsSchema =
    z.object({
      enabled_repositories: EnabledRepositoriesSchema,
      allowed_actions: AllowedActionsSchema.optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsSetGithubActionsPermissionsOrganizationParams = z.infer<
    typeof ActionsSetGithubActionsPermissionsOrganizationParamsSchema
  >

  export type ActionsSetGithubActionsPermissionsOrganizationResponse = undefined

  export const ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
    >

  export const ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseSchema =
    z.object({
      total_count: z.number(),
      repositories: z.array(RepositorySchema)
    })
  export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse =
    z.infer<
      typeof ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseSchema
    >

  export const ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(
          z.number().int().describe('Unique identifier of the repository.')
        )
        .describe('List of repository IDs to enable for GitHub Actions.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
    >

  export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse =
    undefined

  export const ActionsEnableSelectedRepositoryGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsEnableSelectedRepositoryGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsEnableSelectedRepositoryGithubActionsOrganizationParamsSchema
    >

  export type ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse =
    undefined

  export const ActionsDisableSelectedRepositoryGithubActionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsDisableSelectedRepositoryGithubActionsOrganizationParams =
    z.infer<
      typeof ActionsDisableSelectedRepositoryGithubActionsOrganizationParamsSchema
    >

  export type ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse =
    undefined

  export const ActionsGetAllowedActionsOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetAllowedActionsOrganizationParams = z.infer<
    typeof ActionsGetAllowedActionsOrganizationParamsSchema
  >

  export const ActionsGetAllowedActionsOrganizationResponseSchema =
    SelectedActionsSchema
  export type ActionsGetAllowedActionsOrganizationResponse = z.infer<
    typeof ActionsGetAllowedActionsOrganizationResponseSchema
  >

  export const ActionsSetAllowedActionsOrganizationParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(SelectedActionsSchema)
  export type ActionsSetAllowedActionsOrganizationParams = z.infer<
    typeof ActionsSetAllowedActionsOrganizationParamsSchema
  >

  export type ActionsSetAllowedActionsOrganizationResponse = undefined

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParams =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
    >

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseSchema =
    ActionsGetDefaultWorkflowPermissionsSchema
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseSchema
    >

  export const ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema =
    z
      .object({
        org: z
          .string()
          .describe('The organization name. The name is not case sensitive.')
      })
      .merge(ActionsSetDefaultWorkflowPermissionsSchema)
  export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParams =
    z.infer<
      typeof ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
    >

  export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse =
    undefined

  export const ActionsListSelfHostedRunnerGroupsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    visible_to_repository: z
      .string()
      .describe(
        'Only return runner groups that are allowed to be used by this repository.'
      )
      .optional()
  })
  export type ActionsListSelfHostedRunnerGroupsForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnerGroupsForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnerGroupsForOrgResponseSchema = z.object(
    { total_count: z.number(), runner_groups: z.array(RunnerGroupsOrgSchema) }
  )
  export type ActionsListSelfHostedRunnerGroupsForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnerGroupsForOrgResponseSchema
  >

  export const ActionsCreateSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    name: z.string().describe('Name of the runner group.'),
    visibility: z
      .enum(['selected', 'all', 'private'])
      .describe(
        'Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.'
      )
      .default('all'),
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe('List of repository IDs that can access the runner group.')
      .optional(),
    runners: z
      .array(z.number().int().describe('Unique identifier of the runner.'))
      .describe('List of runner IDs to add to the runner group.')
      .optional(),
    allows_public_repositories: z
      .boolean()
      .describe(
        'Whether the runner group can be used by `public` repositories.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsCreateSelfHostedRunnerGroupForOrgParamsSchema
  >

  export type ActionsCreateSelfHostedRunnerGroupForOrgResponse = undefined

  export const ActionsGetSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsGetSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsGetSelfHostedRunnerGroupForOrgParamsSchema
  >

  export const ActionsGetSelfHostedRunnerGroupForOrgResponseSchema =
    RunnerGroupsOrgSchema
  export type ActionsGetSelfHostedRunnerGroupForOrgResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerGroupForOrgResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerGroupFromOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.')
    }
  )
  export type ActionsDeleteSelfHostedRunnerGroupFromOrgParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerGroupFromOrgParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerGroupFromOrgResponse = undefined

  export const ActionsUpdateSelfHostedRunnerGroupForOrgParamsSchema = z.object({
    name: z.string().describe('Name of the runner group.'),
    visibility: z
      .enum(['selected', 'all', 'private'])
      .describe(
        'Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.'
      )
      .optional(),
    allows_public_repositories: z
      .boolean()
      .describe(
        'Whether the runner group can be used by `public` repositories.'
      )
      .default(false),
    restricted_to_workflows: z
      .boolean()
      .describe(
        'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.'
      )
      .default(false),
    selected_workflows: z
      .array(
        z
          .string()
          .describe(
            'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.'
          )
      )
      .describe(
        'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.'
      )
      .optional(),
    network_configuration_id: z
      .string()
      .describe('The identifier of a hosted compute network configuration.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsUpdateSelfHostedRunnerGroupForOrgParams = z.infer<
    typeof ActionsUpdateSelfHostedRunnerGroupForOrgParamsSchema
  >

  export const ActionsUpdateSelfHostedRunnerGroupForOrgResponseSchema =
    RunnerGroupsOrgSchema
  export type ActionsUpdateSelfHostedRunnerGroupForOrgResponse = z.infer<
    typeof ActionsUpdateSelfHostedRunnerGroupForOrgResponseSchema
  >

  export const ActionsListGithubHostedRunnersInGroupForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActionsListGithubHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsListGithubHostedRunnersInGroupForOrgParamsSchema
  >

  export const ActionsListGithubHostedRunnersInGroupForOrgResponseSchema =
    z.object({
      total_count: z.number(),
      runners: z.array(ActionsHostedRunnerSchema)
    })
  export type ActionsListGithubHostedRunnersInGroupForOrgResponse = z.infer<
    typeof ActionsListGithubHostedRunnersInGroupForOrgResponseSchema
  >

  export const ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    })
  export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export const ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseSchema =
    z.object({
      total_count: z.number(),
      repositories: z.array(MinimalRepositorySchema)
    })
  export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    z.infer<
      typeof ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseSchema
    >

  export const ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(
          z.number().int().describe('Unique identifier of the repository.')
        )
        .describe('List of repository IDs that can access the runner group.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.')
    })
  export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams = z.infer<
    typeof ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  >

  export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams =
    z.infer<
      typeof ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
    >

  export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse =
    undefined

  export const ActionsListSelfHostedRunnersInGroupForOrgParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ActionsListSelfHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnersInGroupForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnersInGroupForOrgResponseSchema =
    z.object({ total_count: z.number(), runners: z.array(RunnerSchema) })
  export type ActionsListSelfHostedRunnersInGroupForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnersInGroupForOrgResponseSchema
  >

  export const ActionsSetSelfHostedRunnersInGroupForOrgParamsSchema = z.object({
    runners: z
      .array(z.number().int().describe('Unique identifier of the runner.'))
      .describe('List of runner IDs to add to the runner group.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.')
  })
  export type ActionsSetSelfHostedRunnersInGroupForOrgParams = z.infer<
    typeof ActionsSetSelfHostedRunnersInGroupForOrgParamsSchema
  >

  export type ActionsSetSelfHostedRunnersInGroupForOrgResponse = undefined

  export const ActionsAddSelfHostedRunnerToGroupForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_group_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner group.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsAddSelfHostedRunnerToGroupForOrgParams = z.infer<
    typeof ActionsAddSelfHostedRunnerToGroupForOrgParamsSchema
  >

  export type ActionsAddSelfHostedRunnerToGroupForOrgResponse = undefined

  export const ActionsRemoveSelfHostedRunnerFromGroupForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_group_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner group.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveSelfHostedRunnerFromGroupForOrgParams = z.infer<
    typeof ActionsRemoveSelfHostedRunnerFromGroupForOrgParamsSchema
  >

  export type ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse = undefined

  export const ActionsListSelfHostedRunnersForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of a self-hosted runner.').optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListSelfHostedRunnersForOrgParams = z.infer<
    typeof ActionsListSelfHostedRunnersForOrgParamsSchema
  >

  export const ActionsListSelfHostedRunnersForOrgResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(RunnerSchema)
  })
  export type ActionsListSelfHostedRunnersForOrgResponse = z.infer<
    typeof ActionsListSelfHostedRunnersForOrgResponseSchema
  >

  export const ActionsListRunnerApplicationsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsListRunnerApplicationsForOrgParams = z.infer<
    typeof ActionsListRunnerApplicationsForOrgParamsSchema
  >

  export const ActionsListRunnerApplicationsForOrgResponseSchema = z.array(
    RunnerApplicationSchema
  )
  export type ActionsListRunnerApplicationsForOrgResponse = z.infer<
    typeof ActionsListRunnerApplicationsForOrgResponseSchema
  >

  export const ActionsGenerateRunnerJitconfigForOrgParamsSchema = z.object({
    name: z.string().describe('The name of the new runner.'),
    runner_group_id: z
      .number()
      .int()
      .describe('The ID of the runner group to register the runner to.'),
    labels: z
      .array(z.string())
      .min(1)
      .max(100)
      .describe(
        'The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.'
      ),
    work_folder: z
      .string()
      .describe(
        'The working directory to be used for job execution, relative to the runner install directory.'
      )
      .default('_work'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGenerateRunnerJitconfigForOrgParams = z.infer<
    typeof ActionsGenerateRunnerJitconfigForOrgParamsSchema
  >

  export type ActionsGenerateRunnerJitconfigForOrgResponse = undefined

  export const ActionsCreateRegistrationTokenForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateRegistrationTokenForOrgParams = z.infer<
    typeof ActionsCreateRegistrationTokenForOrgParamsSchema
  >

  export type ActionsCreateRegistrationTokenForOrgResponse = undefined

  export const ActionsCreateRemoveTokenForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateRemoveTokenForOrgParams = z.infer<
    typeof ActionsCreateRemoveTokenForOrgParamsSchema
  >

  export type ActionsCreateRemoveTokenForOrgResponse = undefined

  export const ActionsGetSelfHostedRunnerForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsGetSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsGetSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsGetSelfHostedRunnerForOrgResponseSchema = RunnerSchema
  export type ActionsGetSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerFromOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsDeleteSelfHostedRunnerFromOrgParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerFromOrgParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerFromOrgResponse = undefined

  export const ActionsListLabelsForSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsListLabelsForSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsListLabelsForSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsListLabelsForSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(1)
        .max(100)
        .describe('The names of the custom labels to add to the runner.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(0)
        .max(100)
        .describe(
          'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgParams = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamsSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponseSchema
  >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParams =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamsSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.'),
      name: z
        .string()
        .describe("The name of a self-hosted runner's custom label.")
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParams =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamsSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseSchema
    >

  export const ActionsListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListOrgSecretsParams = z.infer<
    typeof ActionsListOrgSecretsParamsSchema
  >

  export const ActionsListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(OrganizationActionsSecretSchema)
  })
  export type ActionsListOrgSecretsResponse = z.infer<
    typeof ActionsListOrgSecretsResponseSchema
  >

  export const ActionsGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsGetOrgPublicKeyParams = z.infer<
    typeof ActionsGetOrgPublicKeyParamsSchema
  >

  export const ActionsGetOrgPublicKeyResponseSchema = ActionsPublicKeySchema
  export type ActionsGetOrgPublicKeyResponse = z.infer<
    typeof ActionsGetOrgPublicKeyResponseSchema
  >

  export const ActionsGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetOrgSecretParams = z.infer<
    typeof ActionsGetOrgSecretParamsSchema
  >

  export const ActionsGetOrgSecretResponseSchema =
    OrganizationActionsSecretSchema
  export type ActionsGetOrgSecretResponse = z.infer<
    typeof ActionsGetOrgSecretResponseSchema
  >

  export const ActionsCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateOrgSecretParams = z.infer<
    typeof ActionsCreateOrUpdateOrgSecretParamsSchema
  >

  export type ActionsCreateOrUpdateOrgSecretResponse = undefined

  export const ActionsDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteOrgSecretParams = z.infer<
    typeof ActionsDeleteOrgSecretParamsSchema
  >

  export type ActionsDeleteOrgSecretResponse = undefined

  export const ActionsListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ActionsListSelectedReposForOrgSecretParams = z.infer<
    typeof ActionsListSelectedReposForOrgSecretParamsSchema
  >

  export const ActionsListSelectedReposForOrgSecretResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(MinimalRepositorySchema)
  })
  export type ActionsListSelectedReposForOrgSecretResponse = z.infer<
    typeof ActionsListSelectedReposForOrgSecretResponseSchema
  >

  export const ActionsSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsSetSelectedReposForOrgSecretParams = z.infer<
    typeof ActionsSetSelectedReposForOrgSecretParamsSchema
  >

  export type ActionsSetSelectedReposForOrgSecretResponse = undefined

  export const ActionsAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type ActionsAddSelectedRepoToOrgSecretParams = z.infer<
    typeof ActionsAddSelectedRepoToOrgSecretParamsSchema
  >

  export type ActionsAddSelectedRepoToOrgSecretResponse = undefined

  export const ActionsRemoveSelectedRepoFromOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type ActionsRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof ActionsRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type ActionsRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const ActionsListOrgVariablesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListOrgVariablesParams = z.infer<
    typeof ActionsListOrgVariablesParamsSchema
  >

  export const ActionsListOrgVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(OrganizationActionsVariableSchema)
  })
  export type ActionsListOrgVariablesResponse = z.infer<
    typeof ActionsListOrgVariablesResponseSchema
  >

  export const ActionsCreateOrgVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsCreateOrgVariableParams = z.infer<
    typeof ActionsCreateOrgVariableParamsSchema
  >

  export type ActionsCreateOrgVariableResponse = undefined

  export const ActionsGetOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetOrgVariableParams = z.infer<
    typeof ActionsGetOrgVariableParamsSchema
  >

  export const ActionsGetOrgVariableResponseSchema =
    OrganizationActionsVariableSchema
  export type ActionsGetOrgVariableResponse = z.infer<
    typeof ActionsGetOrgVariableResponseSchema
  >

  export const ActionsDeleteOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsDeleteOrgVariableParams = z.infer<
    typeof ActionsDeleteOrgVariableParamsSchema
  >

  export type ActionsDeleteOrgVariableResponse = undefined

  export const ActionsUpdateOrgVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.'
      )
      .optional(),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ActionsUpdateOrgVariableParams = z.infer<
    typeof ActionsUpdateOrgVariableParamsSchema
  >

  export type ActionsUpdateOrgVariableResponse = undefined

  export const ActionsListSelectedReposForOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ActionsListSelectedReposForOrgVariableParams = z.infer<
    typeof ActionsListSelectedReposForOrgVariableParamsSchema
  >

  export const ActionsListSelectedReposForOrgVariableResponseSchema = z.object({
    total_count: z.number().int(),
    repositories: z.array(MinimalRepositorySchema)
  })
  export type ActionsListSelectedReposForOrgVariableResponse = z.infer<
    typeof ActionsListSelectedReposForOrgVariableResponseSchema
  >

  export const ActionsSetSelectedReposForOrgVariableParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'The IDs of the repositories that can access the organization variable.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsSetSelectedReposForOrgVariableParams = z.infer<
    typeof ActionsSetSelectedReposForOrgVariableParamsSchema
  >

  export type ActionsSetSelectedReposForOrgVariableResponse = undefined

  export const ActionsAddSelectedRepoToOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    repository_id: z.number().int()
  })
  export type ActionsAddSelectedRepoToOrgVariableParams = z.infer<
    typeof ActionsAddSelectedRepoToOrgVariableParamsSchema
  >

  export type ActionsAddSelectedRepoToOrgVariableResponse = undefined

  export const ActionsRemoveSelectedRepoFromOrgVariableParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    name: z.string().describe('The name of the variable.'),
    repository_id: z.number().int()
  })
  export type ActionsRemoveSelectedRepoFromOrgVariableParams = z.infer<
    typeof ActionsRemoveSelectedRepoFromOrgVariableParamsSchema
  >

  export type ActionsRemoveSelectedRepoFromOrgVariableResponse = undefined

  export const OrgsListAttestationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    subject_digest: z
      .string()
      .describe(
        "The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`."
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type OrgsListAttestationsParams = z.infer<
    typeof OrgsListAttestationsParamsSchema
  >

  export const OrgsListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type OrgsListAttestationsResponse = z.infer<
    typeof OrgsListAttestationsResponseSchema
  >

  export const OrgsListBlockedUsersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListBlockedUsersParams = z.infer<
    typeof OrgsListBlockedUsersParamsSchema
  >

  export const OrgsListBlockedUsersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListBlockedUsersResponse = z.infer<
    typeof OrgsListBlockedUsersResponseSchema
  >

  export const OrgsCheckBlockedUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckBlockedUserParams = z.infer<
    typeof OrgsCheckBlockedUserParamsSchema
  >

  export type OrgsCheckBlockedUserResponse = undefined

  export const OrgsBlockUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsBlockUserParams = z.infer<typeof OrgsBlockUserParamsSchema>

  export type OrgsBlockUserResponse = undefined

  export const OrgsUnblockUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsUnblockUserParams = z.infer<
    typeof OrgsUnblockUserParamsSchema
  >

  export type OrgsUnblockUserResponse = undefined

  export const CodeScanningListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    state: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this state will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property by which to sort the results.')
      .default('created'),
    severity: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this severity will be returned.'
      )
      .optional()
  })
  export type CodeScanningListAlertsForOrgParams = z.infer<
    typeof CodeScanningListAlertsForOrgParamsSchema
  >

  export const CodeScanningListAlertsForOrgResponseSchema = z.array(
    CodeScanningOrganizationAlertItemsSchema
  )
  export type CodeScanningListAlertsForOrgResponse = z.infer<
    typeof CodeScanningListAlertsForOrgResponseSchema
  >

  export const CodeSecurityGetConfigurationsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    target_type: z
      .enum(['global', 'all'])
      .describe('The target type of the code security configuration')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional()
  })
  export type CodeSecurityGetConfigurationsForOrgParams = z.infer<
    typeof CodeSecurityGetConfigurationsForOrgParamsSchema
  >

  export const CodeSecurityGetConfigurationsForOrgResponseSchema = z.array(
    CodeSecurityConfigurationSchema
  )
  export type CodeSecurityGetConfigurationsForOrgResponse = z.infer<
    typeof CodeSecurityGetConfigurationsForOrgResponseSchema
  >

  export const CodeSecurityCreateConfigurationParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the code security configuration. Must be unique within the organization.'
      ),
    description: z
      .string()
      .max(255)
      .describe('A description of the code security configuration'),
    advanced_security: z
      .enum(['enabled', 'disabled'])
      .describe('The enablement status of GitHub Advanced Security')
      .default('disabled'),
    dependency_graph: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependency Graph')
      .default('enabled'),
    dependency_graph_autosubmit_action: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Automatic dependency submission')
      .default('disabled'),
    dependency_graph_autosubmit_action_options: z
      .object({
        labeled_runners: z
          .boolean()
          .describe(
            "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
          )
          .default(false)
      })
      .describe('Feature options for Automatic dependency submission')
      .optional(),
    dependabot_alerts: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot alerts')
      .default('disabled'),
    dependabot_security_updates: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot security updates')
      .default('disabled'),
    code_scanning_default_setup: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of code scanning default setup')
      .default('disabled'),
    code_scanning_default_setup_options:
      CodeScanningDefaultSetupOptionsSchema.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of code scanning delegated alert dismissal'
      )
      .default('not_set'),
    secret_scanning: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning')
      .default('disabled'),
    secret_scanning_push_protection: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning push protection')
      .default('disabled'),
    secret_scanning_delegated_bypass: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning delegated bypass')
      .default('disabled'),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z
                .number()
                .int()
                .describe(
                  'The ID of the team or role selected as a bypass reviewer'
                ),
              reviewer_type: z
                .enum(['TEAM', 'ROLE'])
                .describe('The type of the bypass reviewer')
            })
          )
          .describe('The bypass reviewers for secret scanning delegated bypass')
          .optional()
      })
      .describe('Feature options for secret scanning delegated bypass')
      .optional(),
    secret_scanning_validity_checks: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning validity checks')
      .default('disabled'),
    secret_scanning_non_provider_patterns: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning non provider patterns'
      )
      .default('disabled'),
    secret_scanning_generic_secrets: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Copilot secret scanning')
      .default('disabled'),
    secret_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning delegated alert dismissal'
      )
      .optional(),
    private_vulnerability_reporting: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of private vulnerability reporting')
      .default('disabled'),
    enforcement: z
      .enum(['enforced', 'unenforced'])
      .describe('The enforcement status for a security configuration')
      .default('enforced'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityCreateConfigurationParams = z.infer<
    typeof CodeSecurityCreateConfigurationParamsSchema
  >

  export type CodeSecurityCreateConfigurationResponse = undefined

  export const CodeSecurityGetDefaultConfigurationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityGetDefaultConfigurationsParams = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsParamsSchema
  >

  export const CodeSecurityGetDefaultConfigurationsResponseSchema =
    CodeSecurityDefaultConfigurationsSchema
  export type CodeSecurityGetDefaultConfigurationsResponse = z.infer<
    typeof CodeSecurityGetDefaultConfigurationsResponseSchema
  >

  export const CodeSecurityDetachConfigurationParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe('An array of repository IDs to detach from configurations.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodeSecurityDetachConfigurationParams = z.infer<
    typeof CodeSecurityDetachConfigurationParamsSchema
  >

  export type CodeSecurityDetachConfigurationResponse = undefined

  export const CodeSecurityGetConfigurationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityGetConfigurationParams = z.infer<
    typeof CodeSecurityGetConfigurationParamsSchema
  >

  export const CodeSecurityGetConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityGetConfigurationResponse = z.infer<
    typeof CodeSecurityGetConfigurationResponseSchema
  >

  export const CodeSecurityDeleteConfigurationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityDeleteConfigurationParams = z.infer<
    typeof CodeSecurityDeleteConfigurationParamsSchema
  >

  export type CodeSecurityDeleteConfigurationResponse = undefined

  export const CodeSecurityUpdateConfigurationParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the code security configuration. Must be unique within the organization.'
      )
      .optional(),
    description: z
      .string()
      .max(255)
      .describe('A description of the code security configuration')
      .optional(),
    advanced_security: z
      .enum(['enabled', 'disabled'])
      .describe('The enablement status of GitHub Advanced Security')
      .optional(),
    dependency_graph: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependency Graph')
      .optional(),
    dependency_graph_autosubmit_action: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Automatic dependency submission')
      .optional(),
    dependency_graph_autosubmit_action_options: z
      .object({
        labeled_runners: z
          .boolean()
          .describe(
            "Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."
          )
          .optional()
      })
      .describe('Feature options for Automatic dependency submission')
      .optional(),
    dependabot_alerts: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot alerts')
      .optional(),
    dependabot_security_updates: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Dependabot security updates')
      .optional(),
    code_scanning_default_setup: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of code scanning default setup')
      .optional(),
    code_scanning_default_setup_options:
      CodeScanningDefaultSetupOptionsSchema.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of code scanning delegated alert dismissal'
      )
      .default('disabled'),
    secret_scanning: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning')
      .optional(),
    secret_scanning_push_protection: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning push protection')
      .optional(),
    secret_scanning_delegated_bypass: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning delegated bypass')
      .optional(),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z
                .number()
                .int()
                .describe(
                  'The ID of the team or role selected as a bypass reviewer'
                ),
              reviewer_type: z
                .enum(['TEAM', 'ROLE'])
                .describe('The type of the bypass reviewer')
            })
          )
          .describe('The bypass reviewers for secret scanning delegated bypass')
          .optional()
      })
      .describe('Feature options for secret scanning delegated bypass')
      .optional(),
    secret_scanning_validity_checks: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of secret scanning validity checks')
      .optional(),
    secret_scanning_non_provider_patterns: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning non-provider patterns'
      )
      .optional(),
    secret_scanning_generic_secrets: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of Copilot secret scanning')
      .optional(),
    secret_scanning_delegated_alert_dismissal: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe(
        'The enablement status of secret scanning delegated alert dismissal'
      )
      .optional(),
    private_vulnerability_reporting: z
      .enum(['enabled', 'disabled', 'not_set'])
      .describe('The enablement status of private vulnerability reporting')
      .optional(),
    enforcement: z
      .enum(['enforced', 'unenforced'])
      .describe('The enforcement status for a security configuration')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityUpdateConfigurationParams = z.infer<
    typeof CodeSecurityUpdateConfigurationParamsSchema
  >

  export const CodeSecurityUpdateConfigurationResponseSchema =
    CodeSecurityConfigurationSchema
  export type CodeSecurityUpdateConfigurationResponse = z.infer<
    typeof CodeSecurityUpdateConfigurationResponseSchema
  >

  export const CodeSecurityAttachConfigurationParamsSchema = z.object({
    scope: z
      .enum([
        'all',
        'all_without_configurations',
        'public',
        'private_or_internal',
        'selected'
      ])
      .describe(
        'The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids`'
      ),
    selected_repository_ids: z
      .array(z.number().int().describe('Unique identifier of the repository.'))
      .describe(
        'An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecurityAttachConfigurationParams = z.infer<
    typeof CodeSecurityAttachConfigurationParamsSchema
  >

  export type CodeSecurityAttachConfigurationResponse = undefined

  export const CodeSecuritySetConfigurationAsDefaultParamsSchema = z.object({
    default_for_new_repos: z
      .enum(['all', 'none', 'private_and_internal', 'public'])
      .describe(
        'Specify which types of repository this security configuration should be applied to by default.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    configuration_id: z
      .number()
      .int()
      .describe('The unique identifier of the code security configuration.')
  })
  export type CodeSecuritySetConfigurationAsDefaultParams = z.infer<
    typeof CodeSecuritySetConfigurationAsDefaultParamsSchema
  >

  export const CodeSecuritySetConfigurationAsDefaultResponseSchema = z.object({
    default_for_new_repos: z
      .enum(['all', 'none', 'private_and_internal', 'public'])
      .describe(
        'Specifies which types of repository this security configuration is applied to by default.'
      )
      .optional(),
    configuration: CodeSecurityConfigurationSchema.optional()
  })
  export type CodeSecuritySetConfigurationAsDefaultResponse = z.infer<
    typeof CodeSecuritySetConfigurationAsDefaultResponseSchema
  >

  export const CodeSecurityGetRepositoriesForConfigurationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      configuration_id: z
        .number()
        .int()
        .describe('The unique identifier of the code security configuration.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      status: z
        .string()
        .describe(
          'A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `detached`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`'
        )
        .default('all')
    })
  export type CodeSecurityGetRepositoriesForConfigurationParams = z.infer<
    typeof CodeSecurityGetRepositoriesForConfigurationParamsSchema
  >

  export const CodeSecurityGetRepositoriesForConfigurationResponseSchema =
    z.array(CodeSecurityConfigurationRepositoriesSchema)
  export type CodeSecurityGetRepositoriesForConfigurationResponse = z.infer<
    typeof CodeSecurityGetRepositoriesForConfigurationResponseSchema
  >

  export const CodespacesListInOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListInOrganizationParams = z.infer<
    typeof CodespacesListInOrganizationParamsSchema
  >

  export const CodespacesListInOrganizationResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesListInOrganizationResponse = z.infer<
    typeof CodespacesListInOrganizationResponseSchema
  >

  export const CodespacesSetCodespacesAccessParamsSchema = z.object({
    visibility: z
      .enum([
        'disabled',
        'selected_members',
        'all_members',
        'all_members_and_outside_collaborators'
      ])
      .describe(
        'Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.'
      ),
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesSetCodespacesAccessParams = z.infer<
    typeof CodespacesSetCodespacesAccessParamsSchema
  >

  export type CodespacesSetCodespacesAccessResponse = undefined

  export const CodespacesSetCodespacesAccessUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members whose codespaces be billed to the organization.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesSetCodespacesAccessUsersParams = z.infer<
    typeof CodespacesSetCodespacesAccessUsersParamsSchema
  >

  export type CodespacesSetCodespacesAccessUsersResponse = undefined

  export const CodespacesDeleteCodespacesAccessUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .max(100)
      .describe(
        'The usernames of the organization members whose codespaces should not be billed to the organization.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesDeleteCodespacesAccessUsersParams = z.infer<
    typeof CodespacesDeleteCodespacesAccessUsersParamsSchema
  >

  export type CodespacesDeleteCodespacesAccessUsersResponse = undefined

  export const CodespacesListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListOrgSecretsParams = z.infer<
    typeof CodespacesListOrgSecretsParamsSchema
  >

  export const CodespacesListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(CodespacesOrgSecretSchema)
  })
  export type CodespacesListOrgSecretsResponse = z.infer<
    typeof CodespacesListOrgSecretsResponseSchema
  >

  export const CodespacesGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CodespacesGetOrgPublicKeyParams = z.infer<
    typeof CodespacesGetOrgPublicKeyParamsSchema
  >

  export const CodespacesGetOrgPublicKeyResponseSchema =
    CodespacesPublicKeySchema
  export type CodespacesGetOrgPublicKeyResponse = z.infer<
    typeof CodespacesGetOrgPublicKeyResponseSchema
  >

  export const CodespacesGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetOrgSecretParams = z.infer<
    typeof CodespacesGetOrgSecretParamsSchema
  >

  export const CodespacesGetOrgSecretResponseSchema = CodespacesOrgSecretSchema
  export type CodespacesGetOrgSecretResponse = z.infer<
    typeof CodespacesGetOrgSecretResponseSchema
  >

  export const CodespacesCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('The ID of the key you used to encrypt the secret.')
      .optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesCreateOrUpdateOrgSecretParams = z.infer<
    typeof CodespacesCreateOrUpdateOrgSecretParamsSchema
  >

  export type CodespacesCreateOrUpdateOrgSecretResponse = undefined

  export const CodespacesDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesDeleteOrgSecretParams = z.infer<
    typeof CodespacesDeleteOrgSecretParamsSchema
  >

  export type CodespacesDeleteOrgSecretResponse = undefined

  export const CodespacesListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type CodespacesListSelectedReposForOrgSecretParams = z.infer<
    typeof CodespacesListSelectedReposForOrgSecretParamsSchema
  >

  export const CodespacesListSelectedReposForOrgSecretResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    }
  )
  export type CodespacesListSelectedReposForOrgSecretResponse = z.infer<
    typeof CodespacesListSelectedReposForOrgSecretResponseSchema
  >

  export const CodespacesSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesSetSelectedReposForOrgSecretParams = z.infer<
    typeof CodespacesSetSelectedReposForOrgSecretParamsSchema
  >

  export type CodespacesSetSelectedReposForOrgSecretResponse = undefined

  export const CodespacesAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type CodespacesAddSelectedRepoToOrgSecretParams = z.infer<
    typeof CodespacesAddSelectedRepoToOrgSecretParamsSchema
  >

  export type CodespacesAddSelectedRepoToOrgSecretResponse = undefined

  export const CodespacesRemoveSelectedRepoFromOrgSecretParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    }
  )
  export type CodespacesRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof CodespacesRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type CodespacesRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const CopilotGetCopilotOrganizationDetailsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotGetCopilotOrganizationDetailsParams = z.infer<
    typeof CopilotGetCopilotOrganizationDetailsParamsSchema
  >

  export const CopilotGetCopilotOrganizationDetailsResponseSchema =
    CopilotOrganizationDetailsSchema
  export type CopilotGetCopilotOrganizationDetailsResponse = z.infer<
    typeof CopilotGetCopilotOrganizationDetailsResponseSchema
  >

  export const CopilotListCopilotSeatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(50)
  })
  export type CopilotListCopilotSeatsParams = z.infer<
    typeof CopilotListCopilotSeatsParamsSchema
  >

  export const CopilotListCopilotSeatsResponseSchema = z.object({
    total_seats: z
      .number()
      .int()
      .describe(
        'Total number of Copilot seats for the organization currently being billed.'
      )
      .optional(),
    seats: z.array(CopilotSeatDetailsSchema).optional()
  })
  export type CopilotListCopilotSeatsResponse = z.infer<
    typeof CopilotListCopilotSeatsResponseSchema
  >

  export const CopilotAddCopilotSeatsForTeamsParamsSchema = z.object({
    selected_teams: z
      .array(z.string())
      .min(1)
      .describe(
        'List of team names within the organization to which to grant access to GitHub Copilot.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotAddCopilotSeatsForTeamsParams = z.infer<
    typeof CopilotAddCopilotSeatsForTeamsParamsSchema
  >

  export type CopilotAddCopilotSeatsForTeamsResponse = undefined

  export const CopilotCancelCopilotSeatAssignmentForTeamsParamsSchema =
    z.object({
      selected_teams: z
        .array(z.string())
        .min(1)
        .describe(
          'The names of teams from which to revoke access to GitHub Copilot.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type CopilotCancelCopilotSeatAssignmentForTeamsParams = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForTeamsParamsSchema
  >

  export const CopilotCancelCopilotSeatAssignmentForTeamsResponseSchema = z
    .object({ seats_cancelled: z.number().int() })
    .describe(
      'The total number of seats set to "pending cancellation" for members of the specified team(s).'
    )
  export type CopilotCancelCopilotSeatAssignmentForTeamsResponse = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForTeamsResponseSchema
  >

  export const CopilotAddCopilotSeatsForUsersParamsSchema = z.object({
    selected_usernames: z
      .array(z.string())
      .min(1)
      .describe(
        'The usernames of the organization members to be granted access to GitHub Copilot.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type CopilotAddCopilotSeatsForUsersParams = z.infer<
    typeof CopilotAddCopilotSeatsForUsersParamsSchema
  >

  export type CopilotAddCopilotSeatsForUsersResponse = undefined

  export const CopilotCancelCopilotSeatAssignmentForUsersParamsSchema =
    z.object({
      selected_usernames: z
        .array(z.string())
        .min(1)
        .describe(
          'The usernames of the organization members for which to revoke access to GitHub Copilot.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type CopilotCancelCopilotSeatAssignmentForUsersParams = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForUsersParamsSchema
  >

  export const CopilotCancelCopilotSeatAssignmentForUsersResponseSchema = z
    .object({ seats_cancelled: z.number().int() })
    .describe(
      'The total number of seats set to "pending cancellation" for the specified users.'
    )
  export type CopilotCancelCopilotSeatAssignmentForUsersResponse = z.infer<
    typeof CopilotCancelCopilotSeatAssignmentForUsersResponseSchema
  >

  export const CopilotCopilotMetricsForOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotCopilotMetricsForOrganizationParams = z.infer<
    typeof CopilotCopilotMetricsForOrganizationParamsSchema
  >

  export const CopilotCopilotMetricsForOrganizationResponseSchema = z.array(
    CopilotUsageMetricsDaySchema
  )
  export type CopilotCopilotMetricsForOrganizationResponse = z.infer<
    typeof CopilotCopilotMetricsForOrganizationResponseSchema
  >

  export const CopilotUsageMetricsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotUsageMetricsForOrgParams = z.infer<
    typeof CopilotUsageMetricsForOrgParamsSchema
  >

  export const CopilotUsageMetricsForOrgResponseSchema = z.array(
    CopilotUsageMetricsSchema
  )
  export type CopilotUsageMetricsForOrgResponse = z.infer<
    typeof CopilotUsageMetricsForOrgResponseSchema
  >

  export const DependabotListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListAlertsForOrgParams = z.infer<
    typeof DependabotListAlertsForOrgParamsSchema
  >

  export const DependabotListAlertsForOrgResponseSchema = z.array(
    DependabotAlertWithRepositorySchema
  )
  export type DependabotListAlertsForOrgResponse = z.infer<
    typeof DependabotListAlertsForOrgResponseSchema
  >

  export const DependabotListOrgSecretsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type DependabotListOrgSecretsParams = z.infer<
    typeof DependabotListOrgSecretsParamsSchema
  >

  export const DependabotListOrgSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(OrganizationDependabotSecretSchema)
  })
  export type DependabotListOrgSecretsResponse = z.infer<
    typeof DependabotListOrgSecretsResponseSchema
  >

  export const DependabotGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type DependabotGetOrgPublicKeyParams = z.infer<
    typeof DependabotGetOrgPublicKeyParamsSchema
  >

  export const DependabotGetOrgPublicKeyResponseSchema =
    DependabotPublicKeySchema
  export type DependabotGetOrgPublicKeyResponse = z.infer<
    typeof DependabotGetOrgPublicKeyResponseSchema
  >

  export const DependabotGetOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotGetOrgSecretParams = z.infer<
    typeof DependabotGetOrgSecretParamsSchema
  >

  export const DependabotGetOrgSecretResponseSchema =
    OrganizationDependabotSecretSchema
  export type DependabotGetOrgSecretResponse = z.infer<
    typeof DependabotGetOrgSecretResponseSchema
  >

  export const DependabotCreateOrUpdateOrgSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    visibility: z
      .enum(['all', 'private', 'selected'])
      .describe(
        'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.'
      ),
    selected_repository_ids: z
      .array(z.string())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotCreateOrUpdateOrgSecretParams = z.infer<
    typeof DependabotCreateOrUpdateOrgSecretParamsSchema
  >

  export type DependabotCreateOrUpdateOrgSecretResponse = undefined

  export const DependabotDeleteOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotDeleteOrgSecretParams = z.infer<
    typeof DependabotDeleteOrgSecretParamsSchema
  >

  export type DependabotDeleteOrgSecretResponse = undefined

  export const DependabotListSelectedReposForOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type DependabotListSelectedReposForOrgSecretParams = z.infer<
    typeof DependabotListSelectedReposForOrgSecretParamsSchema
  >

  export const DependabotListSelectedReposForOrgSecretResponseSchema = z.object(
    {
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    }
  )
  export type DependabotListSelectedReposForOrgSecretResponse = z.infer<
    typeof DependabotListSelectedReposForOrgSecretResponseSchema
  >

  export const DependabotSetSelectedReposForOrgSecretParamsSchema = z.object({
    selected_repository_ids: z
      .array(z.number().int())
      .describe(
        'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotSetSelectedReposForOrgSecretParams = z.infer<
    typeof DependabotSetSelectedReposForOrgSecretParamsSchema
  >

  export type DependabotSetSelectedReposForOrgSecretResponse = undefined

  export const DependabotAddSelectedRepoToOrgSecretParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.'),
    repository_id: z.number().int()
  })
  export type DependabotAddSelectedRepoToOrgSecretParams = z.infer<
    typeof DependabotAddSelectedRepoToOrgSecretParamsSchema
  >

  export type DependabotAddSelectedRepoToOrgSecretResponse = undefined

  export const DependabotRemoveSelectedRepoFromOrgSecretParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    }
  )
  export type DependabotRemoveSelectedRepoFromOrgSecretParams = z.infer<
    typeof DependabotRemoveSelectedRepoFromOrgSecretParamsSchema
  >

  export type DependabotRemoveSelectedRepoFromOrgSecretResponse = undefined

  export const PackagesListDockerMigrationConflictingPackagesForOrganizationParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type PackagesListDockerMigrationConflictingPackagesForOrganizationParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForOrganizationParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForOrganizationResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForOrganizationResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForOrganizationResponseSchema
    >

  export const ActivityListPublicOrgEventsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicOrgEventsParams = z.infer<
    typeof ActivityListPublicOrgEventsParamsSchema
  >

  export const ActivityListPublicOrgEventsResponseSchema = z.array(EventSchema)
  export type ActivityListPublicOrgEventsResponse = z.infer<
    typeof ActivityListPublicOrgEventsResponseSchema
  >

  export const OrgsListFailedInvitationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListFailedInvitationsParams = z.infer<
    typeof OrgsListFailedInvitationsParamsSchema
  >

  export const OrgsListFailedInvitationsResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type OrgsListFailedInvitationsResponse = z.infer<
    typeof OrgsListFailedInvitationsResponseSchema
  >

  export const OrgsListWebhooksParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListWebhooksParams = z.infer<
    typeof OrgsListWebhooksParamsSchema
  >

  export const OrgsListWebhooksResponseSchema = z.array(OrgHookSchema)
  export type OrgsListWebhooksResponse = z.infer<
    typeof OrgsListWebhooksResponseSchema
  >

  export const OrgsCreateWebhookParamsSchema = z.object({
    name: z.string().describe('Must be passed as "web".'),
    config: z
      .object({
        url: WebhookConfigUrlSchema,
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
        username: z.string().optional(),
        password: z.string().optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.'),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateWebhookParams = z.infer<
    typeof OrgsCreateWebhookParamsSchema
  >

  export type OrgsCreateWebhookResponse = undefined

  export const OrgsGetWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsGetWebhookParams = z.infer<typeof OrgsGetWebhookParamsSchema>

  export const OrgsGetWebhookResponseSchema = OrgHookSchema
  export type OrgsGetWebhookResponse = z.infer<
    typeof OrgsGetWebhookResponseSchema
  >

  export const OrgsDeleteWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsDeleteWebhookParams = z.infer<
    typeof OrgsDeleteWebhookParamsSchema
  >

  export type OrgsDeleteWebhookResponse = undefined

  export const OrgsUpdateWebhookParamsSchema = z.object({
    config: z
      .object({
        url: WebhookConfigUrlSchema,
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.')
      .optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    name: z.string().optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsUpdateWebhookParams = z.infer<
    typeof OrgsUpdateWebhookParamsSchema
  >

  export const OrgsUpdateWebhookResponseSchema = OrgHookSchema
  export type OrgsUpdateWebhookResponse = z.infer<
    typeof OrgsUpdateWebhookResponseSchema
  >

  export const OrgsGetWebhookConfigForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsGetWebhookConfigForOrgParams = z.infer<
    typeof OrgsGetWebhookConfigForOrgParamsSchema
  >

  export const OrgsGetWebhookConfigForOrgResponseSchema = WebhookConfigSchema
  export type OrgsGetWebhookConfigForOrgResponse = z.infer<
    typeof OrgsGetWebhookConfigForOrgResponseSchema
  >

  export const OrgsUpdateWebhookConfigForOrgParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsUpdateWebhookConfigForOrgParams = z.infer<
    typeof OrgsUpdateWebhookConfigForOrgParamsSchema
  >

  export const OrgsUpdateWebhookConfigForOrgResponseSchema = WebhookConfigSchema
  export type OrgsUpdateWebhookConfigForOrgResponse = z.infer<
    typeof OrgsUpdateWebhookConfigForOrgResponseSchema
  >

  export const OrgsListWebhookDeliveriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type OrgsListWebhookDeliveriesParams = z.infer<
    typeof OrgsListWebhookDeliveriesParamsSchema
  >

  export const OrgsListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type OrgsListWebhookDeliveriesResponse = z.infer<
    typeof OrgsListWebhookDeliveriesResponseSchema
  >

  export const OrgsGetWebhookDeliveryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type OrgsGetWebhookDeliveryParams = z.infer<
    typeof OrgsGetWebhookDeliveryParamsSchema
  >

  export const OrgsGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type OrgsGetWebhookDeliveryResponse = z.infer<
    typeof OrgsGetWebhookDeliveryResponseSchema
  >

  export const OrgsRedeliverWebhookDeliveryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type OrgsRedeliverWebhookDeliveryParams = z.infer<
    typeof OrgsRedeliverWebhookDeliveryParamsSchema
  >

  export type OrgsRedeliverWebhookDeliveryResponse = undefined

  export const OrgsPingWebhookParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type OrgsPingWebhookParams = z.infer<
    typeof OrgsPingWebhookParamsSchema
  >

  export type OrgsPingWebhookResponse = undefined

  export const ApiInsightsGetRouteStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'http_method',
            'api_route',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    api_route_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetRouteStatsByActorParams = z.infer<
    typeof ApiInsightsGetRouteStatsByActorParamsSchema
  >

  export const ApiInsightsGetRouteStatsByActorResponseSchema =
    ApiInsightsRouteStatsSchema
  export type ApiInsightsGetRouteStatsByActorResponse = z.infer<
    typeof ApiInsightsGetRouteStatsByActorResponseSchema
  >

  export const ApiInsightsGetSubjectStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    subject_name_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetSubjectStatsParams = z.infer<
    typeof ApiInsightsGetSubjectStatsParamsSchema
  >

  export const ApiInsightsGetSubjectStatsResponseSchema =
    ApiInsightsSubjectStatsSchema
  export type ApiInsightsGetSubjectStatsResponse = z.infer<
    typeof ApiInsightsGetSubjectStatsResponseSchema
  >

  export const ApiInsightsGetSummaryStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsParams = z.infer<
    typeof ApiInsightsGetSummaryStatsParamsSchema
  >

  export const ApiInsightsGetSummaryStatsResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsResponseSchema
  >

  export const ApiInsightsGetSummaryStatsByUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsByUserParams = z.infer<
    typeof ApiInsightsGetSummaryStatsByUserParamsSchema
  >

  export const ApiInsightsGetSummaryStatsByUserResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsByUserResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsByUserResponseSchema
  >

  export const ApiInsightsGetSummaryStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ApiInsightsGetSummaryStatsByActorParams = z.infer<
    typeof ApiInsightsGetSummaryStatsByActorParamsSchema
  >

  export const ApiInsightsGetSummaryStatsByActorResponseSchema =
    ApiInsightsSummaryStatsSchema
  export type ApiInsightsGetSummaryStatsByActorResponse = z.infer<
    typeof ApiInsightsGetSummaryStatsByActorResponseSchema
  >

  export const ApiInsightsGetTimeStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsParams = z.infer<
    typeof ApiInsightsGetTimeStatsParamsSchema
  >

  export const ApiInsightsGetTimeStatsResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsResponse = z.infer<
    typeof ApiInsightsGetTimeStatsResponseSchema
  >

  export const ApiInsightsGetTimeStatsByUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsByUserParams = z.infer<
    typeof ApiInsightsGetTimeStatsByUserParamsSchema
  >

  export const ApiInsightsGetTimeStatsByUserResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsByUserResponse = z.infer<
    typeof ApiInsightsGetTimeStatsByUserResponseSchema
  >

  export const ApiInsightsGetTimeStatsByActorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    actor_type: z
      .enum([
        'installation',
        'classic_pat',
        'fine_grained_pat',
        'oauth_app',
        'github_app_user_to_server'
      ])
      .describe('The type of the actor'),
    actor_id: z.number().int().describe('The ID of the actor'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    timestamp_increment: z
      .string()
      .describe(
        'The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)'
      )
  })
  export type ApiInsightsGetTimeStatsByActorParams = z.infer<
    typeof ApiInsightsGetTimeStatsByActorParamsSchema
  >

  export const ApiInsightsGetTimeStatsByActorResponseSchema =
    ApiInsightsTimeStatsSchema
  export type ApiInsightsGetTimeStatsByActorResponse = z.infer<
    typeof ApiInsightsGetTimeStatsByActorResponseSchema
  >

  export const ApiInsightsGetUserStatsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    user_id: z.string().describe('The ID of the user to query for stats'),
    min_timestamp: z
      .string()
      .describe(
        'The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      ),
    max_timestamp: z
      .string()
      .describe(
        'The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .array(
        z
          .enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
          ])
          .default('total_request_count')
      )
      .describe('The property to sort the results by.')
      .optional(),
    actor_name_substring: z
      .string()
      .describe(
        'Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.'
      )
      .optional()
  })
  export type ApiInsightsGetUserStatsParams = z.infer<
    typeof ApiInsightsGetUserStatsParamsSchema
  >

  export const ApiInsightsGetUserStatsResponseSchema =
    ApiInsightsUserStatsSchema
  export type ApiInsightsGetUserStatsResponse = z.infer<
    typeof ApiInsightsGetUserStatsResponseSchema
  >

  export const AppsGetOrgInstallationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type AppsGetOrgInstallationParams = z.infer<
    typeof AppsGetOrgInstallationParamsSchema
  >

  export const AppsGetOrgInstallationResponseSchema = InstallationSchema
  export type AppsGetOrgInstallationResponse = z.infer<
    typeof AppsGetOrgInstallationResponseSchema
  >

  export const OrgsListAppInstallationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListAppInstallationsParams = z.infer<
    typeof OrgsListAppInstallationsParamsSchema
  >

  export const OrgsListAppInstallationsResponseSchema = z.object({
    total_count: z.number().int(),
    installations: z.array(InstallationSchema)
  })
  export type OrgsListAppInstallationsResponse = z.infer<
    typeof OrgsListAppInstallationsResponseSchema
  >

  export const InteractionsGetRestrictionsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type InteractionsGetRestrictionsForOrgParams = z.infer<
    typeof InteractionsGetRestrictionsForOrgParamsSchema
  >

  export const InteractionsGetRestrictionsForOrgResponseSchema = z.union([
    InteractionLimitResponseSchema,
    z.object({}).strict()
  ])
  export type InteractionsGetRestrictionsForOrgResponse = z.infer<
    typeof InteractionsGetRestrictionsForOrgResponseSchema
  >

  export const InteractionsSetRestrictionsForOrgParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(InteractionLimitSchema)
  export type InteractionsSetRestrictionsForOrgParams = z.infer<
    typeof InteractionsSetRestrictionsForOrgParamsSchema
  >

  export const InteractionsSetRestrictionsForOrgResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForOrgResponse = z.infer<
    typeof InteractionsSetRestrictionsForOrgResponseSchema
  >

  export const InteractionsRemoveRestrictionsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type InteractionsRemoveRestrictionsForOrgParams = z.infer<
    typeof InteractionsRemoveRestrictionsForOrgParamsSchema
  >

  export type InteractionsRemoveRestrictionsForOrgResponse = undefined

  export const OrgsListPendingInvitationsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    role: z
      .enum([
        'all',
        'admin',
        'direct_member',
        'billing_manager',
        'hiring_manager'
      ])
      .describe('Filter invitations by their member role.')
      .default('all'),
    invitation_source: z
      .enum(['all', 'member', 'scim'])
      .describe('Filter invitations by their invitation source.')
      .default('all')
  })
  export type OrgsListPendingInvitationsParams = z.infer<
    typeof OrgsListPendingInvitationsParamsSchema
  >

  export const OrgsListPendingInvitationsResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type OrgsListPendingInvitationsResponse = z.infer<
    typeof OrgsListPendingInvitationsResponseSchema
  >

  export const OrgsCreateInvitationParamsSchema = z.object({
    invitee_id: z
      .number()
      .int()
      .describe(
        '**Required unless you provide `email`**. GitHub user ID for the person you are inviting.'
      )
      .optional(),
    email: z
      .string()
      .describe(
        '**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.'
      )
      .optional(),
    role: z
      .enum(['admin', 'direct_member', 'billing_manager', 'reinstate'])
      .describe(
        'The role for the new member. \n * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization. \n * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.'
      )
      .default('direct_member'),
    team_ids: z
      .array(z.number().int())
      .describe('Specify IDs for the teams you want to invite new members to.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateInvitationParams = z.infer<
    typeof OrgsCreateInvitationParamsSchema
  >

  export type OrgsCreateInvitationResponse = undefined

  export const OrgsCancelInvitationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type OrgsCancelInvitationParams = z.infer<
    typeof OrgsCancelInvitationParamsSchema
  >

  export type OrgsCancelInvitationResponse = undefined

  export const OrgsListInvitationTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListInvitationTeamsParams = z.infer<
    typeof OrgsListInvitationTeamsParamsSchema
  >

  export const OrgsListInvitationTeamsResponseSchema = z.array(TeamSchema)
  export type OrgsListInvitationTeamsResponse = z.infer<
    typeof OrgsListInvitationTeamsResponseSchema
  >

  export const OrgsListIssueTypesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListIssueTypesParams = z.infer<
    typeof OrgsListIssueTypesParamsSchema
  >

  export const OrgsListIssueTypesResponseSchema = z.array(IssueTypeSchema)
  export type OrgsListIssueTypesResponse = z.infer<
    typeof OrgsListIssueTypesResponseSchema
  >

  export const OrgsCreateIssueTypeParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
    .merge(OrganizationCreateIssueTypeSchema)
  export type OrgsCreateIssueTypeParams = z.infer<
    typeof OrgsCreateIssueTypeParamsSchema
  >

  export const OrgsCreateIssueTypeResponseSchema = IssueTypeSchema
  export type OrgsCreateIssueTypeResponse = z.infer<
    typeof OrgsCreateIssueTypeResponseSchema
  >

  export const OrgsUpdateIssueTypeParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      issue_type_id: z
        .number()
        .int()
        .describe('The unique identifier of the issue type.')
    })
    .merge(OrganizationUpdateIssueTypeSchema)
  export type OrgsUpdateIssueTypeParams = z.infer<
    typeof OrgsUpdateIssueTypeParamsSchema
  >

  export const OrgsUpdateIssueTypeResponseSchema = IssueTypeSchema
  export type OrgsUpdateIssueTypeResponse = z.infer<
    typeof OrgsUpdateIssueTypeResponseSchema
  >

  export const OrgsDeleteIssueTypeParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    issue_type_id: z
      .number()
      .int()
      .describe('The unique identifier of the issue type.')
  })
  export type OrgsDeleteIssueTypeParams = z.infer<
    typeof OrgsDeleteIssueTypeParamsSchema
  >

  export type OrgsDeleteIssueTypeResponse = undefined

  export const IssuesListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    type: z.string().describe('Can be the name of an issue type.').optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForOrgParams = z.infer<
    typeof IssuesListForOrgParamsSchema
  >

  export const IssuesListForOrgResponseSchema = z.array(IssueSchema)
  export type IssuesListForOrgResponse = z.infer<
    typeof IssuesListForOrgResponseSchema
  >

  export const OrgsListMembersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['2fa_disabled', 'all'])
      .describe(
        'Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. This options is only available for organization owners.'
      )
      .default('all'),
    role: z
      .enum(['all', 'admin', 'member'])
      .describe('Filter members returned by their role.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListMembersParams = z.infer<
    typeof OrgsListMembersParamsSchema
  >

  export const OrgsListMembersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListMembersResponse = z.infer<
    typeof OrgsListMembersResponseSchema
  >

  export const OrgsCheckMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckMembershipForUserParams = z.infer<
    typeof OrgsCheckMembershipForUserParamsSchema
  >

  export type OrgsCheckMembershipForUserResponse = undefined

  export const OrgsRemoveMemberParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveMemberParams = z.infer<
    typeof OrgsRemoveMemberParamsSchema
  >

  export type OrgsRemoveMemberResponse = undefined

  export const CodespacesGetCodespacesForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesGetCodespacesForUserInOrgParams = z.infer<
    typeof CodespacesGetCodespacesForUserInOrgParamsSchema
  >

  export const CodespacesGetCodespacesForUserInOrgResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesGetCodespacesForUserInOrgResponse = z.infer<
    typeof CodespacesGetCodespacesForUserInOrgResponseSchema
  >

  export const CodespacesDeleteFromOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesDeleteFromOrganizationParams = z.infer<
    typeof CodespacesDeleteFromOrganizationParamsSchema
  >

  export type CodespacesDeleteFromOrganizationResponse = undefined

  export const CodespacesStopInOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStopInOrganizationParams = z.infer<
    typeof CodespacesStopInOrganizationParamsSchema
  >

  export const CodespacesStopInOrganizationResponseSchema = CodespaceSchema
  export type CodespacesStopInOrganizationResponse = z.infer<
    typeof CodespacesStopInOrganizationResponseSchema
  >

  export const CopilotGetCopilotSeatDetailsForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type CopilotGetCopilotSeatDetailsForUserParams = z.infer<
    typeof CopilotGetCopilotSeatDetailsForUserParamsSchema
  >

  export const CopilotGetCopilotSeatDetailsForUserResponseSchema =
    CopilotSeatDetailsSchema
  export type CopilotGetCopilotSeatDetailsForUserResponse = z.infer<
    typeof CopilotGetCopilotSeatDetailsForUserResponseSchema
  >

  export const OrgsGetMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsGetMembershipForUserParams = z.infer<
    typeof OrgsGetMembershipForUserParamsSchema
  >

  export const OrgsGetMembershipForUserResponseSchema = OrgMembershipSchema
  export type OrgsGetMembershipForUserResponse = z.infer<
    typeof OrgsGetMembershipForUserResponseSchema
  >

  export const OrgsSetMembershipForUserParamsSchema = z.object({
    role: z
      .enum(['admin', 'member'])
      .describe(
        'The role to give the user in the organization. Can be one of:  \n * `admin` - The user will become an owner of the organization.  \n * `member` - The user will become a non-owner member of the organization.'
      )
      .default('member'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsSetMembershipForUserParams = z.infer<
    typeof OrgsSetMembershipForUserParamsSchema
  >

  export const OrgsSetMembershipForUserResponseSchema = OrgMembershipSchema
  export type OrgsSetMembershipForUserResponse = z.infer<
    typeof OrgsSetMembershipForUserResponseSchema
  >

  export const OrgsRemoveMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveMembershipForUserParams = z.infer<
    typeof OrgsRemoveMembershipForUserParamsSchema
  >

  export type OrgsRemoveMembershipForUserResponse = undefined

  export const MigrationsListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional()
  })
  export type MigrationsListForOrgParams = z.infer<
    typeof MigrationsListForOrgParamsSchema
  >

  export const MigrationsListForOrgResponseSchema = z.array(MigrationSchema)
  export type MigrationsListForOrgResponse = z.infer<
    typeof MigrationsListForOrgResponseSchema
  >

  export const MigrationsStartForOrgParamsSchema = z.object({
    repositories: z
      .array(z.string())
      .describe(
        'A list of arrays indicating which repositories should be migrated.'
      ),
    lock_repositories: z
      .boolean()
      .describe(
        'Indicates whether repositories should be locked (to prevent manipulation) while migrating data.'
      )
      .default(false),
    exclude_metadata: z
      .boolean()
      .describe(
        'Indicates whether metadata should be excluded and only git source should be included for the migration.'
      )
      .default(false),
    exclude_git_data: z
      .boolean()
      .describe(
        'Indicates whether the repository git data should be excluded from the migration.'
      )
      .default(false),
    exclude_attachments: z
      .boolean()
      .describe(
        'Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).'
      )
      .default(false),
    exclude_releases: z
      .boolean()
      .describe(
        'Indicates whether releases should be excluded from the migration (to reduce migration archive file size).'
      )
      .default(false),
    exclude_owner_projects: z
      .boolean()
      .describe(
        'Indicates whether projects owned by the organization or users should be excluded. from the migration.'
      )
      .default(false),
    org_metadata_only: z
      .boolean()
      .describe(
        'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).'
      )
      .default(false),
    exclude: z
      .array(z.literal('repositories'))
      .describe(
        'Exclude related items from being returned in the response in order to improve performance of the request.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type MigrationsStartForOrgParams = z.infer<
    typeof MigrationsStartForOrgParamsSchema
  >

  export type MigrationsStartForOrgResponse = undefined

  export const MigrationsGetStatusForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional()
  })
  export type MigrationsGetStatusForOrgParams = z.infer<
    typeof MigrationsGetStatusForOrgParamsSchema
  >

  export const MigrationsGetStatusForOrgResponseSchema = MigrationSchema
  export type MigrationsGetStatusForOrgResponse = z.infer<
    typeof MigrationsGetStatusForOrgResponseSchema
  >

  export const MigrationsDownloadArchiveForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsDownloadArchiveForOrgParams = z.infer<
    typeof MigrationsDownloadArchiveForOrgParamsSchema
  >

  export type MigrationsDownloadArchiveForOrgResponse = undefined

  export const MigrationsDeleteArchiveForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsDeleteArchiveForOrgParams = z.infer<
    typeof MigrationsDeleteArchiveForOrgParamsSchema
  >

  export type MigrationsDeleteArchiveForOrgResponse = undefined

  export const MigrationsUnlockRepoForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    repo_name: z.string().describe('repo_name parameter')
  })
  export type MigrationsUnlockRepoForOrgParams = z.infer<
    typeof MigrationsUnlockRepoForOrgParamsSchema
  >

  export type MigrationsUnlockRepoForOrgResponse = undefined

  export const MigrationsListReposForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListReposForOrgParams = z.infer<
    typeof MigrationsListReposForOrgParamsSchema
  >

  export const MigrationsListReposForOrgResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type MigrationsListReposForOrgResponse = z.infer<
    typeof MigrationsListReposForOrgResponseSchema
  >

  export const OrgsListOrgRolesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListOrgRolesParams = z.infer<
    typeof OrgsListOrgRolesParamsSchema
  >

  export const OrgsListOrgRolesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The total number of organization roles available to the organization.'
      )
      .optional(),
    roles: z
      .array(OrganizationRoleSchema)
      .describe('The list of organization roles available to the organization.')
      .optional()
  })
  export type OrgsListOrgRolesResponse = z.infer<
    typeof OrgsListOrgRolesResponseSchema
  >

  export const OrgsRevokeAllOrgRolesTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsRevokeAllOrgRolesTeamParams = z.infer<
    typeof OrgsRevokeAllOrgRolesTeamParamsSchema
  >

  export type OrgsRevokeAllOrgRolesTeamResponse = undefined

  export const OrgsAssignTeamToOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsAssignTeamToOrgRoleParams = z.infer<
    typeof OrgsAssignTeamToOrgRoleParamsSchema
  >

  export type OrgsAssignTeamToOrgRoleResponse = undefined

  export const OrgsRevokeOrgRoleTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsRevokeOrgRoleTeamParams = z.infer<
    typeof OrgsRevokeOrgRoleTeamParamsSchema
  >

  export type OrgsRevokeOrgRoleTeamResponse = undefined

  export const OrgsRevokeAllOrgRolesUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRevokeAllOrgRolesUserParams = z.infer<
    typeof OrgsRevokeAllOrgRolesUserParamsSchema
  >

  export type OrgsRevokeAllOrgRolesUserResponse = undefined

  export const OrgsAssignUserToOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsAssignUserToOrgRoleParams = z.infer<
    typeof OrgsAssignUserToOrgRoleParamsSchema
  >

  export type OrgsAssignUserToOrgRoleResponse = undefined

  export const OrgsRevokeOrgRoleUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsRevokeOrgRoleUserParams = z.infer<
    typeof OrgsRevokeOrgRoleUserParamsSchema
  >

  export type OrgsRevokeOrgRoleUserResponse = undefined

  export const OrgsGetOrgRoleParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.')
  })
  export type OrgsGetOrgRoleParams = z.infer<typeof OrgsGetOrgRoleParamsSchema>

  export const OrgsGetOrgRoleResponseSchema = OrganizationRoleSchema
  export type OrgsGetOrgRoleResponse = z.infer<
    typeof OrgsGetOrgRoleResponseSchema
  >

  export const OrgsListOrgRoleTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOrgRoleTeamsParams = z.infer<
    typeof OrgsListOrgRoleTeamsParamsSchema
  >

  export const OrgsListOrgRoleTeamsResponseSchema = z
    .array(TeamRoleAssignmentSchema)
    .describe('List of teams assigned to the organization role')
  export type OrgsListOrgRoleTeamsResponse = z.infer<
    typeof OrgsListOrgRoleTeamsResponseSchema
  >

  export const OrgsListOrgRoleUsersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    role_id: z.number().int().describe('The unique identifier of the role.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOrgRoleUsersParams = z.infer<
    typeof OrgsListOrgRoleUsersParamsSchema
  >

  export const OrgsListOrgRoleUsersResponseSchema = z
    .array(UserRoleAssignmentSchema)
    .describe('List of users assigned to the organization role')
  export type OrgsListOrgRoleUsersResponse = z.infer<
    typeof OrgsListOrgRoleUsersResponseSchema
  >

  export const OrgsListOutsideCollaboratorsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    filter: z
      .enum(['2fa_disabled', 'all'])
      .describe(
        'Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListOutsideCollaboratorsParams = z.infer<
    typeof OrgsListOutsideCollaboratorsParamsSchema
  >

  export const OrgsListOutsideCollaboratorsResponseSchema =
    z.array(SimpleUserSchema)
  export type OrgsListOutsideCollaboratorsResponse = z.infer<
    typeof OrgsListOutsideCollaboratorsResponseSchema
  >

  export const OrgsConvertMemberToOutsideCollaboratorParamsSchema = z.object({
    async: z
      .boolean()
      .describe(
        'When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.'
      )
      .default(false),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsConvertMemberToOutsideCollaboratorParams = z.infer<
    typeof OrgsConvertMemberToOutsideCollaboratorParamsSchema
  >

  export type OrgsConvertMemberToOutsideCollaboratorResponse = undefined

  export const OrgsRemoveOutsideCollaboratorParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsRemoveOutsideCollaboratorParams = z.infer<
    typeof OrgsRemoveOutsideCollaboratorParamsSchema
  >

  export type OrgsRemoveOutsideCollaboratorResponse = undefined

  export const PackagesListPackagesForOrganizationParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForOrganizationParams = z.infer<
    typeof PackagesListPackagesForOrganizationParamsSchema
  >

  export const PackagesListPackagesForOrganizationResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForOrganizationResponse = z.infer<
    typeof PackagesListPackagesForOrganizationResponseSchema
  >

  export const PackagesGetPackageForOrganizationParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PackagesGetPackageForOrganizationParams = z.infer<
    typeof PackagesGetPackageForOrganizationParamsSchema
  >

  export const PackagesGetPackageForOrganizationResponseSchema = PackageSchema
  export type PackagesGetPackageForOrganizationResponse = z.infer<
    typeof PackagesGetPackageForOrganizationResponseSchema
  >

  export const PackagesDeletePackageForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PackagesDeletePackageForOrgParams = z.infer<
    typeof PackagesDeletePackageForOrgParamsSchema
  >

  export type PackagesDeletePackageForOrgResponse = undefined

  export const PackagesRestorePackageForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    token: z.string().describe('package token').optional()
  })
  export type PackagesRestorePackageForOrgParams = z.infer<
    typeof PackagesRestorePackageForOrgParamsSchema
  >

  export type PackagesRestorePackageForOrgResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByOrgParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['active', 'deleted'])
        .describe('The state of the package, either active or deleted.')
        .default('active')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByOrgParams = z.infer<
    typeof PackagesGetAllPackageVersionsForPackageOwnedByOrgParamsSchema
  >

  export const PackagesGetAllPackageVersionsForPackageOwnedByOrgResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByOrgResponseSchema
    >

  export const PackagesGetPackageVersionForOrganizationParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesGetPackageVersionForOrganizationParams = z.infer<
    typeof PackagesGetPackageVersionForOrganizationParamsSchema
  >

  export const PackagesGetPackageVersionForOrganizationResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForOrganizationResponse = z.infer<
    typeof PackagesGetPackageVersionForOrganizationResponseSchema
  >

  export const PackagesDeletePackageVersionForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesDeletePackageVersionForOrgParams = z.infer<
    typeof PackagesDeletePackageVersionForOrgParamsSchema
  >

  export type PackagesDeletePackageVersionForOrgResponse = undefined

  export const PackagesRestorePackageVersionForOrgParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesRestorePackageVersionForOrgParams = z.infer<
    typeof PackagesRestorePackageVersionForOrgParamsSchema
  >

  export type PackagesRestorePackageVersionForOrgResponse = undefined

  export const OrgsListPatGrantRequestsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    sort: z
      .literal('created_at')
      .describe('The property by which to sort the results.')
      .default('created_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    owner: z
      .array(z.string())
      .max(10)
      .describe('A list of owner usernames to use to filter the results.')
      .optional(),
    repository: z
      .string()
      .describe('The name of the repository to use to filter the results.')
      .optional(),
    permission: z
      .string()
      .describe('The permission to use to filter the results.')
      .optional(),
    last_used_before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    last_used_after: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_id: z
      .array(z.string())
      .max(50)
      .describe('The ID of the token')
      .optional()
  })
  export type OrgsListPatGrantRequestsParams = z.infer<
    typeof OrgsListPatGrantRequestsParamsSchema
  >

  export const OrgsListPatGrantRequestsResponseSchema = z.array(
    OrganizationProgrammaticAccessGrantRequestSchema
  )
  export type OrgsListPatGrantRequestsResponse = z.infer<
    typeof OrgsListPatGrantRequestsResponseSchema
  >

  export const OrgsReviewPatGrantRequestsInBulkParamsSchema = z.object({
    pat_request_ids: z
      .array(z.number().int())
      .min(1)
      .max(100)
      .describe(
        'Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.'
      )
      .optional(),
    action: z
      .enum(['approve', 'deny'])
      .describe('Action to apply to the requests.'),
    reason: z
      .string()
      .max(1024)
      .describe(
        'Reason for approving or denying the requests. Max 1024 characters.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsReviewPatGrantRequestsInBulkParams = z.infer<
    typeof OrgsReviewPatGrantRequestsInBulkParamsSchema
  >

  export type OrgsReviewPatGrantRequestsInBulkResponse = undefined

  export const OrgsReviewPatGrantRequestParamsSchema = z.object({
    action: z
      .enum(['approve', 'deny'])
      .describe('Action to apply to the request.'),
    reason: z
      .string()
      .max(1024)
      .describe(
        'Reason for approving or denying the request. Max 1024 characters.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_request_id: z
      .number()
      .int()
      .describe(
        'Unique identifier of the request for access via fine-grained personal access token.'
      )
  })
  export type OrgsReviewPatGrantRequestParams = z.infer<
    typeof OrgsReviewPatGrantRequestParamsSchema
  >

  export type OrgsReviewPatGrantRequestResponse = undefined

  export const OrgsListPatGrantRequestRepositoriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_request_id: z
      .number()
      .int()
      .describe(
        'Unique identifier of the request for access via fine-grained personal access token.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPatGrantRequestRepositoriesParams = z.infer<
    typeof OrgsListPatGrantRequestRepositoriesParamsSchema
  >

  export const OrgsListPatGrantRequestRepositoriesResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type OrgsListPatGrantRequestRepositoriesResponse = z.infer<
    typeof OrgsListPatGrantRequestRepositoriesResponseSchema
  >

  export const OrgsListPatGrantsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    sort: z
      .literal('created_at')
      .describe('The property by which to sort the results.')
      .default('created_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    owner: z
      .array(z.string())
      .max(10)
      .describe('A list of owner usernames to use to filter the results.')
      .optional(),
    repository: z
      .string()
      .describe('The name of the repository to use to filter the results.')
      .optional(),
    permission: z
      .string()
      .describe('The permission to use to filter the results.')
      .optional(),
    last_used_before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    last_used_after: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    token_id: z
      .array(z.string())
      .max(50)
      .describe('The ID of the token')
      .optional()
  })
  export type OrgsListPatGrantsParams = z.infer<
    typeof OrgsListPatGrantsParamsSchema
  >

  export const OrgsListPatGrantsResponseSchema = z.array(
    OrganizationProgrammaticAccessGrantSchema
  )
  export type OrgsListPatGrantsResponse = z.infer<
    typeof OrgsListPatGrantsResponseSchema
  >

  export const OrgsUpdatePatAccessesParamsSchema = z.object({
    action: z
      .literal('revoke')
      .describe('Action to apply to the fine-grained personal access token.'),
    pat_ids: z
      .array(
        z
          .number()
          .int()
          .describe(
            'Unique identifier of the fine-grained personal access token.'
          )
      )
      .min(1)
      .max(100)
      .describe('The IDs of the fine-grained personal access tokens.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdatePatAccessesParams = z.infer<
    typeof OrgsUpdatePatAccessesParamsSchema
  >

  export type OrgsUpdatePatAccessesResponse = undefined

  export const OrgsUpdatePatAccessParamsSchema = z.object({
    action: z
      .literal('revoke')
      .describe('Action to apply to the fine-grained personal access token.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the fine-grained personal access token.'
      )
  })
  export type OrgsUpdatePatAccessParams = z.infer<
    typeof OrgsUpdatePatAccessParamsSchema
  >

  export type OrgsUpdatePatAccessResponse = undefined

  export const OrgsListPatGrantRepositoriesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    pat_id: z
      .number()
      .int()
      .describe('Unique identifier of the fine-grained personal access token.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPatGrantRepositoriesParams = z.infer<
    typeof OrgsListPatGrantRepositoriesParamsSchema
  >

  export const OrgsListPatGrantRepositoriesResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type OrgsListPatGrantRepositoriesResponse = z.infer<
    typeof OrgsListPatGrantRepositoriesResponseSchema
  >

  export const PrivateRegistriesListOrgPrivateRegistriesParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type PrivateRegistriesListOrgPrivateRegistriesParams = z.infer<
    typeof PrivateRegistriesListOrgPrivateRegistriesParamsSchema
  >

  export const PrivateRegistriesListOrgPrivateRegistriesResponseSchema =
    z.object({
      total_count: z.number().int(),
      configurations: z.array(OrgPrivateRegistryConfigurationSchema)
    })
  export type PrivateRegistriesListOrgPrivateRegistriesResponse = z.infer<
    typeof PrivateRegistriesListOrgPrivateRegistriesResponseSchema
  >

  export const PrivateRegistriesCreateOrgPrivateRegistryParamsSchema = z.object(
    {
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.'),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.'
        )
        .optional(),
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.'
        ),
      key_id: z
        .string()
        .describe('The ID of the key you used to encrypt the secret.'),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        ),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    }
  )
  export type PrivateRegistriesCreateOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesCreateOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesCreateOrgPrivateRegistryResponse = undefined

  export const PrivateRegistriesGetOrgPublicKeyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type PrivateRegistriesGetOrgPublicKeyParams = z.infer<
    typeof PrivateRegistriesGetOrgPublicKeyParamsSchema
  >

  export const PrivateRegistriesGetOrgPublicKeyResponseSchema = z.object({
    key_id: z.string().describe('The identifier for the key.'),
    key: z.string().describe('The Base64 encoded public key.')
  })
  export type PrivateRegistriesGetOrgPublicKeyResponse = z.infer<
    typeof PrivateRegistriesGetOrgPublicKeyResponseSchema
  >

  export const PrivateRegistriesGetOrgPrivateRegistryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type PrivateRegistriesGetOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesGetOrgPrivateRegistryParamsSchema
  >

  export const PrivateRegistriesGetOrgPrivateRegistryResponseSchema =
    OrgPrivateRegistryConfigurationSchema
  export type PrivateRegistriesGetOrgPrivateRegistryResponse = z.infer<
    typeof PrivateRegistriesGetOrgPrivateRegistryResponseSchema
  >

  export const PrivateRegistriesDeleteOrgPrivateRegistryParamsSchema = z.object(
    {
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.')
    }
  )
  export type PrivateRegistriesDeleteOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesDeleteOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesDeleteOrgPrivateRegistryResponse = undefined

  export const PrivateRegistriesUpdateOrgPrivateRegistryParamsSchema = z.object(
    {
      registry_type: z
        .literal('maven_repository')
        .describe('The registry type.')
        .optional(),
      username: z
        .string()
        .describe(
          'The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.'
        )
        .optional(),
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.'
        )
        .optional(),
      key_id: z
        .string()
        .describe('The ID of the key you used to encrypt the secret.')
        .optional(),
      visibility: z
        .enum(['all', 'private', 'selected'])
        .describe(
          'Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.'
        )
        .optional(),
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      secret_name: z.string().describe('The name of the secret.')
    }
  )
  export type PrivateRegistriesUpdateOrgPrivateRegistryParams = z.infer<
    typeof PrivateRegistriesUpdateOrgPrivateRegistryParamsSchema
  >

  export type PrivateRegistriesUpdateOrgPrivateRegistryResponse = undefined

  export const ProjectsListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForOrgParams = z.infer<
    typeof ProjectsListForOrgParamsSchema
  >

  export const ProjectsListForOrgResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForOrgResponse = z.infer<
    typeof ProjectsListForOrgResponseSchema
  >

  export const ProjectsCreateForOrgParamsSchema = z.object({
    name: z.string().describe('The name of the project.'),
    body: z.string().describe('The description of the project.').optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ProjectsCreateForOrgParams = z.infer<
    typeof ProjectsCreateForOrgParamsSchema
  >

  export type ProjectsCreateForOrgResponse = undefined

  export const OrgsGetAllCustomPropertiesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetAllCustomPropertiesParams = z.infer<
    typeof OrgsGetAllCustomPropertiesParamsSchema
  >

  export const OrgsGetAllCustomPropertiesResponseSchema =
    z.array(CustomPropertySchema)
  export type OrgsGetAllCustomPropertiesResponse = z.infer<
    typeof OrgsGetAllCustomPropertiesResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesParamsSchema = z.object({
    properties: z
      .array(CustomPropertySchema)
      .min(1)
      .max(100)
      .describe('The array of custom properties to create or update.'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsCreateOrUpdateCustomPropertiesParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesParamsSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesResponseSchema =
    z.array(CustomPropertySchema)
  export type OrgsCreateOrUpdateCustomPropertiesResponse = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesResponseSchema
  >

  export const OrgsGetCustomPropertyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    custom_property_name: z.string().describe('The custom property name')
  })
  export type OrgsGetCustomPropertyParams = z.infer<
    typeof OrgsGetCustomPropertyParamsSchema
  >

  export const OrgsGetCustomPropertyResponseSchema = CustomPropertySchema
  export type OrgsGetCustomPropertyResponse = z.infer<
    typeof OrgsGetCustomPropertyResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertyParamsSchema = z
    .object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      custom_property_name: z.string().describe('The custom property name')
    })
    .merge(CustomPropertySetPayloadSchema)
  export type OrgsCreateOrUpdateCustomPropertyParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertyParamsSchema
  >

  export const OrgsCreateOrUpdateCustomPropertyResponseSchema =
    CustomPropertySchema
  export type OrgsCreateOrUpdateCustomPropertyResponse = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertyResponseSchema
  >

  export const OrgsRemoveCustomPropertyParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    custom_property_name: z.string().describe('The custom property name')
  })
  export type OrgsRemoveCustomPropertyParams = z.infer<
    typeof OrgsRemoveCustomPropertyParamsSchema
  >

  export type OrgsRemoveCustomPropertyResponse = undefined

  export const OrgsListCustomPropertiesValuesForReposParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    repository_query: z
      .string()
      .describe(
        'Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.'
      )
      .optional()
  })
  export type OrgsListCustomPropertiesValuesForReposParams = z.infer<
    typeof OrgsListCustomPropertiesValuesForReposParamsSchema
  >

  export const OrgsListCustomPropertiesValuesForReposResponseSchema = z.array(
    OrgRepoCustomPropertyValuesSchema
  )
  export type OrgsListCustomPropertiesValuesForReposResponse = z.infer<
    typeof OrgsListCustomPropertiesValuesForReposResponseSchema
  >

  export const OrgsCreateOrUpdateCustomPropertiesValuesForReposParamsSchema =
    z.object({
      repository_names: z
        .array(z.string())
        .min(1)
        .max(30)
        .describe(
          'The names of repositories that the custom property values will be applied to.'
        ),
      properties: z
        .array(CustomPropertyValueSchema)
        .describe(
          'List of custom property names and associated values to apply to the repositories.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type OrgsCreateOrUpdateCustomPropertiesValuesForReposParams = z.infer<
    typeof OrgsCreateOrUpdateCustomPropertiesValuesForReposParamsSchema
  >

  export type OrgsCreateOrUpdateCustomPropertiesValuesForReposResponse =
    undefined

  export const OrgsListPublicMembersParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListPublicMembersParams = z.infer<
    typeof OrgsListPublicMembersParamsSchema
  >

  export const OrgsListPublicMembersResponseSchema = z.array(SimpleUserSchema)
  export type OrgsListPublicMembersResponse = z.infer<
    typeof OrgsListPublicMembersResponseSchema
  >

  export const OrgsCheckPublicMembershipForUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type OrgsCheckPublicMembershipForUserParams = z.infer<
    typeof OrgsCheckPublicMembershipForUserParamsSchema
  >

  export type OrgsCheckPublicMembershipForUserResponse = undefined

  export const OrgsSetPublicMembershipForAuthenticatedUserParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type OrgsSetPublicMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsSetPublicMembershipForAuthenticatedUserParamsSchema
  >

  export type OrgsSetPublicMembershipForAuthenticatedUserResponse = undefined

  export const OrgsRemovePublicMembershipForAuthenticatedUserParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type OrgsRemovePublicMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsRemovePublicMembershipForAuthenticatedUserParamsSchema
  >

  export type OrgsRemovePublicMembershipForAuthenticatedUserResponse = undefined

  export const ReposListForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    type: z
      .enum(['all', 'public', 'private', 'forks', 'sources', 'member'])
      .describe('Specifies the types of repositories you want returned.')
      .default('all'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForOrgParams = z.infer<
    typeof ReposListForOrgParamsSchema
  >

  export const ReposListForOrgResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForOrgResponse = z.infer<
    typeof ReposListForOrgResponseSchema
  >

  export const ReposCreateInOrgParamsSchema = z.object({
    name: z.string().describe('The name of the repository.'),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe('Whether the repository is private.')
      .default(false),
    visibility: z
      .enum(['public', 'private'])
      .describe('The visibility of the repository.')
      .optional(),
    has_issues: z
      .boolean()
      .describe(
        'Either `true` to enable issues for this repository or `false` to disable them.'
      )
      .default(true),
    has_projects: z
      .boolean()
      .describe(
        "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error."
      )
      .default(true),
    has_wiki: z
      .boolean()
      .describe(
        'Either `true` to enable the wiki for this repository or `false` to disable it.'
      )
      .default(true),
    has_downloads: z
      .boolean()
      .describe('Whether downloads are enabled.')
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Either `true` to make this repo available as a template repository or `false` to prevent it.'
      )
      .default(false),
    team_id: z
      .number()
      .int()
      .describe(
        'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
      )
      .optional(),
    auto_init: z
      .boolean()
      .describe('Pass `true` to create an initial commit with empty README.')
      .default(false),
    gitignore_template: z
      .string()
      .describe(
        'Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".'
      )
      .optional(),
    license_template: z
      .string()
      .describe(
        'Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".'
      )
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.'
      )
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe(
        'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.'
      )
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe(
        'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.'
      )
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe(
        'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.'
      )
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe(
        'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**'
      )
      .default(false),
    use_squash_pr_title_as_default: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.'
      )
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    custom_properties: z
      .record(z.any())
      .describe(
        'The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ReposCreateInOrgParams = z.infer<
    typeof ReposCreateInOrgParamsSchema
  >

  export type ReposCreateInOrgResponse = undefined

  export const ReposGetOrgRulesetsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    targets: z
      .string()
      .describe(
        'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
      )
      .optional()
  })
  export type ReposGetOrgRulesetsParams = z.infer<
    typeof ReposGetOrgRulesetsParamsSchema
  >

  export const ReposGetOrgRulesetsResponseSchema = z.array(
    RepositoryRulesetSchema
  )
  export type ReposGetOrgRulesetsResponse = z.infer<
    typeof ReposGetOrgRulesetsResponseSchema
  >

  export const ReposCreateOrgRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.'),
    target: z
      .enum(['branch', 'tag', 'push', 'repository'])
      .describe('The target of the ruleset')
      .default('branch'),
    enforcement: RepositoryRuleEnforcementSchema,
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: OrgRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type ReposCreateOrgRulesetParams = z.infer<
    typeof ReposCreateOrgRulesetParamsSchema
  >

  export type ReposCreateOrgRulesetResponse = undefined

  export const ReposGetOrgRuleSuitesParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ref: z
      .string()
      .describe(
        'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
      )
      .optional(),
    repository_name: z
      .string()
      .describe('The name of the repository to filter on.')
      .optional(),
    time_period: z
      .enum(['hour', 'day', 'week', 'month'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
      )
      .default('day'),
    actor_name: z
      .string()
      .describe(
        'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
      )
      .optional(),
    rule_suite_result: z
      .enum(['pass', 'fail', 'bypass', 'all'])
      .describe(
        'The rule results to filter on. When specified, only suites with this result will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetOrgRuleSuitesParams = z.infer<
    typeof ReposGetOrgRuleSuitesParamsSchema
  >

  export const ReposGetOrgRuleSuitesResponseSchema = RuleSuitesSchema
  export type ReposGetOrgRuleSuitesResponse = z.infer<
    typeof ReposGetOrgRuleSuitesResponseSchema
  >

  export const ReposGetOrgRuleSuiteParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    rule_suite_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
      )
  })
  export type ReposGetOrgRuleSuiteParams = z.infer<
    typeof ReposGetOrgRuleSuiteParamsSchema
  >

  export const ReposGetOrgRuleSuiteResponseSchema = RuleSuiteSchema
  export type ReposGetOrgRuleSuiteResponse = z.infer<
    typeof ReposGetOrgRuleSuiteResponseSchema
  >

  export const ReposGetOrgRulesetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposGetOrgRulesetParams = z.infer<
    typeof ReposGetOrgRulesetParamsSchema
  >

  export const ReposGetOrgRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposGetOrgRulesetResponse = z.infer<
    typeof ReposGetOrgRulesetResponseSchema
  >

  export const ReposUpdateOrgRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.').optional(),
    target: z
      .enum(['branch', 'tag', 'push', 'repository'])
      .describe('The target of the ruleset')
      .optional(),
    enforcement: RepositoryRuleEnforcementSchema.optional(),
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: OrgRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposUpdateOrgRulesetParams = z.infer<
    typeof ReposUpdateOrgRulesetParamsSchema
  >

  export const ReposUpdateOrgRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposUpdateOrgRulesetResponse = z.infer<
    typeof ReposUpdateOrgRulesetResponseSchema
  >

  export const ReposDeleteOrgRulesetParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposDeleteOrgRulesetParams = z.infer<
    typeof ReposDeleteOrgRulesetParamsSchema
  >

  export type ReposDeleteOrgRulesetResponse = undefined

  export const OrgsGetOrgRulesetHistoryParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsGetOrgRulesetHistoryParams = z.infer<
    typeof OrgsGetOrgRulesetHistoryParamsSchema
  >

  export const OrgsGetOrgRulesetHistoryResponseSchema =
    z.array(RulesetVersionSchema)
  export type OrgsGetOrgRulesetHistoryResponse = z.infer<
    typeof OrgsGetOrgRulesetHistoryResponseSchema
  >

  export const OrgsGetOrgRulesetVersionParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    version_id: z.number().int().describe('The ID of the version')
  })
  export type OrgsGetOrgRulesetVersionParams = z.infer<
    typeof OrgsGetOrgRulesetVersionParamsSchema
  >

  export const OrgsGetOrgRulesetVersionResponseSchema =
    RulesetVersionWithStateSchema
  export type OrgsGetOrgRulesetVersionResponse = z.infer<
    typeof OrgsGetOrgRulesetVersionResponseSchema
  >

  export const SecretScanningListAlertsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForOrgParams = z.infer<
    typeof SecretScanningListAlertsForOrgParamsSchema
  >

  export const SecretScanningListAlertsForOrgResponseSchema = z.array(
    OrganizationSecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForOrgResponse = z.infer<
    typeof SecretScanningListAlertsForOrgResponseSchema
  >

  export const SecurityAdvisoriesListOrgRepositoryAdvisoriesParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      sort: z
        .enum(['created', 'updated', 'published'])
        .describe('The property to sort the results by.')
        .default('created'),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .gte(1)
        .lte(100)
        .describe(
          'The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['triage', 'draft', 'published', 'closed'])
        .describe(
          'Filter by the state of the repository advisories. Only advisories of this state will be returned.'
        )
        .optional()
    })
  export type SecurityAdvisoriesListOrgRepositoryAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListOrgRepositoryAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListOrgRepositoryAdvisoriesResponseSchema =
    z.array(RepositoryAdvisorySchema)
  export type SecurityAdvisoriesListOrgRepositoryAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListOrgRepositoryAdvisoriesResponseSchema
  >

  export const OrgsListSecurityManagerTeamsParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsListSecurityManagerTeamsParams = z.infer<
    typeof OrgsListSecurityManagerTeamsParamsSchema
  >

  export const OrgsListSecurityManagerTeamsResponseSchema =
    z.array(TeamSimpleSchema)
  export type OrgsListSecurityManagerTeamsResponse = z.infer<
    typeof OrgsListSecurityManagerTeamsResponseSchema
  >

  export const OrgsAddSecurityManagerTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsAddSecurityManagerTeamParams = z.infer<
    typeof OrgsAddSecurityManagerTeamParamsSchema
  >

  export type OrgsAddSecurityManagerTeamResponse = undefined

  export const OrgsRemoveSecurityManagerTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type OrgsRemoveSecurityManagerTeamParams = z.infer<
    typeof OrgsRemoveSecurityManagerTeamParamsSchema
  >

  export type OrgsRemoveSecurityManagerTeamResponse = undefined

  export const BillingGetGithubActionsBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetGithubActionsBillingOrgParams = z.infer<
    typeof BillingGetGithubActionsBillingOrgParamsSchema
  >

  export const BillingGetGithubActionsBillingOrgResponseSchema =
    ActionsBillingUsageSchema
  export type BillingGetGithubActionsBillingOrgResponse = z.infer<
    typeof BillingGetGithubActionsBillingOrgResponseSchema
  >

  export const BillingGetGithubPackagesBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetGithubPackagesBillingOrgParams = z.infer<
    typeof BillingGetGithubPackagesBillingOrgParamsSchema
  >

  export const BillingGetGithubPackagesBillingOrgResponseSchema =
    PackagesBillingUsageSchema
  export type BillingGetGithubPackagesBillingOrgResponse = z.infer<
    typeof BillingGetGithubPackagesBillingOrgResponseSchema
  >

  export const BillingGetSharedStorageBillingOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type BillingGetSharedStorageBillingOrgParams = z.infer<
    typeof BillingGetSharedStorageBillingOrgParamsSchema
  >

  export const BillingGetSharedStorageBillingOrgResponseSchema =
    CombinedBillingUsageSchema
  export type BillingGetSharedStorageBillingOrgResponse = z.infer<
    typeof BillingGetSharedStorageBillingOrgResponseSchema
  >

  export const HostedComputeListNetworkConfigurationsForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type HostedComputeListNetworkConfigurationsForOrgParams = z.infer<
    typeof HostedComputeListNetworkConfigurationsForOrgParamsSchema
  >

  export const HostedComputeListNetworkConfigurationsForOrgResponseSchema =
    z.object({
      total_count: z.number().int(),
      network_configurations: z.array(NetworkConfigurationSchema)
    })
  export type HostedComputeListNetworkConfigurationsForOrgResponse = z.infer<
    typeof HostedComputeListNetworkConfigurationsForOrgResponseSchema
  >

  export const HostedComputeCreateNetworkConfigurationForOrgParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          "Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
        ),
      compute_service: z
        .enum(['none', 'actions'])
        .describe(
          'The hosted compute service to use for the network configuration.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .min(1)
        .max(1)
        .describe(
          'The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.')
    })
  export type HostedComputeCreateNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeCreateNetworkConfigurationForOrgParamsSchema
  >

  export type HostedComputeCreateNetworkConfigurationForOrgResponse = undefined

  export const HostedComputeGetNetworkConfigurationForOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeGetNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeGetNetworkConfigurationForOrgParamsSchema
  >

  export const HostedComputeGetNetworkConfigurationForOrgResponseSchema =
    NetworkConfigurationSchema
  export type HostedComputeGetNetworkConfigurationForOrgResponse = z.infer<
    typeof HostedComputeGetNetworkConfigurationForOrgResponseSchema
  >

  export const HostedComputeDeleteNetworkConfigurationFromOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeDeleteNetworkConfigurationFromOrgParams = z.infer<
    typeof HostedComputeDeleteNetworkConfigurationFromOrgParamsSchema
  >

  export type HostedComputeDeleteNetworkConfigurationFromOrgResponse = undefined

  export const HostedComputeUpdateNetworkConfigurationForOrgParamsSchema =
    z.object({
      name: z
        .string()
        .describe(
          "Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."
        )
        .optional(),
      compute_service: z
        .enum(['none', 'actions'])
        .describe(
          'The hosted compute service to use for the network configuration.'
        )
        .optional(),
      network_settings_ids: z
        .array(z.string())
        .min(0)
        .max(1)
        .describe(
          'The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.'
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      network_configuration_id: z
        .string()
        .describe(
          'Unique identifier of the hosted compute network configuration.'
        )
    })
  export type HostedComputeUpdateNetworkConfigurationForOrgParams = z.infer<
    typeof HostedComputeUpdateNetworkConfigurationForOrgParamsSchema
  >

  export const HostedComputeUpdateNetworkConfigurationForOrgResponseSchema =
    NetworkConfigurationSchema
  export type HostedComputeUpdateNetworkConfigurationForOrgResponse = z.infer<
    typeof HostedComputeUpdateNetworkConfigurationForOrgResponseSchema
  >

  export const HostedComputeGetNetworkSettingsForOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    network_settings_id: z
      .string()
      .describe('Unique identifier of the hosted compute network settings.')
  })
  export type HostedComputeGetNetworkSettingsForOrgParams = z.infer<
    typeof HostedComputeGetNetworkSettingsForOrgParamsSchema
  >

  export const HostedComputeGetNetworkSettingsForOrgResponseSchema =
    NetworkSettingsSchema
  export type HostedComputeGetNetworkSettingsForOrgResponse = z.infer<
    typeof HostedComputeGetNetworkSettingsForOrgResponseSchema
  >

  export const CopilotCopilotMetricsForTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotCopilotMetricsForTeamParams = z.infer<
    typeof CopilotCopilotMetricsForTeamParamsSchema
  >

  export const CopilotCopilotMetricsForTeamResponseSchema = z.array(
    CopilotUsageMetricsDaySchema
  )
  export type CopilotCopilotMetricsForTeamResponse = z.infer<
    typeof CopilotCopilotMetricsForTeamResponseSchema
  >

  export const CopilotUsageMetricsForTeamParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    since: z
      .string()
      .describe(
        'Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.'
      )
      .optional(),
    until: z
      .string()
      .describe(
        'Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(28)
  })
  export type CopilotUsageMetricsForTeamParams = z.infer<
    typeof CopilotUsageMetricsForTeamParamsSchema
  >

  export const CopilotUsageMetricsForTeamResponseSchema = z.array(
    CopilotUsageMetricsSchema
  )
  export type CopilotUsageMetricsForTeamResponse = z.infer<
    typeof CopilotUsageMetricsForTeamResponseSchema
  >

  export const TeamsListParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListParams = z.infer<typeof TeamsListParamsSchema>

  export const TeamsListResponseSchema = z.array(TeamSchema)
  export type TeamsListResponse = z.infer<typeof TeamsListResponseSchema>

  export const TeamsCreateParamsSchema = z.object({
    name: z.string().describe('The name of the team.'),
    description: z.string().describe('The description of the team.').optional(),
    maintainers: z
      .array(z.string())
      .describe(
        'List GitHub IDs for organization members who will become team maintainers.'
      )
      .optional(),
    repo_names: z
      .array(z.string())
      .describe(
        'The full name (e.g., "organization-name/repository-name") of repositories to add the team to.'
      )
      .optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.  \nDefault for child team: `closed`'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. The options are:  \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.  \nDefault: `notifications_enabled`'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type TeamsCreateParams = z.infer<typeof TeamsCreateParamsSchema>

  export type TeamsCreateResponse = undefined

  export const TeamsGetByNameParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsGetByNameParams = z.infer<typeof TeamsGetByNameParamsSchema>

  export const TeamsGetByNameResponseSchema = TeamFullSchema
  export type TeamsGetByNameResponse = z.infer<
    typeof TeamsGetByNameResponseSchema
  >

  export const TeamsDeleteInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsDeleteInOrgParams = z.infer<
    typeof TeamsDeleteInOrgParamsSchema
  >

  export type TeamsDeleteInOrgResponse = undefined

  export const TeamsUpdateInOrgParamsSchema = z.object({
    name: z.string().describe('The name of the team.').optional(),
    description: z.string().describe('The description of the team.').optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsUpdateInOrgParams = z.infer<
    typeof TeamsUpdateInOrgParamsSchema
  >

  export const TeamsUpdateInOrgResponseSchema = TeamFullSchema
  export type TeamsUpdateInOrgResponse = z.infer<
    typeof TeamsUpdateInOrgResponseSchema
  >

  export const TeamsListDiscussionsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    pinned: z.string().describe('Pinned discussions only filter').optional()
  })
  export type TeamsListDiscussionsInOrgParams = z.infer<
    typeof TeamsListDiscussionsInOrgParamsSchema
  >

  export const TeamsListDiscussionsInOrgResponseSchema =
    z.array(TeamDiscussionSchema)
  export type TeamsListDiscussionsInOrgResponse = z.infer<
    typeof TeamsListDiscussionsInOrgResponseSchema
  >

  export const TeamsCreateDiscussionInOrgParamsSchema = z.object({
    title: z.string().describe("The discussion post's title."),
    body: z.string().describe("The discussion post's body text."),
    private: z
      .boolean()
      .describe(
        'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.'
      )
      .default(false),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.')
  })
  export type TeamsCreateDiscussionInOrgParams = z.infer<
    typeof TeamsCreateDiscussionInOrgParamsSchema
  >

  export type TeamsCreateDiscussionInOrgResponse = undefined

  export const TeamsGetDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsGetDiscussionInOrgParams = z.infer<
    typeof TeamsGetDiscussionInOrgParamsSchema
  >

  export const TeamsGetDiscussionInOrgResponseSchema = TeamDiscussionSchema
  export type TeamsGetDiscussionInOrgResponse = z.infer<
    typeof TeamsGetDiscussionInOrgResponseSchema
  >

  export const TeamsDeleteDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsDeleteDiscussionInOrgParams = z.infer<
    typeof TeamsDeleteDiscussionInOrgParamsSchema
  >

  export type TeamsDeleteDiscussionInOrgResponse = undefined

  export const TeamsUpdateDiscussionInOrgParamsSchema = z.object({
    title: z.string().describe("The discussion post's title.").optional(),
    body: z.string().describe("The discussion post's body text.").optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsUpdateDiscussionInOrgParams = z.infer<
    typeof TeamsUpdateDiscussionInOrgParamsSchema
  >

  export const TeamsUpdateDiscussionInOrgResponseSchema = TeamDiscussionSchema
  export type TeamsUpdateDiscussionInOrgResponse = z.infer<
    typeof TeamsUpdateDiscussionInOrgResponseSchema
  >

  export const TeamsListDiscussionCommentsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionCommentsInOrgParams = z.infer<
    typeof TeamsListDiscussionCommentsInOrgParamsSchema
  >

  export const TeamsListDiscussionCommentsInOrgResponseSchema = z.array(
    TeamDiscussionCommentSchema
  )
  export type TeamsListDiscussionCommentsInOrgResponse = z.infer<
    typeof TeamsListDiscussionCommentsInOrgResponseSchema
  >

  export const TeamsCreateDiscussionCommentInOrgParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsCreateDiscussionCommentInOrgParams = z.infer<
    typeof TeamsCreateDiscussionCommentInOrgParamsSchema
  >

  export type TeamsCreateDiscussionCommentInOrgResponse = undefined

  export const TeamsGetDiscussionCommentInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsGetDiscussionCommentInOrgParams = z.infer<
    typeof TeamsGetDiscussionCommentInOrgParamsSchema
  >

  export const TeamsGetDiscussionCommentInOrgResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsGetDiscussionCommentInOrgResponse = z.infer<
    typeof TeamsGetDiscussionCommentInOrgResponseSchema
  >

  export const TeamsDeleteDiscussionCommentInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsDeleteDiscussionCommentInOrgParams = z.infer<
    typeof TeamsDeleteDiscussionCommentInOrgParamsSchema
  >

  export type TeamsDeleteDiscussionCommentInOrgResponse = undefined

  export const TeamsUpdateDiscussionCommentInOrgParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsUpdateDiscussionCommentInOrgParams = z.infer<
    typeof TeamsUpdateDiscussionCommentInOrgParamsSchema
  >

  export const TeamsUpdateDiscussionCommentInOrgResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsUpdateDiscussionCommentInOrgResponse = z.infer<
    typeof TeamsUpdateDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsListForTeamDiscussionCommentInOrgParamsSchema =
    z.object({
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      team_slug: z.string().describe('The slug of the team name.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.'),
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ReactionsListForTeamDiscussionCommentInOrgParams = z.infer<
    typeof ReactionsListForTeamDiscussionCommentInOrgParamsSchema
  >

  export const ReactionsListForTeamDiscussionCommentInOrgResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionCommentInOrgResponse = z.infer<
    typeof ReactionsListForTeamDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentInOrgParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.'
        ),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      team_slug: z.string().describe('The slug of the team name.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.')
    })
  export type ReactionsCreateForTeamDiscussionCommentInOrgParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentInOrgParamsSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentInOrgResponseSchema =
    ReactionSchema
  export type ReactionsCreateForTeamDiscussionCommentInOrgResponse = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentInOrgResponseSchema
  >

  export const ReactionsDeleteForTeamDiscussionCommentParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForTeamDiscussionCommentParams = z.infer<
    typeof ReactionsDeleteForTeamDiscussionCommentParamsSchema
  >

  export type ReactionsDeleteForTeamDiscussionCommentResponse = undefined

  export const ReactionsListForTeamDiscussionInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForTeamDiscussionInOrgParams = z.infer<
    typeof ReactionsListForTeamDiscussionInOrgParamsSchema
  >

  export const ReactionsListForTeamDiscussionInOrgResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionInOrgResponse = z.infer<
    typeof ReactionsListForTeamDiscussionInOrgResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionInOrgParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type ReactionsCreateForTeamDiscussionInOrgParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionInOrgParamsSchema
  >

  export const ReactionsCreateForTeamDiscussionInOrgResponseSchema =
    ReactionSchema
  export type ReactionsCreateForTeamDiscussionInOrgResponse = z.infer<
    typeof ReactionsCreateForTeamDiscussionInOrgResponseSchema
  >

  export const ReactionsDeleteForTeamDiscussionParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForTeamDiscussionParams = z.infer<
    typeof ReactionsDeleteForTeamDiscussionParamsSchema
  >

  export type ReactionsDeleteForTeamDiscussionResponse = undefined

  export const TeamsListPendingInvitationsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListPendingInvitationsInOrgParams = z.infer<
    typeof TeamsListPendingInvitationsInOrgParamsSchema
  >

  export const TeamsListPendingInvitationsInOrgResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type TeamsListPendingInvitationsInOrgResponse = z.infer<
    typeof TeamsListPendingInvitationsInOrgResponseSchema
  >

  export const TeamsListMembersInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    role: z
      .enum(['member', 'maintainer', 'all'])
      .describe('Filters members returned by their role in the team.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListMembersInOrgParams = z.infer<
    typeof TeamsListMembersInOrgParamsSchema
  >

  export const TeamsListMembersInOrgResponseSchema = z.array(SimpleUserSchema)
  export type TeamsListMembersInOrgResponse = z.infer<
    typeof TeamsListMembersInOrgResponseSchema
  >

  export const TeamsGetMembershipForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMembershipForUserInOrgParams = z.infer<
    typeof TeamsGetMembershipForUserInOrgParamsSchema
  >

  export const TeamsGetMembershipForUserInOrgResponseSchema =
    TeamMembershipSchema
  export type TeamsGetMembershipForUserInOrgResponse = z.infer<
    typeof TeamsGetMembershipForUserInOrgResponseSchema
  >

  export const TeamsAddOrUpdateMembershipForUserInOrgParamsSchema = z.object({
    role: z
      .enum(['member', 'maintainer'])
      .describe('The role that this user should have in the team.')
      .default('member'),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddOrUpdateMembershipForUserInOrgParams = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserInOrgParamsSchema
  >

  export const TeamsAddOrUpdateMembershipForUserInOrgResponseSchema =
    TeamMembershipSchema
  export type TeamsAddOrUpdateMembershipForUserInOrgResponse = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserInOrgResponseSchema
  >

  export const TeamsRemoveMembershipForUserInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMembershipForUserInOrgParams = z.infer<
    typeof TeamsRemoveMembershipForUserInOrgParamsSchema
  >

  export type TeamsRemoveMembershipForUserInOrgResponse = undefined

  export const TeamsListProjectsInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListProjectsInOrgParams = z.infer<
    typeof TeamsListProjectsInOrgParamsSchema
  >

  export const TeamsListProjectsInOrgResponseSchema = z.array(TeamProjectSchema)
  export type TeamsListProjectsInOrgResponse = z.infer<
    typeof TeamsListProjectsInOrgResponseSchema
  >

  export const TeamsCheckPermissionsForProjectInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsCheckPermissionsForProjectInOrgParams = z.infer<
    typeof TeamsCheckPermissionsForProjectInOrgParamsSchema
  >

  export const TeamsCheckPermissionsForProjectInOrgResponseSchema =
    TeamProjectSchema
  export type TeamsCheckPermissionsForProjectInOrgResponse = z.infer<
    typeof TeamsCheckPermissionsForProjectInOrgResponseSchema
  >

  export const TeamsAddOrUpdateProjectPermissionsInOrgParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe(
        'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."'
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsAddOrUpdateProjectPermissionsInOrgParams = z.infer<
    typeof TeamsAddOrUpdateProjectPermissionsInOrgParamsSchema
  >

  export type TeamsAddOrUpdateProjectPermissionsInOrgResponse = undefined

  export const TeamsRemoveProjectInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsRemoveProjectInOrgParams = z.infer<
    typeof TeamsRemoveProjectInOrgParamsSchema
  >

  export type TeamsRemoveProjectInOrgResponse = undefined

  export const TeamsListReposInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListReposInOrgParams = z.infer<
    typeof TeamsListReposInOrgParamsSchema
  >

  export const TeamsListReposInOrgResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type TeamsListReposInOrgResponse = z.infer<
    typeof TeamsListReposInOrgResponseSchema
  >

  export const TeamsCheckPermissionsForRepoInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsCheckPermissionsForRepoInOrgParams = z.infer<
    typeof TeamsCheckPermissionsForRepoInOrgParamsSchema
  >

  export const TeamsCheckPermissionsForRepoInOrgResponseSchema =
    TeamRepositorySchema
  export type TeamsCheckPermissionsForRepoInOrgResponse = z.infer<
    typeof TeamsCheckPermissionsForRepoInOrgResponseSchema
  >

  export const TeamsAddOrUpdateRepoPermissionsInOrgParamsSchema = z.object({
    permission: z
      .string()
      .describe(
        "The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."
      )
      .optional(),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsAddOrUpdateRepoPermissionsInOrgParams = z.infer<
    typeof TeamsAddOrUpdateRepoPermissionsInOrgParamsSchema
  >

  export type TeamsAddOrUpdateRepoPermissionsInOrgResponse = undefined

  export const TeamsRemoveRepoInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsRemoveRepoInOrgParams = z.infer<
    typeof TeamsRemoveRepoInOrgParamsSchema
  >

  export type TeamsRemoveRepoInOrgResponse = undefined

  export const TeamsListChildInOrgParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.'),
    team_slug: z.string().describe('The slug of the team name.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListChildInOrgParams = z.infer<
    typeof TeamsListChildInOrgParamsSchema
  >

  export const TeamsListChildInOrgResponseSchema = z.array(TeamSchema)
  export type TeamsListChildInOrgResponse = z.infer<
    typeof TeamsListChildInOrgResponseSchema
  >

  export const OrgsEnableOrDisableSecurityProductOnAllOrgReposParamsSchema =
    z.object({
      query_suite: z
        .enum(['default', 'extended'])
        .describe(
          "CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.\nIf you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied."
        )
        .optional(),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      security_product: z
        .enum([
          'dependency_graph',
          'dependabot_alerts',
          'dependabot_security_updates',
          'advanced_security',
          'code_scanning_default_setup',
          'secret_scanning',
          'secret_scanning_push_protection'
        ])
        .describe('The security feature to enable or disable.'),
      enablement: z
        .enum(['enable_all', 'disable_all'])
        .describe(
          'The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.'
        )
    })
  export type OrgsEnableOrDisableSecurityProductOnAllOrgReposParams = z.infer<
    typeof OrgsEnableOrDisableSecurityProductOnAllOrgReposParamsSchema
  >

  export type OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse =
    undefined

  export const ProjectsGetCardParamsSchema = z.object({
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsGetCardParams = z.infer<
    typeof ProjectsGetCardParamsSchema
  >

  export const ProjectsGetCardResponseSchema = ProjectCardSchema
  export type ProjectsGetCardResponse = z.infer<
    typeof ProjectsGetCardResponseSchema
  >

  export const ProjectsDeleteCardParamsSchema = z.object({
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsDeleteCardParams = z.infer<
    typeof ProjectsDeleteCardParamsSchema
  >

  export type ProjectsDeleteCardResponse = undefined

  export const ProjectsUpdateCardParamsSchema = z.object({
    note: z.string().describe("The project card's note").optional(),
    archived: z
      .boolean()
      .describe('Whether or not the card is archived')
      .optional(),
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsUpdateCardParams = z.infer<
    typeof ProjectsUpdateCardParamsSchema
  >

  export const ProjectsUpdateCardResponseSchema = ProjectCardSchema
  export type ProjectsUpdateCardResponse = z.infer<
    typeof ProjectsUpdateCardResponseSchema
  >

  export const ProjectsMoveCardParamsSchema = z.object({
    position: z
      .string()
      .regex(new RegExp('^(?:top|bottom|after:\\d+)$'))
      .describe(
        'The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.'
      ),
    column_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the column the card should be moved to'
      )
      .optional(),
    card_id: z.number().int().describe('The unique identifier of the card.')
  })
  export type ProjectsMoveCardParams = z.infer<
    typeof ProjectsMoveCardParamsSchema
  >

  export type ProjectsMoveCardResponse = undefined

  export const ProjectsGetColumnParamsSchema = z.object({
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsGetColumnParams = z.infer<
    typeof ProjectsGetColumnParamsSchema
  >

  export const ProjectsGetColumnResponseSchema = ProjectColumnSchema
  export type ProjectsGetColumnResponse = z.infer<
    typeof ProjectsGetColumnResponseSchema
  >

  export const ProjectsDeleteColumnParamsSchema = z.object({
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsDeleteColumnParams = z.infer<
    typeof ProjectsDeleteColumnParamsSchema
  >

  export type ProjectsDeleteColumnResponse = undefined

  export const ProjectsUpdateColumnParamsSchema = z.object({
    name: z.string().describe('Name of the project column'),
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsUpdateColumnParams = z.infer<
    typeof ProjectsUpdateColumnParamsSchema
  >

  export const ProjectsUpdateColumnResponseSchema = ProjectColumnSchema
  export type ProjectsUpdateColumnResponse = z.infer<
    typeof ProjectsUpdateColumnResponseSchema
  >

  export const ProjectsListCardsParamsSchema = z.object({
    column_id: z
      .number()
      .int()
      .describe('The unique identifier of the column.'),
    archived_state: z
      .enum(['all', 'archived', 'not_archived'])
      .describe(
        "Filters the project cards that are returned by the card's state."
      )
      .default('not_archived'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListCardsParams = z.infer<
    typeof ProjectsListCardsParamsSchema
  >

  export const ProjectsListCardsResponseSchema = z.array(ProjectCardSchema)
  export type ProjectsListCardsResponse = z.infer<
    typeof ProjectsListCardsResponseSchema
  >

  export const ProjectsCreateCardParamsSchema = z
    .object({
      column_id: z
        .number()
        .int()
        .describe('The unique identifier of the column.')
    })
    .and(
      z.union([
        z.object({ note: z.string().describe("The project card's note") }),
        z.object({
          content_id: z
            .number()
            .int()
            .describe(
              'The unique identifier of the content associated with the card'
            ),
          content_type: z
            .string()
            .describe('The piece of content associated with the card')
        })
      ])
    )
  export type ProjectsCreateCardParams = z.infer<
    typeof ProjectsCreateCardParamsSchema
  >

  export type ProjectsCreateCardResponse = undefined

  export const ProjectsMoveColumnParamsSchema = z.object({
    position: z
      .string()
      .regex(new RegExp('^(?:first|last|after:\\d+)$'))
      .describe(
        'The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.'
      ),
    column_id: z.number().int().describe('The unique identifier of the column.')
  })
  export type ProjectsMoveColumnParams = z.infer<
    typeof ProjectsMoveColumnParamsSchema
  >

  export type ProjectsMoveColumnResponse = undefined

  export const ProjectsGetParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsGetParams = z.infer<typeof ProjectsGetParamsSchema>

  export const ProjectsGetResponseSchema = ProjectSchema
  export type ProjectsGetResponse = z.infer<typeof ProjectsGetResponseSchema>

  export const ProjectsDeleteParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsDeleteParams = z.infer<typeof ProjectsDeleteParamsSchema>

  export type ProjectsDeleteResponse = undefined

  export const ProjectsUpdateParamsSchema = z.object({
    name: z.string().describe('Name of the project').optional(),
    body: z.string().describe('Body of the project').optional(),
    state: z
      .string()
      .describe("State of the project; either 'open' or 'closed'")
      .optional(),
    organization_permission: z
      .enum(['read', 'write', 'admin', 'none'])
      .describe(
        'The baseline permission that all organization members have on this project'
      )
      .optional(),
    private: z
      .boolean()
      .describe('Whether or not this project can be seen by everyone.')
      .optional(),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsUpdateParams = z.infer<typeof ProjectsUpdateParamsSchema>

  export const ProjectsUpdateResponseSchema = ProjectSchema
  export type ProjectsUpdateResponse = z.infer<
    typeof ProjectsUpdateResponseSchema
  >

  export const ProjectsListCollaboratorsParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    affiliation: z
      .enum(['outside', 'direct', 'all'])
      .describe(
        "Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see."
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListCollaboratorsParams = z.infer<
    typeof ProjectsListCollaboratorsParamsSchema
  >

  export const ProjectsListCollaboratorsResponseSchema =
    z.array(SimpleUserSchema)
  export type ProjectsListCollaboratorsResponse = z.infer<
    typeof ProjectsListCollaboratorsResponseSchema
  >

  export const ProjectsAddCollaboratorParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe('The permission to grant the collaborator.')
      .default('write'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsAddCollaboratorParams = z.infer<
    typeof ProjectsAddCollaboratorParamsSchema
  >

  export type ProjectsAddCollaboratorResponse = undefined

  export const ProjectsRemoveCollaboratorParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsRemoveCollaboratorParams = z.infer<
    typeof ProjectsRemoveCollaboratorParamsSchema
  >

  export type ProjectsRemoveCollaboratorResponse = undefined

  export const ProjectsGetPermissionForUserParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ProjectsGetPermissionForUserParams = z.infer<
    typeof ProjectsGetPermissionForUserParamsSchema
  >

  export const ProjectsGetPermissionForUserResponseSchema =
    ProjectCollaboratorPermissionSchema
  export type ProjectsGetPermissionForUserResponse = z.infer<
    typeof ProjectsGetPermissionForUserResponseSchema
  >

  export const ProjectsListColumnsParamsSchema = z.object({
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListColumnsParams = z.infer<
    typeof ProjectsListColumnsParamsSchema
  >

  export const ProjectsListColumnsResponseSchema = z.array(ProjectColumnSchema)
  export type ProjectsListColumnsResponse = z.infer<
    typeof ProjectsListColumnsResponseSchema
  >

  export const ProjectsCreateColumnParamsSchema = z.object({
    name: z.string().describe('Name of the project column'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type ProjectsCreateColumnParams = z.infer<
    typeof ProjectsCreateColumnParamsSchema
  >

  export type ProjectsCreateColumnResponse = undefined

  export const RateLimitGetParamsSchema = z.object({})
  export type RateLimitGetParams = z.infer<typeof RateLimitGetParamsSchema>

  export const RateLimitGetResponseSchema = RateLimitOverviewSchema
  export type RateLimitGetResponse = z.infer<typeof RateLimitGetResponseSchema>

  export const ReposGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetParams = z.infer<typeof ReposGetParamsSchema>

  export const ReposGetResponseSchema = FullRepositorySchema
  export type ReposGetResponse = z.infer<typeof ReposGetResponseSchema>

  export const ReposDeleteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDeleteParams = z.infer<typeof ReposDeleteParamsSchema>

  export type ReposDeleteResponse = undefined

  export const ReposUpdateParamsSchema = z.object({
    name: z.string().describe('The name of the repository.').optional(),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe(
        'Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.'
      )
      .default(false),
    visibility: z
      .enum(['public', 'private'])
      .describe('The visibility of the repository.')
      .optional(),
    security_and_analysis: z
      .object({
        advanced_security: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."'
          )
          .optional(),
        secret_scanning: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."'
          )
          .optional(),
        secret_scanning_push_protection: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."'
          )
          .optional(),
        secret_scanning_ai_detection: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."'
          )
          .optional(),
        secret_scanning_non_provider_patterns: z
          .object({
            status: z
              .string()
              .describe('Can be `enabled` or `disabled`.')
              .optional()
          })
          .describe(
            'Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."'
          )
          .optional()
      })
      .describe(
        'Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.'
      )
      .optional(),
    has_issues: z
      .boolean()
      .describe(
        'Either `true` to enable issues for this repository or `false` to disable them.'
      )
      .default(true),
    has_projects: z
      .boolean()
      .describe(
        "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error."
      )
      .default(true),
    has_wiki: z
      .boolean()
      .describe(
        'Either `true` to enable the wiki for this repository or `false` to disable it.'
      )
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Either `true` to make this repo available as a template repository or `false` to prevent it.'
      )
      .default(false),
    default_branch: z
      .string()
      .describe('Updates the default branch for this repository.')
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.'
      )
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe(
        'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.'
      )
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe(
        'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.'
      )
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe(
        'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.'
      )
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe(
        'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.'
      )
      .default(false),
    allow_update_branch: z
      .boolean()
      .describe(
        'Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.'
      )
      .default(false),
    use_squash_pr_title_as_default: z
      .boolean()
      .describe(
        'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.'
      )
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    archived: z
      .boolean()
      .describe(
        'Whether to archive this repository. `false` will unarchive a previously archived repository.'
      )
      .default(false),
    allow_forking: z
      .boolean()
      .describe(
        'Either `true` to allow private forks, or `false` to prevent private forks.'
      )
      .default(false),
    web_commit_signoff_required: z
      .boolean()
      .describe(
        'Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.'
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposUpdateParams = z.infer<typeof ReposUpdateParamsSchema>

  export const ReposUpdateResponseSchema = FullRepositorySchema
  export type ReposUpdateResponse = z.infer<typeof ReposUpdateResponseSchema>

  export const ActionsListArtifactsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    name: z
      .string()
      .describe(
        'The name field of an artifact. When specified, only artifacts with this name will be returned.'
      )
      .optional()
  })
  export type ActionsListArtifactsForRepoParams = z.infer<
    typeof ActionsListArtifactsForRepoParamsSchema
  >

  export const ActionsListArtifactsForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    artifacts: z.array(ArtifactSchema)
  })
  export type ActionsListArtifactsForRepoResponse = z.infer<
    typeof ActionsListArtifactsForRepoResponseSchema
  >

  export const ActionsGetArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.')
  })
  export type ActionsGetArtifactParams = z.infer<
    typeof ActionsGetArtifactParamsSchema
  >

  export const ActionsGetArtifactResponseSchema = ArtifactSchema
  export type ActionsGetArtifactResponse = z.infer<
    typeof ActionsGetArtifactResponseSchema
  >

  export const ActionsDeleteArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.')
  })
  export type ActionsDeleteArtifactParams = z.infer<
    typeof ActionsDeleteArtifactParamsSchema
  >

  export type ActionsDeleteArtifactResponse = undefined

  export const ActionsDownloadArtifactParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    artifact_id: z
      .number()
      .int()
      .describe('The unique identifier of the artifact.'),
    archive_format: z.string()
  })
  export type ActionsDownloadArtifactParams = z.infer<
    typeof ActionsDownloadArtifactParamsSchema
  >

  export type ActionsDownloadArtifactResponse = undefined

  export const ActionsGetActionsCacheUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetActionsCacheUsageParams = z.infer<
    typeof ActionsGetActionsCacheUsageParamsSchema
  >

  export const ActionsGetActionsCacheUsageResponseSchema =
    ActionsCacheUsageByRepositorySchema
  export type ActionsGetActionsCacheUsageResponse = z.infer<
    typeof ActionsGetActionsCacheUsageResponseSchema
  >

  export const ActionsGetActionsCacheListParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    ref: z
      .string()
      .describe(
        'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    key: z
      .string()
      .describe('An explicit key or prefix for identifying the cache')
      .optional(),
    sort: z
      .enum(['created_at', 'last_accessed_at', 'size_in_bytes'])
      .describe(
        'The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.'
      )
      .default('last_accessed_at'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc')
  })
  export type ActionsGetActionsCacheListParams = z.infer<
    typeof ActionsGetActionsCacheListParamsSchema
  >

  export const ActionsGetActionsCacheListResponseSchema = ActionsCacheListSchema
  export type ActionsGetActionsCacheListResponse = z.infer<
    typeof ActionsGetActionsCacheListResponseSchema
  >

  export const ActionsDeleteActionsCacheByKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key: z.string().describe('A key for identifying the cache.'),
    ref: z
      .string()
      .describe(
        'The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional()
  })
  export type ActionsDeleteActionsCacheByKeyParams = z.infer<
    typeof ActionsDeleteActionsCacheByKeyParamsSchema
  >

  export const ActionsDeleteActionsCacheByKeyResponseSchema =
    ActionsCacheListSchema
  export type ActionsDeleteActionsCacheByKeyResponse = z.infer<
    typeof ActionsDeleteActionsCacheByKeyResponseSchema
  >

  export const ActionsDeleteActionsCacheByIdParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    cache_id: z
      .number()
      .int()
      .describe('The unique identifier of the GitHub Actions cache.')
  })
  export type ActionsDeleteActionsCacheByIdParams = z.infer<
    typeof ActionsDeleteActionsCacheByIdParamsSchema
  >

  export type ActionsDeleteActionsCacheByIdResponse = undefined

  export const ActionsGetJobForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsGetJobForWorkflowRunParams = z.infer<
    typeof ActionsGetJobForWorkflowRunParamsSchema
  >

  export const ActionsGetJobForWorkflowRunResponseSchema = JobSchema
  export type ActionsGetJobForWorkflowRunResponse = z.infer<
    typeof ActionsGetJobForWorkflowRunResponseSchema
  >

  export const ActionsDownloadJobLogsForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsDownloadJobLogsForWorkflowRunParams = z.infer<
    typeof ActionsDownloadJobLogsForWorkflowRunParamsSchema
  >

  export type ActionsDownloadJobLogsForWorkflowRunResponse = undefined

  export const ActionsReRunJobForWorkflowRunParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    job_id: z.number().int().describe('The unique identifier of the job.')
  })
  export type ActionsReRunJobForWorkflowRunParams = z.infer<
    typeof ActionsReRunJobForWorkflowRunParamsSchema
  >

  export type ActionsReRunJobForWorkflowRunResponse = undefined

  export const ActionsGetCustomOidcSubClaimForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetCustomOidcSubClaimForRepoParams = z.infer<
    typeof ActionsGetCustomOidcSubClaimForRepoParamsSchema
  >

  export const ActionsGetCustomOidcSubClaimForRepoResponseSchema =
    OidcCustomSubRepoSchema
  export type ActionsGetCustomOidcSubClaimForRepoResponse = z.infer<
    typeof ActionsGetCustomOidcSubClaimForRepoResponseSchema
  >

  export const ActionsSetCustomOidcSubClaimForRepoParamsSchema = z.object({
    use_default: z
      .boolean()
      .describe(
        'Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.'
      ),
    include_claim_keys: z
      .array(z.string())
      .describe(
        'Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsSetCustomOidcSubClaimForRepoParams = z.infer<
    typeof ActionsSetCustomOidcSubClaimForRepoParamsSchema
  >

  export type ActionsSetCustomOidcSubClaimForRepoResponse = undefined

  export const ActionsListRepoOrganizationSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoOrganizationSecretsParams = z.infer<
    typeof ActionsListRepoOrganizationSecretsParamsSchema
  >

  export const ActionsListRepoOrganizationSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListRepoOrganizationSecretsResponse = z.infer<
    typeof ActionsListRepoOrganizationSecretsResponseSchema
  >

  export const ActionsListRepoOrganizationVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoOrganizationVariablesParams = z.infer<
    typeof ActionsListRepoOrganizationVariablesParamsSchema
  >

  export const ActionsListRepoOrganizationVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListRepoOrganizationVariablesResponse = z.infer<
    typeof ActionsListRepoOrganizationVariablesResponseSchema
  >

  export const ActionsGetGithubActionsPermissionsRepositoryParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsGetGithubActionsPermissionsRepositoryParams = z.infer<
    typeof ActionsGetGithubActionsPermissionsRepositoryParamsSchema
  >

  export const ActionsGetGithubActionsPermissionsRepositoryResponseSchema =
    ActionsRepositoryPermissionsSchema
  export type ActionsGetGithubActionsPermissionsRepositoryResponse = z.infer<
    typeof ActionsGetGithubActionsPermissionsRepositoryResponseSchema
  >

  export const ActionsSetGithubActionsPermissionsRepositoryParamsSchema =
    z.object({
      enabled: ActionsEnabledSchema,
      allowed_actions: AllowedActionsSchema.optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsSetGithubActionsPermissionsRepositoryParams = z.infer<
    typeof ActionsSetGithubActionsPermissionsRepositoryParamsSchema
  >

  export type ActionsSetGithubActionsPermissionsRepositoryResponse = undefined

  export const ActionsGetWorkflowAccessToRepositoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetWorkflowAccessToRepositoryParams = z.infer<
    typeof ActionsGetWorkflowAccessToRepositoryParamsSchema
  >

  export const ActionsGetWorkflowAccessToRepositoryResponseSchema =
    ActionsWorkflowAccessToRepositorySchema
  export type ActionsGetWorkflowAccessToRepositoryResponse = z.infer<
    typeof ActionsGetWorkflowAccessToRepositoryResponseSchema
  >

  export const ActionsSetWorkflowAccessToRepositoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(ActionsWorkflowAccessToRepositorySchema)
  export type ActionsSetWorkflowAccessToRepositoryParams = z.infer<
    typeof ActionsSetWorkflowAccessToRepositoryParamsSchema
  >

  export type ActionsSetWorkflowAccessToRepositoryResponse = undefined

  export const ActionsGetAllowedActionsRepositoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetAllowedActionsRepositoryParams = z.infer<
    typeof ActionsGetAllowedActionsRepositoryParamsSchema
  >

  export const ActionsGetAllowedActionsRepositoryResponseSchema =
    SelectedActionsSchema
  export type ActionsGetAllowedActionsRepositoryResponse = z.infer<
    typeof ActionsGetAllowedActionsRepositoryResponseSchema
  >

  export const ActionsSetAllowedActionsRepositoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(SelectedActionsSchema)
  export type ActionsSetAllowedActionsRepositoryParams = z.infer<
    typeof ActionsSetAllowedActionsRepositoryParamsSchema
  >

  export type ActionsSetAllowedActionsRepositoryResponse = undefined

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParams =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
    >

  export const ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseSchema =
    ActionsGetDefaultWorkflowPermissionsSchema
  export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse =
    z.infer<
      typeof ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseSchema
    >

  export const ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema =
    z
      .object({
        owner: z
          .string()
          .describe(
            'The account owner of the repository. The name is not case sensitive.'
          ),
        repo: z
          .string()
          .describe(
            'The name of the repository without the `.git` extension. The name is not case sensitive.'
          )
      })
      .merge(ActionsSetDefaultWorkflowPermissionsSchema)
  export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParams =
    z.infer<
      typeof ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
    >

  export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse =
    undefined

  export const ActionsListSelfHostedRunnersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of a self-hosted runner.').optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListSelfHostedRunnersForRepoParams = z.infer<
    typeof ActionsListSelfHostedRunnersForRepoParamsSchema
  >

  export const ActionsListSelfHostedRunnersForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    runners: z.array(RunnerSchema)
  })
  export type ActionsListSelfHostedRunnersForRepoResponse = z.infer<
    typeof ActionsListSelfHostedRunnersForRepoResponseSchema
  >

  export const ActionsListRunnerApplicationsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsListRunnerApplicationsForRepoParams = z.infer<
    typeof ActionsListRunnerApplicationsForRepoParamsSchema
  >

  export const ActionsListRunnerApplicationsForRepoResponseSchema = z.array(
    RunnerApplicationSchema
  )
  export type ActionsListRunnerApplicationsForRepoResponse = z.infer<
    typeof ActionsListRunnerApplicationsForRepoResponseSchema
  >

  export const ActionsGenerateRunnerJitconfigForRepoParamsSchema = z.object({
    name: z.string().describe('The name of the new runner.'),
    runner_group_id: z
      .number()
      .int()
      .describe('The ID of the runner group to register the runner to.'),
    labels: z
      .array(z.string())
      .min(1)
      .max(100)
      .describe(
        'The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.'
      ),
    work_folder: z
      .string()
      .describe(
        'The working directory to be used for job execution, relative to the runner install directory.'
      )
      .default('_work'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGenerateRunnerJitconfigForRepoParams = z.infer<
    typeof ActionsGenerateRunnerJitconfigForRepoParamsSchema
  >

  export type ActionsGenerateRunnerJitconfigForRepoResponse = undefined

  export const ActionsCreateRegistrationTokenForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRegistrationTokenForRepoParams = z.infer<
    typeof ActionsCreateRegistrationTokenForRepoParamsSchema
  >

  export type ActionsCreateRegistrationTokenForRepoResponse = undefined

  export const ActionsCreateRemoveTokenForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRemoveTokenForRepoParams = z.infer<
    typeof ActionsCreateRemoveTokenForRepoParamsSchema
  >

  export type ActionsCreateRemoveTokenForRepoResponse = undefined

  export const ActionsGetSelfHostedRunnerForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsGetSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsGetSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsGetSelfHostedRunnerForRepoResponseSchema = RunnerSchema
  export type ActionsGetSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsGetSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsDeleteSelfHostedRunnerFromRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    runner_id: z
      .number()
      .int()
      .describe('Unique identifier of the self-hosted runner.')
  })
  export type ActionsDeleteSelfHostedRunnerFromRepoParams = z.infer<
    typeof ActionsDeleteSelfHostedRunnerFromRepoParamsSchema
  >

  export type ActionsDeleteSelfHostedRunnerFromRepoResponse = undefined

  export const ActionsListLabelsForSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsListLabelsForSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsListLabelsForSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsListLabelsForSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsListLabelsForSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(1)
        .max(100)
        .describe('The names of the custom labels to add to the runner.'),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse = z.infer<
    typeof ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponseSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamsSchema =
    z.object({
      labels: z
        .array(z.string())
        .min(0)
        .max(100)
        .describe(
          'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoParams = z.infer<
    typeof ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamsSchema
  >

  export const ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.')
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParams =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamsSchema
    >

  export const ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      runner_id: z
        .number()
        .int()
        .describe('Unique identifier of the self-hosted runner.'),
      name: z
        .string()
        .describe("The name of a self-hosted runner's custom label.")
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParams =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamsSchema
    >

  export const ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseSchema =
    z.object({
      total_count: z.number().int(),
      labels: z.array(RunnerLabelSchema)
    })
  export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse =
    z.infer<
      typeof ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseSchema
    >

  export const ActionsListWorkflowRunsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    actor: z
      .string()
      .describe(
        "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
      )
      .optional(),
    branch: z
      .string()
      .describe(
        'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
      )
      .optional(),
    event: z
      .string()
      .describe(
        'Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."'
      )
      .optional(),
    status: z
      .enum([
        'completed',
        'action_required',
        'cancelled',
        'failure',
        'neutral',
        'skipped',
        'stale',
        'success',
        'timed_out',
        'in_progress',
        'queued',
        'requested',
        'waiting',
        'pending'
      ])
      .describe(
        'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    created: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false),
    check_suite_id: z
      .number()
      .int()
      .describe(
        'Returns workflow runs with the `check_suite_id` that you specify.'
      )
      .optional(),
    head_sha: z
      .string()
      .describe(
        'Only returns workflow runs that are associated with the specified `head_sha`.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunsForRepoParams = z.infer<
    typeof ActionsListWorkflowRunsForRepoParamsSchema
  >

  export const ActionsListWorkflowRunsForRepoResponseSchema = z.object({
    total_count: z.number().int(),
    workflow_runs: z.array(WorkflowRunSchema)
  })
  export type ActionsListWorkflowRunsForRepoResponse = z.infer<
    typeof ActionsListWorkflowRunsForRepoResponseSchema
  >

  export const ActionsGetWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false)
  })
  export type ActionsGetWorkflowRunParams = z.infer<
    typeof ActionsGetWorkflowRunParamsSchema
  >

  export const ActionsGetWorkflowRunResponseSchema = WorkflowRunSchema
  export type ActionsGetWorkflowRunResponse = z.infer<
    typeof ActionsGetWorkflowRunResponseSchema
  >

  export const ActionsDeleteWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDeleteWorkflowRunParams = z.infer<
    typeof ActionsDeleteWorkflowRunParamsSchema
  >

  export type ActionsDeleteWorkflowRunResponse = undefined

  export const ActionsGetReviewsForRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetReviewsForRunParams = z.infer<
    typeof ActionsGetReviewsForRunParamsSchema
  >

  export const ActionsGetReviewsForRunResponseSchema = z.array(
    EnvironmentApprovalsSchema
  )
  export type ActionsGetReviewsForRunResponse = z.infer<
    typeof ActionsGetReviewsForRunResponseSchema
  >

  export const ActionsApproveWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsApproveWorkflowRunParams = z.infer<
    typeof ActionsApproveWorkflowRunParamsSchema
  >

  export type ActionsApproveWorkflowRunResponse = undefined

  export const ActionsListWorkflowRunArtifactsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    name: z
      .string()
      .describe(
        'The name field of an artifact. When specified, only artifacts with this name will be returned.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunArtifactsParams = z.infer<
    typeof ActionsListWorkflowRunArtifactsParamsSchema
  >

  export const ActionsListWorkflowRunArtifactsResponseSchema = z.object({
    total_count: z.number().int(),
    artifacts: z.array(ArtifactSchema)
  })
  export type ActionsListWorkflowRunArtifactsResponse = z.infer<
    typeof ActionsListWorkflowRunArtifactsResponseSchema
  >

  export const ActionsGetWorkflowRunAttemptParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.'),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false)
  })
  export type ActionsGetWorkflowRunAttemptParams = z.infer<
    typeof ActionsGetWorkflowRunAttemptParamsSchema
  >

  export const ActionsGetWorkflowRunAttemptResponseSchema = WorkflowRunSchema
  export type ActionsGetWorkflowRunAttemptResponse = z.infer<
    typeof ActionsGetWorkflowRunAttemptResponseSchema
  >

  export const ActionsListJobsForWorkflowRunAttemptParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListJobsForWorkflowRunAttemptParams = z.infer<
    typeof ActionsListJobsForWorkflowRunAttemptParamsSchema
  >

  export const ActionsListJobsForWorkflowRunAttemptResponseSchema = z.object({
    total_count: z.number().int(),
    jobs: z.array(JobSchema)
  })
  export type ActionsListJobsForWorkflowRunAttemptResponse = z.infer<
    typeof ActionsListJobsForWorkflowRunAttemptResponseSchema
  >

  export const ActionsDownloadWorkflowRunAttemptLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    attempt_number: z
      .number()
      .int()
      .describe('The attempt number of the workflow run.')
  })
  export type ActionsDownloadWorkflowRunAttemptLogsParams = z.infer<
    typeof ActionsDownloadWorkflowRunAttemptLogsParamsSchema
  >

  export type ActionsDownloadWorkflowRunAttemptLogsResponse = undefined

  export const ActionsCancelWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsCancelWorkflowRunParams = z.infer<
    typeof ActionsCancelWorkflowRunParamsSchema
  >

  export type ActionsCancelWorkflowRunResponse = undefined

  export const ActionsReviewCustomGatesForRunParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      run_id: z
        .number()
        .int()
        .describe('The unique identifier of the workflow run.')
    })
    .and(
      z.union([
        ReviewCustomGatesCommentRequiredSchema,
        ReviewCustomGatesStateRequiredSchema
      ])
    )
  export type ActionsReviewCustomGatesForRunParams = z.infer<
    typeof ActionsReviewCustomGatesForRunParamsSchema
  >

  export type ActionsReviewCustomGatesForRunResponse = undefined

  export const ActionsForceCancelWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsForceCancelWorkflowRunParams = z.infer<
    typeof ActionsForceCancelWorkflowRunParamsSchema
  >

  export type ActionsForceCancelWorkflowRunResponse = undefined

  export const ActionsListJobsForWorkflowRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.'),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListJobsForWorkflowRunParams = z.infer<
    typeof ActionsListJobsForWorkflowRunParamsSchema
  >

  export const ActionsListJobsForWorkflowRunResponseSchema = z.object({
    total_count: z.number().int(),
    jobs: z.array(JobSchema)
  })
  export type ActionsListJobsForWorkflowRunResponse = z.infer<
    typeof ActionsListJobsForWorkflowRunResponseSchema
  >

  export const ActionsDownloadWorkflowRunLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDownloadWorkflowRunLogsParams = z.infer<
    typeof ActionsDownloadWorkflowRunLogsParamsSchema
  >

  export type ActionsDownloadWorkflowRunLogsResponse = undefined

  export const ActionsDeleteWorkflowRunLogsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsDeleteWorkflowRunLogsParams = z.infer<
    typeof ActionsDeleteWorkflowRunLogsParamsSchema
  >

  export type ActionsDeleteWorkflowRunLogsResponse = undefined

  export const ActionsGetPendingDeploymentsForRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetPendingDeploymentsForRunParams = z.infer<
    typeof ActionsGetPendingDeploymentsForRunParamsSchema
  >

  export const ActionsGetPendingDeploymentsForRunResponseSchema = z.array(
    PendingDeploymentSchema
  )
  export type ActionsGetPendingDeploymentsForRunResponse = z.infer<
    typeof ActionsGetPendingDeploymentsForRunResponseSchema
  >

  export const ActionsReviewPendingDeploymentsForRunParamsSchema = z.object({
    environment_ids: z
      .array(z.number().int())
      .describe('The list of environment ids to approve or reject'),
    state: z
      .enum(['approved', 'rejected'])
      .describe(
        'Whether to approve or reject deployment to the specified environments.'
      ),
    comment: z
      .string()
      .describe('A comment to accompany the deployment review'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReviewPendingDeploymentsForRunParams = z.infer<
    typeof ActionsReviewPendingDeploymentsForRunParamsSchema
  >

  export const ActionsReviewPendingDeploymentsForRunResponseSchema =
    z.array(DeploymentSchema)
  export type ActionsReviewPendingDeploymentsForRunResponse = z.infer<
    typeof ActionsReviewPendingDeploymentsForRunResponseSchema
  >

  export const ActionsReRunWorkflowParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReRunWorkflowParams = z.infer<
    typeof ActionsReRunWorkflowParamsSchema
  >

  export type ActionsReRunWorkflowResponse = undefined

  export const ActionsReRunWorkflowFailedJobsParamsSchema = z.object({
    enable_debug_logging: z
      .boolean()
      .describe('Whether to enable debug logging for the re-run.')
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsReRunWorkflowFailedJobsParams = z.infer<
    typeof ActionsReRunWorkflowFailedJobsParamsSchema
  >

  export type ActionsReRunWorkflowFailedJobsResponse = undefined

  export const ActionsGetWorkflowRunUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    run_id: z
      .number()
      .int()
      .describe('The unique identifier of the workflow run.')
  })
  export type ActionsGetWorkflowRunUsageParams = z.infer<
    typeof ActionsGetWorkflowRunUsageParamsSchema
  >

  export const ActionsGetWorkflowRunUsageResponseSchema = WorkflowRunUsageSchema
  export type ActionsGetWorkflowRunUsageResponse = z.infer<
    typeof ActionsGetWorkflowRunUsageResponseSchema
  >

  export const ActionsListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoSecretsParams = z.infer<
    typeof ActionsListRepoSecretsParamsSchema
  >

  export const ActionsListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListRepoSecretsResponse = z.infer<
    typeof ActionsListRepoSecretsResponseSchema
  >

  export const ActionsGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsGetRepoPublicKeyParams = z.infer<
    typeof ActionsGetRepoPublicKeyParamsSchema
  >

  export const ActionsGetRepoPublicKeyResponseSchema = ActionsPublicKeySchema
  export type ActionsGetRepoPublicKeyResponse = z.infer<
    typeof ActionsGetRepoPublicKeyResponseSchema
  >

  export const ActionsGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetRepoSecretParams = z.infer<
    typeof ActionsGetRepoSecretParamsSchema
  >

  export const ActionsGetRepoSecretResponseSchema = ActionsSecretSchema
  export type ActionsGetRepoSecretResponse = z.infer<
    typeof ActionsGetRepoSecretResponseSchema
  >

  export const ActionsCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateRepoSecretParams = z.infer<
    typeof ActionsCreateOrUpdateRepoSecretParamsSchema
  >

  export type ActionsCreateOrUpdateRepoSecretResponse = undefined

  export const ActionsDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteRepoSecretParams = z.infer<
    typeof ActionsDeleteRepoSecretParamsSchema
  >

  export type ActionsDeleteRepoSecretResponse = undefined

  export const ActionsListRepoVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoVariablesParams = z.infer<
    typeof ActionsListRepoVariablesParamsSchema
  >

  export const ActionsListRepoVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListRepoVariablesResponse = z.infer<
    typeof ActionsListRepoVariablesResponseSchema
  >

  export const ActionsCreateRepoVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsCreateRepoVariableParams = z.infer<
    typeof ActionsCreateRepoVariableParamsSchema
  >

  export type ActionsCreateRepoVariableResponse = undefined

  export const ActionsGetRepoVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetRepoVariableParams = z.infer<
    typeof ActionsGetRepoVariableParamsSchema
  >

  export const ActionsGetRepoVariableResponseSchema = ActionsVariableSchema
  export type ActionsGetRepoVariableResponse = z.infer<
    typeof ActionsGetRepoVariableResponseSchema
  >

  export const ActionsDeleteRepoVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsDeleteRepoVariableParams = z.infer<
    typeof ActionsDeleteRepoVariableParamsSchema
  >

  export type ActionsDeleteRepoVariableResponse = undefined

  export const ActionsUpdateRepoVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActionsUpdateRepoVariableParams = z.infer<
    typeof ActionsUpdateRepoVariableParamsSchema
  >

  export type ActionsUpdateRepoVariableResponse = undefined

  export const ActionsListRepoWorkflowsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListRepoWorkflowsParams = z.infer<
    typeof ActionsListRepoWorkflowsParamsSchema
  >

  export const ActionsListRepoWorkflowsResponseSchema = z.object({
    total_count: z.number().int(),
    workflows: z.array(WorkflowSchema)
  })
  export type ActionsListRepoWorkflowsResponse = z.infer<
    typeof ActionsListRepoWorkflowsResponseSchema
  >

  export const ActionsGetWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsGetWorkflowParams = z.infer<
    typeof ActionsGetWorkflowParamsSchema
  >

  export const ActionsGetWorkflowResponseSchema = WorkflowSchema
  export type ActionsGetWorkflowResponse = z.infer<
    typeof ActionsGetWorkflowResponseSchema
  >

  export const ActionsDisableWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsDisableWorkflowParams = z.infer<
    typeof ActionsDisableWorkflowParamsSchema
  >

  export type ActionsDisableWorkflowResponse = undefined

  export const ActionsCreateWorkflowDispatchParamsSchema = z.object({
    ref: z
      .string()
      .describe(
        'The git reference for the workflow. The reference can be a branch or tag name.'
      ),
    inputs: z
      .record(z.any())
      .describe(
        'Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsCreateWorkflowDispatchParams = z.infer<
    typeof ActionsCreateWorkflowDispatchParamsSchema
  >

  export type ActionsCreateWorkflowDispatchResponse = undefined

  export const ActionsEnableWorkflowParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsEnableWorkflowParams = z.infer<
    typeof ActionsEnableWorkflowParamsSchema
  >

  export type ActionsEnableWorkflowResponse = undefined

  export const ActionsListWorkflowRunsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      ),
    actor: z
      .string()
      .describe(
        "Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run."
      )
      .optional(),
    branch: z
      .string()
      .describe(
        'Returns workflow runs associated with a branch. Use the name of the branch of the `push`.'
      )
      .optional(),
    event: z
      .string()
      .describe(
        'Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."'
      )
      .optional(),
    status: z
      .enum([
        'completed',
        'action_required',
        'cancelled',
        'failure',
        'neutral',
        'skipped',
        'stale',
        'success',
        'timed_out',
        'in_progress',
        'queued',
        'requested',
        'waiting',
        'pending'
      ])
      .describe(
        'Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    created: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."'
      )
      .optional(),
    exclude_pull_requests: z
      .boolean()
      .describe(
        'If `true` pull requests are omitted from the response (empty array).'
      )
      .default(false),
    check_suite_id: z
      .number()
      .int()
      .describe(
        'Returns workflow runs with the `check_suite_id` that you specify.'
      )
      .optional(),
    head_sha: z
      .string()
      .describe(
        'Only returns workflow runs that are associated with the specified `head_sha`.'
      )
      .optional()
  })
  export type ActionsListWorkflowRunsParams = z.infer<
    typeof ActionsListWorkflowRunsParamsSchema
  >

  export const ActionsListWorkflowRunsResponseSchema = z.object({
    total_count: z.number().int(),
    workflow_runs: z.array(WorkflowRunSchema)
  })
  export type ActionsListWorkflowRunsResponse = z.infer<
    typeof ActionsListWorkflowRunsResponseSchema
  >

  export const ActionsGetWorkflowUsageParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    workflow_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the workflow. You can also pass the workflow file name as a string.'
      )
  })
  export type ActionsGetWorkflowUsageParams = z.infer<
    typeof ActionsGetWorkflowUsageParamsSchema
  >

  export const ActionsGetWorkflowUsageResponseSchema = WorkflowUsageSchema
  export type ActionsGetWorkflowUsageResponse = z.infer<
    typeof ActionsGetWorkflowUsageResponseSchema
  >

  export const ReposListActivitiesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    ref: z
      .string()
      .describe(
        'The Git reference for the activities you want to list.\n\nThe `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.'
      )
      .optional(),
    actor: z
      .string()
      .describe(
        'The GitHub username to use to filter by the actor who performed the activity.'
      )
      .optional(),
    time_period: z
      .enum(['day', 'week', 'month', 'quarter', 'year'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).'
      )
      .optional(),
    activity_type: z
      .enum([
        'push',
        'force_push',
        'branch_creation',
        'branch_deletion',
        'pr_merge',
        'merge_queue_merge'
      ])
      .describe(
        'The activity type to filter by.\n\nFor example, you can choose to filter by "force_push", to see all force pushes to the repository.'
      )
      .optional()
  })
  export type ReposListActivitiesParams = z.infer<
    typeof ReposListActivitiesParamsSchema
  >

  export const ReposListActivitiesResponseSchema = z.array(ActivitySchema)
  export type ReposListActivitiesResponse = z.infer<
    typeof ReposListActivitiesResponseSchema
  >

  export const IssuesListAssigneesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListAssigneesParams = z.infer<
    typeof IssuesListAssigneesParamsSchema
  >

  export const IssuesListAssigneesResponseSchema = z.array(SimpleUserSchema)
  export type IssuesListAssigneesResponse = z.infer<
    typeof IssuesListAssigneesResponseSchema
  >

  export const IssuesCheckUserCanBeAssignedParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    assignee: z.string()
  })
  export type IssuesCheckUserCanBeAssignedParams = z.infer<
    typeof IssuesCheckUserCanBeAssignedParamsSchema
  >

  export type IssuesCheckUserCanBeAssignedResponse = undefined

  export const ReposCreateAttestationParamsSchema = z.object({
    bundle: z
      .object({
        mediaType: z.string().optional(),
        verificationMaterial: z.object({}).catchall(z.any()).optional(),
        dsseEnvelope: z.object({}).catchall(z.any()).optional()
      })
      .describe(
        "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateAttestationParams = z.infer<
    typeof ReposCreateAttestationParamsSchema
  >

  export type ReposCreateAttestationResponse = undefined

  export const ReposListAttestationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    subject_digest: z
      .string()
      .describe(
        "The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`."
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type ReposListAttestationsParams = z.infer<
    typeof ReposListAttestationsParamsSchema
  >

  export const ReposListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type ReposListAttestationsResponse = z.infer<
    typeof ReposListAttestationsResponseSchema
  >

  export const ReposListAutolinksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListAutolinksParams = z.infer<
    typeof ReposListAutolinksParamsSchema
  >

  export const ReposListAutolinksResponseSchema = z.array(AutolinkSchema)
  export type ReposListAutolinksResponse = z.infer<
    typeof ReposListAutolinksResponseSchema
  >

  export const ReposCreateAutolinkParamsSchema = z.object({
    key_prefix: z
      .string()
      .describe(
        'This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.'
      ),
    url_template: z
      .string()
      .describe(
        'The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.'
      ),
    is_alphanumeric: z
      .boolean()
      .describe(
        'Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateAutolinkParams = z.infer<
    typeof ReposCreateAutolinkParamsSchema
  >

  export type ReposCreateAutolinkResponse = undefined

  export const ReposGetAutolinkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    autolink_id: z
      .number()
      .int()
      .describe('The unique identifier of the autolink.')
  })
  export type ReposGetAutolinkParams = z.infer<
    typeof ReposGetAutolinkParamsSchema
  >

  export const ReposGetAutolinkResponseSchema = AutolinkSchema
  export type ReposGetAutolinkResponse = z.infer<
    typeof ReposGetAutolinkResponseSchema
  >

  export const ReposDeleteAutolinkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    autolink_id: z
      .number()
      .int()
      .describe('The unique identifier of the autolink.')
  })
  export type ReposDeleteAutolinkParams = z.infer<
    typeof ReposDeleteAutolinkParamsSchema
  >

  export type ReposDeleteAutolinkResponse = undefined

  export const ReposCheckAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckAutomatedSecurityFixesParams = z.infer<
    typeof ReposCheckAutomatedSecurityFixesParamsSchema
  >

  export const ReposCheckAutomatedSecurityFixesResponseSchema =
    CheckAutomatedSecurityFixesSchema
  export type ReposCheckAutomatedSecurityFixesResponse = z.infer<
    typeof ReposCheckAutomatedSecurityFixesResponseSchema
  >

  export const ReposEnableAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnableAutomatedSecurityFixesParams = z.infer<
    typeof ReposEnableAutomatedSecurityFixesParamsSchema
  >

  export type ReposEnableAutomatedSecurityFixesResponse = undefined

  export const ReposDisableAutomatedSecurityFixesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDisableAutomatedSecurityFixesParams = z.infer<
    typeof ReposDisableAutomatedSecurityFixesParamsSchema
  >

  export type ReposDisableAutomatedSecurityFixesResponse = undefined

  export const ReposListBranchesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    protected: z
      .boolean()
      .describe(
        'Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListBranchesParams = z.infer<
    typeof ReposListBranchesParamsSchema
  >

  export const ReposListBranchesResponseSchema = z.array(ShortBranchSchema)
  export type ReposListBranchesResponse = z.infer<
    typeof ReposListBranchesResponseSchema
  >

  export const ReposGetBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetBranchParams = z.infer<typeof ReposGetBranchParamsSchema>

  export const ReposGetBranchResponseSchema = BranchWithProtectionSchema
  export type ReposGetBranchResponse = z.infer<
    typeof ReposGetBranchResponseSchema
  >

  export const ReposGetBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetBranchProtectionParams = z.infer<
    typeof ReposGetBranchProtectionParamsSchema
  >

  export const ReposGetBranchProtectionResponseSchema = BranchProtectionSchema
  export type ReposGetBranchProtectionResponse = z.infer<
    typeof ReposGetBranchProtectionResponseSchema
  >

  export const ReposUpdateBranchProtectionParamsSchema = z.object({
    required_status_checks: z
      .object({
        strict: z
          .boolean()
          .describe('Require branches to be up to date before merging.'),
        contexts: z
          .array(z.string())
          .describe(
            '**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.'
          ),
        checks: z
          .array(
            z.object({
              context: z.string().describe('The name of the required check'),
              app_id: z
                .number()
                .int()
                .describe(
                  'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                )
                .optional()
            })
          )
          .describe(
            'The list of status checks to require in order to merge into this branch.'
          )
          .optional()
      })
      .describe(
        'Require status checks to pass before merging. Set to `null` to disable.'
      ),
    enforce_admins: z
      .boolean()
      .describe(
        'Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.'
      ),
    required_pull_request_reviews: z
      .object({
        dismissal_restrictions: z
          .object({
            users: z
              .array(z.string())
              .describe('The list of user `login`s with dismissal access')
              .optional(),
            teams: z
              .array(z.string())
              .describe('The list of team `slug`s with dismissal access')
              .optional(),
            apps: z
              .array(z.string())
              .describe('The list of app `slug`s with dismissal access')
              .optional()
          })
          .describe(
            'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.'
          )
          .optional(),
        dismiss_stale_reviews: z
          .boolean()
          .describe(
            'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
          )
          .optional(),
        require_code_owner_reviews: z
          .boolean()
          .describe(
            'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.'
          )
          .optional(),
        required_approving_review_count: z
          .number()
          .int()
          .describe(
            'Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
          )
          .optional(),
        require_last_push_approval: z
          .boolean()
          .describe(
            'Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.'
          )
          .default(false),
        bypass_pull_request_allowances: z
          .object({
            users: z
              .array(z.string())
              .describe(
                'The list of user `login`s allowed to bypass pull request requirements.'
              )
              .optional(),
            teams: z
              .array(z.string())
              .describe(
                'The list of team `slug`s allowed to bypass pull request requirements.'
              )
              .optional(),
            apps: z
              .array(z.string())
              .describe(
                'The list of app `slug`s allowed to bypass pull request requirements.'
              )
              .optional()
          })
          .describe(
            'Allow specific users, teams, or apps to bypass pull request requirements.'
          )
          .optional()
      })
      .describe(
        'Require at least one approving review on a pull request, before merging. Set to `null` to disable.'
      ),
    restrictions: z
      .object({
        users: z
          .array(z.string())
          .describe('The list of user `login`s with push access'),
        teams: z
          .array(z.string())
          .describe('The list of team `slug`s with push access'),
        apps: z
          .array(z.string())
          .describe('The list of app `slug`s with push access')
          .optional()
      })
      .describe(
        'Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.'
      ),
    required_linear_history: z
      .boolean()
      .describe(
        'Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.'
      )
      .optional(),
    allow_force_pushes: z
      .boolean()
      .describe(
        'Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."'
      )
      .optional(),
    allow_deletions: z
      .boolean()
      .describe(
        'Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.'
      )
      .optional(),
    block_creations: z
      .boolean()
      .describe(
        'If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.'
      )
      .optional(),
    required_conversation_resolution: z
      .boolean()
      .describe(
        'Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.'
      )
      .optional(),
    lock_branch: z
      .boolean()
      .describe(
        'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.'
      )
      .default(false),
    allow_fork_syncing: z
      .boolean()
      .describe(
        'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.'
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdateBranchProtectionParams = z.infer<
    typeof ReposUpdateBranchProtectionParamsSchema
  >

  export const ReposUpdateBranchProtectionResponseSchema = ProtectedBranchSchema
  export type ReposUpdateBranchProtectionResponse = z.infer<
    typeof ReposUpdateBranchProtectionResponseSchema
  >

  export const ReposDeleteBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteBranchProtectionParams = z.infer<
    typeof ReposDeleteBranchProtectionParamsSchema
  >

  export type ReposDeleteBranchProtectionResponse = undefined

  export const ReposGetAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAdminBranchProtectionParams = z.infer<
    typeof ReposGetAdminBranchProtectionParamsSchema
  >

  export const ReposGetAdminBranchProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposGetAdminBranchProtectionResponse = z.infer<
    typeof ReposGetAdminBranchProtectionResponseSchema
  >

  export const ReposSetAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetAdminBranchProtectionParams = z.infer<
    typeof ReposSetAdminBranchProtectionParamsSchema
  >

  export const ReposSetAdminBranchProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposSetAdminBranchProtectionResponse = z.infer<
    typeof ReposSetAdminBranchProtectionResponseSchema
  >

  export const ReposDeleteAdminBranchProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteAdminBranchProtectionParams = z.infer<
    typeof ReposDeleteAdminBranchProtectionParamsSchema
  >

  export type ReposDeleteAdminBranchProtectionResponse = undefined

  export const ReposGetPullRequestReviewProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetPullRequestReviewProtectionParams = z.infer<
    typeof ReposGetPullRequestReviewProtectionParamsSchema
  >

  export const ReposGetPullRequestReviewProtectionResponseSchema =
    ProtectedBranchPullRequestReviewSchema
  export type ReposGetPullRequestReviewProtectionResponse = z.infer<
    typeof ReposGetPullRequestReviewProtectionResponseSchema
  >

  export const ReposDeletePullRequestReviewProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeletePullRequestReviewProtectionParams = z.infer<
    typeof ReposDeletePullRequestReviewProtectionParamsSchema
  >

  export type ReposDeletePullRequestReviewProtectionResponse = undefined

  export const ReposUpdatePullRequestReviewProtectionParamsSchema = z.object({
    dismissal_restrictions: z
      .object({
        users: z
          .array(z.string())
          .describe('The list of user `login`s with dismissal access')
          .optional(),
        teams: z
          .array(z.string())
          .describe('The list of team `slug`s with dismissal access')
          .optional(),
        apps: z
          .array(z.string())
          .describe('The list of app `slug`s with dismissal access')
          .optional()
      })
      .describe(
        'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.'
      )
      .optional(),
    dismiss_stale_reviews: z
      .boolean()
      .describe(
        'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
      )
      .optional(),
    require_code_owner_reviews: z
      .boolean()
      .describe(
        'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.'
      )
      .optional(),
    required_approving_review_count: z
      .number()
      .int()
      .describe(
        'Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
      )
      .optional(),
    require_last_push_approval: z
      .boolean()
      .describe(
        'Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`'
      )
      .default(false),
    bypass_pull_request_allowances: z
      .object({
        users: z
          .array(z.string())
          .describe(
            'The list of user `login`s allowed to bypass pull request requirements.'
          )
          .optional(),
        teams: z
          .array(z.string())
          .describe(
            'The list of team `slug`s allowed to bypass pull request requirements.'
          )
          .optional(),
        apps: z
          .array(z.string())
          .describe(
            'The list of app `slug`s allowed to bypass pull request requirements.'
          )
          .optional()
      })
      .describe(
        'Allow specific users, teams, or apps to bypass pull request requirements.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdatePullRequestReviewProtectionParams = z.infer<
    typeof ReposUpdatePullRequestReviewProtectionParamsSchema
  >

  export const ReposUpdatePullRequestReviewProtectionResponseSchema =
    ProtectedBranchPullRequestReviewSchema
  export type ReposUpdatePullRequestReviewProtectionResponse = z.infer<
    typeof ReposUpdatePullRequestReviewProtectionResponseSchema
  >

  export const ReposGetCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetCommitSignatureProtectionParams = z.infer<
    typeof ReposGetCommitSignatureProtectionParamsSchema
  >

  export const ReposGetCommitSignatureProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposGetCommitSignatureProtectionResponse = z.infer<
    typeof ReposGetCommitSignatureProtectionResponseSchema
  >

  export const ReposCreateCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposCreateCommitSignatureProtectionParams = z.infer<
    typeof ReposCreateCommitSignatureProtectionParamsSchema
  >

  export const ReposCreateCommitSignatureProtectionResponseSchema =
    ProtectedBranchAdminEnforcedSchema
  export type ReposCreateCommitSignatureProtectionResponse = z.infer<
    typeof ReposCreateCommitSignatureProtectionResponseSchema
  >

  export const ReposDeleteCommitSignatureProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteCommitSignatureProtectionParams = z.infer<
    typeof ReposDeleteCommitSignatureProtectionParamsSchema
  >

  export type ReposDeleteCommitSignatureProtectionResponse = undefined

  export const ReposGetStatusChecksProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetStatusChecksProtectionParams = z.infer<
    typeof ReposGetStatusChecksProtectionParamsSchema
  >

  export const ReposGetStatusChecksProtectionResponseSchema =
    StatusCheckPolicySchema
  export type ReposGetStatusChecksProtectionResponse = z.infer<
    typeof ReposGetStatusChecksProtectionResponseSchema
  >

  export const ReposRemoveStatusCheckProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveStatusCheckProtectionParams = z.infer<
    typeof ReposRemoveStatusCheckProtectionParamsSchema
  >

  export type ReposRemoveStatusCheckProtectionResponse = undefined

  export const ReposUpdateStatusCheckProtectionParamsSchema = z.object({
    strict: z
      .boolean()
      .describe('Require branches to be up to date before merging.')
      .optional(),
    contexts: z
      .array(z.string())
      .describe(
        '**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.'
      )
      .optional(),
    checks: z
      .array(
        z.object({
          context: z.string().describe('The name of the required check'),
          app_id: z
            .number()
            .int()
            .describe(
              'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
            )
            .optional()
        })
      )
      .describe(
        'The list of status checks to require in order to merge into this branch.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposUpdateStatusCheckProtectionParams = z.infer<
    typeof ReposUpdateStatusCheckProtectionParamsSchema
  >

  export const ReposUpdateStatusCheckProtectionResponseSchema =
    StatusCheckPolicySchema
  export type ReposUpdateStatusCheckProtectionResponse = z.infer<
    typeof ReposUpdateStatusCheckProtectionResponseSchema
  >

  export const ReposGetAllStatusCheckContextsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAllStatusCheckContextsParams = z.infer<
    typeof ReposGetAllStatusCheckContextsParamsSchema
  >

  export const ReposGetAllStatusCheckContextsResponseSchema = z.array(
    z.string()
  )
  export type ReposGetAllStatusCheckContextsResponse = z.infer<
    typeof ReposGetAllStatusCheckContextsResponseSchema
  >

  export const ReposAddStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposAddStatusCheckContextsParams = z.infer<
    typeof ReposAddStatusCheckContextsParamsSchema
  >

  export const ReposAddStatusCheckContextsResponseSchema = z.array(z.string())
  export type ReposAddStatusCheckContextsResponse = z.infer<
    typeof ReposAddStatusCheckContextsResponseSchema
  >

  export const ReposSetStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposSetStatusCheckContextsParams = z.infer<
    typeof ReposSetStatusCheckContextsParamsSchema
  >

  export const ReposSetStatusCheckContextsResponseSchema = z.array(z.string())
  export type ReposSetStatusCheckContextsResponse = z.infer<
    typeof ReposSetStatusCheckContextsResponseSchema
  >

  export const ReposRemoveStatusCheckContextsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          contexts: z
            .array(z.string())
            .describe('The name of the status checks')
        }),
        z.array(z.string()).describe('The name of the status checks')
      ])
    )
  export type ReposRemoveStatusCheckContextsParams = z.infer<
    typeof ReposRemoveStatusCheckContextsParamsSchema
  >

  export const ReposRemoveStatusCheckContextsResponseSchema = z.array(
    z.string()
  )
  export type ReposRemoveStatusCheckContextsResponse = z.infer<
    typeof ReposRemoveStatusCheckContextsResponseSchema
  >

  export const ReposGetAccessRestrictionsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAccessRestrictionsParams = z.infer<
    typeof ReposGetAccessRestrictionsParamsSchema
  >

  export const ReposGetAccessRestrictionsResponseSchema =
    BranchRestrictionPolicySchema
  export type ReposGetAccessRestrictionsResponse = z.infer<
    typeof ReposGetAccessRestrictionsResponseSchema
  >

  export const ReposDeleteAccessRestrictionsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposDeleteAccessRestrictionsParams = z.infer<
    typeof ReposDeleteAccessRestrictionsParamsSchema
  >

  export type ReposDeleteAccessRestrictionsResponse = undefined

  export const ReposGetAppsWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetAppsWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetAppsWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetAppsWithAccessToProtectedBranchResponseSchema =
    z.array(IntegrationSchema)
  export type ReposGetAppsWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetAppsWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposAddAppAccessRestrictionsParams = z.infer<
    typeof ReposAddAppAccessRestrictionsParamsSchema
  >

  export const ReposAddAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposAddAppAccessRestrictionsResponse = z.infer<
    typeof ReposAddAppAccessRestrictionsResponseSchema
  >

  export const ReposSetAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetAppAccessRestrictionsParams = z.infer<
    typeof ReposSetAppAccessRestrictionsParamsSchema
  >

  export const ReposSetAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposSetAppAccessRestrictionsResponse = z.infer<
    typeof ReposSetAppAccessRestrictionsResponseSchema
  >

  export const ReposRemoveAppAccessRestrictionsParamsSchema = z.object({
    apps: z
      .array(z.string())
      .describe(
        'The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveAppAccessRestrictionsParams = z.infer<
    typeof ReposRemoveAppAccessRestrictionsParamsSchema
  >

  export const ReposRemoveAppAccessRestrictionsResponseSchema =
    z.array(IntegrationSchema)
  export type ReposRemoveAppAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveAppAccessRestrictionsResponseSchema
  >

  export const ReposGetTeamsWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetTeamsWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetTeamsWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetTeamsWithAccessToProtectedBranchResponseSchema =
    z.array(TeamSchema)
  export type ReposGetTeamsWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetTeamsWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposAddTeamAccessRestrictionsParams = z.infer<
    typeof ReposAddTeamAccessRestrictionsParamsSchema
  >

  export const ReposAddTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposAddTeamAccessRestrictionsResponse = z.infer<
    typeof ReposAddTeamAccessRestrictionsResponseSchema
  >

  export const ReposSetTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposSetTeamAccessRestrictionsParams = z.infer<
    typeof ReposSetTeamAccessRestrictionsParamsSchema
  >

  export const ReposSetTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposSetTeamAccessRestrictionsResponse = z.infer<
    typeof ReposSetTeamAccessRestrictionsResponseSchema
  >

  export const ReposRemoveTeamAccessRestrictionsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      branch: z
        .string()
        .describe(
          'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
        )
    })
    .and(
      z.union([
        z.object({
          teams: z.array(z.string()).describe('The slug values for teams')
        }),
        z.array(z.string()).describe('The slug values for teams')
      ])
    )
  export type ReposRemoveTeamAccessRestrictionsParams = z.infer<
    typeof ReposRemoveTeamAccessRestrictionsParamsSchema
  >

  export const ReposRemoveTeamAccessRestrictionsResponseSchema =
    z.array(TeamSchema)
  export type ReposRemoveTeamAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveTeamAccessRestrictionsResponseSchema
  >

  export const ReposGetUsersWithAccessToProtectedBranchParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposGetUsersWithAccessToProtectedBranchParams = z.infer<
    typeof ReposGetUsersWithAccessToProtectedBranchParamsSchema
  >

  export const ReposGetUsersWithAccessToProtectedBranchResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposGetUsersWithAccessToProtectedBranchResponse = z.infer<
    typeof ReposGetUsersWithAccessToProtectedBranchResponseSchema
  >

  export const ReposAddUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposAddUserAccessRestrictionsParams = z.infer<
    typeof ReposAddUserAccessRestrictionsParamsSchema
  >

  export const ReposAddUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposAddUserAccessRestrictionsResponse = z.infer<
    typeof ReposAddUserAccessRestrictionsResponseSchema
  >

  export const ReposSetUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposSetUserAccessRestrictionsParams = z.infer<
    typeof ReposSetUserAccessRestrictionsParamsSchema
  >

  export const ReposSetUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposSetUserAccessRestrictionsResponse = z.infer<
    typeof ReposSetUserAccessRestrictionsResponseSchema
  >

  export const ReposRemoveUserAccessRestrictionsParamsSchema = z.object({
    users: z.array(z.string()).describe('The username for users'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRemoveUserAccessRestrictionsParams = z.infer<
    typeof ReposRemoveUserAccessRestrictionsParamsSchema
  >

  export const ReposRemoveUserAccessRestrictionsResponseSchema =
    z.array(SimpleUserSchema)
  export type ReposRemoveUserAccessRestrictionsResponse = z.infer<
    typeof ReposRemoveUserAccessRestrictionsResponseSchema
  >

  export const ReposRenameBranchParamsSchema = z.object({
    new_name: z.string().describe('The new name of the branch.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      )
  })
  export type ReposRenameBranchParams = z.infer<
    typeof ReposRenameBranchParamsSchema
  >

  export type ReposRenameBranchResponse = undefined

  export const ChecksCreateParamsSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the check. For example, "code-coverage".'),
      head_sha: z.string().describe('The SHA of the commit.'),
      details_url: z
        .string()
        .describe(
          "The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used."
        )
        .optional(),
      external_id: z
        .string()
        .describe("A reference for the run on the integrator's system.")
        .optional(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
        )
        .default('queued'),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      conclusion: z
        .enum([
          'action_required',
          'cancelled',
          'failure',
          'neutral',
          'success',
          'skipped',
          'stale',
          'timed_out'
        ])
        .describe(
          '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      output: z
        .object({
          title: z.string().describe('The title of the check run.'),
          summary: z
            .string()
            .max(65_535)
            .describe(
              'The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
            ),
          text: z
            .string()
            .max(65_535)
            .describe(
              'The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
            )
            .optional(),
          annotations: z
            .array(
              z.object({
                path: z
                  .string()
                  .describe(
                    'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                  ),
                start_line: z
                  .number()
                  .int()
                  .describe(
                    'The start line of the annotation. Line numbers start at 1.'
                  ),
                end_line: z
                  .number()
                  .int()
                  .describe('The end line of the annotation.'),
                start_column: z
                  .number()
                  .int()
                  .describe(
                    'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                  )
                  .optional(),
                end_column: z
                  .number()
                  .int()
                  .describe(
                    'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                  )
                  .optional(),
                annotation_level: z
                  .enum(['notice', 'warning', 'failure'])
                  .describe('The level of the annotation.'),
                message: z
                  .string()
                  .describe(
                    'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                  ),
                title: z
                  .string()
                  .describe(
                    'The title that represents the annotation. The maximum size is 255 characters.'
                  )
                  .optional(),
                raw_details: z
                  .string()
                  .describe(
                    'Details about this annotation. The maximum size is 64 KB.'
                  )
                  .optional()
              })
            )
            .max(50)
            .describe(
              'Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about how you can view annotations on GitHub, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".'
            )
            .optional(),
          images: z
            .array(
              z.object({
                alt: z.string().describe('The alternative text for the image.'),
                image_url: z.string().describe('The full URL of the image.'),
                caption: z
                  .string()
                  .describe('A short image description.')
                  .optional()
              })
            )
            .describe(
              'Adds images to the output displayed in the GitHub pull request UI.'
            )
            .optional()
        })
        .describe(
          'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.'
        )
        .optional(),
      actions: z
        .array(
          z.object({
            label: z
              .string()
              .max(20)
              .describe(
                'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
              ),
            description: z
              .string()
              .max(40)
              .describe(
                'A short explanation of what this action would do. The maximum size is 40 characters.'
              ),
            identifier: z
              .string()
              .max(20)
              .describe(
                "A reference for the action on the integrator's system. The maximum size is 20 characters."
              )
          })
        )
        .max(3)
        .describe(
          'Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(
      z.union([
        z.object({ status: z.literal('completed') }).catchall(z.any()),
        z
          .object({ status: z.enum(['queued', 'in_progress']).optional() })
          .catchall(z.any())
      ])
    )
  export type ChecksCreateParams = z.infer<typeof ChecksCreateParamsSchema>

  export type ChecksCreateResponse = undefined

  export const ChecksGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.')
  })
  export type ChecksGetParams = z.infer<typeof ChecksGetParamsSchema>

  export const ChecksGetResponseSchema = CheckRunSchema
  export type ChecksGetResponse = z.infer<typeof ChecksGetResponseSchema>

  export const ChecksUpdateParamsSchema = z
    .object({
      name: z
        .string()
        .describe('The name of the check. For example, "code-coverage".')
        .optional(),
      details_url: z
        .string()
        .describe(
          "The URL of the integrator's site that has the full details of the check."
        )
        .optional(),
      external_id: z
        .string()
        .describe("A reference for the run on the integrator's system.")
        .optional(),
      started_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      status: z
        .enum([
          'queued',
          'in_progress',
          'completed',
          'waiting',
          'requested',
          'pending'
        ])
        .describe(
          'The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.'
        )
        .optional(),
      conclusion: z
        .enum([
          'action_required',
          'cancelled',
          'failure',
          'neutral',
          'success',
          'skipped',
          'stale',
          'timed_out'
        ])
        .describe(
          '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.'
        )
        .optional(),
      completed_at: z
        .string()
        .datetime({ offset: true })
        .describe(
          'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      output: z
        .object({
          title: z.string().describe('**Required**.').optional(),
          summary: z.string().max(65_535).describe('Can contain Markdown.'),
          text: z
            .string()
            .max(65_535)
            .describe('Can contain Markdown.')
            .optional(),
          annotations: z
            .array(
              z.object({
                path: z
                  .string()
                  .describe(
                    'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                  ),
                start_line: z
                  .number()
                  .int()
                  .describe(
                    'The start line of the annotation. Line numbers start at 1.'
                  ),
                end_line: z
                  .number()
                  .int()
                  .describe('The end line of the annotation.'),
                start_column: z
                  .number()
                  .int()
                  .describe(
                    'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                  )
                  .optional(),
                end_column: z
                  .number()
                  .int()
                  .describe(
                    'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                  )
                  .optional(),
                annotation_level: z
                  .enum(['notice', 'warning', 'failure'])
                  .describe('The level of the annotation.'),
                message: z
                  .string()
                  .describe(
                    'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                  ),
                title: z
                  .string()
                  .describe(
                    'The title that represents the annotation. The maximum size is 255 characters.'
                  )
                  .optional(),
                raw_details: z
                  .string()
                  .describe(
                    'Details about this annotation. The maximum size is 64 KB.'
                  )
                  .optional()
              })
            )
            .max(50)
            .describe(
              'Adds information from your analysis to specific lines of code. Annotations are visible in GitHub\'s pull request UI. Annotations are visible in GitHub\'s pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about annotations in the UI, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".'
            )
            .optional(),
          images: z
            .array(
              z.object({
                alt: z.string().describe('The alternative text for the image.'),
                image_url: z.string().describe('The full URL of the image.'),
                caption: z
                  .string()
                  .describe('A short image description.')
                  .optional()
              })
            )
            .describe(
              'Adds images to the output displayed in the GitHub pull request UI.'
            )
            .optional()
        })
        .describe(
          'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.'
        )
        .optional(),
      actions: z
        .array(
          z.object({
            label: z
              .string()
              .max(20)
              .describe(
                'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
              ),
            description: z
              .string()
              .max(40)
              .describe(
                'A short explanation of what this action would do. The maximum size is 40 characters.'
              ),
            identifier: z
              .string()
              .max(20)
              .describe(
                "A reference for the action on the integrator's system. The maximum size is 20 characters."
              )
          })
        )
        .max(3)
        .describe(
          'Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      check_run_id: z
        .number()
        .int()
        .describe('The unique identifier of the check run.')
    })
    .and(
      z.union([
        z
          .object({ status: z.literal('completed').optional() })
          .catchall(z.any()),
        z
          .object({ status: z.enum(['queued', 'in_progress']).optional() })
          .catchall(z.any())
      ])
    )
  export type ChecksUpdateParams = z.infer<typeof ChecksUpdateParamsSchema>

  export const ChecksUpdateResponseSchema = CheckRunSchema
  export type ChecksUpdateResponse = z.infer<typeof ChecksUpdateResponseSchema>

  export const ChecksListAnnotationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListAnnotationsParams = z.infer<
    typeof ChecksListAnnotationsParamsSchema
  >

  export const ChecksListAnnotationsResponseSchema = z.array(
    CheckAnnotationSchema
  )
  export type ChecksListAnnotationsResponse = z.infer<
    typeof ChecksListAnnotationsResponseSchema
  >

  export const ChecksRerequestRunParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_run_id: z
      .number()
      .int()
      .describe('The unique identifier of the check run.')
  })
  export type ChecksRerequestRunParams = z.infer<
    typeof ChecksRerequestRunParamsSchema
  >

  export type ChecksRerequestRunResponse = undefined

  export const ChecksCreateSuiteParamsSchema = z.object({
    head_sha: z.string().describe('The sha of the head commit.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ChecksCreateSuiteParams = z.infer<
    typeof ChecksCreateSuiteParamsSchema
  >

  export const ChecksCreateSuiteResponseSchema = CheckSuiteSchema
  export type ChecksCreateSuiteResponse = z.infer<
    typeof ChecksCreateSuiteResponseSchema
  >

  export const ChecksSetSuitesPreferencesParamsSchema = z.object({
    auto_trigger_checks: z
      .array(
        z.object({
          app_id: z.number().int().describe('The `id` of the GitHub App.'),
          setting: z
            .boolean()
            .describe(
              'Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.'
            )
            .default(true)
        })
      )
      .describe(
        'Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ChecksSetSuitesPreferencesParams = z.infer<
    typeof ChecksSetSuitesPreferencesParamsSchema
  >

  export const ChecksSetSuitesPreferencesResponseSchema =
    CheckSuitePreferenceSchema
  export type ChecksSetSuitesPreferencesResponse = z.infer<
    typeof ChecksSetSuitesPreferencesResponseSchema
  >

  export const ChecksGetSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.')
  })
  export type ChecksGetSuiteParams = z.infer<typeof ChecksGetSuiteParamsSchema>

  export const ChecksGetSuiteResponseSchema = CheckSuiteSchema
  export type ChecksGetSuiteResponse = z.infer<
    typeof ChecksGetSuiteResponseSchema
  >

  export const ChecksListForSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.'),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    status: z
      .enum(['queued', 'in_progress', 'completed'])
      .describe('Returns check runs with the specified `status`.')
      .optional(),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListForSuiteParams = z.infer<
    typeof ChecksListForSuiteParamsSchema
  >

  export const ChecksListForSuiteResponseSchema = z.object({
    total_count: z.number().int(),
    check_runs: z.array(CheckRunSchema)
  })
  export type ChecksListForSuiteResponse = z.infer<
    typeof ChecksListForSuiteResponseSchema
  >

  export const ChecksRerequestSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    check_suite_id: z
      .number()
      .int()
      .describe('The unique identifier of the check suite.')
  })
  export type ChecksRerequestSuiteParams = z.infer<
    typeof ChecksRerequestSuiteParamsSchema
  >

  export type ChecksRerequestSuiteResponse = undefined

  export const CodeScanningListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property by which to sort the results.')
      .default('created'),
    state: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this state will be returned.'
      )
      .optional(),
    severity: z
      .any()
      .describe(
        'If specified, only code scanning alerts with this severity will be returned.'
      )
      .optional()
  })
  export type CodeScanningListAlertsForRepoParams = z.infer<
    typeof CodeScanningListAlertsForRepoParamsSchema
  >

  export const CodeScanningListAlertsForRepoResponseSchema = z.array(
    CodeScanningAlertItemsSchema
  )
  export type CodeScanningListAlertsForRepoResponse = z.infer<
    typeof CodeScanningListAlertsForRepoResponseSchema
  >

  export const CodeScanningGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningGetAlertParams = z.infer<
    typeof CodeScanningGetAlertParamsSchema
  >

  export const CodeScanningGetAlertResponseSchema = CodeScanningAlertSchema
  export type CodeScanningGetAlertResponse = z.infer<
    typeof CodeScanningGetAlertResponseSchema
  >

  export const CodeScanningUpdateAlertParamsSchema = z.object({
    state: CodeScanningAlertSetStateSchema,
    dismissed_reason: CodeScanningAlertDismissedReasonSchema.optional(),
    dismissed_comment: CodeScanningAlertDismissedCommentSchema.optional(),
    create_request: CodeScanningAlertCreateRequestSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningUpdateAlertParams = z.infer<
    typeof CodeScanningUpdateAlertParamsSchema
  >

  export const CodeScanningUpdateAlertResponseSchema = CodeScanningAlertSchema
  export type CodeScanningUpdateAlertResponse = z.infer<
    typeof CodeScanningUpdateAlertResponseSchema
  >

  export const CodeScanningGetAutofixParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningGetAutofixParams = z.infer<
    typeof CodeScanningGetAutofixParamsSchema
  >

  export const CodeScanningGetAutofixResponseSchema = CodeScanningAutofixSchema
  export type CodeScanningGetAutofixResponse = z.infer<
    typeof CodeScanningGetAutofixResponseSchema
  >

  export const CodeScanningCreateAutofixParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type CodeScanningCreateAutofixParams = z.infer<
    typeof CodeScanningCreateAutofixParamsSchema
  >

  export const CodeScanningCreateAutofixResponseSchema =
    CodeScanningAutofixSchema
  export type CodeScanningCreateAutofixResponse = z.infer<
    typeof CodeScanningCreateAutofixResponseSchema
  >

  export const CodeScanningCommitAutofixParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      alert_number: z
        .any()
        .describe(
          'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
        )
    })
    .merge(CodeScanningAutofixCommitsSchema)
  export type CodeScanningCommitAutofixParams = z.infer<
    typeof CodeScanningCommitAutofixParamsSchema
  >

  export type CodeScanningCommitAutofixResponse = undefined

  export const CodeScanningListAlertInstancesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional()
  })
  export type CodeScanningListAlertInstancesParams = z.infer<
    typeof CodeScanningListAlertInstancesParamsSchema
  >

  export const CodeScanningListAlertInstancesResponseSchema = z.array(
    CodeScanningAlertInstanceSchema
  )
  export type CodeScanningListAlertInstancesResponse = z.infer<
    typeof CodeScanningListAlertInstancesResponseSchema
  >

  export const CodeScanningListRecentAnalysesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tool_name: z
      .any()
      .describe(
        'The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.'
      )
      .optional(),
    tool_guid: z
      .any()
      .describe(
        'The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    pr: z
      .number()
      .int()
      .describe(
        'The number of the pull request for the results you want to list.'
      )
      .optional(),
    ref: z
      .any()
      .describe(
        'The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional(),
    sarif_id: z
      .any()
      .describe('Filter analyses belonging to the same SARIF upload.')
      .optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    sort: z
      .literal('created')
      .describe('The property by which to sort the results.')
      .default('created')
  })
  export type CodeScanningListRecentAnalysesParams = z.infer<
    typeof CodeScanningListRecentAnalysesParamsSchema
  >

  export const CodeScanningListRecentAnalysesResponseSchema = z.array(
    CodeScanningAnalysisSchema
  )
  export type CodeScanningListRecentAnalysesResponse = z.infer<
    typeof CodeScanningListRecentAnalysesResponseSchema
  >

  export const CodeScanningGetAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    analysis_id: z
      .number()
      .int()
      .describe(
        'The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.'
      )
  })
  export type CodeScanningGetAnalysisParams = z.infer<
    typeof CodeScanningGetAnalysisParamsSchema
  >

  export const CodeScanningGetAnalysisResponseSchema =
    CodeScanningAnalysisSchema
  export type CodeScanningGetAnalysisResponse = z.infer<
    typeof CodeScanningGetAnalysisResponseSchema
  >

  export const CodeScanningDeleteAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    analysis_id: z
      .number()
      .int()
      .describe(
        'The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.'
      ),
    confirm_delete: z
      .union([z.string(), z.null()])
      .describe(
        "Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`"
      )
      .optional()
  })
  export type CodeScanningDeleteAnalysisParams = z.infer<
    typeof CodeScanningDeleteAnalysisParamsSchema
  >

  export const CodeScanningDeleteAnalysisResponseSchema =
    CodeScanningAnalysisDeletionSchema
  export type CodeScanningDeleteAnalysisResponse = z.infer<
    typeof CodeScanningDeleteAnalysisResponseSchema
  >

  export const CodeScanningListCodeqlDatabasesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningListCodeqlDatabasesParams = z.infer<
    typeof CodeScanningListCodeqlDatabasesParamsSchema
  >

  export const CodeScanningListCodeqlDatabasesResponseSchema = z.array(
    CodeScanningCodeqlDatabaseSchema
  )
  export type CodeScanningListCodeqlDatabasesResponse = z.infer<
    typeof CodeScanningListCodeqlDatabasesResponseSchema
  >

  export const CodeScanningGetCodeqlDatabaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    language: z.string().describe('The language of the CodeQL database.')
  })
  export type CodeScanningGetCodeqlDatabaseParams = z.infer<
    typeof CodeScanningGetCodeqlDatabaseParamsSchema
  >

  export const CodeScanningGetCodeqlDatabaseResponseSchema =
    CodeScanningCodeqlDatabaseSchema
  export type CodeScanningGetCodeqlDatabaseResponse = z.infer<
    typeof CodeScanningGetCodeqlDatabaseResponseSchema
  >

  export const CodeScanningDeleteCodeqlDatabaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    language: z.string().describe('The language of the CodeQL database.')
  })
  export type CodeScanningDeleteCodeqlDatabaseParams = z.infer<
    typeof CodeScanningDeleteCodeqlDatabaseParamsSchema
  >

  export type CodeScanningDeleteCodeqlDatabaseResponse = undefined

  export const CodeScanningCreateVariantAnalysisParamsSchema = z
    .object({
      language: CodeScanningVariantAnalysisLanguageSchema,
      query_pack: z
        .string()
        .describe(
          'A Base64-encoded tarball containing a CodeQL query and all its dependencies'
        ),
      repositories: z
        .array(z.string())
        .describe(
          'List of repository names (in the form `owner/repo-name`) to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      repository_lists: z
        .array(z.string())
        .max(1)
        .describe(
          'List of repository lists to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      repository_owners: z
        .array(z.string())
        .max(1)
        .describe(
          'List of organization or user names whose repositories the query should be run against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any(), z.any()]))
  export type CodeScanningCreateVariantAnalysisParams = z.infer<
    typeof CodeScanningCreateVariantAnalysisParamsSchema
  >

  export type CodeScanningCreateVariantAnalysisResponse = undefined

  export const CodeScanningGetVariantAnalysisParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    codeql_variant_analysis_id: z
      .number()
      .int()
      .describe('The unique identifier of the variant analysis.')
  })
  export type CodeScanningGetVariantAnalysisParams = z.infer<
    typeof CodeScanningGetVariantAnalysisParamsSchema
  >

  export const CodeScanningGetVariantAnalysisResponseSchema =
    CodeScanningVariantAnalysisSchema
  export type CodeScanningGetVariantAnalysisResponse = z.infer<
    typeof CodeScanningGetVariantAnalysisResponseSchema
  >

  export const CodeScanningGetVariantAnalysisRepoTaskParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z.string().describe('The name of the controller repository.'),
    codeql_variant_analysis_id: z
      .number()
      .int()
      .describe('The ID of the variant analysis.'),
    repo_owner: z
      .string()
      .describe(
        'The account owner of the variant analysis repository. The name is not case sensitive.'
      ),
    repo_name: z
      .string()
      .describe('The name of the variant analysis repository.')
  })
  export type CodeScanningGetVariantAnalysisRepoTaskParams = z.infer<
    typeof CodeScanningGetVariantAnalysisRepoTaskParamsSchema
  >

  export const CodeScanningGetVariantAnalysisRepoTaskResponseSchema =
    CodeScanningVariantAnalysisRepoTaskSchema
  export type CodeScanningGetVariantAnalysisRepoTaskResponse = z.infer<
    typeof CodeScanningGetVariantAnalysisRepoTaskResponseSchema
  >

  export const CodeScanningGetDefaultSetupParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningGetDefaultSetupParams = z.infer<
    typeof CodeScanningGetDefaultSetupParamsSchema
  >

  export const CodeScanningGetDefaultSetupResponseSchema =
    CodeScanningDefaultSetupSchema
  export type CodeScanningGetDefaultSetupResponse = z.infer<
    typeof CodeScanningGetDefaultSetupResponseSchema
  >

  export const CodeScanningUpdateDefaultSetupParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(CodeScanningDefaultSetupUpdateSchema)
  export type CodeScanningUpdateDefaultSetupParams = z.infer<
    typeof CodeScanningUpdateDefaultSetupParamsSchema
  >

  export const CodeScanningUpdateDefaultSetupResponseSchema = EmptyObjectSchema
  export type CodeScanningUpdateDefaultSetupResponse = z.infer<
    typeof CodeScanningUpdateDefaultSetupResponseSchema
  >

  export const CodeScanningUploadSarifParamsSchema = z.object({
    commit_sha: CodeScanningAnalysisCommitShaSchema,
    ref: CodeScanningRefFullSchema,
    sarif: CodeScanningAnalysisSarifFileSchema,
    checkout_uri: z
      .string()
      .url()
      .describe(
        'The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.'
      )
      .optional(),
    started_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    tool_name: z
      .string()
      .describe(
        'The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.'
      )
      .optional(),
    validate: z
      .boolean()
      .describe(
        'Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodeScanningUploadSarifParams = z.infer<
    typeof CodeScanningUploadSarifParamsSchema
  >

  export type CodeScanningUploadSarifResponse = undefined

  export const CodeScanningGetSarifParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sarif_id: z.string().describe('The SARIF ID obtained after uploading.')
  })
  export type CodeScanningGetSarifParams = z.infer<
    typeof CodeScanningGetSarifParamsSchema
  >

  export const CodeScanningGetSarifResponseSchema =
    CodeScanningSarifsStatusSchema
  export type CodeScanningGetSarifResponse = z.infer<
    typeof CodeScanningGetSarifResponseSchema
  >

  export const CodeSecurityGetConfigurationForRepositoryParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type CodeSecurityGetConfigurationForRepositoryParams = z.infer<
    typeof CodeSecurityGetConfigurationForRepositoryParamsSchema
  >

  export const CodeSecurityGetConfigurationForRepositoryResponseSchema =
    CodeSecurityConfigurationForRepositorySchema
  export type CodeSecurityGetConfigurationForRepositoryResponse = z.infer<
    typeof CodeSecurityGetConfigurationForRepositoryResponseSchema
  >

  export const ReposCodeownersErrorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        "A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)"
      )
      .optional()
  })
  export type ReposCodeownersErrorsParams = z.infer<
    typeof ReposCodeownersErrorsParamsSchema
  >

  export const ReposCodeownersErrorsResponseSchema = CodeownersErrorsSchema
  export type ReposCodeownersErrorsResponse = z.infer<
    typeof ReposCodeownersErrorsResponseSchema
  >

  export const CodespacesListInRepositoryForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type CodespacesListInRepositoryForAuthenticatedUserParams = z.infer<
    typeof CodespacesListInRepositoryForAuthenticatedUserParamsSchema
  >

  export const CodespacesListInRepositoryForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      codespaces: z.array(CodespaceSchema)
    })
  export type CodespacesListInRepositoryForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListInRepositoryForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateWithRepoForAuthenticatedUserParamsSchema =
    z.object({
      ref: z
        .string()
        .describe('Git ref (typically a branch name) for this codespace')
        .optional(),
      location: z
        .string()
        .describe(
          'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
        )
        .optional(),
      geo: z
        .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
        .describe(
          'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      machine: z
        .string()
        .describe('Machine type to use for this codespace')
        .optional(),
      devcontainer_path: z
        .string()
        .describe('Path to devcontainer.json config to use for this codespace')
        .optional(),
      multi_repo_permissions_opt_out: z
        .boolean()
        .describe(
          'Whether to authorize requested permissions from devcontainer.json'
        )
        .optional(),
      working_directory: z
        .string()
        .describe('Working directory for this codespace')
        .optional(),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe('Time in minutes before codespace stops from inactivity')
        .optional(),
      display_name: z
        .string()
        .describe('Display name for this codespace')
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type CodespacesCreateWithRepoForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateWithRepoForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateWithRepoForAuthenticatedUserResponse = undefined

  export const CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamsSchema
    >

  export const CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      devcontainers: z.array(
        z.object({
          path: z.string(),
          name: z.string().optional(),
          display_name: z.string().optional()
        })
      )
    })
  export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse =
    z.infer<
      typeof CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseSchema
    >

  export const CodespacesRepoMachinesForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      location: z
        .string()
        .describe(
          'The location to check for available machines. Assigned by IP if not provided.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      ref: z
        .string()
        .describe(
          'The branch or commit to check for prebuild availability and devcontainer restrictions.'
        )
        .optional()
    })
  export type CodespacesRepoMachinesForAuthenticatedUserParams = z.infer<
    typeof CodespacesRepoMachinesForAuthenticatedUserParamsSchema
  >

  export const CodespacesRepoMachinesForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      machines: z.array(CodespaceMachineSchema)
    })
  export type CodespacesRepoMachinesForAuthenticatedUserResponse = z.infer<
    typeof CodespacesRepoMachinesForAuthenticatedUserResponseSchema
  >

  export const CodespacesPreFlightWithRepoForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ref: z
        .string()
        .describe(
          'The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe(
          'An alternative IP for default location auto-detection, such as when proxying a request.'
        )
        .optional()
    })
  export type CodespacesPreFlightWithRepoForAuthenticatedUserParams = z.infer<
    typeof CodespacesPreFlightWithRepoForAuthenticatedUserParamsSchema
  >

  export const CodespacesPreFlightWithRepoForAuthenticatedUserResponseSchema =
    z.object({
      billable_owner: SimpleUserSchema.optional(),
      defaults: z
        .object({ location: z.string(), devcontainer_path: z.string() })
        .optional()
    })
  export type CodespacesPreFlightWithRepoForAuthenticatedUserResponse = z.infer<
    typeof CodespacesPreFlightWithRepoForAuthenticatedUserResponseSchema
  >

  export const CodespacesCheckPermissionsForDevcontainerParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ref: z
        .string()
        .describe(
          'The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
        ),
      devcontainer_path: z
        .string()
        .describe(
          'Path to the devcontainer.json configuration to use for the permission check.'
        )
    }
  )
  export type CodespacesCheckPermissionsForDevcontainerParams = z.infer<
    typeof CodespacesCheckPermissionsForDevcontainerParamsSchema
  >

  export const CodespacesCheckPermissionsForDevcontainerResponseSchema =
    CodespacesPermissionsCheckForDevcontainerSchema
  export type CodespacesCheckPermissionsForDevcontainerResponse = z.infer<
    typeof CodespacesCheckPermissionsForDevcontainerResponseSchema
  >

  export const CodespacesListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type CodespacesListRepoSecretsParams = z.infer<
    typeof CodespacesListRepoSecretsParamsSchema
  >

  export const CodespacesListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(RepoCodespacesSecretSchema)
  })
  export type CodespacesListRepoSecretsResponse = z.infer<
    typeof CodespacesListRepoSecretsResponseSchema
  >

  export const CodespacesGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type CodespacesGetRepoPublicKeyParams = z.infer<
    typeof CodespacesGetRepoPublicKeyParamsSchema
  >

  export const CodespacesGetRepoPublicKeyResponseSchema =
    CodespacesPublicKeySchema
  export type CodespacesGetRepoPublicKeyResponse = z.infer<
    typeof CodespacesGetRepoPublicKeyResponseSchema
  >

  export const CodespacesGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetRepoSecretParams = z.infer<
    typeof CodespacesGetRepoSecretParamsSchema
  >

  export const CodespacesGetRepoSecretResponseSchema =
    RepoCodespacesSecretSchema
  export type CodespacesGetRepoSecretResponse = z.infer<
    typeof CodespacesGetRepoSecretResponseSchema
  >

  export const CodespacesCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesCreateOrUpdateRepoSecretParams = z.infer<
    typeof CodespacesCreateOrUpdateRepoSecretParamsSchema
  >

  export type CodespacesCreateOrUpdateRepoSecretResponse = undefined

  export const CodespacesDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesDeleteRepoSecretParams = z.infer<
    typeof CodespacesDeleteRepoSecretParamsSchema
  >

  export type CodespacesDeleteRepoSecretResponse = undefined

  export const ReposListCollaboratorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    affiliation: z
      .enum(['outside', 'direct', 'all'])
      .describe(
        'Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.'
      )
      .default('all'),
    permission: z
      .enum(['pull', 'triage', 'push', 'maintain', 'admin'])
      .describe(
        'Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCollaboratorsParams = z.infer<
    typeof ReposListCollaboratorsParamsSchema
  >

  export const ReposListCollaboratorsResponseSchema =
    z.array(CollaboratorSchema)
  export type ReposListCollaboratorsResponse = z.infer<
    typeof ReposListCollaboratorsResponseSchema
  >

  export const ReposCheckCollaboratorParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposCheckCollaboratorParams = z.infer<
    typeof ReposCheckCollaboratorParamsSchema
  >

  export type ReposCheckCollaboratorResponse = undefined

  export const ReposAddCollaboratorParamsSchema = z.object({
    permission: z
      .string()
      .describe(
        'The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.'
      )
      .default('push'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposAddCollaboratorParams = z.infer<
    typeof ReposAddCollaboratorParamsSchema
  >

  export type ReposAddCollaboratorResponse = undefined

  export const ReposRemoveCollaboratorParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposRemoveCollaboratorParams = z.infer<
    typeof ReposRemoveCollaboratorParamsSchema
  >

  export type ReposRemoveCollaboratorResponse = undefined

  export const ReposGetCollaboratorPermissionLevelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type ReposGetCollaboratorPermissionLevelParams = z.infer<
    typeof ReposGetCollaboratorPermissionLevelParamsSchema
  >

  export const ReposGetCollaboratorPermissionLevelResponseSchema =
    RepositoryCollaboratorPermissionSchema
  export type ReposGetCollaboratorPermissionLevelResponse = z.infer<
    typeof ReposGetCollaboratorPermissionLevelResponseSchema
  >

  export const ReposListCommitCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitCommentsForRepoParams = z.infer<
    typeof ReposListCommitCommentsForRepoParamsSchema
  >

  export const ReposListCommitCommentsForRepoResponseSchema =
    z.array(CommitCommentSchema)
  export type ReposListCommitCommentsForRepoResponse = z.infer<
    typeof ReposListCommitCommentsForRepoResponseSchema
  >

  export const ReposGetCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposGetCommitCommentParams = z.infer<
    typeof ReposGetCommitCommentParamsSchema
  >

  export const ReposGetCommitCommentResponseSchema = CommitCommentSchema
  export type ReposGetCommitCommentResponse = z.infer<
    typeof ReposGetCommitCommentResponseSchema
  >

  export const ReposDeleteCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposDeleteCommitCommentParams = z.infer<
    typeof ReposDeleteCommitCommentParamsSchema
  >

  export type ReposDeleteCommitCommentResponse = undefined

  export const ReposUpdateCommitCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReposUpdateCommitCommentParams = z.infer<
    typeof ReposUpdateCommitCommentParamsSchema
  >

  export const ReposUpdateCommitCommentResponseSchema = CommitCommentSchema
  export type ReposUpdateCommitCommentResponse = z.infer<
    typeof ReposUpdateCommitCommentResponseSchema
  >

  export const ReactionsListForCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForCommitCommentParams = z.infer<
    typeof ReactionsListForCommitCommentParamsSchema
  >

  export const ReactionsListForCommitCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForCommitCommentResponse = z.infer<
    typeof ReactionsListForCommitCommentResponseSchema
  >

  export const ReactionsCreateForCommitCommentParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReactionsCreateForCommitCommentParams = z.infer<
    typeof ReactionsCreateForCommitCommentParamsSchema
  >

  export const ReactionsCreateForCommitCommentResponseSchema = ReactionSchema
  export type ReactionsCreateForCommitCommentResponse = z.infer<
    typeof ReactionsCreateForCommitCommentResponseSchema
  >

  export const ReactionsDeleteForCommitCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForCommitCommentParams = z.infer<
    typeof ReactionsDeleteForCommitCommentParamsSchema
  >

  export type ReactionsDeleteForCommitCommentResponse = undefined

  export const ReposListCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z
      .string()
      .describe(
        'SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).'
      )
      .optional(),
    path: z
      .string()
      .describe('Only commits containing this file path will be returned.')
      .optional(),
    author: z
      .string()
      .describe(
        'GitHub username or email address to use to filter by commit author.'
      )
      .optional(),
    committer: z
      .string()
      .describe(
        'GitHub username or email address to use to filter by commit committer.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.'
      )
      .optional(),
    until: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitsParams = z.infer<
    typeof ReposListCommitsParamsSchema
  >

  export const ReposListCommitsResponseSchema = z.array(CommitSchema)
  export type ReposListCommitsResponse = z.infer<
    typeof ReposListCommitsResponseSchema
  >

  export const ReposListBranchesForHeadCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type ReposListBranchesForHeadCommitParams = z.infer<
    typeof ReposListBranchesForHeadCommitParamsSchema
  >

  export const ReposListBranchesForHeadCommitResponseSchema =
    z.array(BranchShortSchema)
  export type ReposListBranchesForHeadCommitResponse = z.infer<
    typeof ReposListBranchesForHeadCommitResponseSchema
  >

  export const ReposListCommentsForCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommentsForCommitParams = z.infer<
    typeof ReposListCommentsForCommitParamsSchema
  >

  export const ReposListCommentsForCommitResponseSchema =
    z.array(CommitCommentSchema)
  export type ReposListCommentsForCommitResponse = z.infer<
    typeof ReposListCommentsForCommitResponseSchema
  >

  export const ReposCreateCommitCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    path: z
      .string()
      .describe('Relative path of the file to comment on.')
      .optional(),
    position: z
      .number()
      .int()
      .describe('Line index in the diff to comment on.')
      .optional(),
    line: z
      .number()
      .int()
      .describe(
        '**Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type ReposCreateCommitCommentParams = z.infer<
    typeof ReposCreateCommitCommentParamsSchema
  >

  export type ReposCreateCommitCommentResponse = undefined

  export const ReposListPullRequestsAssociatedWithCommitParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      commit_sha: z.string().describe('The SHA of the commit.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ReposListPullRequestsAssociatedWithCommitParams = z.infer<
    typeof ReposListPullRequestsAssociatedWithCommitParamsSchema
  >

  export const ReposListPullRequestsAssociatedWithCommitResponseSchema =
    z.array(PullRequestSimpleSchema)
  export type ReposListPullRequestsAssociatedWithCommitResponse = z.infer<
    typeof ReposListPullRequestsAssociatedWithCommitResponseSchema
  >

  export const ReposGetCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposGetCommitParams = z.infer<typeof ReposGetCommitParamsSchema>

  export const ReposGetCommitResponseSchema = CommitSchema
  export type ReposGetCommitResponse = z.infer<
    typeof ReposGetCommitResponseSchema
  >

  export const ChecksListForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    status: z
      .enum(['queued', 'in_progress', 'completed'])
      .describe('Returns check runs with the specified `status`.')
      .optional(),
    filter: z
      .enum(['latest', 'all'])
      .describe(
        'Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.'
      )
      .default('latest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    app_id: z.number().int().optional()
  })
  export type ChecksListForRefParams = z.infer<
    typeof ChecksListForRefParamsSchema
  >

  export const ChecksListForRefResponseSchema = z.object({
    total_count: z.number().int(),
    check_runs: z.array(CheckRunSchema)
  })
  export type ChecksListForRefResponse = z.infer<
    typeof ChecksListForRefResponseSchema
  >

  export const ChecksListSuitesForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    app_id: z
      .number()
      .int()
      .describe('Filters check suites by GitHub App `id`.')
      .optional(),
    check_name: z
      .string()
      .describe('Returns check runs with the specified `name`.')
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ChecksListSuitesForRefParams = z.infer<
    typeof ChecksListSuitesForRefParamsSchema
  >

  export const ChecksListSuitesForRefResponseSchema = z.object({
    total_count: z.number().int(),
    check_suites: z.array(CheckSuiteSchema)
  })
  export type ChecksListSuitesForRefResponse = z.infer<
    typeof ChecksListSuitesForRefResponseSchema
  >

  export const ReposGetCombinedStatusForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetCombinedStatusForRefParams = z.infer<
    typeof ReposGetCombinedStatusForRefParamsSchema
  >

  export const ReposGetCombinedStatusForRefResponseSchema =
    CombinedCommitStatusSchema
  export type ReposGetCombinedStatusForRefResponse = z.infer<
    typeof ReposGetCombinedStatusForRefResponseSchema
  >

  export const ReposListCommitStatusesForRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListCommitStatusesForRefParams = z.infer<
    typeof ReposListCommitStatusesForRefParamsSchema
  >

  export const ReposListCommitStatusesForRefResponseSchema =
    z.array(StatusSchema)
  export type ReposListCommitStatusesForRefResponse = z.infer<
    typeof ReposListCommitStatusesForRefResponseSchema
  >

  export const ReposGetCommunityProfileMetricsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCommunityProfileMetricsParams = z.infer<
    typeof ReposGetCommunityProfileMetricsParamsSchema
  >

  export const ReposGetCommunityProfileMetricsResponseSchema =
    CommunityProfileSchema
  export type ReposGetCommunityProfileMetricsResponse = z.infer<
    typeof ReposGetCommunityProfileMetricsResponseSchema
  >

  export const ReposCompareCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    basehead: z
      .string()
      .describe(
        'The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposCompareCommitsParams = z.infer<
    typeof ReposCompareCommitsParamsSchema
  >

  export const ReposCompareCommitsResponseSchema = CommitComparisonSchema
  export type ReposCompareCommitsResponse = z.infer<
    typeof ReposCompareCommitsResponseSchema
  >

  export const ReposGetContentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter'),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetContentParams = z.infer<
    typeof ReposGetContentParamsSchema
  >

  export const ReposGetContentResponseSchema = z.union([
    ContentDirectorySchema,
    ContentFileSchema,
    ContentSymlinkSchema,
    ContentSubmoduleSchema
  ])
  export type ReposGetContentResponse = z.infer<
    typeof ReposGetContentResponseSchema
  >

  export const ReposCreateOrUpdateFileContentsParamsSchema = z.object({
    message: z.string().describe('The commit message.'),
    content: z
      .string()
      .describe('The new file content, using Base64 encoding.'),
    sha: z
      .string()
      .describe(
        '**Required if you are updating a file**. The blob SHA of the file being replaced.'
      )
      .optional(),
    branch: z
      .string()
      .describe('The branch name. Default: the repositorys default branch.')
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe(
            "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
          ),
        email: z
          .string()
          .describe(
            "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
          ),
        date: z.string().optional()
      })
      .describe(
        'The person that committed the file. Default: the authenticated user.'
      )
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe(
            "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
          ),
        email: z
          .string()
          .describe(
            "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
          ),
        date: z.string().optional()
      })
      .describe(
        'The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter')
  })
  export type ReposCreateOrUpdateFileContentsParams = z.infer<
    typeof ReposCreateOrUpdateFileContentsParamsSchema
  >

  export const ReposCreateOrUpdateFileContentsResponseSchema = FileCommitSchema
  export type ReposCreateOrUpdateFileContentsResponse = z.infer<
    typeof ReposCreateOrUpdateFileContentsResponseSchema
  >

  export const ReposDeleteFileParamsSchema = z.object({
    message: z.string().describe('The commit message.'),
    sha: z.string().describe('The blob SHA of the file being deleted.'),
    branch: z
      .string()
      .describe('The branch name. Default: the repositorys default branch')
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional()
      })
      .describe('object containing information about the committer.')
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional()
      })
      .describe('object containing information about the author.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    path: z.string().describe('path parameter')
  })
  export type ReposDeleteFileParams = z.infer<
    typeof ReposDeleteFileParamsSchema
  >

  export const ReposDeleteFileResponseSchema = FileCommitSchema
  export type ReposDeleteFileResponse = z.infer<
    typeof ReposDeleteFileResponseSchema
  >

  export const ReposListContributorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    anon: z
      .string()
      .describe(
        'Set to `1` or `true` to include anonymous contributors in results.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListContributorsParams = z.infer<
    typeof ReposListContributorsParamsSchema
  >

  export const ReposListContributorsResponseSchema = z.array(ContributorSchema)
  export type ReposListContributorsResponse = z.infer<
    typeof ReposListContributorsResponseSchema
  >

  export const DependabotListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .string()
      .describe(
        'A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`'
      )
      .optional(),
    severity: z
      .string()
      .describe(
        'A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`'
      )
      .optional(),
    ecosystem: z
      .string()
      .describe(
        'A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`'
      )
      .optional(),
    package: z
      .string()
      .describe(
        'A comma-separated list of package names. If specified, only alerts for these packages will be returned.'
      )
      .optional(),
    manifest: z
      .string()
      .describe(
        'A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.'
      )
      .optional(),
    epss_percentage: z
      .string()
      .describe(
        'CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.'
      )
      .optional(),
    scope: z
      .enum(['development', 'runtime'])
      .describe(
        'The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'epss_percentage'])
      .describe(
        "The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        '**Closing down notice**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    first: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.'
      )
      .default(30),
    last: z
      .number()
      .int()
      .gte(1)
      .lte(100)
      .describe(
        '**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.'
      )
      .optional()
  })
  export type DependabotListAlertsForRepoParams = z.infer<
    typeof DependabotListAlertsForRepoParamsSchema
  >

  export const DependabotListAlertsForRepoResponseSchema = z.array(
    DependabotAlertSchema
  )
  export type DependabotListAlertsForRepoResponse = z.infer<
    typeof DependabotListAlertsForRepoResponseSchema
  >

  export const DependabotGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
      )
  })
  export type DependabotGetAlertParams = z.infer<
    typeof DependabotGetAlertParamsSchema
  >

  export const DependabotGetAlertResponseSchema = DependabotAlertSchema
  export type DependabotGetAlertResponse = z.infer<
    typeof DependabotGetAlertResponseSchema
  >

  export const DependabotUpdateAlertParamsSchema = z.object({
    state: z
      .enum(['dismissed', 'open'])
      .describe(
        'The state of the Dependabot alert.\nA `dismissed_reason` must be provided when setting the state to `dismissed`.'
      ),
    dismissed_reason: z
      .enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
      ])
      .describe(
        '**Required when `state` is `dismissed`.** A reason for dismissing the alert.'
      )
      .optional(),
    dismissed_comment: z
      .string()
      .max(280)
      .describe('An optional comment associated with dismissing the alert.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies a Dependabot alert in its repository.\nYou can find this at the end of the URL for a Dependabot alert within GitHub,\nor in `number` fields in the response from the\n`GET /repos/{owner}/{repo}/dependabot/alerts` operation.'
      )
  })
  export type DependabotUpdateAlertParams = z.infer<
    typeof DependabotUpdateAlertParamsSchema
  >

  export const DependabotUpdateAlertResponseSchema = DependabotAlertSchema
  export type DependabotUpdateAlertResponse = z.infer<
    typeof DependabotUpdateAlertResponseSchema
  >

  export const DependabotListRepoSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type DependabotListRepoSecretsParams = z.infer<
    typeof DependabotListRepoSecretsParamsSchema
  >

  export const DependabotListRepoSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(DependabotSecretSchema)
  })
  export type DependabotListRepoSecretsResponse = z.infer<
    typeof DependabotListRepoSecretsResponseSchema
  >

  export const DependabotGetRepoPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type DependabotGetRepoPublicKeyParams = z.infer<
    typeof DependabotGetRepoPublicKeyParamsSchema
  >

  export const DependabotGetRepoPublicKeyResponseSchema =
    DependabotPublicKeySchema
  export type DependabotGetRepoPublicKeyResponse = z.infer<
    typeof DependabotGetRepoPublicKeyResponseSchema
  >

  export const DependabotGetRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotGetRepoSecretParams = z.infer<
    typeof DependabotGetRepoSecretParamsSchema
  >

  export const DependabotGetRepoSecretResponseSchema = DependabotSecretSchema
  export type DependabotGetRepoSecretResponse = z.infer<
    typeof DependabotGetRepoSecretResponseSchema
  >

  export const DependabotCreateOrUpdateRepoSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint.'
      )
      .optional(),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotCreateOrUpdateRepoSecretParams = z.infer<
    typeof DependabotCreateOrUpdateRepoSecretParamsSchema
  >

  export type DependabotCreateOrUpdateRepoSecretResponse = undefined

  export const DependabotDeleteRepoSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type DependabotDeleteRepoSecretParams = z.infer<
    typeof DependabotDeleteRepoSecretParamsSchema
  >

  export type DependabotDeleteRepoSecretResponse = undefined

  export const DependencyGraphDiffRangeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    basehead: z
      .string()
      .describe(
        'The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.'
      ),
    name: z
      .string()
      .describe(
        'The full path, relative to the repository root, of the dependency manifest file.'
      )
      .optional()
  })
  export type DependencyGraphDiffRangeParams = z.infer<
    typeof DependencyGraphDiffRangeParamsSchema
  >

  export const DependencyGraphDiffRangeResponseSchema =
    DependencyGraphDiffSchema
  export type DependencyGraphDiffRangeResponse = z.infer<
    typeof DependencyGraphDiffRangeResponseSchema
  >

  export const DependencyGraphExportSbomParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type DependencyGraphExportSbomParams = z.infer<
    typeof DependencyGraphExportSbomParamsSchema
  >

  export const DependencyGraphExportSbomResponseSchema =
    DependencyGraphSpdxSbomSchema
  export type DependencyGraphExportSbomResponse = z.infer<
    typeof DependencyGraphExportSbomResponseSchema
  >

  export const DependencyGraphCreateRepositorySnapshotParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(SnapshotSchema)
  export type DependencyGraphCreateRepositorySnapshotParams = z.infer<
    typeof DependencyGraphCreateRepositorySnapshotParamsSchema
  >

  export type DependencyGraphCreateRepositorySnapshotResponse = undefined

  export const ReposListDeploymentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z
      .string()
      .describe('The SHA recorded at creation time.')
      .default('none'),
    ref: z
      .string()
      .describe('The name of the ref. This can be a branch, tag, or SHA.')
      .default('none'),
    task: z
      .string()
      .describe(
        'The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).'
      )
      .default('none'),
    environment: z
      .union([z.string().default('none'), z.null()])
      .describe(
        'The name of the environment that was deployed to (e.g., `staging` or `production`).'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentsParams = z.infer<
    typeof ReposListDeploymentsParamsSchema
  >

  export const ReposListDeploymentsResponseSchema = z.array(DeploymentSchema)
  export type ReposListDeploymentsResponse = z.infer<
    typeof ReposListDeploymentsResponseSchema
  >

  export const ReposCreateDeploymentParamsSchema = z.object({
    ref: z
      .string()
      .describe('The ref to deploy. This can be a branch, tag, or SHA.'),
    task: z
      .string()
      .describe(
        'Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).'
      )
      .default('deploy'),
    auto_merge: z
      .boolean()
      .describe(
        "Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch."
      )
      .default(true),
    required_contexts: z
      .array(z.string())
      .describe(
        'The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.'
      )
      .optional(),
    payload: z
      .union([
        z.record(z.any()),
        z
          .string()
          .describe('JSON payload with extra information about the deployment.')
          .default('')
      ])
      .optional(),
    environment: z
      .string()
      .describe(
        'Name for the target deployment environment (e.g., `production`, `staging`, `qa`).'
      )
      .default('production'),
    description: z
      .string()
      .describe('Short description of the deployment.')
      .default(''),
    transient_environment: z
      .boolean()
      .describe(
        'Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`'
      )
      .default(false),
    production_environment: z
      .boolean()
      .describe(
        'Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeploymentParams = z.infer<
    typeof ReposCreateDeploymentParamsSchema
  >

  export type ReposCreateDeploymentResponse = undefined

  export const ReposGetDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposGetDeploymentParams = z.infer<
    typeof ReposGetDeploymentParamsSchema
  >

  export const ReposGetDeploymentResponseSchema = DeploymentSchema
  export type ReposGetDeploymentResponse = z.infer<
    typeof ReposGetDeploymentResponseSchema
  >

  export const ReposDeleteDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposDeleteDeploymentParams = z.infer<
    typeof ReposDeleteDeploymentParamsSchema
  >

  export type ReposDeleteDeploymentResponse = undefined

  export const ReposListDeploymentStatusesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentStatusesParams = z.infer<
    typeof ReposListDeploymentStatusesParamsSchema
  >

  export const ReposListDeploymentStatusesResponseSchema = z.array(
    DeploymentStatusSchema
  )
  export type ReposListDeploymentStatusesResponse = z.infer<
    typeof ReposListDeploymentStatusesResponseSchema
  >

  export const ReposCreateDeploymentStatusParamsSchema = z.object({
    state: z
      .enum([
        'error',
        'failure',
        'inactive',
        'in_progress',
        'queued',
        'pending',
        'success'
      ])
      .describe(
        'The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.'
      ),
    target_url: z
      .string()
      .describe(
        "The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.\n\n> [!NOTE]\n> It's recommended to use the `log_url` parameter, which replaces `target_url`."
      )
      .default(''),
    log_url: z
      .string()
      .describe(
        'The full URL of the deployment\'s output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`'
      )
      .default(''),
    description: z
      .string()
      .describe(
        'A short description of the status. The maximum description length is 140 characters.'
      )
      .default(''),
    environment: z
      .string()
      .describe(
        'Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.'
      )
      .optional(),
    environment_url: z
      .string()
      .describe('Sets the URL for accessing your environment. Default: `""`')
      .default(''),
    auto_inactive: z
      .boolean()
      .describe(
        "Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`"
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter')
  })
  export type ReposCreateDeploymentStatusParams = z.infer<
    typeof ReposCreateDeploymentStatusParamsSchema
  >

  export type ReposCreateDeploymentStatusResponse = undefined

  export const ReposGetDeploymentStatusParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    deployment_id: z.number().int().describe('deployment_id parameter'),
    status_id: z.number().int()
  })
  export type ReposGetDeploymentStatusParams = z.infer<
    typeof ReposGetDeploymentStatusParamsSchema
  >

  export const ReposGetDeploymentStatusResponseSchema = DeploymentStatusSchema
  export type ReposGetDeploymentStatusResponse = z.infer<
    typeof ReposGetDeploymentStatusResponseSchema
  >

  export const ReposCreateDispatchEventParamsSchema = z.object({
    event_type: z
      .string()
      .min(1)
      .max(100)
      .describe(
        'A custom webhook event name. Must be 100 characters or fewer.'
      ),
    client_payload: z
      .record(z.any())
      .describe(
        'JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDispatchEventParams = z.infer<
    typeof ReposCreateDispatchEventParamsSchema
  >

  export type ReposCreateDispatchEventResponse = undefined

  export const ReposGetAllEnvironmentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetAllEnvironmentsParams = z.infer<
    typeof ReposGetAllEnvironmentsParamsSchema
  >

  export const ReposGetAllEnvironmentsResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe('The number of environments in this repository')
      .optional(),
    environments: z.array(EnvironmentSchema).optional()
  })
  export type ReposGetAllEnvironmentsResponse = z.infer<
    typeof ReposGetAllEnvironmentsResponseSchema
  >

  export const ReposGetEnvironmentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposGetEnvironmentParams = z.infer<
    typeof ReposGetEnvironmentParamsSchema
  >

  export const ReposGetEnvironmentResponseSchema = EnvironmentSchema
  export type ReposGetEnvironmentResponse = z.infer<
    typeof ReposGetEnvironmentResponseSchema
  >

  export const ReposCreateOrUpdateEnvironmentParamsSchema = z.object({
    wait_timer: WaitTimerSchema.optional(),
    prevent_self_review: PreventSelfReviewSchema.optional(),
    reviewers: z
      .array(
        z.object({
          type: DeploymentReviewerTypeSchema.optional(),
          id: z
            .number()
            .int()
            .describe(
              'The id of the user or team who can review the deployment'
            )
            .optional()
        })
      )
      .describe(
        'The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.'
      )
      .optional(),
    deployment_branch_policy: DeploymentBranchPolicySettingsSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposCreateOrUpdateEnvironmentParams = z.infer<
    typeof ReposCreateOrUpdateEnvironmentParamsSchema
  >

  export const ReposCreateOrUpdateEnvironmentResponseSchema = EnvironmentSchema
  export type ReposCreateOrUpdateEnvironmentResponse = z.infer<
    typeof ReposCreateOrUpdateEnvironmentResponseSchema
  >

  export const ReposDeleteAnEnvironmentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ReposDeleteAnEnvironmentParams = z.infer<
    typeof ReposDeleteAnEnvironmentParamsSchema
  >

  export type ReposDeleteAnEnvironmentResponse = undefined

  export const ReposListDeploymentBranchPoliciesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeploymentBranchPoliciesParams = z.infer<
    typeof ReposListDeploymentBranchPoliciesParamsSchema
  >

  export const ReposListDeploymentBranchPoliciesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The number of deployment branch policies for the environment.'
      ),
    branch_policies: z.array(DeploymentBranchPolicySchema)
  })
  export type ReposListDeploymentBranchPoliciesResponse = z.infer<
    typeof ReposListDeploymentBranchPoliciesResponseSchema
  >

  export const ReposCreateDeploymentBranchPolicyParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        )
    })
    .merge(DeploymentBranchPolicyNamePatternWithTypeSchema)
  export type ReposCreateDeploymentBranchPolicyParams = z.infer<
    typeof ReposCreateDeploymentBranchPolicyParamsSchema
  >

  export const ReposCreateDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposCreateDeploymentBranchPolicyResponse = z.infer<
    typeof ReposCreateDeploymentBranchPolicyResponseSchema
  >

  export const ReposGetDeploymentBranchPolicyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    branch_policy_id: z
      .number()
      .int()
      .describe('The unique identifier of the branch policy.')
  })
  export type ReposGetDeploymentBranchPolicyParams = z.infer<
    typeof ReposGetDeploymentBranchPolicyParamsSchema
  >

  export const ReposGetDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposGetDeploymentBranchPolicyResponse = z.infer<
    typeof ReposGetDeploymentBranchPolicyResponseSchema
  >

  export const ReposUpdateDeploymentBranchPolicyParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        ),
      branch_policy_id: z
        .number()
        .int()
        .describe('The unique identifier of the branch policy.')
    })
    .merge(DeploymentBranchPolicyNamePatternSchema)
  export type ReposUpdateDeploymentBranchPolicyParams = z.infer<
    typeof ReposUpdateDeploymentBranchPolicyParamsSchema
  >

  export const ReposUpdateDeploymentBranchPolicyResponseSchema =
    DeploymentBranchPolicySchema
  export type ReposUpdateDeploymentBranchPolicyResponse = z.infer<
    typeof ReposUpdateDeploymentBranchPolicyResponseSchema
  >

  export const ReposDeleteDeploymentBranchPolicyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    branch_policy_id: z
      .number()
      .int()
      .describe('The unique identifier of the branch policy.')
  })
  export type ReposDeleteDeploymentBranchPolicyParams = z.infer<
    typeof ReposDeleteDeploymentBranchPolicyParamsSchema
  >

  export type ReposDeleteDeploymentBranchPolicyResponse = undefined

  export const ReposGetAllDeploymentProtectionRulesParamsSchema = z.object({
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      )
  })
  export type ReposGetAllDeploymentProtectionRulesParams = z.infer<
    typeof ReposGetAllDeploymentProtectionRulesParamsSchema
  >

  export const ReposGetAllDeploymentProtectionRulesResponseSchema = z.object({
    total_count: z
      .number()
      .int()
      .describe(
        'The number of enabled custom deployment protection rules for this environment'
      )
      .optional(),
    custom_deployment_protection_rules: z
      .array(DeploymentProtectionRuleSchema)
      .optional()
  })
  export type ReposGetAllDeploymentProtectionRulesResponse = z.infer<
    typeof ReposGetAllDeploymentProtectionRulesResponseSchema
  >

  export const ReposCreateDeploymentProtectionRuleParamsSchema = z.object({
    integration_id: z
      .number()
      .int()
      .describe(
        'The ID of the custom app that will be enabled on the environment.'
      )
      .optional(),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeploymentProtectionRuleParams = z.infer<
    typeof ReposCreateDeploymentProtectionRuleParamsSchema
  >

  export type ReposCreateDeploymentProtectionRuleResponse = undefined

  export const ReposListCustomDeploymentRuleIntegrationsParamsSchema = z.object(
    {
      environment_name: z
        .string()
        .describe(
          'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30)
    }
  )
  export type ReposListCustomDeploymentRuleIntegrationsParams = z.infer<
    typeof ReposListCustomDeploymentRuleIntegrationsParamsSchema
  >

  export const ReposListCustomDeploymentRuleIntegrationsResponseSchema =
    z.object({
      total_count: z
        .number()
        .int()
        .describe(
          'The total number of custom deployment protection rule integrations available for this environment.'
        )
        .optional(),
      available_custom_deployment_protection_rule_integrations: z
        .array(CustomDeploymentRuleAppSchema)
        .optional()
    })
  export type ReposListCustomDeploymentRuleIntegrationsResponse = z.infer<
    typeof ReposListCustomDeploymentRuleIntegrationsResponseSchema
  >

  export const ReposGetCustomDeploymentProtectionRuleParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    protection_rule_id: z
      .number()
      .int()
      .describe('The unique identifier of the protection rule.')
  })
  export type ReposGetCustomDeploymentProtectionRuleParams = z.infer<
    typeof ReposGetCustomDeploymentProtectionRuleParamsSchema
  >

  export const ReposGetCustomDeploymentProtectionRuleResponseSchema =
    DeploymentProtectionRuleSchema
  export type ReposGetCustomDeploymentProtectionRuleResponse = z.infer<
    typeof ReposGetCustomDeploymentProtectionRuleResponseSchema
  >

  export const ReposDisableDeploymentProtectionRuleParamsSchema = z.object({
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    protection_rule_id: z
      .number()
      .int()
      .describe('The unique identifier of the protection rule.')
  })
  export type ReposDisableDeploymentProtectionRuleParams = z.infer<
    typeof ReposDisableDeploymentProtectionRuleParamsSchema
  >

  export type ReposDisableDeploymentProtectionRuleResponse = undefined

  export const ActionsListEnvironmentSecretsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListEnvironmentSecretsParams = z.infer<
    typeof ActionsListEnvironmentSecretsParamsSchema
  >

  export const ActionsListEnvironmentSecretsResponseSchema = z.object({
    total_count: z.number().int(),
    secrets: z.array(ActionsSecretSchema)
  })
  export type ActionsListEnvironmentSecretsResponse = z.infer<
    typeof ActionsListEnvironmentSecretsResponseSchema
  >

  export const ActionsGetEnvironmentPublicKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsGetEnvironmentPublicKeyParams = z.infer<
    typeof ActionsGetEnvironmentPublicKeyParamsSchema
  >

  export const ActionsGetEnvironmentPublicKeyResponseSchema =
    ActionsPublicKeySchema
  export type ActionsGetEnvironmentPublicKeyResponse = z.infer<
    typeof ActionsGetEnvironmentPublicKeyResponseSchema
  >

  export const ActionsGetEnvironmentSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsGetEnvironmentSecretParams = z.infer<
    typeof ActionsGetEnvironmentSecretParamsSchema
  >

  export const ActionsGetEnvironmentSecretResponseSchema = ActionsSecretSchema
  export type ActionsGetEnvironmentSecretResponse = z.infer<
    typeof ActionsGetEnvironmentSecretResponseSchema
  >

  export const ActionsCreateOrUpdateEnvironmentSecretParamsSchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
        )
      )
      .describe(
        'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint.'
      ),
    key_id: z
      .string()
      .describe('ID of the key you used to encrypt the secret.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsCreateOrUpdateEnvironmentSecretParams = z.infer<
    typeof ActionsCreateOrUpdateEnvironmentSecretParamsSchema
  >

  export type ActionsCreateOrUpdateEnvironmentSecretResponse = undefined

  export const ActionsDeleteEnvironmentSecretParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    secret_name: z.string().describe('The name of the secret.')
  })
  export type ActionsDeleteEnvironmentSecretParams = z.infer<
    typeof ActionsDeleteEnvironmentSecretParamsSchema
  >

  export type ActionsDeleteEnvironmentSecretResponse = undefined

  export const ActionsListEnvironmentVariablesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(10),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActionsListEnvironmentVariablesParams = z.infer<
    typeof ActionsListEnvironmentVariablesParamsSchema
  >

  export const ActionsListEnvironmentVariablesResponseSchema = z.object({
    total_count: z.number().int(),
    variables: z.array(ActionsVariableSchema)
  })
  export type ActionsListEnvironmentVariablesResponse = z.infer<
    typeof ActionsListEnvironmentVariablesResponseSchema
  >

  export const ActionsCreateEnvironmentVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsCreateEnvironmentVariableParams = z.infer<
    typeof ActionsCreateEnvironmentVariableParamsSchema
  >

  export type ActionsCreateEnvironmentVariableResponse = undefined

  export const ActionsGetEnvironmentVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      ),
    name: z.string().describe('The name of the variable.')
  })
  export type ActionsGetEnvironmentVariableParams = z.infer<
    typeof ActionsGetEnvironmentVariableParamsSchema
  >

  export const ActionsGetEnvironmentVariableResponseSchema =
    ActionsVariableSchema
  export type ActionsGetEnvironmentVariableResponse = z.infer<
    typeof ActionsGetEnvironmentVariableResponseSchema
  >

  export const ActionsDeleteEnvironmentVariableParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string().describe('The name of the variable.'),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsDeleteEnvironmentVariableParams = z.infer<
    typeof ActionsDeleteEnvironmentVariableParamsSchema
  >

  export type ActionsDeleteEnvironmentVariableResponse = undefined

  export const ActionsUpdateEnvironmentVariableParamsSchema = z.object({
    name: z.string().describe('The name of the variable.'),
    value: z.string().describe('The value of the variable.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    environment_name: z
      .string()
      .describe(
        'The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.'
      )
  })
  export type ActionsUpdateEnvironmentVariableParams = z.infer<
    typeof ActionsUpdateEnvironmentVariableParamsSchema
  >

  export type ActionsUpdateEnvironmentVariableResponse = undefined

  export const ActivityListRepoEventsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListRepoEventsParams = z.infer<
    typeof ActivityListRepoEventsParamsSchema
  >

  export const ActivityListRepoEventsResponseSchema = z.array(EventSchema)
  export type ActivityListRepoEventsResponse = z.infer<
    typeof ActivityListRepoEventsResponseSchema
  >

  export const ReposListForksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z
      .enum(['newest', 'oldest', 'stargazers', 'watchers'])
      .describe('The sort order. `stargazers` will sort by star count.')
      .default('newest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForksParams = z.infer<typeof ReposListForksParamsSchema>

  export const ReposListForksResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForksResponse = z.infer<
    typeof ReposListForksResponseSchema
  >

  export const ReposCreateForkParamsSchema = z.object({
    organization: z
      .string()
      .describe(
        'Optional parameter to specify the organization name if forking into an organization.'
      )
      .optional(),
    name: z
      .string()
      .describe(
        'When forking from an existing repository, a new name for the fork.'
      )
      .optional(),
    default_branch_only: z
      .boolean()
      .describe(
        'When forking from an existing repository, fork with only the default branch.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateForkParams = z.infer<
    typeof ReposCreateForkParamsSchema
  >

  export type ReposCreateForkResponse = undefined

  export const GitCreateBlobParamsSchema = z.object({
    content: z.string().describe("The new blob's content."),
    encoding: z
      .string()
      .describe(
        'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.'
      )
      .default('utf-8'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateBlobParams = z.infer<typeof GitCreateBlobParamsSchema>

  export type GitCreateBlobResponse = undefined

  export const GitGetBlobParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    file_sha: z.string()
  })
  export type GitGetBlobParams = z.infer<typeof GitGetBlobParamsSchema>

  export const GitGetBlobResponseSchema = BlobSchema
  export type GitGetBlobResponse = z.infer<typeof GitGetBlobResponseSchema>

  export const GitCreateCommitParamsSchema = z.object({
    message: z.string().describe('The commit message'),
    tree: z
      .string()
      .describe('The SHA of the tree object this commit points to'),
    parents: z
      .array(z.string())
      .describe(
        'The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.'
      )
      .optional(),
    author: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit'),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit'),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.'
      )
      .optional(),
    committer: z
      .object({
        name: z
          .string()
          .describe('The name of the author (or committer) of the commit')
          .optional(),
        email: z
          .string()
          .describe('The email of the author (or committer) of the commit')
          .optional(),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.'
      )
      .optional(),
    signature: z
      .string()
      .describe(
        'The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateCommitParams = z.infer<
    typeof GitCreateCommitParamsSchema
  >

  export type GitCreateCommitResponse = undefined

  export const GitGetCommitParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    commit_sha: z.string().describe('The SHA of the commit.')
  })
  export type GitGetCommitParams = z.infer<typeof GitGetCommitParamsSchema>

  export const GitGetCommitResponseSchema = GitCommitSchema
  export type GitGetCommitResponse = z.infer<typeof GitGetCommitResponseSchema>

  export const GitListMatchingRefsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitListMatchingRefsParams = z.infer<
    typeof GitListMatchingRefsParamsSchema
  >

  export const GitListMatchingRefsResponseSchema = z.array(GitRefSchema)
  export type GitListMatchingRefsResponse = z.infer<
    typeof GitListMatchingRefsResponseSchema
  >

  export const GitGetRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitGetRefParams = z.infer<typeof GitGetRefParamsSchema>

  export const GitGetRefResponseSchema = GitRefSchema
  export type GitGetRefResponse = z.infer<typeof GitGetRefResponseSchema>

  export const GitCreateRefParamsSchema = z.object({
    ref: z
      .string()
      .describe(
        "The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
      ),
    sha: z.string().describe('The SHA1 value for this reference.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateRefParams = z.infer<typeof GitCreateRefParamsSchema>

  export type GitCreateRefResponse = undefined

  export const GitDeleteRefParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitDeleteRefParams = z.infer<typeof GitDeleteRefParamsSchema>

  export type GitDeleteRefResponse = undefined

  export const GitUpdateRefParamsSchema = z.object({
    sha: z.string().describe('The SHA1 value to set this reference to'),
    force: z
      .boolean()
      .describe(
        "Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work."
      )
      .default(false),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.'
      )
  })
  export type GitUpdateRefParams = z.infer<typeof GitUpdateRefParamsSchema>

  export const GitUpdateRefResponseSchema = GitRefSchema
  export type GitUpdateRefResponse = z.infer<typeof GitUpdateRefResponseSchema>

  export const GitCreateTagParamsSchema = z.object({
    tag: z
      .string()
      .describe(
        'The tag\'s name. This is typically a version (e.g., "v0.0.1").'
      ),
    message: z.string().describe('The tag message.'),
    object: z.string().describe('The SHA of the git object this is tagging.'),
    type: z
      .enum(['commit', 'tree', 'blob'])
      .describe(
        "The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`."
      ),
    tagger: z
      .object({
        name: z.string().describe('The name of the author of the tag'),
        email: z.string().describe('The email of the author of the tag'),
        date: z
          .string()
          .datetime({ offset: true })
          .describe(
            'When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          )
          .optional()
      })
      .describe(
        'An object with information about the individual creating the tag.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateTagParams = z.infer<typeof GitCreateTagParamsSchema>

  export type GitCreateTagResponse = undefined

  export const GitGetTagParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag_sha: z.string()
  })
  export type GitGetTagParams = z.infer<typeof GitGetTagParamsSchema>

  export const GitGetTagResponseSchema = GitTagSchema
  export type GitGetTagResponse = z.infer<typeof GitGetTagResponseSchema>

  export const GitCreateTreeParamsSchema = z.object({
    tree: z
      .array(
        z.object({
          path: z
            .string()
            .describe('The file referenced in the tree.')
            .optional(),
          mode: z
            .enum(['100644', '100755', '040000', '160000', '120000'])
            .describe(
              'The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.'
            )
            .optional(),
          type: z
            .enum(['blob', 'tree', 'commit'])
            .describe('Either `blob`, `tree`, or `commit`.')
            .optional(),
          sha: z
            .string()
            .describe(
              'The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
            )
            .optional(),
          content: z
            .string()
            .describe(
              'The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
            )
            .optional()
        })
      )
      .describe(
        'Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.'
      ),
    base_tree: z
      .string()
      .describe(
        "The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type GitCreateTreeParams = z.infer<typeof GitCreateTreeParamsSchema>

  export type GitCreateTreeResponse = undefined

  export const GitGetTreeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tree_sha: z
      .string()
      .describe('The SHA1 value or ref (branch or tag) name of the tree.'),
    recursive: z
      .string()
      .describe(
        'Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.'
      )
      .optional()
  })
  export type GitGetTreeParams = z.infer<typeof GitGetTreeParamsSchema>

  export const GitGetTreeResponseSchema = GitTreeSchema
  export type GitGetTreeResponse = z.infer<typeof GitGetTreeResponseSchema>

  export const ReposListWebhooksParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListWebhooksParams = z.infer<
    typeof ReposListWebhooksParamsSchema
  >

  export const ReposListWebhooksResponseSchema = z.array(HookSchema)
  export type ReposListWebhooksResponse = z.infer<
    typeof ReposListWebhooksResponseSchema
  >

  export const ReposCreateWebhookParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.'
      )
      .optional(),
    config: z
      .object({
        url: WebhookConfigUrlSchema.optional(),
        content_type: WebhookConfigContentTypeSchema.optional(),
        secret: WebhookConfigSecretSchema.optional(),
        insecure_ssl: WebhookConfigInsecureSslSchema.optional()
      })
      .describe('Key/value pairs to provide settings for this webhook.')
      .optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.'
      )
      .default(['push']),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateWebhookParams = z.infer<
    typeof ReposCreateWebhookParamsSchema
  >

  export type ReposCreateWebhookResponse = undefined

  export const ReposGetWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposGetWebhookParams = z.infer<
    typeof ReposGetWebhookParamsSchema
  >

  export const ReposGetWebhookResponseSchema = HookSchema
  export type ReposGetWebhookResponse = z.infer<
    typeof ReposGetWebhookResponseSchema
  >

  export const ReposDeleteWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposDeleteWebhookParams = z.infer<
    typeof ReposDeleteWebhookParamsSchema
  >

  export type ReposDeleteWebhookResponse = undefined

  export const ReposUpdateWebhookParamsSchema = z.object({
    config: WebhookConfigSchema.optional(),
    events: z
      .array(z.string())
      .describe(
        'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.'
      )
      .default(['push']),
    add_events: z
      .array(z.string())
      .describe(
        'Determines a list of events to be added to the list of events that the Hook triggers for.'
      )
      .optional(),
    remove_events: z
      .array(z.string())
      .describe(
        'Determines a list of events to be removed from the list of events that the Hook triggers for.'
      )
      .optional(),
    active: z
      .boolean()
      .describe(
        'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.'
      )
      .default(true),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposUpdateWebhookParams = z.infer<
    typeof ReposUpdateWebhookParamsSchema
  >

  export const ReposUpdateWebhookResponseSchema = HookSchema
  export type ReposUpdateWebhookResponse = z.infer<
    typeof ReposUpdateWebhookResponseSchema
  >

  export const ReposGetWebhookConfigForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposGetWebhookConfigForRepoParams = z.infer<
    typeof ReposGetWebhookConfigForRepoParamsSchema
  >

  export const ReposGetWebhookConfigForRepoResponseSchema = WebhookConfigSchema
  export type ReposGetWebhookConfigForRepoResponse = z.infer<
    typeof ReposGetWebhookConfigForRepoResponseSchema
  >

  export const ReposUpdateWebhookConfigForRepoParamsSchema = z.object({
    url: WebhookConfigUrlSchema.optional(),
    content_type: WebhookConfigContentTypeSchema.optional(),
    secret: WebhookConfigSecretSchema.optional(),
    insecure_ssl: WebhookConfigInsecureSslSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposUpdateWebhookConfigForRepoParams = z.infer<
    typeof ReposUpdateWebhookConfigForRepoParamsSchema
  >

  export const ReposUpdateWebhookConfigForRepoResponseSchema =
    WebhookConfigSchema
  export type ReposUpdateWebhookConfigForRepoResponse = z.infer<
    typeof ReposUpdateWebhookConfigForRepoResponseSchema
  >

  export const ReposListWebhookDeliveriesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    cursor: z
      .string()
      .describe(
        'Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.'
      )
      .optional()
  })
  export type ReposListWebhookDeliveriesParams = z.infer<
    typeof ReposListWebhookDeliveriesParamsSchema
  >

  export const ReposListWebhookDeliveriesResponseSchema = z.array(
    HookDeliveryItemSchema
  )
  export type ReposListWebhookDeliveriesResponse = z.infer<
    typeof ReposListWebhookDeliveriesResponseSchema
  >

  export const ReposGetWebhookDeliveryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type ReposGetWebhookDeliveryParams = z.infer<
    typeof ReposGetWebhookDeliveryParamsSchema
  >

  export const ReposGetWebhookDeliveryResponseSchema = HookDeliverySchema
  export type ReposGetWebhookDeliveryResponse = z.infer<
    typeof ReposGetWebhookDeliveryResponseSchema
  >

  export const ReposRedeliverWebhookDeliveryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      ),
    delivery_id: z.number().int()
  })
  export type ReposRedeliverWebhookDeliveryParams = z.infer<
    typeof ReposRedeliverWebhookDeliveryParamsSchema
  >

  export type ReposRedeliverWebhookDeliveryResponse = undefined

  export const ReposPingWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposPingWebhookParams = z.infer<
    typeof ReposPingWebhookParamsSchema
  >

  export type ReposPingWebhookResponse = undefined

  export const ReposTestPushWebhookParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    hook_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.'
      )
  })
  export type ReposTestPushWebhookParams = z.infer<
    typeof ReposTestPushWebhookParamsSchema
  >

  export type ReposTestPushWebhookResponse = undefined

  export const MigrationsGetImportStatusParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsGetImportStatusParams = z.infer<
    typeof MigrationsGetImportStatusParamsSchema
  >

  export const MigrationsGetImportStatusResponseSchema = ImportSchema
  export type MigrationsGetImportStatusResponse = z.infer<
    typeof MigrationsGetImportStatusResponseSchema
  >

  export const MigrationsStartImportParamsSchema = z.object({
    vcs_url: z.string().describe('The URL of the originating repository.'),
    vcs: z
      .enum(['subversion', 'git', 'mercurial', 'tfvc'])
      .describe(
        'The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.'
      )
      .optional(),
    vcs_username: z
      .string()
      .describe(
        'If authentication is required, the username to provide to `vcs_url`.'
      )
      .optional(),
    vcs_password: z
      .string()
      .describe(
        'If authentication is required, the password to provide to `vcs_url`.'
      )
      .optional(),
    tfvc_project: z
      .string()
      .describe(
        'For a tfvc import, the name of the project that is being imported.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsStartImportParams = z.infer<
    typeof MigrationsStartImportParamsSchema
  >

  export type MigrationsStartImportResponse = undefined

  export const MigrationsCancelImportParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsCancelImportParams = z.infer<
    typeof MigrationsCancelImportParamsSchema
  >

  export type MigrationsCancelImportResponse = undefined

  export const MigrationsUpdateImportParamsSchema = z.object({
    vcs_username: z
      .string()
      .describe('The username to provide to the originating repository.')
      .optional(),
    vcs_password: z
      .string()
      .describe('The password to provide to the originating repository.')
      .optional(),
    vcs: z
      .enum(['subversion', 'tfvc', 'git', 'mercurial'])
      .describe('The type of version control system you are migrating from.')
      .optional(),
    tfvc_project: z
      .string()
      .describe(
        'For a tfvc import, the name of the project that is being imported.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsUpdateImportParams = z.infer<
    typeof MigrationsUpdateImportParamsSchema
  >

  export const MigrationsUpdateImportResponseSchema = ImportSchema
  export type MigrationsUpdateImportResponse = z.infer<
    typeof MigrationsUpdateImportResponseSchema
  >

  export const MigrationsGetCommitAuthorsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    since: z
      .number()
      .int()
      .describe('A user ID. Only return users with an ID greater than this ID.')
      .optional()
  })
  export type MigrationsGetCommitAuthorsParams = z.infer<
    typeof MigrationsGetCommitAuthorsParamsSchema
  >

  export const MigrationsGetCommitAuthorsResponseSchema =
    z.array(PorterAuthorSchema)
  export type MigrationsGetCommitAuthorsResponse = z.infer<
    typeof MigrationsGetCommitAuthorsResponseSchema
  >

  export const MigrationsMapCommitAuthorParamsSchema = z.object({
    email: z.string().describe('The new Git author email.').optional(),
    name: z.string().describe('The new Git author name.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    author_id: z.number().int()
  })
  export type MigrationsMapCommitAuthorParams = z.infer<
    typeof MigrationsMapCommitAuthorParamsSchema
  >

  export const MigrationsMapCommitAuthorResponseSchema = PorterAuthorSchema
  export type MigrationsMapCommitAuthorResponse = z.infer<
    typeof MigrationsMapCommitAuthorResponseSchema
  >

  export const MigrationsGetLargeFilesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsGetLargeFilesParams = z.infer<
    typeof MigrationsGetLargeFilesParamsSchema
  >

  export const MigrationsGetLargeFilesResponseSchema = z.array(
    PorterLargeFileSchema
  )
  export type MigrationsGetLargeFilesResponse = z.infer<
    typeof MigrationsGetLargeFilesResponseSchema
  >

  export const MigrationsSetLfsPreferenceParamsSchema = z.object({
    use_lfs: z
      .enum(['opt_in', 'opt_out'])
      .describe(
        'Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type MigrationsSetLfsPreferenceParams = z.infer<
    typeof MigrationsSetLfsPreferenceParamsSchema
  >

  export const MigrationsSetLfsPreferenceResponseSchema = ImportSchema
  export type MigrationsSetLfsPreferenceResponse = z.infer<
    typeof MigrationsSetLfsPreferenceResponseSchema
  >

  export const AppsGetRepoInstallationParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type AppsGetRepoInstallationParams = z.infer<
    typeof AppsGetRepoInstallationParamsSchema
  >

  export const AppsGetRepoInstallationResponseSchema = InstallationSchema
  export type AppsGetRepoInstallationResponse = z.infer<
    typeof AppsGetRepoInstallationResponseSchema
  >

  export const InteractionsGetRestrictionsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type InteractionsGetRestrictionsForRepoParams = z.infer<
    typeof InteractionsGetRestrictionsForRepoParamsSchema
  >

  export const InteractionsGetRestrictionsForRepoResponseSchema = z.union([
    InteractionLimitResponseSchema,
    z.object({}).strict()
  ])
  export type InteractionsGetRestrictionsForRepoResponse = z.infer<
    typeof InteractionsGetRestrictionsForRepoResponseSchema
  >

  export const InteractionsSetRestrictionsForRepoParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(InteractionLimitSchema)
  export type InteractionsSetRestrictionsForRepoParams = z.infer<
    typeof InteractionsSetRestrictionsForRepoParamsSchema
  >

  export const InteractionsSetRestrictionsForRepoResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForRepoResponse = z.infer<
    typeof InteractionsSetRestrictionsForRepoResponseSchema
  >

  export const InteractionsRemoveRestrictionsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type InteractionsRemoveRestrictionsForRepoParams = z.infer<
    typeof InteractionsRemoveRestrictionsForRepoParamsSchema
  >

  export type InteractionsRemoveRestrictionsForRepoResponse = undefined

  export const ReposListInvitationsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListInvitationsParams = z.infer<
    typeof ReposListInvitationsParamsSchema
  >

  export const ReposListInvitationsResponseSchema = z.array(
    RepositoryInvitationSchema
  )
  export type ReposListInvitationsResponse = z.infer<
    typeof ReposListInvitationsResponseSchema
  >

  export const ReposDeleteInvitationParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type ReposDeleteInvitationParams = z.infer<
    typeof ReposDeleteInvitationParamsSchema
  >

  export type ReposDeleteInvitationResponse = undefined

  export const ReposUpdateInvitationParamsSchema = z.object({
    permissions: z
      .enum(['read', 'write', 'maintain', 'triage', 'admin'])
      .describe(
        'The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    invitation_id: z
      .number()
      .int()
      .describe('The unique identifier of the invitation.')
  })
  export type ReposUpdateInvitationParams = z.infer<
    typeof ReposUpdateInvitationParamsSchema
  >

  export const ReposUpdateInvitationResponseSchema = RepositoryInvitationSchema
  export type ReposUpdateInvitationResponse = z.infer<
    typeof ReposUpdateInvitationResponseSchema
  >

  export const IssuesListForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone: z
      .string()
      .describe(
        'If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.'
      )
      .optional(),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    assignee: z
      .string()
      .describe(
        'Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned.'
      )
      .optional(),
    creator: z.string().describe('The user that created the issue.').optional(),
    mentioned: z
      .string()
      .describe("A user that's mentioned in the issue.")
      .optional(),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForRepoParams = z.infer<
    typeof IssuesListForRepoParamsSchema
  >

  export const IssuesListForRepoResponseSchema = z.array(IssueSchema)
  export type IssuesListForRepoResponse = z.infer<
    typeof IssuesListForRepoResponseSchema
  >

  export const IssuesCreateParamsSchema = z.object({
    title: z
      .union([z.string(), z.number().int()])
      .describe('The title of the issue.'),
    body: z.string().describe('The contents of the issue.').optional(),
    assignee: z
      .string()
      .describe(
        'Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_'
      )
      .optional(),
    milestone: z
      .union([
        z.string(),
        z
          .number()
          .int()
          .describe(
            'The `number` of the milestone to associate this issue with. _NOTE: Only users with push access can set the milestone for new issues. The milestone is silently dropped otherwise._'
          )
      ])
      .optional(),
    labels: z
      .array(
        z.union([
          z.string(),
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
            description: z.string().optional(),
            color: z.string().optional()
          })
        ])
      )
      .describe(
        'Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._'
      )
      .optional(),
    assignees: z
      .array(z.string())
      .describe(
        'Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateParams = z.infer<typeof IssuesCreateParamsSchema>

  export type IssuesCreateResponse = undefined

  export const IssuesListCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('Either `asc` or `desc`. Ignored without the `sort` parameter.')
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListCommentsForRepoParams = z.infer<
    typeof IssuesListCommentsForRepoParamsSchema
  >

  export const IssuesListCommentsForRepoResponseSchema =
    z.array(IssueCommentSchema)
  export type IssuesListCommentsForRepoResponse = z.infer<
    typeof IssuesListCommentsForRepoResponseSchema
  >

  export const IssuesGetCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesGetCommentParams = z.infer<
    typeof IssuesGetCommentParamsSchema
  >

  export const IssuesGetCommentResponseSchema = IssueCommentSchema
  export type IssuesGetCommentResponse = z.infer<
    typeof IssuesGetCommentResponseSchema
  >

  export const IssuesDeleteCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesDeleteCommentParams = z.infer<
    typeof IssuesDeleteCommentParamsSchema
  >

  export type IssuesDeleteCommentResponse = undefined

  export const IssuesUpdateCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type IssuesUpdateCommentParams = z.infer<
    typeof IssuesUpdateCommentParamsSchema
  >

  export const IssuesUpdateCommentResponseSchema = IssueCommentSchema
  export type IssuesUpdateCommentResponse = z.infer<
    typeof IssuesUpdateCommentResponseSchema
  >

  export const ReactionsListForIssueCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForIssueCommentParams = z.infer<
    typeof ReactionsListForIssueCommentParamsSchema
  >

  export const ReactionsListForIssueCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForIssueCommentResponse = z.infer<
    typeof ReactionsListForIssueCommentResponseSchema
  >

  export const ReactionsCreateForIssueCommentParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type ReactionsCreateForIssueCommentParams = z.infer<
    typeof ReactionsCreateForIssueCommentParamsSchema
  >

  export const ReactionsCreateForIssueCommentResponseSchema = ReactionSchema
  export type ReactionsCreateForIssueCommentResponse = z.infer<
    typeof ReactionsCreateForIssueCommentResponseSchema
  >

  export const ReactionsDeleteForIssueCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForIssueCommentParams = z.infer<
    typeof ReactionsDeleteForIssueCommentParamsSchema
  >

  export type ReactionsDeleteForIssueCommentResponse = undefined

  export const IssuesListEventsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsForRepoParams = z.infer<
    typeof IssuesListEventsForRepoParamsSchema
  >

  export const IssuesListEventsForRepoResponseSchema = z.array(IssueEventSchema)
  export type IssuesListEventsForRepoResponse = z.infer<
    typeof IssuesListEventsForRepoResponseSchema
  >

  export const IssuesGetEventParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    event_id: z.number().int()
  })
  export type IssuesGetEventParams = z.infer<typeof IssuesGetEventParamsSchema>

  export const IssuesGetEventResponseSchema = IssueEventSchema
  export type IssuesGetEventResponse = z.infer<
    typeof IssuesGetEventResponseSchema
  >

  export const IssuesGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesGetParams = z.infer<typeof IssuesGetParamsSchema>

  export const IssuesGetResponseSchema = IssueSchema
  export type IssuesGetResponse = z.infer<typeof IssuesGetResponseSchema>

  export const IssuesUpdateParamsSchema = z.object({
    title: z
      .union([z.string(), z.number().int()])
      .describe('The title of the issue.')
      .optional(),
    body: z.string().describe('The contents of the issue.').optional(),
    assignee: z
      .string()
      .describe(
        'Username to assign to this issue. **This field is closing down.**'
      )
      .optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('The open or closed state of the issue.')
      .optional(),
    state_reason: z
      .enum(['completed', 'not_planned', 'reopened'])
      .describe(
        'The reason for the state change. Ignored unless `state` is changed.'
      )
      .optional(),
    milestone: z
      .union([
        z.string(),
        z
          .number()
          .int()
          .describe(
            'The `number` of the milestone to associate this issue with or use `null` to remove the current milestone. Only users with push access can set the milestone for issues. Without push access to the repository, milestone changes are silently dropped.'
          )
      ])
      .optional(),
    labels: z
      .array(
        z.union([
          z.string(),
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
            description: z.string().optional(),
            color: z.string().optional()
          })
        ])
      )
      .describe(
        'Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.'
      )
      .optional(),
    assignees: z
      .array(z.string())
      .describe(
        'Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.'
      )
      .optional(),
    type: z
      .string()
      .describe(
        'The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesUpdateParams = z.infer<typeof IssuesUpdateParamsSchema>

  export const IssuesUpdateResponseSchema = IssueSchema
  export type IssuesUpdateResponse = z.infer<typeof IssuesUpdateResponseSchema>

  export const IssuesAddAssigneesParamsSchema = z.object({
    assignees: z
      .array(z.string())
      .describe(
        'Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesAddAssigneesParams = z.infer<
    typeof IssuesAddAssigneesParamsSchema
  >

  export type IssuesAddAssigneesResponse = undefined

  export const IssuesRemoveAssigneesParamsSchema = z.object({
    assignees: z
      .array(z.string())
      .describe(
        'Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveAssigneesParams = z.infer<
    typeof IssuesRemoveAssigneesParamsSchema
  >

  export const IssuesRemoveAssigneesResponseSchema = IssueSchema
  export type IssuesRemoveAssigneesResponse = z.infer<
    typeof IssuesRemoveAssigneesResponseSchema
  >

  export const IssuesCheckUserCanBeAssignedToIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    assignee: z.string()
  })
  export type IssuesCheckUserCanBeAssignedToIssueParams = z.infer<
    typeof IssuesCheckUserCanBeAssignedToIssueParamsSchema
  >

  export type IssuesCheckUserCanBeAssignedToIssueResponse = undefined

  export const IssuesListCommentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListCommentsParams = z.infer<
    typeof IssuesListCommentsParamsSchema
  >

  export const IssuesListCommentsResponseSchema = z.array(IssueCommentSchema)
  export type IssuesListCommentsResponse = z.infer<
    typeof IssuesListCommentsResponseSchema
  >

  export const IssuesCreateCommentParamsSchema = z.object({
    body: z.string().describe('The contents of the comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesCreateCommentParams = z.infer<
    typeof IssuesCreateCommentParamsSchema
  >

  export type IssuesCreateCommentResponse = undefined

  export const IssuesListEventsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsParams = z.infer<
    typeof IssuesListEventsParamsSchema
  >

  export const IssuesListEventsResponseSchema = z.array(
    IssueEventForIssueSchema
  )
  export type IssuesListEventsResponse = z.infer<
    typeof IssuesListEventsResponseSchema
  >

  export const IssuesListLabelsOnIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsOnIssueParams = z.infer<
    typeof IssuesListLabelsOnIssueParamsSchema
  >

  export const IssuesListLabelsOnIssueResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsOnIssueResponse = z.infer<
    typeof IssuesListLabelsOnIssueResponseSchema
  >

  export const IssuesAddLabelsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      issue_number: z
        .number()
        .int()
        .describe('The number that identifies the issue.')
    })
    .and(
      z.union([
        z.object({
          labels: z
            .array(z.string())
            .min(1)
            .describe(
              'The names of the labels to add to the issue\'s existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)."'
            )
            .optional()
        }),
        z.array(z.string()).min(1),
        z.object({
          labels: z
            .array(z.object({ name: z.string() }))
            .min(1)
            .optional()
        }),
        z.array(z.object({ name: z.string() })).min(1),
        z.string()
      ])
    )
  export type IssuesAddLabelsParams = z.infer<
    typeof IssuesAddLabelsParamsSchema
  >

  export const IssuesAddLabelsResponseSchema = z.array(LabelSchema)
  export type IssuesAddLabelsResponse = z.infer<
    typeof IssuesAddLabelsResponseSchema
  >

  export const IssuesSetLabelsParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      issue_number: z
        .number()
        .int()
        .describe('The number that identifies the issue.')
    })
    .and(
      z.union([
        z.object({
          labels: z
            .array(z.string())
            .min(1)
            .describe(
              'The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)."'
            )
            .optional()
        }),
        z.array(z.string()).min(1),
        z.object({
          labels: z
            .array(z.object({ name: z.string() }))
            .min(1)
            .optional()
        }),
        z.array(z.object({ name: z.string() })).min(1),
        z.string()
      ])
    )
  export type IssuesSetLabelsParams = z.infer<
    typeof IssuesSetLabelsParamsSchema
  >

  export const IssuesSetLabelsResponseSchema = z.array(LabelSchema)
  export type IssuesSetLabelsResponse = z.infer<
    typeof IssuesSetLabelsResponseSchema
  >

  export const IssuesRemoveAllLabelsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveAllLabelsParams = z.infer<
    typeof IssuesRemoveAllLabelsParamsSchema
  >

  export type IssuesRemoveAllLabelsResponse = undefined

  export const IssuesRemoveLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    name: z.string()
  })
  export type IssuesRemoveLabelParams = z.infer<
    typeof IssuesRemoveLabelParamsSchema
  >

  export const IssuesRemoveLabelResponseSchema = z.array(LabelSchema)
  export type IssuesRemoveLabelResponse = z.infer<
    typeof IssuesRemoveLabelResponseSchema
  >

  export const IssuesLockParamsSchema = z.object({
    lock_reason: z
      .enum(['off-topic', 'too heated', 'resolved', 'spam'])
      .describe(
        "The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  \n * `off-topic`  \n * `too heated`  \n * `resolved`  \n * `spam`"
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesLockParams = z.infer<typeof IssuesLockParamsSchema>

  export type IssuesLockResponse = undefined

  export const IssuesUnlockParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesUnlockParams = z.infer<typeof IssuesUnlockParamsSchema>

  export type IssuesUnlockResponse = undefined

  export const ReactionsListForIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForIssueParams = z.infer<
    typeof ReactionsListForIssueParamsSchema
  >

  export const ReactionsListForIssueResponseSchema = z.array(ReactionSchema)
  export type ReactionsListForIssueResponse = z.infer<
    typeof ReactionsListForIssueResponseSchema
  >

  export const ReactionsCreateForIssueParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type ReactionsCreateForIssueParams = z.infer<
    typeof ReactionsCreateForIssueParamsSchema
  >

  export const ReactionsCreateForIssueResponseSchema = ReactionSchema
  export type ReactionsCreateForIssueResponse = z.infer<
    typeof ReactionsCreateForIssueResponseSchema
  >

  export const ReactionsDeleteForIssueParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForIssueParams = z.infer<
    typeof ReactionsDeleteForIssueParamsSchema
  >

  export type ReactionsDeleteForIssueResponse = undefined

  export const IssuesRemoveSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe('The id of the sub-issue to remove'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesRemoveSubIssueParams = z.infer<
    typeof IssuesRemoveSubIssueParamsSchema
  >

  export const IssuesRemoveSubIssueResponseSchema = IssueSchema
  export type IssuesRemoveSubIssueResponse = z.infer<
    typeof IssuesRemoveSubIssueResponseSchema
  >

  export const IssuesListSubIssuesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListSubIssuesParams = z.infer<
    typeof IssuesListSubIssuesParamsSchema
  >

  export const IssuesListSubIssuesResponseSchema = z.array(IssueSchema)
  export type IssuesListSubIssuesResponse = z.infer<
    typeof IssuesListSubIssuesResponseSchema
  >

  export const IssuesAddSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue'
      ),
    replace_parent: z
      .boolean()
      .describe(
        'Option that, when true, instructs the operation to replace the sub-issues current parent issue'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesAddSubIssueParams = z.infer<
    typeof IssuesAddSubIssueParamsSchema
  >

  export type IssuesAddSubIssueResponse = undefined

  export const IssuesReprioritizeSubIssueParamsSchema = z.object({
    sub_issue_id: z
      .number()
      .int()
      .describe('The id of the sub-issue to reprioritize'),
    after_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).'
      )
      .optional(),
    before_id: z
      .number()
      .int()
      .describe(
        'The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.')
  })
  export type IssuesReprioritizeSubIssueParams = z.infer<
    typeof IssuesReprioritizeSubIssueParamsSchema
  >

  export const IssuesReprioritizeSubIssueResponseSchema = IssueSchema
  export type IssuesReprioritizeSubIssueResponse = z.infer<
    typeof IssuesReprioritizeSubIssueResponseSchema
  >

  export const IssuesListEventsForTimelineParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    issue_number: z
      .number()
      .int()
      .describe('The number that identifies the issue.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListEventsForTimelineParams = z.infer<
    typeof IssuesListEventsForTimelineParamsSchema
  >

  export const IssuesListEventsForTimelineResponseSchema = z.array(
    TimelineIssueEventsSchema
  )
  export type IssuesListEventsForTimelineResponse = z.infer<
    typeof IssuesListEventsForTimelineResponseSchema
  >

  export const ReposListDeployKeysParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListDeployKeysParams = z.infer<
    typeof ReposListDeployKeysParamsSchema
  >

  export const ReposListDeployKeysResponseSchema = z.array(DeployKeySchema)
  export type ReposListDeployKeysResponse = z.infer<
    typeof ReposListDeployKeysResponseSchema
  >

  export const ReposCreateDeployKeyParamsSchema = z.object({
    title: z.string().describe('A name for the key.').optional(),
    key: z.string().describe('The contents of the key.'),
    read_only: z
      .boolean()
      .describe(
        'If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateDeployKeyParams = z.infer<
    typeof ReposCreateDeployKeyParamsSchema
  >

  export type ReposCreateDeployKeyResponse = undefined

  export const ReposGetDeployKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type ReposGetDeployKeyParams = z.infer<
    typeof ReposGetDeployKeyParamsSchema
  >

  export const ReposGetDeployKeyResponseSchema = DeployKeySchema
  export type ReposGetDeployKeyResponse = z.infer<
    typeof ReposGetDeployKeyResponseSchema
  >

  export const ReposDeleteDeployKeyParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type ReposDeleteDeployKeyParams = z.infer<
    typeof ReposDeleteDeployKeyParamsSchema
  >

  export type ReposDeleteDeployKeyResponse = undefined

  export const IssuesListLabelsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsForRepoParams = z.infer<
    typeof IssuesListLabelsForRepoParamsSchema
  >

  export const IssuesListLabelsForRepoResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsForRepoResponse = z.infer<
    typeof IssuesListLabelsForRepoResponseSchema
  >

  export const IssuesCreateLabelParamsSchema = z.object({
    name: z
      .string()
      .describe(
        'The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
      ),
    color: z
      .string()
      .describe(
        'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
      )
      .optional(),
    description: z
      .string()
      .describe(
        'A short description of the label. Must be 100 characters or fewer.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateLabelParams = z.infer<
    typeof IssuesCreateLabelParamsSchema
  >

  export type IssuesCreateLabelResponse = undefined

  export const IssuesGetLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesGetLabelParams = z.infer<typeof IssuesGetLabelParamsSchema>

  export const IssuesGetLabelResponseSchema = LabelSchema
  export type IssuesGetLabelResponse = z.infer<
    typeof IssuesGetLabelResponseSchema
  >

  export const IssuesDeleteLabelParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesDeleteLabelParams = z.infer<
    typeof IssuesDeleteLabelParamsSchema
  >

  export type IssuesDeleteLabelResponse = undefined

  export const IssuesUpdateLabelParamsSchema = z.object({
    new_name: z
      .string()
      .describe(
        'The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
      )
      .optional(),
    color: z
      .string()
      .describe(
        'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
      )
      .optional(),
    description: z
      .string()
      .describe(
        'A short description of the label. Must be 100 characters or fewer.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    name: z.string()
  })
  export type IssuesUpdateLabelParams = z.infer<
    typeof IssuesUpdateLabelParamsSchema
  >

  export const IssuesUpdateLabelResponseSchema = LabelSchema
  export type IssuesUpdateLabelResponse = z.infer<
    typeof IssuesUpdateLabelResponseSchema
  >

  export const ReposListLanguagesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListLanguagesParams = z.infer<
    typeof ReposListLanguagesParamsSchema
  >

  export const ReposListLanguagesResponseSchema = LanguageSchema
  export type ReposListLanguagesResponse = z.infer<
    typeof ReposListLanguagesResponseSchema
  >

  export const LicensesGetForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .any()
      .describe(
        'The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.'
      )
      .optional()
  })
  export type LicensesGetForRepoParams = z.infer<
    typeof LicensesGetForRepoParamsSchema
  >

  export const LicensesGetForRepoResponseSchema = LicenseContentSchema
  export type LicensesGetForRepoResponse = z.infer<
    typeof LicensesGetForRepoResponseSchema
  >

  export const ReposMergeUpstreamParamsSchema = z.object({
    branch: z
      .string()
      .describe(
        'The name of the branch which should be updated to match upstream.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposMergeUpstreamParams = z.infer<
    typeof ReposMergeUpstreamParamsSchema
  >

  export const ReposMergeUpstreamResponseSchema = MergedUpstreamSchema
  export type ReposMergeUpstreamResponse = z.infer<
    typeof ReposMergeUpstreamResponseSchema
  >

  export const ReposMergeParamsSchema = z.object({
    base: z
      .string()
      .describe(
        'The name of the base branch that the head will be merged into.'
      ),
    head: z
      .string()
      .describe(
        'The head to merge. This can be a branch name or a commit SHA1.'
      ),
    commit_message: z
      .string()
      .describe(
        'Commit message to use for the merge commit. If omitted, a default message will be used.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposMergeParams = z.infer<typeof ReposMergeParamsSchema>

  export type ReposMergeResponse = undefined

  export const IssuesListMilestonesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe(
        'The state of the milestone. Either `open`, `closed`, or `all`.'
      )
      .default('open'),
    sort: z
      .enum(['due_on', 'completeness'])
      .describe('What to sort results by. Either `due_on` or `completeness`.')
      .default('due_on'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction of the sort. Either `asc` or `desc`.')
      .default('asc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListMilestonesParams = z.infer<
    typeof IssuesListMilestonesParamsSchema
  >

  export const IssuesListMilestonesResponseSchema = z.array(MilestoneSchema)
  export type IssuesListMilestonesResponse = z.infer<
    typeof IssuesListMilestonesResponseSchema
  >

  export const IssuesCreateMilestoneParamsSchema = z.object({
    title: z.string().describe('The title of the milestone.'),
    state: z
      .enum(['open', 'closed'])
      .describe('The state of the milestone. Either `open` or `closed`.')
      .default('open'),
    description: z
      .string()
      .describe('A description of the milestone.')
      .optional(),
    due_on: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type IssuesCreateMilestoneParams = z.infer<
    typeof IssuesCreateMilestoneParamsSchema
  >

  export type IssuesCreateMilestoneResponse = undefined

  export const IssuesGetMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesGetMilestoneParams = z.infer<
    typeof IssuesGetMilestoneParamsSchema
  >

  export const IssuesGetMilestoneResponseSchema = MilestoneSchema
  export type IssuesGetMilestoneResponse = z.infer<
    typeof IssuesGetMilestoneResponseSchema
  >

  export const IssuesDeleteMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesDeleteMilestoneParams = z.infer<
    typeof IssuesDeleteMilestoneParamsSchema
  >

  export type IssuesDeleteMilestoneResponse = undefined

  export const IssuesUpdateMilestoneParamsSchema = z.object({
    title: z.string().describe('The title of the milestone.').optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('The state of the milestone. Either `open` or `closed`.')
      .default('open'),
    description: z
      .string()
      .describe('A description of the milestone.')
      .optional(),
    due_on: z
      .string()
      .datetime({ offset: true })
      .describe(
        'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.')
  })
  export type IssuesUpdateMilestoneParams = z.infer<
    typeof IssuesUpdateMilestoneParamsSchema
  >

  export const IssuesUpdateMilestoneResponseSchema = MilestoneSchema
  export type IssuesUpdateMilestoneResponse = z.infer<
    typeof IssuesUpdateMilestoneResponseSchema
  >

  export const IssuesListLabelsForMilestoneParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    milestone_number: z
      .number()
      .int()
      .describe('The number that identifies the milestone.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListLabelsForMilestoneParams = z.infer<
    typeof IssuesListLabelsForMilestoneParamsSchema
  >

  export const IssuesListLabelsForMilestoneResponseSchema = z.array(LabelSchema)
  export type IssuesListLabelsForMilestoneResponse = z.infer<
    typeof IssuesListLabelsForMilestoneResponseSchema
  >

  export const ActivityListRepoNotificationsForAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      all: z
        .boolean()
        .describe('If `true`, show notifications marked as read.')
        .default(false),
      participating: z
        .boolean()
        .describe(
          'If `true`, only shows notifications in which the user is directly participating or mentioned.'
        )
        .default(false),
      since: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      before: z
        .string()
        .datetime({ offset: true })
        .describe(
          'Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListRepoNotificationsForAuthenticatedUserParams = z.infer<
    typeof ActivityListRepoNotificationsForAuthenticatedUserParamsSchema
  >

  export const ActivityListRepoNotificationsForAuthenticatedUserResponseSchema =
    z.array(ThreadSchema)
  export type ActivityListRepoNotificationsForAuthenticatedUserResponse =
    z.infer<
      typeof ActivityListRepoNotificationsForAuthenticatedUserResponseSchema
    >

  export const ActivityMarkRepoNotificationsAsReadParamsSchema = z.object({
    last_read_at: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityMarkRepoNotificationsAsReadParams = z.infer<
    typeof ActivityMarkRepoNotificationsAsReadParamsSchema
  >

  export type ActivityMarkRepoNotificationsAsReadResponse = undefined

  export const ReposGetPagesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPagesParams = z.infer<typeof ReposGetPagesParamsSchema>

  export const ReposGetPagesResponseSchema = PageSchema
  export type ReposGetPagesResponse = z.infer<
    typeof ReposGetPagesResponseSchema
  >

  export const ReposCreatePagesSiteParamsSchema = z
    .object({
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe(
          'The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.'
        )
        .optional(),
      source: z
        .object({
          branch: z
            .string()
            .describe(
              "The repository branch used to publish your site's source files."
            ),
          path: z
            .enum(['/', '/docs'])
            .describe(
              'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`'
            )
            .default('/')
        })
        .describe(
          'The source branch and directory used to publish your Pages site.'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any()]))
  export type ReposCreatePagesSiteParams = z.infer<
    typeof ReposCreatePagesSiteParamsSchema
  >

  export type ReposCreatePagesSiteResponse = undefined

  export const ReposUpdateInformationAboutPagesSiteParamsSchema = z
    .object({
      cname: z
        .string()
        .describe(
          'Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/pages/configuring-a-custom-domain-for-your-github-pages-site)."'
        )
        .optional(),
      https_enforced: z
        .boolean()
        .describe(
          'Specify whether HTTPS should be enforced for the repository.'
        )
        .optional(),
      build_type: z
        .enum(['legacy', 'workflow'])
        .describe(
          'The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.'
        )
        .optional(),
      source: z
        .union([
          z
            .enum(['gh-pages', 'master', 'master /docs'])
            .describe(
              'Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`, `"master"`, and `"master /docs"`.'
            ),
          z
            .object({
              branch: z
                .string()
                .describe(
                  "The repository branch used to publish your site's source files."
                ),
              path: z
                .enum(['/', '/docs'])
                .describe(
                  'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`.'
                )
            })
            .describe(
              'Update the source for the repository. Must include the branch name and path.'
            )
        ])
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .and(z.union([z.any(), z.any(), z.any(), z.any(), z.any()]))
  export type ReposUpdateInformationAboutPagesSiteParams = z.infer<
    typeof ReposUpdateInformationAboutPagesSiteParamsSchema
  >

  export type ReposUpdateInformationAboutPagesSiteResponse = undefined

  export const ReposDeletePagesSiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDeletePagesSiteParams = z.infer<
    typeof ReposDeletePagesSiteParamsSchema
  >

  export type ReposDeletePagesSiteResponse = undefined

  export const ReposListPagesBuildsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListPagesBuildsParams = z.infer<
    typeof ReposListPagesBuildsParamsSchema
  >

  export const ReposListPagesBuildsResponseSchema = z.array(PageBuildSchema)
  export type ReposListPagesBuildsResponse = z.infer<
    typeof ReposListPagesBuildsResponseSchema
  >

  export const ReposRequestPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposRequestPagesBuildParams = z.infer<
    typeof ReposRequestPagesBuildParamsSchema
  >

  export type ReposRequestPagesBuildResponse = undefined

  export const ReposGetLatestPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetLatestPagesBuildParams = z.infer<
    typeof ReposGetLatestPagesBuildParamsSchema
  >

  export const ReposGetLatestPagesBuildResponseSchema = PageBuildSchema
  export type ReposGetLatestPagesBuildResponse = z.infer<
    typeof ReposGetLatestPagesBuildResponseSchema
  >

  export const ReposGetPagesBuildParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    build_id: z.number().int()
  })
  export type ReposGetPagesBuildParams = z.infer<
    typeof ReposGetPagesBuildParamsSchema
  >

  export const ReposGetPagesBuildResponseSchema = PageBuildSchema
  export type ReposGetPagesBuildResponse = z.infer<
    typeof ReposGetPagesBuildResponseSchema
  >

  export const ReposCreatePagesDeploymentParamsSchema = z.object({
    artifact_id: z
      .number()
      .describe(
        'The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.'
      )
      .optional(),
    artifact_url: z
      .string()
      .describe(
        'The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.'
      )
      .optional(),
    environment: z
      .string()
      .describe('The target environment for this GitHub Pages deployment.')
      .default('github-pages'),
    pages_build_version: z
      .string()
      .describe(
        'A unique string that represents the version of the build for this deployment.'
      )
      .default('GITHUB_SHA'),
    oidc_token: z
      .string()
      .describe(
        'The OIDC token issued by GitHub Actions certifying the origin of the deployment.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreatePagesDeploymentParams = z.infer<
    typeof ReposCreatePagesDeploymentParamsSchema
  >

  export const ReposCreatePagesDeploymentResponseSchema = PageDeploymentSchema
  export type ReposCreatePagesDeploymentResponse = z.infer<
    typeof ReposCreatePagesDeploymentResponseSchema
  >

  export const ReposGetPagesDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pages_deployment_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
      )
  })
  export type ReposGetPagesDeploymentParams = z.infer<
    typeof ReposGetPagesDeploymentParamsSchema
  >

  export const ReposGetPagesDeploymentResponseSchema =
    PagesDeploymentStatusSchema
  export type ReposGetPagesDeploymentResponse = z.infer<
    typeof ReposGetPagesDeploymentResponseSchema
  >

  export const ReposCancelPagesDeploymentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pages_deployment_id: z
      .union([z.number().int(), z.string()])
      .describe(
        'The ID of the Pages deployment. You can also give the commit SHA of the deployment.'
      )
  })
  export type ReposCancelPagesDeploymentParams = z.infer<
    typeof ReposCancelPagesDeploymentParamsSchema
  >

  export type ReposCancelPagesDeploymentResponse = undefined

  export const ReposGetPagesHealthCheckParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPagesHealthCheckParams = z.infer<
    typeof ReposGetPagesHealthCheckParamsSchema
  >

  export const ReposGetPagesHealthCheckResponseSchema = PagesHealthCheckSchema
  export type ReposGetPagesHealthCheckResponse = z.infer<
    typeof ReposGetPagesHealthCheckResponseSchema
  >

  export const ReposCheckPrivateVulnerabilityReportingParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckPrivateVulnerabilityReportingParams = z.infer<
    typeof ReposCheckPrivateVulnerabilityReportingParamsSchema
  >

  export const ReposCheckPrivateVulnerabilityReportingResponseSchema = z.object(
    {
      enabled: z
        .boolean()
        .describe(
          'Whether or not private vulnerability reporting is enabled for the repository.'
        )
    }
  )
  export type ReposCheckPrivateVulnerabilityReportingResponse = z.infer<
    typeof ReposCheckPrivateVulnerabilityReportingResponseSchema
  >

  export const ReposEnablePrivateVulnerabilityReportingParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnablePrivateVulnerabilityReportingParams = z.infer<
    typeof ReposEnablePrivateVulnerabilityReportingParamsSchema
  >

  export type ReposEnablePrivateVulnerabilityReportingResponse = undefined

  export const ReposDisablePrivateVulnerabilityReportingParamsSchema = z.object(
    {
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type ReposDisablePrivateVulnerabilityReportingParams = z.infer<
    typeof ReposDisablePrivateVulnerabilityReportingParamsSchema
  >

  export type ReposDisablePrivateVulnerabilityReportingResponse = undefined

  export const ProjectsListForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForRepoParams = z.infer<
    typeof ProjectsListForRepoParamsSchema
  >

  export const ProjectsListForRepoResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForRepoResponse = z.infer<
    typeof ProjectsListForRepoResponseSchema
  >

  export const ProjectsCreateForRepoParamsSchema = z.object({
    name: z.string().describe('The name of the project.'),
    body: z.string().describe('The description of the project.').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ProjectsCreateForRepoParams = z.infer<
    typeof ProjectsCreateForRepoParamsSchema
  >

  export type ProjectsCreateForRepoResponse = undefined

  export const ReposGetCustomPropertiesValuesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCustomPropertiesValuesParams = z.infer<
    typeof ReposGetCustomPropertiesValuesParamsSchema
  >

  export const ReposGetCustomPropertiesValuesResponseSchema = z.array(
    CustomPropertyValueSchema
  )
  export type ReposGetCustomPropertiesValuesResponse = z.infer<
    typeof ReposGetCustomPropertiesValuesResponseSchema
  >

  export const ReposCreateOrUpdateCustomPropertiesValuesParamsSchema = z.object(
    {
      properties: z
        .array(CustomPropertyValueSchema)
        .describe(
          'A list of custom property names and associated values to apply to the repositories.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    }
  )
  export type ReposCreateOrUpdateCustomPropertiesValuesParams = z.infer<
    typeof ReposCreateOrUpdateCustomPropertiesValuesParamsSchema
  >

  export type ReposCreateOrUpdateCustomPropertiesValuesResponse = undefined

  export const PullsListParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Either `open`, `closed`, or `all` to filter by state.')
      .default('open'),
    head: z
      .string()
      .describe(
        'Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.'
      )
      .optional(),
    base: z
      .string()
      .describe('Filter pulls by base branch name. Example: `gh-pages`.')
      .optional(),
    sort: z
      .enum(['created', 'updated', 'popularity', 'long-running'])
      .describe(
        'What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListParams = z.infer<typeof PullsListParamsSchema>

  export const PullsListResponseSchema = z.array(PullRequestSimpleSchema)
  export type PullsListResponse = z.infer<typeof PullsListResponseSchema>

  export const PullsCreateParamsSchema = z.object({
    title: z
      .string()
      .describe(
        'The title of the new pull request. Required unless `issue` is specified.'
      )
      .optional(),
    head: z
      .string()
      .describe(
        'The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.'
      ),
    head_repo: z
      .string()
      .describe(
        'The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.'
      )
      .optional(),
    base: z
      .string()
      .describe(
        'The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.'
      ),
    body: z.string().describe('The contents of the pull request.').optional(),
    maintainer_can_modify: z
      .boolean()
      .describe(
        'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
      )
      .optional(),
    draft: z
      .boolean()
      .describe(
        'Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.'
      )
      .optional(),
    issue: z
      .number()
      .int()
      .describe(
        'An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type PullsCreateParams = z.infer<typeof PullsCreateParamsSchema>

  export type PullsCreateResponse = undefined

  export const PullsListReviewCommentsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sort: z.enum(['created', 'updated', 'created_at']).optional(),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction to sort results. Ignored without `sort` parameter.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewCommentsForRepoParams = z.infer<
    typeof PullsListReviewCommentsForRepoParamsSchema
  >

  export const PullsListReviewCommentsForRepoResponseSchema = z.array(
    PullRequestReviewCommentSchema
  )
  export type PullsListReviewCommentsForRepoResponse = z.infer<
    typeof PullsListReviewCommentsForRepoResponseSchema
  >

  export const PullsGetReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsGetReviewCommentParams = z.infer<
    typeof PullsGetReviewCommentParamsSchema
  >

  export const PullsGetReviewCommentResponseSchema =
    PullRequestReviewCommentSchema
  export type PullsGetReviewCommentResponse = z.infer<
    typeof PullsGetReviewCommentResponseSchema
  >

  export const PullsDeleteReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsDeleteReviewCommentParams = z.infer<
    typeof PullsDeleteReviewCommentParamsSchema
  >

  export type PullsDeleteReviewCommentResponse = undefined

  export const PullsUpdateReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the reply to the review comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsUpdateReviewCommentParams = z.infer<
    typeof PullsUpdateReviewCommentParamsSchema
  >

  export const PullsUpdateReviewCommentResponseSchema =
    PullRequestReviewCommentSchema
  export type PullsUpdateReviewCommentResponse = z.infer<
    typeof PullsUpdateReviewCommentResponseSchema
  >

  export const ReactionsListForPullRequestReviewCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForPullRequestReviewCommentParams = z.infer<
    typeof ReactionsListForPullRequestReviewCommentParamsSchema
  >

  export const ReactionsListForPullRequestReviewCommentResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForPullRequestReviewCommentResponse = z.infer<
    typeof ReactionsListForPullRequestReviewCommentResponseSchema
  >

  export const ReactionsCreateForPullRequestReviewCommentParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.'
        ),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      comment_id: z
        .number()
        .int()
        .describe('The unique identifier of the comment.')
    })
  export type ReactionsCreateForPullRequestReviewCommentParams = z.infer<
    typeof ReactionsCreateForPullRequestReviewCommentParamsSchema
  >

  export const ReactionsCreateForPullRequestReviewCommentResponseSchema =
    ReactionSchema
  export type ReactionsCreateForPullRequestReviewCommentResponse = z.infer<
    typeof ReactionsCreateForPullRequestReviewCommentResponseSchema
  >

  export const ReactionsDeleteForPullRequestCommentParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForPullRequestCommentParams = z.infer<
    typeof ReactionsDeleteForPullRequestCommentParamsSchema
  >

  export type ReactionsDeleteForPullRequestCommentResponse = undefined

  export const PullsGetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsGetParams = z.infer<typeof PullsGetParamsSchema>

  export const PullsGetResponseSchema = PullRequestSchema
  export type PullsGetResponse = z.infer<typeof PullsGetResponseSchema>

  export const PullsUpdateParamsSchema = z.object({
    title: z.string().describe('The title of the pull request.').optional(),
    body: z.string().describe('The contents of the pull request.').optional(),
    state: z
      .enum(['open', 'closed'])
      .describe('State of this Pull Request. Either `open` or `closed`.')
      .optional(),
    base: z
      .string()
      .describe(
        'The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.'
      )
      .optional(),
    maintainer_can_modify: z
      .boolean()
      .describe(
        'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsUpdateParams = z.infer<typeof PullsUpdateParamsSchema>

  export const PullsUpdateResponseSchema = PullRequestSchema
  export type PullsUpdateResponse = z.infer<typeof PullsUpdateResponseSchema>

  export const CodespacesCreateWithPrForAuthenticatedUserParamsSchema =
    z.object({
      location: z
        .string()
        .describe(
          'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
        )
        .optional(),
      geo: z
        .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
        .describe(
          'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
        )
        .optional(),
      client_ip: z
        .string()
        .describe('IP for location auto-detection when proxying a request')
        .optional(),
      machine: z
        .string()
        .describe('Machine type to use for this codespace')
        .optional(),
      devcontainer_path: z
        .string()
        .describe('Path to devcontainer.json config to use for this codespace')
        .optional(),
      multi_repo_permissions_opt_out: z
        .boolean()
        .describe(
          'Whether to authorize requested permissions from devcontainer.json'
        )
        .optional(),
      working_directory: z
        .string()
        .describe('Working directory for this codespace')
        .optional(),
      idle_timeout_minutes: z
        .number()
        .int()
        .describe('Time in minutes before codespace stops from inactivity')
        .optional(),
      display_name: z
        .string()
        .describe('Display name for this codespace')
        .optional(),
      retention_period_minutes: z
        .number()
        .int()
        .describe(
          'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
        )
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      pull_number: z
        .number()
        .int()
        .describe('The number that identifies the pull request.')
    })
  export type CodespacesCreateWithPrForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateWithPrForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateWithPrForAuthenticatedUserResponse = undefined

  export const PullsListReviewCommentsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    sort: z
      .enum(['created', 'updated'])
      .describe('The property to sort the results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The direction to sort results. Ignored without `sort` parameter.'
      )
      .optional(),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewCommentsParams = z.infer<
    typeof PullsListReviewCommentsParamsSchema
  >

  export const PullsListReviewCommentsResponseSchema = z.array(
    PullRequestReviewCommentSchema
  )
  export type PullsListReviewCommentsResponse = z.infer<
    typeof PullsListReviewCommentsResponseSchema
  >

  export const PullsCreateReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the review comment.'),
    commit_id: z
      .string()
      .describe(
        'The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.'
      ),
    path: z
      .string()
      .describe('The relative path to the file that necessitates a comment.'),
    position: z
      .number()
      .int()
      .describe(
        '**This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.'
      )
      .optional(),
    side: z
      .enum(['LEFT', 'RIGHT'])
      .describe(
        'In a split diff view, the side of the diff that the pull request\'s changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.'
      )
      .optional(),
    line: z
      .number()
      .int()
      .describe(
        '**Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.'
      )
      .optional(),
    start_line: z
      .number()
      .int()
      .describe(
        '**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.'
      )
      .optional(),
    start_side: z
      .enum(['LEFT', 'RIGHT', 'side'])
      .describe(
        '**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.'
      )
      .optional(),
    in_reply_to: z
      .number()
      .int()
      .describe(
        'The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.'
      )
      .optional(),
    subject_type: z
      .enum(['line', 'file'])
      .describe('The level at which the comment is targeted.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCreateReviewCommentParams = z.infer<
    typeof PullsCreateReviewCommentParamsSchema
  >

  export type PullsCreateReviewCommentResponse = undefined

  export const PullsCreateReplyForReviewCommentParamsSchema = z.object({
    body: z.string().describe('The text of the review comment.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    comment_id: z
      .number()
      .int()
      .describe('The unique identifier of the comment.')
  })
  export type PullsCreateReplyForReviewCommentParams = z.infer<
    typeof PullsCreateReplyForReviewCommentParamsSchema
  >

  export type PullsCreateReplyForReviewCommentResponse = undefined

  export const PullsListCommitsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListCommitsParams = z.infer<
    typeof PullsListCommitsParamsSchema
  >

  export const PullsListCommitsResponseSchema = z.array(CommitSchema)
  export type PullsListCommitsResponse = z.infer<
    typeof PullsListCommitsResponseSchema
  >

  export const PullsListFilesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListFilesParams = z.infer<typeof PullsListFilesParamsSchema>

  export const PullsListFilesResponseSchema = z.array(DiffEntrySchema)
  export type PullsListFilesResponse = z.infer<
    typeof PullsListFilesResponseSchema
  >

  export const PullsCheckIfMergedParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCheckIfMergedParams = z.infer<
    typeof PullsCheckIfMergedParamsSchema
  >

  export type PullsCheckIfMergedResponse = undefined

  export const PullsMergeParamsSchema = z.object({
    commit_title: z
      .string()
      .describe('Title for the automatic commit message.')
      .optional(),
    commit_message: z
      .string()
      .describe('Extra detail to append to automatic commit message.')
      .optional(),
    sha: z
      .string()
      .describe('SHA that pull request head must match to allow merge.')
      .optional(),
    merge_method: z
      .enum(['merge', 'squash', 'rebase'])
      .describe('The merge method to use.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsMergeParams = z.infer<typeof PullsMergeParamsSchema>

  export const PullsMergeResponseSchema = PullRequestMergeResultSchema
  export type PullsMergeResponse = z.infer<typeof PullsMergeResponseSchema>

  export const PullsListRequestedReviewersParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsListRequestedReviewersParams = z.infer<
    typeof PullsListRequestedReviewersParamsSchema
  >

  export const PullsListRequestedReviewersResponseSchema =
    PullRequestReviewRequestSchema
  export type PullsListRequestedReviewersResponse = z.infer<
    typeof PullsListRequestedReviewersResponseSchema
  >

  export const PullsRequestReviewersParamsSchema = z
    .object({
      reviewers: z
        .array(z.string())
        .describe('An array of user `login`s that will be requested.')
        .optional(),
      team_reviewers: z
        .array(z.string())
        .describe('An array of team `slug`s that will be requested.')
        .optional(),
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      pull_number: z
        .number()
        .int()
        .describe('The number that identifies the pull request.')
    })
    .and(z.union([z.any(), z.any()]))
  export type PullsRequestReviewersParams = z.infer<
    typeof PullsRequestReviewersParamsSchema
  >

  export type PullsRequestReviewersResponse = undefined

  export const PullsRemoveRequestedReviewersParamsSchema = z.object({
    reviewers: z
      .array(z.string())
      .describe('An array of user `login`s that will be removed.'),
    team_reviewers: z
      .array(z.string())
      .describe('An array of team `slug`s that will be removed.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsRemoveRequestedReviewersParams = z.infer<
    typeof PullsRemoveRequestedReviewersParamsSchema
  >

  export const PullsRemoveRequestedReviewersResponseSchema =
    PullRequestSimpleSchema
  export type PullsRemoveRequestedReviewersResponse = z.infer<
    typeof PullsRemoveRequestedReviewersResponseSchema
  >

  export const PullsListReviewsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListReviewsParams = z.infer<
    typeof PullsListReviewsParamsSchema
  >

  export const PullsListReviewsResponseSchema = z.array(PullRequestReviewSchema)
  export type PullsListReviewsResponse = z.infer<
    typeof PullsListReviewsResponseSchema
  >

  export const PullsCreateReviewParamsSchema = z.object({
    commit_id: z
      .string()
      .describe(
        'The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.'
      )
      .optional(),
    body: z
      .string()
      .describe(
        '**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.'
      )
      .optional(),
    event: z
      .enum(['APPROVE', 'REQUEST_CHANGES', 'COMMENT'])
      .describe(
        'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.'
      )
      .optional(),
    comments: z
      .array(
        z.object({
          path: z
            .string()
            .describe(
              'The relative path to the file that necessitates a review comment.'
            ),
          position: z
            .number()
            .int()
            .describe(
              'The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.'
            )
            .optional(),
          body: z.string().describe('Text of the review comment.'),
          line: z.number().int().optional(),
          side: z.string().optional(),
          start_line: z.number().int().optional(),
          start_side: z.string().optional()
        })
      )
      .describe(
        'Use the following table to specify the location, destination, and contents of the draft review comment.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsCreateReviewParams = z.infer<
    typeof PullsCreateReviewParamsSchema
  >

  export const PullsCreateReviewResponseSchema = PullRequestReviewSchema
  export type PullsCreateReviewResponse = z.infer<
    typeof PullsCreateReviewResponseSchema
  >

  export const PullsGetReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsGetReviewParams = z.infer<typeof PullsGetReviewParamsSchema>

  export const PullsGetReviewResponseSchema = PullRequestReviewSchema
  export type PullsGetReviewResponse = z.infer<
    typeof PullsGetReviewResponseSchema
  >

  export const PullsUpdateReviewParamsSchema = z.object({
    body: z.string().describe('The body text of the pull request review.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsUpdateReviewParams = z.infer<
    typeof PullsUpdateReviewParamsSchema
  >

  export const PullsUpdateReviewResponseSchema = PullRequestReviewSchema
  export type PullsUpdateReviewResponse = z.infer<
    typeof PullsUpdateReviewResponseSchema
  >

  export const PullsDeletePendingReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsDeletePendingReviewParams = z.infer<
    typeof PullsDeletePendingReviewParamsSchema
  >

  export const PullsDeletePendingReviewResponseSchema = PullRequestReviewSchema
  export type PullsDeletePendingReviewResponse = z.infer<
    typeof PullsDeletePendingReviewResponseSchema
  >

  export const PullsListCommentsForReviewParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z
      .number()
      .int()
      .describe('The unique identifier of the review.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type PullsListCommentsForReviewParams = z.infer<
    typeof PullsListCommentsForReviewParamsSchema
  >

  export const PullsListCommentsForReviewResponseSchema =
    z.array(ReviewCommentSchema)
  export type PullsListCommentsForReviewResponse = z.infer<
    typeof PullsListCommentsForReviewResponseSchema
  >

  export const PullsDismissReviewParamsSchema = z.object({
    message: z
      .string()
      .describe('The message for the pull request review dismissal'),
    event: z.literal('DISMISS').optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsDismissReviewParams = z.infer<
    typeof PullsDismissReviewParamsSchema
  >

  export const PullsDismissReviewResponseSchema = PullRequestReviewSchema
  export type PullsDismissReviewResponse = z.infer<
    typeof PullsDismissReviewResponseSchema
  >

  export const PullsSubmitReviewParamsSchema = z.object({
    body: z
      .string()
      .describe('The body text of the pull request review')
      .optional(),
    event: z
      .enum(['APPROVE', 'REQUEST_CHANGES', 'COMMENT'])
      .describe(
        'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.'),
    review_id: z.number().int().describe('The unique identifier of the review.')
  })
  export type PullsSubmitReviewParams = z.infer<
    typeof PullsSubmitReviewParamsSchema
  >

  export const PullsSubmitReviewResponseSchema = PullRequestReviewSchema
  export type PullsSubmitReviewResponse = z.infer<
    typeof PullsSubmitReviewResponseSchema
  >

  export const PullsUpdateBranchParamsSchema = z.object({
    expected_head_sha: z
      .string()
      .describe(
        "The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/commits/commits#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    pull_number: z
      .number()
      .int()
      .describe('The number that identifies the pull request.')
  })
  export type PullsUpdateBranchParams = z.infer<
    typeof PullsUpdateBranchParamsSchema
  >

  export type PullsUpdateBranchResponse = undefined

  export const ReposGetReadmeParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetReadmeParams = z.infer<typeof ReposGetReadmeParamsSchema>

  export const ReposGetReadmeResponseSchema = ContentFileSchema
  export type ReposGetReadmeResponse = z.infer<
    typeof ReposGetReadmeResponseSchema
  >

  export const ReposGetReadmeInDirectoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    dir: z.string().describe('The alternate path to look for a README file'),
    ref: z
      .string()
      .describe(
        'The name of the commit/branch/tag. Default: the repositorys default branch.'
      )
      .optional()
  })
  export type ReposGetReadmeInDirectoryParams = z.infer<
    typeof ReposGetReadmeInDirectoryParamsSchema
  >

  export const ReposGetReadmeInDirectoryResponseSchema = ContentFileSchema
  export type ReposGetReadmeInDirectoryResponse = z.infer<
    typeof ReposGetReadmeInDirectoryResponseSchema
  >

  export const ReposListReleasesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListReleasesParams = z.infer<
    typeof ReposListReleasesParamsSchema
  >

  export const ReposListReleasesResponseSchema = z.array(ReleaseSchema)
  export type ReposListReleasesResponse = z.infer<
    typeof ReposListReleasesResponseSchema
  >

  export const ReposCreateReleaseParamsSchema = z.object({
    tag_name: z.string().describe('The name of the tag.'),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch."
      )
      .optional(),
    name: z.string().describe('The name of the release.').optional(),
    body: z
      .string()
      .describe('Text describing the contents of the tag.')
      .optional(),
    draft: z
      .boolean()
      .describe(
        '`true` to create a draft (unpublished) release, `false` to create a published one.'
      )
      .default(false),
    prerelease: z
      .boolean()
      .describe(
        '`true` to identify the release as a prerelease. `false` to identify the release as a full release.'
      )
      .default(false),
    discussion_category_name: z
      .string()
      .describe(
        'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
      )
      .optional(),
    generate_release_notes: z
      .boolean()
      .describe(
        'Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.'
      )
      .default(false),
    make_latest: z
      .enum(['true', 'false', 'legacy'])
      .describe(
        'Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.'
      )
      .default('true'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateReleaseParams = z.infer<
    typeof ReposCreateReleaseParamsSchema
  >

  export type ReposCreateReleaseResponse = undefined

  export const ReposGetReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposGetReleaseAssetParams = z.infer<
    typeof ReposGetReleaseAssetParamsSchema
  >

  export const ReposGetReleaseAssetResponseSchema = ReleaseAssetSchema
  export type ReposGetReleaseAssetResponse = z.infer<
    typeof ReposGetReleaseAssetResponseSchema
  >

  export const ReposDeleteReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposDeleteReleaseAssetParams = z.infer<
    typeof ReposDeleteReleaseAssetParamsSchema
  >

  export type ReposDeleteReleaseAssetResponse = undefined

  export const ReposUpdateReleaseAssetParamsSchema = z.object({
    name: z.string().describe('The file name of the asset.').optional(),
    label: z
      .string()
      .describe(
        'An alternate short description of the asset. Used in place of the filename.'
      )
      .optional(),
    state: z.string().optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    asset_id: z.number().int().describe('The unique identifier of the asset.')
  })
  export type ReposUpdateReleaseAssetParams = z.infer<
    typeof ReposUpdateReleaseAssetParamsSchema
  >

  export const ReposUpdateReleaseAssetResponseSchema = ReleaseAssetSchema
  export type ReposUpdateReleaseAssetResponse = z.infer<
    typeof ReposUpdateReleaseAssetResponseSchema
  >

  export const ReposGenerateReleaseNotesParamsSchema = z.object({
    tag_name: z
      .string()
      .describe(
        'The tag name for the release. This can be an existing tag or a new one.'
      ),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists."
      )
      .optional(),
    previous_tag_name: z
      .string()
      .describe(
        'The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.'
      )
      .optional(),
    configuration_file_path: z
      .string()
      .describe(
        "Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used."
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGenerateReleaseNotesParams = z.infer<
    typeof ReposGenerateReleaseNotesParamsSchema
  >

  export const ReposGenerateReleaseNotesResponseSchema =
    ReleaseNotesContentSchema
  export type ReposGenerateReleaseNotesResponse = z.infer<
    typeof ReposGenerateReleaseNotesResponseSchema
  >

  export const ReposGetLatestReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetLatestReleaseParams = z.infer<
    typeof ReposGetLatestReleaseParamsSchema
  >

  export const ReposGetLatestReleaseResponseSchema = ReleaseSchema
  export type ReposGetLatestReleaseResponse = z.infer<
    typeof ReposGetLatestReleaseResponseSchema
  >

  export const ReposGetReleaseByTagParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag: z.string().describe('tag parameter')
  })
  export type ReposGetReleaseByTagParams = z.infer<
    typeof ReposGetReleaseByTagParamsSchema
  >

  export const ReposGetReleaseByTagResponseSchema = ReleaseSchema
  export type ReposGetReleaseByTagResponse = z.infer<
    typeof ReposGetReleaseByTagResponseSchema
  >

  export const ReposGetReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposGetReleaseParams = z.infer<
    typeof ReposGetReleaseParamsSchema
  >

  export const ReposGetReleaseResponseSchema = ReleaseSchema
  export type ReposGetReleaseResponse = z.infer<
    typeof ReposGetReleaseResponseSchema
  >

  export const ReposDeleteReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposDeleteReleaseParams = z.infer<
    typeof ReposDeleteReleaseParamsSchema
  >

  export type ReposDeleteReleaseResponse = undefined

  export const ReposUpdateReleaseParamsSchema = z.object({
    tag_name: z.string().describe('The name of the tag.').optional(),
    target_commitish: z
      .string()
      .describe(
        "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch."
      )
      .optional(),
    name: z.string().describe('The name of the release.').optional(),
    body: z
      .string()
      .describe('Text describing the contents of the tag.')
      .optional(),
    draft: z
      .boolean()
      .describe(
        '`true` makes the release a draft, and `false` publishes the release.'
      )
      .optional(),
    prerelease: z
      .boolean()
      .describe(
        '`true` to identify the release as a prerelease, `false` to identify the release as a full release.'
      )
      .optional(),
    make_latest: z
      .enum(['true', 'false', 'legacy'])
      .describe(
        'Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.'
      )
      .default('true'),
    discussion_category_name: z
      .string()
      .describe(
        'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReposUpdateReleaseParams = z.infer<
    typeof ReposUpdateReleaseParamsSchema
  >

  export const ReposUpdateReleaseResponseSchema = ReleaseSchema
  export type ReposUpdateReleaseResponse = z.infer<
    typeof ReposUpdateReleaseResponseSchema
  >

  export const ReposListReleaseAssetsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListReleaseAssetsParams = z.infer<
    typeof ReposListReleaseAssetsParamsSchema
  >

  export const ReposListReleaseAssetsResponseSchema =
    z.array(ReleaseAssetSchema)
  export type ReposListReleaseAssetsResponse = z.infer<
    typeof ReposListReleaseAssetsResponseSchema
  >

  export const ReposUploadReleaseAssetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    name: z.string(),
    label: z.string().optional()
  })
  export type ReposUploadReleaseAssetParams = z.infer<
    typeof ReposUploadReleaseAssetParamsSchema
  >

  export type ReposUploadReleaseAssetResponse = undefined

  export const ReactionsListForReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    content: z
      .enum(['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes'])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForReleaseParams = z.infer<
    typeof ReactionsListForReleaseParamsSchema
  >

  export const ReactionsListForReleaseResponseSchema = z.array(ReactionSchema)
  export type ReactionsListForReleaseResponse = z.infer<
    typeof ReactionsListForReleaseResponseSchema
  >

  export const ReactionsCreateForReleaseParamsSchema = z.object({
    content: z
      .enum(['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes'])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.')
  })
  export type ReactionsCreateForReleaseParams = z.infer<
    typeof ReactionsCreateForReleaseParamsSchema
  >

  export const ReactionsCreateForReleaseResponseSchema = ReactionSchema
  export type ReactionsCreateForReleaseResponse = z.infer<
    typeof ReactionsCreateForReleaseResponseSchema
  >

  export const ReactionsDeleteForReleaseParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    release_id: z
      .number()
      .int()
      .describe('The unique identifier of the release.'),
    reaction_id: z
      .number()
      .int()
      .describe('The unique identifier of the reaction.')
  })
  export type ReactionsDeleteForReleaseParams = z.infer<
    typeof ReactionsDeleteForReleaseParamsSchema
  >

  export type ReactionsDeleteForReleaseResponse = undefined

  export const ReposGetBranchRulesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    branch: z
      .string()
      .describe(
        'The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetBranchRulesParams = z.infer<
    typeof ReposGetBranchRulesParamsSchema
  >

  export const ReposGetBranchRulesResponseSchema = z.array(
    RepositoryRuleDetailedSchema
  )
  export type ReposGetBranchRulesResponse = z.infer<
    typeof ReposGetBranchRulesResponseSchema
  >

  export const ReposGetRepoRulesetsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    includes_parents: z
      .boolean()
      .describe(
        'Include rulesets configured at higher levels that apply to this repository'
      )
      .default(true),
    targets: z
      .string()
      .describe(
        'A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n'
      )
      .optional()
  })
  export type ReposGetRepoRulesetsParams = z.infer<
    typeof ReposGetRepoRulesetsParamsSchema
  >

  export const ReposGetRepoRulesetsResponseSchema = z.array(
    RepositoryRulesetSchema
  )
  export type ReposGetRepoRulesetsResponse = z.infer<
    typeof ReposGetRepoRulesetsResponseSchema
  >

  export const ReposCreateRepoRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.'),
    target: z
      .enum(['branch', 'tag', 'push'])
      .describe('The target of the ruleset')
      .default('branch'),
    enforcement: RepositoryRuleEnforcementSchema,
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: RepositoryRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateRepoRulesetParams = z.infer<
    typeof ReposCreateRepoRulesetParamsSchema
  >

  export type ReposCreateRepoRulesetResponse = undefined

  export const ReposGetRepoRuleSuitesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z
      .string()
      .describe(
        'The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.'
      )
      .optional(),
    time_period: z
      .enum(['hour', 'day', 'week', 'month'])
      .describe(
        'The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).'
      )
      .default('day'),
    actor_name: z
      .string()
      .describe(
        'The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.'
      )
      .optional(),
    rule_suite_result: z
      .enum(['pass', 'fail', 'bypass', 'all'])
      .describe(
        'The rule results to filter on. When specified, only suites with this result will be returned.'
      )
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetRepoRuleSuitesParams = z.infer<
    typeof ReposGetRepoRuleSuitesParamsSchema
  >

  export const ReposGetRepoRuleSuitesResponseSchema = RuleSuitesSchema
  export type ReposGetRepoRuleSuitesResponse = z.infer<
    typeof ReposGetRepoRuleSuitesResponseSchema
  >

  export const ReposGetRepoRuleSuiteParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    rule_suite_id: z
      .number()
      .int()
      .describe(
        'The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.'
      )
  })
  export type ReposGetRepoRuleSuiteParams = z.infer<
    typeof ReposGetRepoRuleSuiteParamsSchema
  >

  export const ReposGetRepoRuleSuiteResponseSchema = RuleSuiteSchema
  export type ReposGetRepoRuleSuiteResponse = z.infer<
    typeof ReposGetRepoRuleSuiteResponseSchema
  >

  export const ReposGetRepoRulesetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    includes_parents: z
      .boolean()
      .describe(
        'Include rulesets configured at higher levels that apply to this repository'
      )
      .default(true)
  })
  export type ReposGetRepoRulesetParams = z.infer<
    typeof ReposGetRepoRulesetParamsSchema
  >

  export const ReposGetRepoRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposGetRepoRulesetResponse = z.infer<
    typeof ReposGetRepoRulesetResponseSchema
  >

  export const ReposUpdateRepoRulesetParamsSchema = z.object({
    name: z.string().describe('The name of the ruleset.').optional(),
    target: z
      .enum(['branch', 'tag', 'push'])
      .describe('The target of the ruleset')
      .optional(),
    enforcement: RepositoryRuleEnforcementSchema.optional(),
    bypass_actors: z
      .array(RepositoryRulesetBypassActorSchema)
      .describe('The actors that can bypass the rules in this ruleset')
      .optional(),
    conditions: RepositoryRulesetConditionsSchema.optional(),
    rules: z
      .array(RepositoryRuleSchema)
      .describe('An array of rules within the ruleset.')
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposUpdateRepoRulesetParams = z.infer<
    typeof ReposUpdateRepoRulesetParamsSchema
  >

  export const ReposUpdateRepoRulesetResponseSchema = RepositoryRulesetSchema
  export type ReposUpdateRepoRulesetResponse = z.infer<
    typeof ReposUpdateRepoRulesetResponseSchema
  >

  export const ReposDeleteRepoRulesetParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.')
  })
  export type ReposDeleteRepoRulesetParams = z.infer<
    typeof ReposDeleteRepoRulesetParamsSchema
  >

  export type ReposDeleteRepoRulesetResponse = undefined

  export const ReposGetRepoRulesetHistoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposGetRepoRulesetHistoryParams = z.infer<
    typeof ReposGetRepoRulesetHistoryParamsSchema
  >

  export const ReposGetRepoRulesetHistoryResponseSchema =
    z.array(RulesetVersionSchema)
  export type ReposGetRepoRulesetHistoryResponse = z.infer<
    typeof ReposGetRepoRulesetHistoryResponseSchema
  >

  export const ReposGetRepoRulesetVersionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ruleset_id: z.number().int().describe('The ID of the ruleset.'),
    version_id: z.number().int().describe('The ID of the version')
  })
  export type ReposGetRepoRulesetVersionParams = z.infer<
    typeof ReposGetRepoRulesetVersionParamsSchema
  >

  export const ReposGetRepoRulesetVersionResponseSchema =
    RulesetVersionWithStateSchema
  export type ReposGetRepoRulesetVersionResponse = z.infer<
    typeof ReposGetRepoRulesetVersionResponseSchema
  >

  export const SecretScanningListAlertsForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    state: z
      .enum(['open', 'resolved'])
      .describe(
        'Set to `open` or `resolved` to only list secret scanning alerts in a specific state.'
      )
      .optional(),
    secret_type: z
      .string()
      .describe(
        'A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/enterprise-cloud@latest/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.'
      )
      .optional(),
    resolution: z
      .string()
      .describe(
        'A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.'
      )
      .optional(),
    validity: z
      .string()
      .describe(
        'A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.'
      )
      .optional(),
    is_publicly_leaked: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.'
      )
      .default(false),
    is_multi_repo: z
      .boolean()
      .describe(
        'A boolean value representing whether or not to filter alerts by the multi-repo tag being present.'
      )
      .default(false)
  })
  export type SecretScanningListAlertsForRepoParams = z.infer<
    typeof SecretScanningListAlertsForRepoParamsSchema
  >

  export const SecretScanningListAlertsForRepoResponseSchema = z.array(
    SecretScanningAlertSchema
  )
  export type SecretScanningListAlertsForRepoResponse = z.infer<
    typeof SecretScanningListAlertsForRepoResponseSchema
  >

  export const SecretScanningGetAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type SecretScanningGetAlertParams = z.infer<
    typeof SecretScanningGetAlertParamsSchema
  >

  export const SecretScanningGetAlertResponseSchema = SecretScanningAlertSchema
  export type SecretScanningGetAlertResponse = z.infer<
    typeof SecretScanningGetAlertResponseSchema
  >

  export const SecretScanningUpdateAlertParamsSchema = z.object({
    state: SecretScanningAlertStateSchema,
    resolution: SecretScanningAlertResolutionSchema.optional(),
    resolution_comment: SecretScanningAlertResolutionCommentSchema.optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      )
  })
  export type SecretScanningUpdateAlertParams = z.infer<
    typeof SecretScanningUpdateAlertParamsSchema
  >

  export const SecretScanningUpdateAlertResponseSchema =
    SecretScanningAlertSchema
  export type SecretScanningUpdateAlertResponse = z.infer<
    typeof SecretScanningUpdateAlertResponseSchema
  >

  export const SecretScanningListLocationsForAlertParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    alert_number: z
      .any()
      .describe(
        'The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type SecretScanningListLocationsForAlertParams = z.infer<
    typeof SecretScanningListLocationsForAlertParamsSchema
  >

  export const SecretScanningListLocationsForAlertResponseSchema = z
    .array(SecretScanningLocationSchema)
    .describe('List of locations where the secret was detected')
  export type SecretScanningListLocationsForAlertResponse = z.infer<
    typeof SecretScanningListLocationsForAlertResponseSchema
  >

  export const SecretScanningCreatePushProtectionBypassParamsSchema = z.object({
    reason: SecretScanningPushProtectionBypassReasonSchema,
    placeholder_id: SecretScanningPushProtectionBypassPlaceholderIdSchema,
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type SecretScanningCreatePushProtectionBypassParams = z.infer<
    typeof SecretScanningCreatePushProtectionBypassParamsSchema
  >

  export const SecretScanningCreatePushProtectionBypassResponseSchema =
    SecretScanningPushProtectionBypassSchema
  export type SecretScanningCreatePushProtectionBypassResponse = z.infer<
    typeof SecretScanningCreatePushProtectionBypassResponseSchema
  >

  export const SecretScanningGetScanHistoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type SecretScanningGetScanHistoryParams = z.infer<
    typeof SecretScanningGetScanHistoryParamsSchema
  >

  export const SecretScanningGetScanHistoryResponseSchema =
    SecretScanningScanHistorySchema
  export type SecretScanningGetScanHistoryResponse = z.infer<
    typeof SecretScanningGetScanHistoryResponseSchema
  >

  export const SecurityAdvisoriesListRepositoryAdvisoriesParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      sort: z
        .enum(['created', 'updated', 'published'])
        .describe('The property to sort the results by.')
        .default('created'),
      before: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      after: z
        .string()
        .describe(
          'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .gte(1)
        .lte(100)
        .describe(
          'The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['triage', 'draft', 'published', 'closed'])
        .describe(
          'Filter by state of the repository advisories. Only advisories of this state will be returned.'
        )
        .optional()
    })
  export type SecurityAdvisoriesListRepositoryAdvisoriesParams = z.infer<
    typeof SecurityAdvisoriesListRepositoryAdvisoriesParamsSchema
  >

  export const SecurityAdvisoriesListRepositoryAdvisoriesResponseSchema =
    z.array(RepositoryAdvisorySchema)
  export type SecurityAdvisoriesListRepositoryAdvisoriesResponse = z.infer<
    typeof SecurityAdvisoriesListRepositoryAdvisoriesResponseSchema
  >

  export const SecurityAdvisoriesCreateRepositoryAdvisoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
    .merge(RepositoryAdvisoryCreateSchema)
  export type SecurityAdvisoriesCreateRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesCreateRepositoryAdvisoryParamsSchema
  >

  export type SecurityAdvisoriesCreateRepositoryAdvisoryResponse = undefined

  export const SecurityAdvisoriesCreatePrivateVulnerabilityReportParamsSchema =
    z
      .object({
        owner: z
          .string()
          .describe(
            'The account owner of the repository. The name is not case sensitive.'
          ),
        repo: z
          .string()
          .describe(
            'The name of the repository without the `.git` extension. The name is not case sensitive.'
          )
      })
      .merge(PrivateVulnerabilityReportCreateSchema)
  export type SecurityAdvisoriesCreatePrivateVulnerabilityReportParams =
    z.infer<
      typeof SecurityAdvisoriesCreatePrivateVulnerabilityReportParamsSchema
    >

  export type SecurityAdvisoriesCreatePrivateVulnerabilityReportResponse =
    undefined

  export const SecurityAdvisoriesGetRepositoryAdvisoryParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesGetRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesGetRepositoryAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesGetRepositoryAdvisoryResponseSchema =
    RepositoryAdvisorySchema
  export type SecurityAdvisoriesGetRepositoryAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesGetRepositoryAdvisoryResponseSchema
  >

  export const SecurityAdvisoriesUpdateRepositoryAdvisoryParamsSchema = z
    .object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ghsa_id: z
        .string()
        .describe(
          'The GHSA (GitHub Security Advisory) identifier of the advisory.'
        )
    })
    .merge(RepositoryAdvisoryUpdateSchema)
  export type SecurityAdvisoriesUpdateRepositoryAdvisoryParams = z.infer<
    typeof SecurityAdvisoriesUpdateRepositoryAdvisoryParamsSchema
  >

  export const SecurityAdvisoriesUpdateRepositoryAdvisoryResponseSchema =
    RepositoryAdvisorySchema
  export type SecurityAdvisoriesUpdateRepositoryAdvisoryResponse = z.infer<
    typeof SecurityAdvisoriesUpdateRepositoryAdvisoryResponseSchema
  >

  export const SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        ),
      ghsa_id: z
        .string()
        .describe(
          'The GHSA (GitHub Security Advisory) identifier of the advisory.'
        )
    })
  export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParams =
    z.infer<
      typeof SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamsSchema
    >

  export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponse =
    undefined

  export const SecurityAdvisoriesCreateForkParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ghsa_id: z
      .string()
      .describe(
        'The GHSA (GitHub Security Advisory) identifier of the advisory.'
      )
  })
  export type SecurityAdvisoriesCreateForkParams = z.infer<
    typeof SecurityAdvisoriesCreateForkParamsSchema
  >

  export type SecurityAdvisoriesCreateForkResponse = undefined

  export const ActivityListStargazersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListStargazersForRepoParams = z.infer<
    typeof ActivityListStargazersForRepoParamsSchema
  >

  export const ActivityListStargazersForRepoResponseSchema = z.union([
    z.array(SimpleUserSchema),
    z.array(StargazerSchema)
  ])
  export type ActivityListStargazersForRepoResponse = z.infer<
    typeof ActivityListStargazersForRepoResponseSchema
  >

  export const ReposGetCodeFrequencyStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCodeFrequencyStatsParams = z.infer<
    typeof ReposGetCodeFrequencyStatsParamsSchema
  >

  export const ReposGetCodeFrequencyStatsResponseSchema = z.array(
    CodeFrequencyStatSchema
  )
  export type ReposGetCodeFrequencyStatsResponse = z.infer<
    typeof ReposGetCodeFrequencyStatsResponseSchema
  >

  export const ReposGetCommitActivityStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetCommitActivityStatsParams = z.infer<
    typeof ReposGetCommitActivityStatsParamsSchema
  >

  export const ReposGetCommitActivityStatsResponseSchema =
    z.array(CommitActivitySchema)
  export type ReposGetCommitActivityStatsResponse = z.infer<
    typeof ReposGetCommitActivityStatsResponseSchema
  >

  export const ReposGetContributorsStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetContributorsStatsParams = z.infer<
    typeof ReposGetContributorsStatsParamsSchema
  >

  export const ReposGetContributorsStatsResponseSchema = z.array(
    ContributorActivitySchema
  )
  export type ReposGetContributorsStatsResponse = z.infer<
    typeof ReposGetContributorsStatsResponseSchema
  >

  export const ReposGetParticipationStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetParticipationStatsParams = z.infer<
    typeof ReposGetParticipationStatsParamsSchema
  >

  export const ReposGetParticipationStatsResponseSchema =
    ParticipationStatsSchema
  export type ReposGetParticipationStatsResponse = z.infer<
    typeof ReposGetParticipationStatsResponseSchema
  >

  export const ReposGetPunchCardStatsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetPunchCardStatsParams = z.infer<
    typeof ReposGetPunchCardStatsParamsSchema
  >

  export const ReposGetPunchCardStatsResponseSchema = z.array(
    CodeFrequencyStatSchema
  )
  export type ReposGetPunchCardStatsResponse = z.infer<
    typeof ReposGetPunchCardStatsResponseSchema
  >

  export const ReposCreateCommitStatusParamsSchema = z.object({
    state: z
      .enum(['error', 'failure', 'pending', 'success'])
      .describe('The state of the status.'),
    target_url: z
      .string()
      .describe(
        'The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`'
      )
      .optional(),
    description: z
      .string()
      .describe('A short description of the status.')
      .optional(),
    context: z
      .string()
      .describe(
        'A string label to differentiate this status from the status of other systems. This field is case-insensitive.'
      )
      .default('default'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    sha: z.string()
  })
  export type ReposCreateCommitStatusParams = z.infer<
    typeof ReposCreateCommitStatusParamsSchema
  >

  export type ReposCreateCommitStatusResponse = undefined

  export const ActivityListWatchersForRepoParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListWatchersForRepoParams = z.infer<
    typeof ActivityListWatchersForRepoParamsSchema
  >

  export const ActivityListWatchersForRepoResponseSchema =
    z.array(SimpleUserSchema)
  export type ActivityListWatchersForRepoResponse = z.infer<
    typeof ActivityListWatchersForRepoResponseSchema
  >

  export const ActivityGetRepoSubscriptionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityGetRepoSubscriptionParams = z.infer<
    typeof ActivityGetRepoSubscriptionParamsSchema
  >

  export const ActivityGetRepoSubscriptionResponseSchema =
    RepositorySubscriptionSchema
  export type ActivityGetRepoSubscriptionResponse = z.infer<
    typeof ActivityGetRepoSubscriptionResponseSchema
  >

  export const ActivitySetRepoSubscriptionParamsSchema = z.object({
    subscribed: z
      .boolean()
      .describe(
        'Determines if notifications should be received from this repository.'
      )
      .optional(),
    ignored: z
      .boolean()
      .describe(
        'Determines if all notifications should be blocked from this repository.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivitySetRepoSubscriptionParams = z.infer<
    typeof ActivitySetRepoSubscriptionParamsSchema
  >

  export const ActivitySetRepoSubscriptionResponseSchema =
    RepositorySubscriptionSchema
  export type ActivitySetRepoSubscriptionResponse = z.infer<
    typeof ActivitySetRepoSubscriptionResponseSchema
  >

  export const ActivityDeleteRepoSubscriptionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityDeleteRepoSubscriptionParams = z.infer<
    typeof ActivityDeleteRepoSubscriptionParamsSchema
  >

  export type ActivityDeleteRepoSubscriptionResponse = undefined

  export const ReposListTagsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListTagsParams = z.infer<typeof ReposListTagsParamsSchema>

  export const ReposListTagsResponseSchema = z.array(TagSchema)
  export type ReposListTagsResponse = z.infer<
    typeof ReposListTagsResponseSchema
  >

  export const ReposListTagProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposListTagProtectionParams = z.infer<
    typeof ReposListTagProtectionParamsSchema
  >

  export const ReposListTagProtectionResponseSchema =
    z.array(TagProtectionSchema)
  export type ReposListTagProtectionResponse = z.infer<
    typeof ReposListTagProtectionResponseSchema
  >

  export const ReposCreateTagProtectionParamsSchema = z.object({
    pattern: z
      .string()
      .describe(
        'An optional glob pattern to match against when enforcing tag protection.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateTagProtectionParams = z.infer<
    typeof ReposCreateTagProtectionParamsSchema
  >

  export type ReposCreateTagProtectionResponse = undefined

  export const ReposDeleteTagProtectionParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    tag_protection_id: z
      .number()
      .int()
      .describe('The unique identifier of the tag protection.')
  })
  export type ReposDeleteTagProtectionParams = z.infer<
    typeof ReposDeleteTagProtectionParamsSchema
  >

  export type ReposDeleteTagProtectionResponse = undefined

  export const ReposDownloadTarballArchiveParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z.string()
  })
  export type ReposDownloadTarballArchiveParams = z.infer<
    typeof ReposDownloadTarballArchiveParamsSchema
  >

  export type ReposDownloadTarballArchiveResponse = undefined

  export const ReposListTeamsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListTeamsParams = z.infer<typeof ReposListTeamsParamsSchema>

  export const ReposListTeamsResponseSchema = z.array(TeamSchema)
  export type ReposListTeamsResponse = z.infer<
    typeof ReposListTeamsResponseSchema
  >

  export const ReposGetAllTopicsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type ReposGetAllTopicsParams = z.infer<
    typeof ReposGetAllTopicsParamsSchema
  >

  export const ReposGetAllTopicsResponseSchema = TopicSchema
  export type ReposGetAllTopicsResponse = z.infer<
    typeof ReposGetAllTopicsResponseSchema
  >

  export const ReposReplaceAllTopicsParamsSchema = z.object({
    names: z
      .array(z.string())
      .describe(
        'An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.'
      ),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposReplaceAllTopicsParams = z.infer<
    typeof ReposReplaceAllTopicsParamsSchema
  >

  export const ReposReplaceAllTopicsResponseSchema = TopicSchema
  export type ReposReplaceAllTopicsResponse = z.infer<
    typeof ReposReplaceAllTopicsResponseSchema
  >

  export const ReposGetClonesParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per: z
      .enum(['day', 'week'])
      .describe('The time frame to display results for.')
      .default('day')
  })
  export type ReposGetClonesParams = z.infer<typeof ReposGetClonesParamsSchema>

  export const ReposGetClonesResponseSchema = CloneTrafficSchema
  export type ReposGetClonesResponse = z.infer<
    typeof ReposGetClonesResponseSchema
  >

  export const ReposGetTopPathsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetTopPathsParams = z.infer<
    typeof ReposGetTopPathsParamsSchema
  >

  export const ReposGetTopPathsResponseSchema = z.array(ContentTrafficSchema)
  export type ReposGetTopPathsResponse = z.infer<
    typeof ReposGetTopPathsResponseSchema
  >

  export const ReposGetTopReferrersParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposGetTopReferrersParams = z.infer<
    typeof ReposGetTopReferrersParamsSchema
  >

  export const ReposGetTopReferrersResponseSchema = z.array(
    ReferrerTrafficSchema
  )
  export type ReposGetTopReferrersResponse = z.infer<
    typeof ReposGetTopReferrersResponseSchema
  >

  export const ReposGetViewsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    per: z
      .enum(['day', 'week'])
      .describe('The time frame to display results for.')
      .default('day')
  })
  export type ReposGetViewsParams = z.infer<typeof ReposGetViewsParamsSchema>

  export const ReposGetViewsResponseSchema = ViewTrafficSchema
  export type ReposGetViewsResponse = z.infer<
    typeof ReposGetViewsResponseSchema
  >

  export const ReposTransferParamsSchema = z.object({
    new_owner: z
      .string()
      .describe(
        'The username or organization name the repository will be transferred to.'
      ),
    new_name: z
      .string()
      .describe('The new name to be given to the repository.')
      .optional(),
    team_ids: z
      .array(z.number().int())
      .describe(
        'ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.'
      )
      .optional(),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposTransferParams = z.infer<typeof ReposTransferParamsSchema>

  export type ReposTransferResponse = undefined

  export const ReposCheckVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCheckVulnerabilityAlertsParams = z.infer<
    typeof ReposCheckVulnerabilityAlertsParamsSchema
  >

  export type ReposCheckVulnerabilityAlertsResponse = undefined

  export const ReposEnableVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposEnableVulnerabilityAlertsParams = z.infer<
    typeof ReposEnableVulnerabilityAlertsParamsSchema
  >

  export type ReposEnableVulnerabilityAlertsResponse = undefined

  export const ReposDisableVulnerabilityAlertsParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposDisableVulnerabilityAlertsParams = z.infer<
    typeof ReposDisableVulnerabilityAlertsParamsSchema
  >

  export type ReposDisableVulnerabilityAlertsResponse = undefined

  export const ReposDownloadZipballArchiveParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      ),
    ref: z.string()
  })
  export type ReposDownloadZipballArchiveParams = z.infer<
    typeof ReposDownloadZipballArchiveParamsSchema
  >

  export type ReposDownloadZipballArchiveResponse = undefined

  export const ReposCreateUsingTemplateParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.'
      )
      .optional(),
    name: z.string().describe('The name of the new repository.'),
    description: z
      .string()
      .describe('A short description of the new repository.')
      .optional(),
    include_all_branches: z
      .boolean()
      .describe(
        'Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.'
      )
      .default(false),
    private: z
      .boolean()
      .describe(
        'Either `true` to create a new private repository or `false` to create a new public one.'
      )
      .default(false),
    template_owner: z
      .string()
      .describe(
        'The account owner of the template repository. The name is not case sensitive.'
      ),
    template_repo: z
      .string()
      .describe(
        'The name of the template repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ReposCreateUsingTemplateParams = z.infer<
    typeof ReposCreateUsingTemplateParamsSchema
  >

  export type ReposCreateUsingTemplateResponse = undefined

  export const ReposListPublicParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe(
        'A repository ID. Only return repositories with an ID greater than this ID.'
      )
      .optional()
  })
  export type ReposListPublicParams = z.infer<
    typeof ReposListPublicParamsSchema
  >

  export const ReposListPublicResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListPublicResponse = z.infer<
    typeof ReposListPublicResponseSchema
  >

  export const SearchCodeParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)" for a detailed list of qualifiers.'
      ),
    sort: z
      .literal('indexed')
      .describe(
        '**This field is closing down.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        '**This field is closing down.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. '
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchCodeParams = z.infer<typeof SearchCodeParamsSchema>

  export const SearchCodeResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(CodeSearchResultItemSchema)
  })
  export type SearchCodeResponse = z.infer<typeof SearchCodeResponseSchema>

  export const SearchCommitsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['author-date', 'committer-date'])
      .describe(
        'Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchCommitsParams = z.infer<typeof SearchCommitsParamsSchema>

  export const SearchCommitsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(CommitSearchResultItemSchema)
  })
  export type SearchCommitsResponse = z.infer<
    typeof SearchCommitsResponseSchema
  >

  export const SearchIssuesAndPullRequestsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum([
        'comments',
        'reactions',
        'reactions-+1',
        'reactions--1',
        'reactions-smile',
        'reactions-thinking_face',
        'reactions-heart',
        'reactions-tada',
        'interactions',
        'created',
        'updated'
      ])
      .describe(
        'Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    advanced_search: z
      .string()
      .describe(
        'Set to `true` to use advanced search.\nExample: `http://api.github.com/search/issues?q={query}&advanced_search=true`'
      )
      .optional()
  })
  export type SearchIssuesAndPullRequestsParams = z.infer<
    typeof SearchIssuesAndPullRequestsParamsSchema
  >

  export const SearchIssuesAndPullRequestsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(IssueSearchResultItemSchema)
  })
  export type SearchIssuesAndPullRequestsResponse = z.infer<
    typeof SearchIssuesAndPullRequestsResponseSchema
  >

  export const SearchLabelsParamsSchema = z.object({
    repository_id: z.number().int().describe('The id of the repository.'),
    q: z
      .string()
      .describe(
        'The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).'
      ),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchLabelsParams = z.infer<typeof SearchLabelsParamsSchema>

  export const SearchLabelsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(LabelSearchResultItemSchema)
  })
  export type SearchLabelsResponse = z.infer<typeof SearchLabelsResponseSchema>

  export const SearchReposParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['stars', 'forks', 'help-wanted-issues', 'updated'])
      .describe(
        'Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchReposParams = z.infer<typeof SearchReposParamsSchema>

  export const SearchReposResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(RepoSearchResultItemSchema)
  })
  export type SearchReposResponse = z.infer<typeof SearchReposResponseSchema>

  export const SearchTopicsParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).'
      ),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchTopicsParams = z.infer<typeof SearchTopicsParamsSchema>

  export const SearchTopicsResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(TopicSearchResultItemSchema)
  })
  export type SearchTopicsResponse = z.infer<typeof SearchTopicsResponseSchema>

  export const SearchUsersParamsSchema = z.object({
    q: z
      .string()
      .describe(
        'The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)" for a detailed list of qualifiers.'
      ),
    sort: z
      .enum(['followers', 'repositories', 'joined'])
      .describe(
        'Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)'
      )
      .optional(),
    order: z
      .enum(['desc', 'asc'])
      .describe(
        'Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.'
      )
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type SearchUsersParams = z.infer<typeof SearchUsersParamsSchema>

  export const SearchUsersResponseSchema = z.object({
    total_count: z.number().int(),
    incomplete_results: z.boolean(),
    items: z.array(UserSearchResultItemSchema)
  })
  export type SearchUsersResponse = z.infer<typeof SearchUsersResponseSchema>

  export const TeamsGetLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsGetLegacyParams = z.infer<typeof TeamsGetLegacyParamsSchema>

  export const TeamsGetLegacyResponseSchema = TeamFullSchema
  export type TeamsGetLegacyResponse = z.infer<
    typeof TeamsGetLegacyResponseSchema
  >

  export const TeamsDeleteLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsDeleteLegacyParams = z.infer<
    typeof TeamsDeleteLegacyParamsSchema
  >

  export type TeamsDeleteLegacyResponse = undefined

  export const TeamsUpdateLegacyParamsSchema = z.object({
    name: z.string().describe('The name of the team.'),
    description: z.string().describe('The description of the team.').optional(),
    privacy: z
      .enum(['secret', 'closed'])
      .describe(
        'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.'
      )
      .optional(),
    notification_setting: z
      .enum(['notifications_enabled', 'notifications_disabled'])
      .describe(
        'The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.'
      )
      .optional(),
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        '**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.'
      )
      .default('pull'),
    parent_team_id: z
      .number()
      .int()
      .describe('The ID of a team to set as the parent team.')
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsUpdateLegacyParams = z.infer<
    typeof TeamsUpdateLegacyParamsSchema
  >

  export const TeamsUpdateLegacyResponseSchema = TeamFullSchema
  export type TeamsUpdateLegacyResponse = z.infer<
    typeof TeamsUpdateLegacyResponseSchema
  >

  export const TeamsListDiscussionsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionsLegacyParams = z.infer<
    typeof TeamsListDiscussionsLegacyParamsSchema
  >

  export const TeamsListDiscussionsLegacyResponseSchema =
    z.array(TeamDiscussionSchema)
  export type TeamsListDiscussionsLegacyResponse = z.infer<
    typeof TeamsListDiscussionsLegacyResponseSchema
  >

  export const TeamsCreateDiscussionLegacyParamsSchema = z.object({
    title: z.string().describe("The discussion post's title."),
    body: z.string().describe("The discussion post's body text."),
    private: z
      .boolean()
      .describe(
        'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.'
      )
      .default(false),
    team_id: z.number().int().describe('The unique identifier of the team.')
  })
  export type TeamsCreateDiscussionLegacyParams = z.infer<
    typeof TeamsCreateDiscussionLegacyParamsSchema
  >

  export type TeamsCreateDiscussionLegacyResponse = undefined

  export const TeamsGetDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsGetDiscussionLegacyParams = z.infer<
    typeof TeamsGetDiscussionLegacyParamsSchema
  >

  export const TeamsGetDiscussionLegacyResponseSchema = TeamDiscussionSchema
  export type TeamsGetDiscussionLegacyResponse = z.infer<
    typeof TeamsGetDiscussionLegacyResponseSchema
  >

  export const TeamsDeleteDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsDeleteDiscussionLegacyParams = z.infer<
    typeof TeamsDeleteDiscussionLegacyParamsSchema
  >

  export type TeamsDeleteDiscussionLegacyResponse = undefined

  export const TeamsUpdateDiscussionLegacyParamsSchema = z.object({
    title: z.string().describe("The discussion post's title.").optional(),
    body: z.string().describe("The discussion post's body text.").optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsUpdateDiscussionLegacyParams = z.infer<
    typeof TeamsUpdateDiscussionLegacyParamsSchema
  >

  export const TeamsUpdateDiscussionLegacyResponseSchema = TeamDiscussionSchema
  export type TeamsUpdateDiscussionLegacyResponse = z.infer<
    typeof TeamsUpdateDiscussionLegacyResponseSchema
  >

  export const TeamsListDiscussionCommentsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListDiscussionCommentsLegacyParams = z.infer<
    typeof TeamsListDiscussionCommentsLegacyParamsSchema
  >

  export const TeamsListDiscussionCommentsLegacyResponseSchema = z.array(
    TeamDiscussionCommentSchema
  )
  export type TeamsListDiscussionCommentsLegacyResponse = z.infer<
    typeof TeamsListDiscussionCommentsLegacyResponseSchema
  >

  export const TeamsCreateDiscussionCommentLegacyParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type TeamsCreateDiscussionCommentLegacyParams = z.infer<
    typeof TeamsCreateDiscussionCommentLegacyParamsSchema
  >

  export type TeamsCreateDiscussionCommentLegacyResponse = undefined

  export const TeamsGetDiscussionCommentLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsGetDiscussionCommentLegacyParams = z.infer<
    typeof TeamsGetDiscussionCommentLegacyParamsSchema
  >

  export const TeamsGetDiscussionCommentLegacyResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsGetDiscussionCommentLegacyResponse = z.infer<
    typeof TeamsGetDiscussionCommentLegacyResponseSchema
  >

  export const TeamsDeleteDiscussionCommentLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsDeleteDiscussionCommentLegacyParams = z.infer<
    typeof TeamsDeleteDiscussionCommentLegacyParamsSchema
  >

  export type TeamsDeleteDiscussionCommentLegacyResponse = undefined

  export const TeamsUpdateDiscussionCommentLegacyParamsSchema = z.object({
    body: z.string().describe("The discussion comment's body text."),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    comment_number: z
      .number()
      .int()
      .describe('The number that identifies the comment.')
  })
  export type TeamsUpdateDiscussionCommentLegacyParams = z.infer<
    typeof TeamsUpdateDiscussionCommentLegacyParamsSchema
  >

  export const TeamsUpdateDiscussionCommentLegacyResponseSchema =
    TeamDiscussionCommentSchema
  export type TeamsUpdateDiscussionCommentLegacyResponse = z.infer<
    typeof TeamsUpdateDiscussionCommentLegacyResponseSchema
  >

  export const ReactionsListForTeamDiscussionCommentLegacyParamsSchema =
    z.object({
      team_id: z.number().int().describe('The unique identifier of the team.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.'),
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.'
        )
        .optional(),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ReactionsListForTeamDiscussionCommentLegacyParams = z.infer<
    typeof ReactionsListForTeamDiscussionCommentLegacyParamsSchema
  >

  export const ReactionsListForTeamDiscussionCommentLegacyResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionCommentLegacyResponse = z.infer<
    typeof ReactionsListForTeamDiscussionCommentLegacyResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionCommentLegacyParamsSchema =
    z.object({
      content: z
        .enum([
          '+1',
          '-1',
          'laugh',
          'confused',
          'heart',
          'hooray',
          'rocket',
          'eyes'
        ])
        .describe(
          'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.'
        ),
      team_id: z.number().int().describe('The unique identifier of the team.'),
      discussion_number: z
        .number()
        .int()
        .describe('The number that identifies the discussion.'),
      comment_number: z
        .number()
        .int()
        .describe('The number that identifies the comment.')
    })
  export type ReactionsCreateForTeamDiscussionCommentLegacyParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionCommentLegacyParamsSchema
  >

  export type ReactionsCreateForTeamDiscussionCommentLegacyResponse = undefined

  export const ReactionsListForTeamDiscussionLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.'),
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReactionsListForTeamDiscussionLegacyParams = z.infer<
    typeof ReactionsListForTeamDiscussionLegacyParamsSchema
  >

  export const ReactionsListForTeamDiscussionLegacyResponseSchema =
    z.array(ReactionSchema)
  export type ReactionsListForTeamDiscussionLegacyResponse = z.infer<
    typeof ReactionsListForTeamDiscussionLegacyResponseSchema
  >

  export const ReactionsCreateForTeamDiscussionLegacyParamsSchema = z.object({
    content: z
      .enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
      ])
      .describe(
        'The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.'
      ),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    discussion_number: z
      .number()
      .int()
      .describe('The number that identifies the discussion.')
  })
  export type ReactionsCreateForTeamDiscussionLegacyParams = z.infer<
    typeof ReactionsCreateForTeamDiscussionLegacyParamsSchema
  >

  export type ReactionsCreateForTeamDiscussionLegacyResponse = undefined

  export const TeamsListPendingInvitationsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListPendingInvitationsLegacyParams = z.infer<
    typeof TeamsListPendingInvitationsLegacyParamsSchema
  >

  export const TeamsListPendingInvitationsLegacyResponseSchema = z.array(
    OrganizationInvitationSchema
  )
  export type TeamsListPendingInvitationsLegacyResponse = z.infer<
    typeof TeamsListPendingInvitationsLegacyResponseSchema
  >

  export const TeamsListMembersLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    role: z
      .enum(['member', 'maintainer', 'all'])
      .describe('Filters members returned by their role in the team.')
      .default('all'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListMembersLegacyParams = z.infer<
    typeof TeamsListMembersLegacyParamsSchema
  >

  export const TeamsListMembersLegacyResponseSchema = z.array(SimpleUserSchema)
  export type TeamsListMembersLegacyResponse = z.infer<
    typeof TeamsListMembersLegacyResponseSchema
  >

  export const TeamsGetMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMemberLegacyParams = z.infer<
    typeof TeamsGetMemberLegacyParamsSchema
  >

  export type TeamsGetMemberLegacyResponse = undefined

  export const TeamsAddMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddMemberLegacyParams = z.infer<
    typeof TeamsAddMemberLegacyParamsSchema
  >

  export type TeamsAddMemberLegacyResponse = undefined

  export const TeamsRemoveMemberLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMemberLegacyParams = z.infer<
    typeof TeamsRemoveMemberLegacyParamsSchema
  >

  export type TeamsRemoveMemberLegacyResponse = undefined

  export const TeamsGetMembershipForUserLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsGetMembershipForUserLegacyParams = z.infer<
    typeof TeamsGetMembershipForUserLegacyParamsSchema
  >

  export const TeamsGetMembershipForUserLegacyResponseSchema =
    TeamMembershipSchema
  export type TeamsGetMembershipForUserLegacyResponse = z.infer<
    typeof TeamsGetMembershipForUserLegacyResponseSchema
  >

  export const TeamsAddOrUpdateMembershipForUserLegacyParamsSchema = z.object({
    role: z
      .enum(['member', 'maintainer'])
      .describe('The role that this user should have in the team.')
      .default('member'),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsAddOrUpdateMembershipForUserLegacyParams = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserLegacyParamsSchema
  >

  export const TeamsAddOrUpdateMembershipForUserLegacyResponseSchema =
    TeamMembershipSchema
  export type TeamsAddOrUpdateMembershipForUserLegacyResponse = z.infer<
    typeof TeamsAddOrUpdateMembershipForUserLegacyResponseSchema
  >

  export const TeamsRemoveMembershipForUserLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type TeamsRemoveMembershipForUserLegacyParams = z.infer<
    typeof TeamsRemoveMembershipForUserLegacyParamsSchema
  >

  export type TeamsRemoveMembershipForUserLegacyResponse = undefined

  export const TeamsListProjectsLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListProjectsLegacyParams = z.infer<
    typeof TeamsListProjectsLegacyParamsSchema
  >

  export const TeamsListProjectsLegacyResponseSchema =
    z.array(TeamProjectSchema)
  export type TeamsListProjectsLegacyResponse = z.infer<
    typeof TeamsListProjectsLegacyResponseSchema
  >

  export const TeamsCheckPermissionsForProjectLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsCheckPermissionsForProjectLegacyParams = z.infer<
    typeof TeamsCheckPermissionsForProjectLegacyParamsSchema
  >

  export const TeamsCheckPermissionsForProjectLegacyResponseSchema =
    TeamProjectSchema
  export type TeamsCheckPermissionsForProjectLegacyResponse = z.infer<
    typeof TeamsCheckPermissionsForProjectLegacyResponseSchema
  >

  export const TeamsAddOrUpdateProjectPermissionsLegacyParamsSchema = z.object({
    permission: z
      .enum(['read', 'write', 'admin'])
      .describe(
        'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."'
      )
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsAddOrUpdateProjectPermissionsLegacyParams = z.infer<
    typeof TeamsAddOrUpdateProjectPermissionsLegacyParamsSchema
  >

  export type TeamsAddOrUpdateProjectPermissionsLegacyResponse = undefined

  export const TeamsRemoveProjectLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    project_id: z
      .number()
      .int()
      .describe('The unique identifier of the project.')
  })
  export type TeamsRemoveProjectLegacyParams = z.infer<
    typeof TeamsRemoveProjectLegacyParamsSchema
  >

  export type TeamsRemoveProjectLegacyResponse = undefined

  export const TeamsListReposLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListReposLegacyParams = z.infer<
    typeof TeamsListReposLegacyParamsSchema
  >

  export const TeamsListReposLegacyResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type TeamsListReposLegacyResponse = z.infer<
    typeof TeamsListReposLegacyResponseSchema
  >

  export const TeamsCheckPermissionsForRepoLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsCheckPermissionsForRepoLegacyParams = z.infer<
    typeof TeamsCheckPermissionsForRepoLegacyParamsSchema
  >

  export const TeamsCheckPermissionsForRepoLegacyResponseSchema =
    TeamRepositorySchema
  export type TeamsCheckPermissionsForRepoLegacyResponse = z.infer<
    typeof TeamsCheckPermissionsForRepoLegacyResponseSchema
  >

  export const TeamsAddOrUpdateRepoPermissionsLegacyParamsSchema = z.object({
    permission: z
      .enum(['pull', 'push', 'admin'])
      .describe(
        "The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."
      )
      .optional(),
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsAddOrUpdateRepoPermissionsLegacyParams = z.infer<
    typeof TeamsAddOrUpdateRepoPermissionsLegacyParamsSchema
  >

  export type TeamsAddOrUpdateRepoPermissionsLegacyResponse = undefined

  export const TeamsRemoveRepoLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type TeamsRemoveRepoLegacyParams = z.infer<
    typeof TeamsRemoveRepoLegacyParamsSchema
  >

  export type TeamsRemoveRepoLegacyResponse = undefined

  export const TeamsListChildLegacyParamsSchema = z.object({
    team_id: z.number().int().describe('The unique identifier of the team.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListChildLegacyParams = z.infer<
    typeof TeamsListChildLegacyParamsSchema
  >

  export const TeamsListChildLegacyResponseSchema = z.array(TeamSchema)
  export type TeamsListChildLegacyResponse = z.infer<
    typeof TeamsListChildLegacyResponseSchema
  >

  export const UsersGetAuthenticatedParamsSchema = z.object({})
  export type UsersGetAuthenticatedParams = z.infer<
    typeof UsersGetAuthenticatedParamsSchema
  >

  export const UsersGetAuthenticatedResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetAuthenticatedResponse = z.infer<
    typeof UsersGetAuthenticatedResponseSchema
  >

  export const UsersUpdateAuthenticatedParamsSchema = z.object({
    name: z.string().describe('The new name of the user.').optional(),
    email: z
      .string()
      .describe('The publicly visible email address of the user.')
      .optional(),
    blog: z.string().describe('The new blog URL of the user.').optional(),
    twitter_username: z
      .string()
      .describe('The new Twitter username of the user.')
      .optional(),
    company: z.string().describe('The new company of the user.').optional(),
    location: z.string().describe('The new location of the user.').optional(),
    hireable: z
      .boolean()
      .describe('The new hiring availability of the user.')
      .optional(),
    bio: z.string().describe('The new short biography of the user.').optional()
  })
  export type UsersUpdateAuthenticatedParams = z.infer<
    typeof UsersUpdateAuthenticatedParamsSchema
  >

  export const UsersUpdateAuthenticatedResponseSchema = PrivateUserSchema
  export type UsersUpdateAuthenticatedResponse = z.infer<
    typeof UsersUpdateAuthenticatedResponseSchema
  >

  export const UsersListBlockedByAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListBlockedByAuthenticatedUserParams = z.infer<
    typeof UsersListBlockedByAuthenticatedUserParamsSchema
  >

  export const UsersListBlockedByAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListBlockedByAuthenticatedUserResponse = z.infer<
    typeof UsersListBlockedByAuthenticatedUserResponseSchema
  >

  export const UsersCheckBlockedParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersCheckBlockedParams = z.infer<
    typeof UsersCheckBlockedParamsSchema
  >

  export type UsersCheckBlockedResponse = undefined

  export const UsersBlockParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersBlockParams = z.infer<typeof UsersBlockParamsSchema>

  export type UsersBlockResponse = undefined

  export const UsersUnblockParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersUnblockParams = z.infer<typeof UsersUnblockParamsSchema>

  export type UsersUnblockResponse = undefined

  export const CodespacesListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    repository_id: z
      .number()
      .int()
      .describe('ID of the Repository to filter on')
      .optional()
  })
  export type CodespacesListForAuthenticatedUserParams = z.infer<
    typeof CodespacesListForAuthenticatedUserParamsSchema
  >

  export const CodespacesListForAuthenticatedUserResponseSchema = z.object({
    total_count: z.number().int(),
    codespaces: z.array(CodespaceSchema)
  })
  export type CodespacesListForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z.object({
          repository_id: z
            .number()
            .int()
            .describe('Repository id for this codespace'),
          ref: z
            .string()
            .describe('Git ref (typically a branch name) for this codespace')
            .optional(),
          location: z
            .string()
            .describe(
              'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
            )
            .optional(),
          geo: z
            .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
            .describe(
              'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
            )
            .optional(),
          client_ip: z
            .string()
            .describe('IP for location auto-detection when proxying a request')
            .optional(),
          machine: z
            .string()
            .describe('Machine type to use for this codespace')
            .optional(),
          devcontainer_path: z
            .string()
            .describe(
              'Path to devcontainer.json config to use for this codespace'
            )
            .optional(),
          multi_repo_permissions_opt_out: z
            .boolean()
            .describe(
              'Whether to authorize requested permissions from devcontainer.json'
            )
            .optional(),
          working_directory: z
            .string()
            .describe('Working directory for this codespace')
            .optional(),
          idle_timeout_minutes: z
            .number()
            .int()
            .describe('Time in minutes before codespace stops from inactivity')
            .optional(),
          display_name: z
            .string()
            .describe('Display name for this codespace')
            .optional(),
          retention_period_minutes: z
            .number()
            .int()
            .describe(
              'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).'
            )
            .optional()
        }),
        z.object({
          pull_request: z
            .object({
              pull_request_number: z
                .number()
                .int()
                .describe('Pull request number'),
              repository_id: z
                .number()
                .int()
                .describe('Repository id for this codespace')
            })
            .describe('Pull request number for this codespace'),
          location: z
            .string()
            .describe(
              'The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.'
            )
            .optional(),
          geo: z
            .enum(['EuropeWest', 'SoutheastAsia', 'UsEast', 'UsWest'])
            .describe(
              'The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.'
            )
            .optional(),
          machine: z
            .string()
            .describe('Machine type to use for this codespace')
            .optional(),
          devcontainer_path: z
            .string()
            .describe(
              'Path to devcontainer.json config to use for this codespace'
            )
            .optional(),
          working_directory: z
            .string()
            .describe('Working directory for this codespace')
            .optional(),
          idle_timeout_minutes: z
            .number()
            .int()
            .describe('Time in minutes before codespace stops from inactivity')
            .optional()
        })
      ])
    )
  export type CodespacesCreateForAuthenticatedUserParams = z.infer<
    typeof CodespacesCreateForAuthenticatedUserParamsSchema
  >

  export type CodespacesCreateForAuthenticatedUserResponse = undefined

  export const CodespacesListSecretsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type CodespacesListSecretsForAuthenticatedUserParams = z.infer<
    typeof CodespacesListSecretsForAuthenticatedUserParamsSchema
  >

  export const CodespacesListSecretsForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      secrets: z.array(CodespacesSecretSchema)
    })
  export type CodespacesListSecretsForAuthenticatedUserResponse = z.infer<
    typeof CodespacesListSecretsForAuthenticatedUserResponseSchema
  >

  export const CodespacesGetPublicKeyForAuthenticatedUserParamsSchema =
    z.object({})
  export type CodespacesGetPublicKeyForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetPublicKeyForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetPublicKeyForAuthenticatedUserResponseSchema =
    CodespacesUserPublicKeySchema
  export type CodespacesGetPublicKeyForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetPublicKeyForAuthenticatedUserResponseSchema
  >

  export const CodespacesGetSecretForAuthenticatedUserParamsSchema = z.object({
    secret_name: z.string().describe('The name of the secret.')
  })
  export type CodespacesGetSecretForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetSecretForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetSecretForAuthenticatedUserResponseSchema =
    CodespacesSecretSchema
  export type CodespacesGetSecretForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetSecretForAuthenticatedUserResponseSchema
  >

  export const CodespacesCreateOrUpdateSecretForAuthenticatedUserParamsSchema =
    z.object({
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          )
        )
        .describe(
          'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint.'
        )
        .optional(),
      key_id: z
        .string()
        .describe('ID of the key you used to encrypt the secret.'),
      selected_repository_ids: z
        .array(z.union([z.number().int(), z.string()]))
        .describe(
          'An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.'
        )
        .optional(),
      secret_name: z.string().describe('The name of the secret.')
    })
  export type CodespacesCreateOrUpdateSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesCreateOrUpdateSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesDeleteSecretForAuthenticatedUserParamsSchema =
    z.object({ secret_name: z.string().describe('The name of the secret.') })
  export type CodespacesDeleteSecretForAuthenticatedUserParams = z.infer<
    typeof CodespacesDeleteSecretForAuthenticatedUserParamsSchema
  >

  export type CodespacesDeleteSecretForAuthenticatedUserResponse = undefined

  export const CodespacesListRepositoriesForSecretForAuthenticatedUserParamsSchema =
    z.object({ secret_name: z.string().describe('The name of the secret.') })
  export type CodespacesListRepositoriesForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesListRepositoriesForSecretForAuthenticatedUserParamsSchema
    >

  export const CodespacesListRepositoriesForSecretForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      repositories: z.array(MinimalRepositorySchema)
    })
  export type CodespacesListRepositoriesForSecretForAuthenticatedUserResponse =
    z.infer<
      typeof CodespacesListRepositoriesForSecretForAuthenticatedUserResponseSchema
    >

  export const CodespacesSetRepositoriesForSecretForAuthenticatedUserParamsSchema =
    z.object({
      selected_repository_ids: z
        .array(z.number().int())
        .describe(
          'An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.'
        ),
      secret_name: z.string().describe('The name of the secret.')
    })
  export type CodespacesSetRepositoriesForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesSetRepositoriesForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesAddRepositoryForSecretForAuthenticatedUserParamsSchema =
    z.object({
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    })
  export type CodespacesAddRepositoryForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesAddRepositoryForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesAddRepositoryForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamsSchema =
    z.object({
      secret_name: z.string().describe('The name of the secret.'),
      repository_id: z.number().int()
    })
  export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserParams =
    z.infer<
      typeof CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamsSchema
    >

  export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse =
    undefined

  export const CodespacesGetForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesGetForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetForAuthenticatedUserResponseSchema = CodespaceSchema
  export type CodespacesGetForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetForAuthenticatedUserResponseSchema
  >

  export const CodespacesDeleteForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesDeleteForAuthenticatedUserParams = z.infer<
    typeof CodespacesDeleteForAuthenticatedUserParamsSchema
  >

  export type CodespacesDeleteForAuthenticatedUserResponse = undefined

  export const CodespacesUpdateForAuthenticatedUserParamsSchema = z.object({
    machine: z
      .string()
      .describe('A valid machine to transition this codespace to.')
      .optional(),
    display_name: z
      .string()
      .describe('Display name for this codespace')
      .optional(),
    recent_folders: z
      .array(z.string())
      .describe(
        'Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.'
      )
      .optional(),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesUpdateForAuthenticatedUserParams = z.infer<
    typeof CodespacesUpdateForAuthenticatedUserParamsSchema
  >

  export const CodespacesUpdateForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesUpdateForAuthenticatedUserResponse = z.infer<
    typeof CodespacesUpdateForAuthenticatedUserResponseSchema
  >

  export const CodespacesExportForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesExportForAuthenticatedUserParams = z.infer<
    typeof CodespacesExportForAuthenticatedUserParamsSchema
  >

  export type CodespacesExportForAuthenticatedUserResponse = undefined

  export const CodespacesGetExportDetailsForAuthenticatedUserParamsSchema =
    z.object({
      codespace_name: z.string().describe('The name of the codespace.'),
      export_id: z
        .string()
        .describe(
          'The ID of the export operation, or `latest`. Currently only `latest` is currently supported.'
        )
    })
  export type CodespacesGetExportDetailsForAuthenticatedUserParams = z.infer<
    typeof CodespacesGetExportDetailsForAuthenticatedUserParamsSchema
  >

  export const CodespacesGetExportDetailsForAuthenticatedUserResponseSchema =
    CodespaceExportDetailsSchema
  export type CodespacesGetExportDetailsForAuthenticatedUserResponse = z.infer<
    typeof CodespacesGetExportDetailsForAuthenticatedUserResponseSchema
  >

  export const CodespacesCodespaceMachinesForAuthenticatedUserParamsSchema =
    z.object({
      codespace_name: z.string().describe('The name of the codespace.')
    })
  export type CodespacesCodespaceMachinesForAuthenticatedUserParams = z.infer<
    typeof CodespacesCodespaceMachinesForAuthenticatedUserParamsSchema
  >

  export const CodespacesCodespaceMachinesForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      machines: z.array(CodespaceMachineSchema)
    })
  export type CodespacesCodespaceMachinesForAuthenticatedUserResponse = z.infer<
    typeof CodespacesCodespaceMachinesForAuthenticatedUserResponseSchema
  >

  export const CodespacesPublishForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('A name for the new repository.').optional(),
    private: z
      .boolean()
      .describe('Whether the new repository should be private.')
      .default(false),
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesPublishForAuthenticatedUserParams = z.infer<
    typeof CodespacesPublishForAuthenticatedUserParamsSchema
  >

  export type CodespacesPublishForAuthenticatedUserResponse = undefined

  export const CodespacesStartForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStartForAuthenticatedUserParams = z.infer<
    typeof CodespacesStartForAuthenticatedUserParamsSchema
  >

  export const CodespacesStartForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesStartForAuthenticatedUserResponse = z.infer<
    typeof CodespacesStartForAuthenticatedUserResponseSchema
  >

  export const CodespacesStopForAuthenticatedUserParamsSchema = z.object({
    codespace_name: z.string().describe('The name of the codespace.')
  })
  export type CodespacesStopForAuthenticatedUserParams = z.infer<
    typeof CodespacesStopForAuthenticatedUserParamsSchema
  >

  export const CodespacesStopForAuthenticatedUserResponseSchema =
    CodespaceSchema
  export type CodespacesStopForAuthenticatedUserResponse = z.infer<
    typeof CodespacesStopForAuthenticatedUserResponseSchema
  >

  export const PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParamsSchema =
    z.object({})
  export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseSchema
    >

  export const UsersSetPrimaryEmailVisibilityForAuthenticatedUserParamsSchema =
    z.object({
      visibility: z
        .enum(['public', 'private'])
        .describe('Denotes whether an email is publicly visible.')
    })
  export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserParams =
    z.infer<
      typeof UsersSetPrimaryEmailVisibilityForAuthenticatedUserParamsSchema
    >

  export const UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse =
    z.infer<
      typeof UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponseSchema
    >

  export const UsersListEmailsForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListEmailsForAuthenticatedUserParams = z.infer<
    typeof UsersListEmailsForAuthenticatedUserParamsSchema
  >

  export const UsersListEmailsForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersListEmailsForAuthenticatedUserResponse = z.infer<
    typeof UsersListEmailsForAuthenticatedUserResponseSchema
  >

  export const UsersAddEmailForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z.object({
          emails: z
            .array(z.string())
            .min(1)
            .describe(
              'Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.'
            )
        }),
        z.array(z.string()).min(1),
        z.string()
      ])
    )
  export type UsersAddEmailForAuthenticatedUserParams = z.infer<
    typeof UsersAddEmailForAuthenticatedUserParamsSchema
  >

  export type UsersAddEmailForAuthenticatedUserResponse = undefined

  export const UsersDeleteEmailForAuthenticatedUserParamsSchema = z
    .object({})
    .and(
      z.union([
        z
          .object({
            emails: z
              .array(z.string())
              .min(1)
              .describe(
                'Email addresses associated with the GitHub user account.'
              )
          })
          .describe(
            'Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.'
          ),
        z.array(z.string()).min(1),
        z.string()
      ])
    )
  export type UsersDeleteEmailForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteEmailForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteEmailForAuthenticatedUserResponse = undefined

  export const UsersListFollowersForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowersForAuthenticatedUserParams = z.infer<
    typeof UsersListFollowersForAuthenticatedUserParamsSchema
  >

  export const UsersListFollowersForAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowersForAuthenticatedUserResponse = z.infer<
    typeof UsersListFollowersForAuthenticatedUserResponseSchema
  >

  export const UsersListFollowedByAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowedByAuthenticatedUserParams = z.infer<
    typeof UsersListFollowedByAuthenticatedUserParamsSchema
  >

  export const UsersListFollowedByAuthenticatedUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowedByAuthenticatedUserResponse = z.infer<
    typeof UsersListFollowedByAuthenticatedUserResponseSchema
  >

  export const UsersCheckPersonIsFollowedByAuthenticatedParamsSchema = z.object(
    { username: z.string().describe('The handle for the GitHub user account.') }
  )
  export type UsersCheckPersonIsFollowedByAuthenticatedParams = z.infer<
    typeof UsersCheckPersonIsFollowedByAuthenticatedParamsSchema
  >

  export type UsersCheckPersonIsFollowedByAuthenticatedResponse = undefined

  export const UsersFollowParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersFollowParams = z.infer<typeof UsersFollowParamsSchema>

  export type UsersFollowResponse = undefined

  export const UsersUnfollowParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersUnfollowParams = z.infer<typeof UsersUnfollowParamsSchema>

  export type UsersUnfollowResponse = undefined

  export const UsersListGpgKeysForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListGpgKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListGpgKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListGpgKeysForAuthenticatedUserResponseSchema =
    z.array(GpgKeySchema)
  export type UsersListGpgKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListGpgKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreateGpgKeyForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('A descriptive name for the new key.').optional(),
    armored_public_key: z
      .string()
      .describe('A GPG key in ASCII-armored format.')
  })
  export type UsersCreateGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreateGpgKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreateGpgKeyForAuthenticatedUserResponse = undefined

  export const UsersGetGpgKeyForAuthenticatedUserParamsSchema = z.object({
    gpg_key_id: z
      .number()
      .int()
      .describe('The unique identifier of the GPG key.')
  })
  export type UsersGetGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetGpgKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetGpgKeyForAuthenticatedUserResponseSchema = GpgKeySchema
  export type UsersGetGpgKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetGpgKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeleteGpgKeyForAuthenticatedUserParamsSchema = z.object({
    gpg_key_id: z
      .number()
      .int()
      .describe('The unique identifier of the GPG key.')
  })
  export type UsersDeleteGpgKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteGpgKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteGpgKeyForAuthenticatedUserResponse = undefined

  export const AppsListInstallationsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type AppsListInstallationsForAuthenticatedUserParams = z.infer<
    typeof AppsListInstallationsForAuthenticatedUserParamsSchema
  >

  export const AppsListInstallationsForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      installations: z.array(InstallationSchema)
    })
  export type AppsListInstallationsForAuthenticatedUserResponse = z.infer<
    typeof AppsListInstallationsForAuthenticatedUserResponseSchema
  >

  export const AppsListInstallationReposForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListInstallationReposForAuthenticatedUserParams = z.infer<
    typeof AppsListInstallationReposForAuthenticatedUserParamsSchema
  >

  export const AppsListInstallationReposForAuthenticatedUserResponseSchema =
    z.object({
      total_count: z.number().int(),
      repository_selection: z.string().optional(),
      repositories: z.array(RepositorySchema)
    })
  export type AppsListInstallationReposForAuthenticatedUserResponse = z.infer<
    typeof AppsListInstallationReposForAuthenticatedUserResponseSchema
  >

  export const AppsAddRepoToInstallationForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type AppsAddRepoToInstallationForAuthenticatedUserParams = z.infer<
    typeof AppsAddRepoToInstallationForAuthenticatedUserParamsSchema
  >

  export type AppsAddRepoToInstallationForAuthenticatedUserResponse = undefined

  export const AppsRemoveRepoFromInstallationForAuthenticatedUserParamsSchema =
    z.object({
      installation_id: z
        .number()
        .int()
        .describe('The unique identifier of the installation.'),
      repository_id: z
        .number()
        .int()
        .describe('The unique identifier of the repository.')
    })
  export type AppsRemoveRepoFromInstallationForAuthenticatedUserParams =
    z.infer<
      typeof AppsRemoveRepoFromInstallationForAuthenticatedUserParamsSchema
    >

  export type AppsRemoveRepoFromInstallationForAuthenticatedUserResponse =
    undefined

  export const InteractionsGetRestrictionsForAuthenticatedUserParamsSchema =
    z.object({})
  export type InteractionsGetRestrictionsForAuthenticatedUserParams = z.infer<
    typeof InteractionsGetRestrictionsForAuthenticatedUserParamsSchema
  >

  export const InteractionsGetRestrictionsForAuthenticatedUserResponseSchema =
    z.union([InteractionLimitResponseSchema, z.object({}).strict()])
  export type InteractionsGetRestrictionsForAuthenticatedUserResponse = z.infer<
    typeof InteractionsGetRestrictionsForAuthenticatedUserResponseSchema
  >

  export const InteractionsSetRestrictionsForAuthenticatedUserParamsSchema = InteractionLimitSchema
  export type InteractionsSetRestrictionsForAuthenticatedUserParams = z.infer<
    typeof InteractionsSetRestrictionsForAuthenticatedUserParamsSchema
  >

  export const InteractionsSetRestrictionsForAuthenticatedUserResponseSchema =
    InteractionLimitResponseSchema
  export type InteractionsSetRestrictionsForAuthenticatedUserResponse = z.infer<
    typeof InteractionsSetRestrictionsForAuthenticatedUserResponseSchema
  >

  export const InteractionsRemoveRestrictionsForAuthenticatedUserParamsSchema =
    z.object({})
  export type InteractionsRemoveRestrictionsForAuthenticatedUserParams =
    z.infer<
      typeof InteractionsRemoveRestrictionsForAuthenticatedUserParamsSchema
    >

  export type InteractionsRemoveRestrictionsForAuthenticatedUserResponse =
    undefined

  export const IssuesListForAuthenticatedUserParamsSchema = z.object({
    filter: z
      .enum(['assigned', 'created', 'mentioned', 'subscribed', 'repos', 'all'])
      .describe(
        "Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."
      )
      .default('assigned'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the issues to return.')
      .default('open'),
    labels: z
      .string()
      .describe(
        'A list of comma separated label names. Example: `bug,ui,@high`'
      )
      .optional(),
    sort: z
      .enum(['created', 'updated', 'comments'])
      .describe('What to sort results by.')
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type IssuesListForAuthenticatedUserParams = z.infer<
    typeof IssuesListForAuthenticatedUserParamsSchema
  >

  export const IssuesListForAuthenticatedUserResponseSchema =
    z.array(IssueSchema)
  export type IssuesListForAuthenticatedUserResponse = z.infer<
    typeof IssuesListForAuthenticatedUserResponseSchema
  >

  export const UsersListPublicSshKeysForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListPublicSshKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListPublicSshKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListPublicSshKeysForAuthenticatedUserResponseSchema =
    z.array(KeySchema)
  export type UsersListPublicSshKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListPublicSshKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreatePublicSshKeyForAuthenticatedUserParamsSchema =
    z.object({
      title: z
        .string()
        .describe('A descriptive name for the new key.')
        .optional(),
      key: z
        .string()
        .regex(
          new RegExp('^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) ')
        )
        .describe('The public SSH key to add to your GitHub account.')
    })
  export type UsersCreatePublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreatePublicSshKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreatePublicSshKeyForAuthenticatedUserResponse = undefined

  export const UsersGetPublicSshKeyForAuthenticatedUserParamsSchema = z.object({
    key_id: z.number().int().describe('The unique identifier of the key.')
  })
  export type UsersGetPublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetPublicSshKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetPublicSshKeyForAuthenticatedUserResponseSchema =
    KeySchema
  export type UsersGetPublicSshKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetPublicSshKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeletePublicSshKeyForAuthenticatedUserParamsSchema =
    z.object({
      key_id: z.number().int().describe('The unique identifier of the key.')
    })
  export type UsersDeletePublicSshKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeletePublicSshKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeletePublicSshKeyForAuthenticatedUserResponse = undefined

  export const AppsListSubscriptionsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type AppsListSubscriptionsForAuthenticatedUserParams = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserParamsSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserResponseSchema =
    z.array(UserMarketplacePurchaseSchema)
  export type AppsListSubscriptionsForAuthenticatedUserResponse = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserResponseSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserStubbedParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type AppsListSubscriptionsForAuthenticatedUserStubbedParams = z.infer<
    typeof AppsListSubscriptionsForAuthenticatedUserStubbedParamsSchema
  >

  export const AppsListSubscriptionsForAuthenticatedUserStubbedResponseSchema =
    z.array(UserMarketplacePurchaseSchema)
  export type AppsListSubscriptionsForAuthenticatedUserStubbedResponse =
    z.infer<
      typeof AppsListSubscriptionsForAuthenticatedUserStubbedResponseSchema
    >

  export const OrgsListMembershipsForAuthenticatedUserParamsSchema = z.object({
    state: z
      .enum(['active', 'pending'])
      .describe(
        'Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListMembershipsForAuthenticatedUserParams = z.infer<
    typeof OrgsListMembershipsForAuthenticatedUserParamsSchema
  >

  export const OrgsListMembershipsForAuthenticatedUserResponseSchema =
    z.array(OrgMembershipSchema)
  export type OrgsListMembershipsForAuthenticatedUserResponse = z.infer<
    typeof OrgsListMembershipsForAuthenticatedUserResponseSchema
  >

  export const OrgsGetMembershipForAuthenticatedUserParamsSchema = z.object({
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsGetMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsGetMembershipForAuthenticatedUserParamsSchema
  >

  export const OrgsGetMembershipForAuthenticatedUserResponseSchema =
    OrgMembershipSchema
  export type OrgsGetMembershipForAuthenticatedUserResponse = z.infer<
    typeof OrgsGetMembershipForAuthenticatedUserResponseSchema
  >

  export const OrgsUpdateMembershipForAuthenticatedUserParamsSchema = z.object({
    state: z
      .literal('active')
      .describe(
        'The state that the membership should be in. Only `"active"` will be accepted.'
      ),
    org: z
      .string()
      .describe('The organization name. The name is not case sensitive.')
  })
  export type OrgsUpdateMembershipForAuthenticatedUserParams = z.infer<
    typeof OrgsUpdateMembershipForAuthenticatedUserParamsSchema
  >

  export const OrgsUpdateMembershipForAuthenticatedUserResponseSchema =
    OrgMembershipSchema
  export type OrgsUpdateMembershipForAuthenticatedUserResponse = z.infer<
    typeof OrgsUpdateMembershipForAuthenticatedUserResponseSchema
  >

  export const MigrationsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListForAuthenticatedUserParams = z.infer<
    typeof MigrationsListForAuthenticatedUserParamsSchema
  >

  export const MigrationsListForAuthenticatedUserResponseSchema =
    z.array(MigrationSchema)
  export type MigrationsListForAuthenticatedUserResponse = z.infer<
    typeof MigrationsListForAuthenticatedUserResponseSchema
  >

  export const MigrationsStartForAuthenticatedUserParamsSchema = z.object({
    lock_repositories: z
      .boolean()
      .describe(
        'Lock the repositories being migrated at the start of the migration'
      )
      .optional(),
    exclude_metadata: z
      .boolean()
      .describe(
        'Indicates whether metadata should be excluded and only git source should be included for the migration.'
      )
      .optional(),
    exclude_git_data: z
      .boolean()
      .describe(
        'Indicates whether the repository git data should be excluded from the migration.'
      )
      .optional(),
    exclude_attachments: z
      .boolean()
      .describe('Do not include attachments in the migration')
      .optional(),
    exclude_releases: z
      .boolean()
      .describe('Do not include releases in the migration')
      .optional(),
    exclude_owner_projects: z
      .boolean()
      .describe(
        'Indicates whether projects owned by the organization or users should be excluded.'
      )
      .optional(),
    org_metadata_only: z
      .boolean()
      .describe(
        'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).'
      )
      .default(false),
    exclude: z
      .array(
        z
          .literal('repositories')
          .describe('Allowed values that can be passed to the exclude param.')
      )
      .describe(
        'Exclude attributes from the API response to improve performance'
      )
      .optional(),
    repositories: z.array(
      z.string().describe('Repository path, owner and name')
    )
  })
  export type MigrationsStartForAuthenticatedUserParams = z.infer<
    typeof MigrationsStartForAuthenticatedUserParamsSchema
  >

  export type MigrationsStartForAuthenticatedUserResponse = undefined

  export const MigrationsGetStatusForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    exclude: z.array(z.string()).optional()
  })
  export type MigrationsGetStatusForAuthenticatedUserParams = z.infer<
    typeof MigrationsGetStatusForAuthenticatedUserParamsSchema
  >

  export const MigrationsGetStatusForAuthenticatedUserResponseSchema =
    MigrationSchema
  export type MigrationsGetStatusForAuthenticatedUserResponse = z.infer<
    typeof MigrationsGetStatusForAuthenticatedUserResponseSchema
  >

  export const MigrationsGetArchiveForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.')
  })
  export type MigrationsGetArchiveForAuthenticatedUserParams = z.infer<
    typeof MigrationsGetArchiveForAuthenticatedUserParamsSchema
  >

  export type MigrationsGetArchiveForAuthenticatedUserResponse = undefined

  export const MigrationsDeleteArchiveForAuthenticatedUserParamsSchema =
    z.object({
      migration_id: z
        .number()
        .int()
        .describe('The unique identifier of the migration.')
    })
  export type MigrationsDeleteArchiveForAuthenticatedUserParams = z.infer<
    typeof MigrationsDeleteArchiveForAuthenticatedUserParamsSchema
  >

  export type MigrationsDeleteArchiveForAuthenticatedUserResponse = undefined

  export const MigrationsUnlockRepoForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    repo_name: z.string().describe('repo_name parameter')
  })
  export type MigrationsUnlockRepoForAuthenticatedUserParams = z.infer<
    typeof MigrationsUnlockRepoForAuthenticatedUserParamsSchema
  >

  export type MigrationsUnlockRepoForAuthenticatedUserResponse = undefined

  export const MigrationsListReposForAuthenticatedUserParamsSchema = z.object({
    migration_id: z
      .number()
      .int()
      .describe('The unique identifier of the migration.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type MigrationsListReposForAuthenticatedUserParams = z.infer<
    typeof MigrationsListReposForAuthenticatedUserParamsSchema
  >

  export const MigrationsListReposForAuthenticatedUserResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type MigrationsListReposForAuthenticatedUserResponse = z.infer<
    typeof MigrationsListReposForAuthenticatedUserResponseSchema
  >

  export const OrgsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListForAuthenticatedUserParams = z.infer<
    typeof OrgsListForAuthenticatedUserParamsSchema
  >

  export const OrgsListForAuthenticatedUserResponseSchema = z.array(
    OrganizationSimpleSchema
  )
  export type OrgsListForAuthenticatedUserResponse = z.infer<
    typeof OrgsListForAuthenticatedUserResponseSchema
  >

  export const PackagesListPackagesForAuthenticatedUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForAuthenticatedUserParams = z.infer<
    typeof PackagesListPackagesForAuthenticatedUserParamsSchema
  >

  export const PackagesListPackagesForAuthenticatedUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForAuthenticatedUserResponse = z.infer<
    typeof PackagesListPackagesForAuthenticatedUserResponseSchema
  >

  export const PackagesGetPackageForAuthenticatedUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.')
  })
  export type PackagesGetPackageForAuthenticatedUserParams = z.infer<
    typeof PackagesGetPackageForAuthenticatedUserParamsSchema
  >

  export const PackagesGetPackageForAuthenticatedUserResponseSchema =
    PackageSchema
  export type PackagesGetPackageForAuthenticatedUserResponse = z.infer<
    typeof PackagesGetPackageForAuthenticatedUserResponseSchema
  >

  export const PackagesDeletePackageForAuthenticatedUserParamsSchema = z.object(
    {
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.')
    }
  )
  export type PackagesDeletePackageForAuthenticatedUserParams = z.infer<
    typeof PackagesDeletePackageForAuthenticatedUserParamsSchema
  >

  export type PackagesDeletePackageForAuthenticatedUserResponse = undefined

  export const PackagesRestorePackageForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      token: z.string().describe('package token').optional()
    })
  export type PackagesRestorePackageForAuthenticatedUserParams = z.infer<
    typeof PackagesRestorePackageForAuthenticatedUserParamsSchema
  >

  export type PackagesRestorePackageForAuthenticatedUserResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      state: z
        .enum(['active', 'deleted'])
        .describe('The state of the package, either active or deleted.')
        .default('active')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsSchema
    >

  export const PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseSchema
    >

  export const PackagesGetPackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesGetPackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesGetPackageVersionForAuthenticatedUserParamsSchema
  >

  export const PackagesGetPackageVersionForAuthenticatedUserResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForAuthenticatedUserResponse = z.infer<
    typeof PackagesGetPackageVersionForAuthenticatedUserResponseSchema
  >

  export const PackagesDeletePackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesDeletePackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesDeletePackageVersionForAuthenticatedUserParamsSchema
  >

  export type PackagesDeletePackageVersionForAuthenticatedUserResponse =
    undefined

  export const PackagesRestorePackageVersionForAuthenticatedUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      package_version_id: z
        .number()
        .int()
        .describe('Unique identifier of the package version.')
    })
  export type PackagesRestorePackageVersionForAuthenticatedUserParams = z.infer<
    typeof PackagesRestorePackageVersionForAuthenticatedUserParamsSchema
  >

  export type PackagesRestorePackageVersionForAuthenticatedUserResponse =
    undefined

  export const ProjectsCreateForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('Name of the project'),
    body: z.string().describe('Body of the project').optional()
  })
  export type ProjectsCreateForAuthenticatedUserParams = z.infer<
    typeof ProjectsCreateForAuthenticatedUserParamsSchema
  >

  export type ProjectsCreateForAuthenticatedUserResponse = undefined

  export const UsersListPublicEmailsForAuthenticatedUserParamsSchema = z.object(
    {
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type UsersListPublicEmailsForAuthenticatedUserParams = z.infer<
    typeof UsersListPublicEmailsForAuthenticatedUserParamsSchema
  >

  export const UsersListPublicEmailsForAuthenticatedUserResponseSchema =
    z.array(EmailSchema)
  export type UsersListPublicEmailsForAuthenticatedUserResponse = z.infer<
    typeof UsersListPublicEmailsForAuthenticatedUserResponseSchema
  >

  export const ReposListForAuthenticatedUserParamsSchema = z.object({
    visibility: z
      .enum(['all', 'public', 'private'])
      .describe('Limit results to repositories with the specified visibility.')
      .default('all'),
    affiliation: z
      .string()
      .describe(
        'Comma-separated list of values. Can include:  \n * `owner`: Repositories that are owned by the authenticated user.  \n * `collaborator`: Repositories that the user has been added to as a collaborator.  \n * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.'
      )
      .default('owner,collaborator,organization_member'),
    type: z
      .enum(['all', 'owner', 'public', 'private', 'member'])
      .describe(
        'Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.'
      )
      .default('all'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('full_name'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    before: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional()
  })
  export type ReposListForAuthenticatedUserParams = z.infer<
    typeof ReposListForAuthenticatedUserParamsSchema
  >

  export const ReposListForAuthenticatedUserResponseSchema =
    z.array(RepositorySchema)
  export type ReposListForAuthenticatedUserResponse = z.infer<
    typeof ReposListForAuthenticatedUserResponseSchema
  >

  export const ReposCreateForAuthenticatedUserParamsSchema = z.object({
    name: z.string().describe('The name of the repository.'),
    description: z
      .string()
      .describe('A short description of the repository.')
      .optional(),
    homepage: z
      .string()
      .describe('A URL with more information about the repository.')
      .optional(),
    private: z
      .boolean()
      .describe('Whether the repository is private.')
      .default(false),
    has_issues: z
      .boolean()
      .describe('Whether issues are enabled.')
      .default(true),
    has_projects: z
      .boolean()
      .describe('Whether projects are enabled.')
      .default(true),
    has_wiki: z
      .boolean()
      .describe('Whether the wiki is enabled.')
      .default(true),
    has_discussions: z
      .boolean()
      .describe('Whether discussions are enabled.')
      .default(false),
    team_id: z
      .number()
      .int()
      .describe(
        'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
      )
      .optional(),
    auto_init: z
      .boolean()
      .describe('Whether the repository is initialized with a minimal README.')
      .default(false),
    gitignore_template: z
      .string()
      .describe('The desired language or platform to apply to the .gitignore.')
      .optional(),
    license_template: z
      .string()
      .describe(
        'The license keyword of the open source license for this repository.'
      )
      .optional(),
    allow_squash_merge: z
      .boolean()
      .describe('Whether to allow squash merges for pull requests.')
      .default(true),
    allow_merge_commit: z
      .boolean()
      .describe('Whether to allow merge commits for pull requests.')
      .default(true),
    allow_rebase_merge: z
      .boolean()
      .describe('Whether to allow rebase merges for pull requests.')
      .default(true),
    allow_auto_merge: z
      .boolean()
      .describe('Whether to allow Auto-merge to be used on pull requests.')
      .default(false),
    delete_branch_on_merge: z
      .boolean()
      .describe('Whether to delete head branches when pull requests are merged')
      .default(false),
    squash_merge_commit_title: z
      .enum(['PR_TITLE', 'COMMIT_OR_PR_TITLE'])
      .describe(
        "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
      )
      .optional(),
    squash_merge_commit_message: z
      .enum(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'])
      .describe(
        "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    merge_commit_title: z
      .enum(['PR_TITLE', 'MERGE_MESSAGE'])
      .describe(
        "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
      )
      .optional(),
    merge_commit_message: z
      .enum(['PR_BODY', 'PR_TITLE', 'BLANK'])
      .describe(
        "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
      )
      .optional(),
    has_downloads: z
      .boolean()
      .describe('Whether downloads are enabled.')
      .default(true),
    is_template: z
      .boolean()
      .describe(
        'Whether this repository acts as a template that can be used to generate new repositories.'
      )
      .default(false)
  })
  export type ReposCreateForAuthenticatedUserParams = z.infer<
    typeof ReposCreateForAuthenticatedUserParamsSchema
  >

  export type ReposCreateForAuthenticatedUserResponse = undefined

  export const ReposListInvitationsForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListInvitationsForAuthenticatedUserParams = z.infer<
    typeof ReposListInvitationsForAuthenticatedUserParamsSchema
  >

  export const ReposListInvitationsForAuthenticatedUserResponseSchema = z.array(
    RepositoryInvitationSchema
  )
  export type ReposListInvitationsForAuthenticatedUserResponse = z.infer<
    typeof ReposListInvitationsForAuthenticatedUserResponseSchema
  >

  export const ReposDeclineInvitationForAuthenticatedUserParamsSchema =
    z.object({
      invitation_id: z
        .number()
        .int()
        .describe('The unique identifier of the invitation.')
    })
  export type ReposDeclineInvitationForAuthenticatedUserParams = z.infer<
    typeof ReposDeclineInvitationForAuthenticatedUserParamsSchema
  >

  export type ReposDeclineInvitationForAuthenticatedUserResponse = undefined

  export const ReposAcceptInvitationForAuthenticatedUserParamsSchema = z.object(
    {
      invitation_id: z
        .number()
        .int()
        .describe('The unique identifier of the invitation.')
    }
  )
  export type ReposAcceptInvitationForAuthenticatedUserParams = z.infer<
    typeof ReposAcceptInvitationForAuthenticatedUserParamsSchema
  >

  export type ReposAcceptInvitationForAuthenticatedUserResponse = undefined

  export const UsersListSocialAccountsForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListSocialAccountsForAuthenticatedUserParams = z.infer<
    typeof UsersListSocialAccountsForAuthenticatedUserParamsSchema
  >

  export const UsersListSocialAccountsForAuthenticatedUserResponseSchema =
    z.array(SocialAccountSchema)
  export type UsersListSocialAccountsForAuthenticatedUserResponse = z.infer<
    typeof UsersListSocialAccountsForAuthenticatedUserResponseSchema
  >

  export const UsersAddSocialAccountForAuthenticatedUserParamsSchema = z.object(
    {
      account_urls: z
        .array(z.string())
        .describe('Full URLs for the social media profiles to add.')
    }
  )
  export type UsersAddSocialAccountForAuthenticatedUserParams = z.infer<
    typeof UsersAddSocialAccountForAuthenticatedUserParamsSchema
  >

  export type UsersAddSocialAccountForAuthenticatedUserResponse = undefined

  export const UsersDeleteSocialAccountForAuthenticatedUserParamsSchema =
    z.object({
      account_urls: z
        .array(z.string())
        .describe('Full URLs for the social media profiles to delete.')
    })
  export type UsersDeleteSocialAccountForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteSocialAccountForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteSocialAccountForAuthenticatedUserResponse = undefined

  export const UsersListSshSigningKeysForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type UsersListSshSigningKeysForAuthenticatedUserParams = z.infer<
    typeof UsersListSshSigningKeysForAuthenticatedUserParamsSchema
  >

  export const UsersListSshSigningKeysForAuthenticatedUserResponseSchema =
    z.array(SshSigningKeySchema)
  export type UsersListSshSigningKeysForAuthenticatedUserResponse = z.infer<
    typeof UsersListSshSigningKeysForAuthenticatedUserResponseSchema
  >

  export const UsersCreateSshSigningKeyForAuthenticatedUserParamsSchema =
    z.object({
      title: z
        .string()
        .describe('A descriptive name for the new key.')
        .optional(),
      key: z
        .string()
        .regex(
          new RegExp(
            '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com '
          )
        )
        .describe(
          'The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."'
        )
    })
  export type UsersCreateSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersCreateSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export type UsersCreateSshSigningKeyForAuthenticatedUserResponse = undefined

  export const UsersGetSshSigningKeyForAuthenticatedUserParamsSchema = z.object(
    {
      ssh_signing_key_id: z
        .number()
        .int()
        .describe('The unique identifier of the SSH signing key.')
    }
  )
  export type UsersGetSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersGetSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export const UsersGetSshSigningKeyForAuthenticatedUserResponseSchema =
    SshSigningKeySchema
  export type UsersGetSshSigningKeyForAuthenticatedUserResponse = z.infer<
    typeof UsersGetSshSigningKeyForAuthenticatedUserResponseSchema
  >

  export const UsersDeleteSshSigningKeyForAuthenticatedUserParamsSchema =
    z.object({
      ssh_signing_key_id: z
        .number()
        .int()
        .describe('The unique identifier of the SSH signing key.')
    })
  export type UsersDeleteSshSigningKeyForAuthenticatedUserParams = z.infer<
    typeof UsersDeleteSshSigningKeyForAuthenticatedUserParamsSchema
  >

  export type UsersDeleteSshSigningKeyForAuthenticatedUserResponse = undefined

  export const ActivityListReposStarredByAuthenticatedUserParamsSchema =
    z.object({
      sort: z
        .enum(['created', 'updated'])
        .describe(
          'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
        )
        .default('created'),
      direction: z
        .enum(['asc', 'desc'])
        .describe('The direction to sort the results by.')
        .default('desc'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListReposStarredByAuthenticatedUserParams = z.infer<
    typeof ActivityListReposStarredByAuthenticatedUserParamsSchema
  >

  export const ActivityListReposStarredByAuthenticatedUserResponseSchema =
    z.array(RepositorySchema)
  export type ActivityListReposStarredByAuthenticatedUserResponse = z.infer<
    typeof ActivityListReposStarredByAuthenticatedUserResponseSchema
  >

  export const ActivityCheckRepoIsStarredByAuthenticatedUserParamsSchema =
    z.object({
      owner: z
        .string()
        .describe(
          'The account owner of the repository. The name is not case sensitive.'
        ),
      repo: z
        .string()
        .describe(
          'The name of the repository without the `.git` extension. The name is not case sensitive.'
        )
    })
  export type ActivityCheckRepoIsStarredByAuthenticatedUserParams = z.infer<
    typeof ActivityCheckRepoIsStarredByAuthenticatedUserParamsSchema
  >

  export type ActivityCheckRepoIsStarredByAuthenticatedUserResponse = undefined

  export const ActivityStarRepoForAuthenticatedUserParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityStarRepoForAuthenticatedUserParams = z.infer<
    typeof ActivityStarRepoForAuthenticatedUserParamsSchema
  >

  export type ActivityStarRepoForAuthenticatedUserResponse = undefined

  export const ActivityUnstarRepoForAuthenticatedUserParamsSchema = z.object({
    owner: z
      .string()
      .describe(
        'The account owner of the repository. The name is not case sensitive.'
      ),
    repo: z
      .string()
      .describe(
        'The name of the repository without the `.git` extension. The name is not case sensitive.'
      )
  })
  export type ActivityUnstarRepoForAuthenticatedUserParams = z.infer<
    typeof ActivityUnstarRepoForAuthenticatedUserParamsSchema
  >

  export type ActivityUnstarRepoForAuthenticatedUserResponse = undefined

  export const ActivityListWatchedReposForAuthenticatedUserParamsSchema =
    z.object({
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    })
  export type ActivityListWatchedReposForAuthenticatedUserParams = z.infer<
    typeof ActivityListWatchedReposForAuthenticatedUserParamsSchema
  >

  export const ActivityListWatchedReposForAuthenticatedUserResponseSchema =
    z.array(MinimalRepositorySchema)
  export type ActivityListWatchedReposForAuthenticatedUserResponse = z.infer<
    typeof ActivityListWatchedReposForAuthenticatedUserResponseSchema
  >

  export const TeamsListForAuthenticatedUserParamsSchema = z.object({
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type TeamsListForAuthenticatedUserParams = z.infer<
    typeof TeamsListForAuthenticatedUserParamsSchema
  >

  export const TeamsListForAuthenticatedUserResponseSchema =
    z.array(TeamFullSchema)
  export type TeamsListForAuthenticatedUserResponse = z.infer<
    typeof TeamsListForAuthenticatedUserResponseSchema
  >

  export const UsersGetByIdParamsSchema = z.object({
    account_id: z.number().int().describe('account_id parameter')
  })
  export type UsersGetByIdParams = z.infer<typeof UsersGetByIdParamsSchema>

  export const UsersGetByIdResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetByIdResponse = z.infer<typeof UsersGetByIdResponseSchema>

  export const UsersListParamsSchema = z.object({
    since: z
      .number()
      .int()
      .describe('A user ID. Only return users with an ID greater than this ID.')
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type UsersListParams = z.infer<typeof UsersListParamsSchema>

  export const UsersListResponseSchema = z.array(SimpleUserSchema)
  export type UsersListResponse = z.infer<typeof UsersListResponseSchema>

  export const UsersGetByUsernameParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type UsersGetByUsernameParams = z.infer<
    typeof UsersGetByUsernameParamsSchema
  >

  export const UsersGetByUsernameResponseSchema = z.union([
    PrivateUserSchema,
    PublicUserSchema
  ])
  export type UsersGetByUsernameResponse = z.infer<
    typeof UsersGetByUsernameResponseSchema
  >

  export const UsersListAttestationsParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    subject_digest: z.string().describe('Subject Digest'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    before: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    after: z
      .string()
      .describe(
        'A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .optional(),
    predicate_type: z
      .string()
      .describe(
        'Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, or freeform text for custom predicate types.'
      )
      .optional()
  })
  export type UsersListAttestationsParams = z.infer<
    typeof UsersListAttestationsParamsSchema
  >

  export const UsersListAttestationsResponseSchema = z.object({
    attestations: z
      .array(
        z.object({
          bundle: z
            .object({
              mediaType: z.string().optional(),
              verificationMaterial: z.object({}).catchall(z.any()).optional(),
              dsseEnvelope: z.object({}).catchall(z.any()).optional()
            })
            .describe(
              "The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information."
            )
            .optional(),
          repository_id: z.number().int().optional(),
          bundle_url: z.string().optional()
        })
      )
      .optional()
  })
  export type UsersListAttestationsResponse = z.infer<
    typeof UsersListAttestationsResponseSchema
  >

  export const PackagesListDockerMigrationConflictingPackagesForUserParamsSchema =
    z.object({
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type PackagesListDockerMigrationConflictingPackagesForUserParams =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForUserParamsSchema
    >

  export const PackagesListDockerMigrationConflictingPackagesForUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListDockerMigrationConflictingPackagesForUserResponse =
    z.infer<
      typeof PackagesListDockerMigrationConflictingPackagesForUserResponseSchema
    >

  export const ActivityListEventsForAuthenticatedUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListEventsForAuthenticatedUserParams = z.infer<
    typeof ActivityListEventsForAuthenticatedUserParamsSchema
  >

  export const ActivityListEventsForAuthenticatedUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListEventsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListEventsForAuthenticatedUserResponseSchema
  >

  export const ActivityListOrgEventsForAuthenticatedUserParamsSchema = z.object(
    {
      username: z.string().describe('The handle for the GitHub user account.'),
      org: z
        .string()
        .describe('The organization name. The name is not case sensitive.'),
      per_page: z
        .number()
        .int()
        .describe(
          'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(30),
      page: z
        .number()
        .int()
        .describe(
          'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
        )
        .default(1)
    }
  )
  export type ActivityListOrgEventsForAuthenticatedUserParams = z.infer<
    typeof ActivityListOrgEventsForAuthenticatedUserParamsSchema
  >

  export const ActivityListOrgEventsForAuthenticatedUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListOrgEventsForAuthenticatedUserResponse = z.infer<
    typeof ActivityListOrgEventsForAuthenticatedUserResponseSchema
  >

  export const ActivityListPublicEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListPublicEventsForUserParams = z.infer<
    typeof ActivityListPublicEventsForUserParamsSchema
  >

  export const ActivityListPublicEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListPublicEventsForUserResponse = z.infer<
    typeof ActivityListPublicEventsForUserResponseSchema
  >

  export const UsersListFollowersForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowersForUserParams = z.infer<
    typeof UsersListFollowersForUserParamsSchema
  >

  export const UsersListFollowersForUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowersForUserResponse = z.infer<
    typeof UsersListFollowersForUserResponseSchema
  >

  export const UsersListFollowingForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListFollowingForUserParams = z.infer<
    typeof UsersListFollowingForUserParamsSchema
  >

  export const UsersListFollowingForUserResponseSchema =
    z.array(SimpleUserSchema)
  export type UsersListFollowingForUserResponse = z.infer<
    typeof UsersListFollowingForUserResponseSchema
  >

  export const UsersCheckFollowingForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    target_user: z.string()
  })
  export type UsersCheckFollowingForUserParams = z.infer<
    typeof UsersCheckFollowingForUserParamsSchema
  >

  export type UsersCheckFollowingForUserResponse = undefined

  export const GistsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    since: z
      .string()
      .datetime({ offset: true })
      .describe(
        'Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type GistsListForUserParams = z.infer<
    typeof GistsListForUserParamsSchema
  >

  export const GistsListForUserResponseSchema = z.array(BaseGistSchema)
  export type GistsListForUserResponse = z.infer<
    typeof GistsListForUserResponseSchema
  >

  export const UsersListGpgKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListGpgKeysForUserParams = z.infer<
    typeof UsersListGpgKeysForUserParamsSchema
  >

  export const UsersListGpgKeysForUserResponseSchema = z.array(GpgKeySchema)
  export type UsersListGpgKeysForUserResponse = z.infer<
    typeof UsersListGpgKeysForUserResponseSchema
  >

  export const UsersGetContextForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    subject_type: z
      .enum(['organization', 'repository', 'issue', 'pull_request'])
      .describe(
        "Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`."
      )
      .optional(),
    subject_id: z
      .string()
      .describe(
        'Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.'
      )
      .optional()
  })
  export type UsersGetContextForUserParams = z.infer<
    typeof UsersGetContextForUserParamsSchema
  >

  export const UsersGetContextForUserResponseSchema = HovercardSchema
  export type UsersGetContextForUserResponse = z.infer<
    typeof UsersGetContextForUserResponseSchema
  >

  export const AppsGetUserInstallationParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type AppsGetUserInstallationParams = z.infer<
    typeof AppsGetUserInstallationParamsSchema
  >

  export const AppsGetUserInstallationResponseSchema = InstallationSchema
  export type AppsGetUserInstallationResponse = z.infer<
    typeof AppsGetUserInstallationResponseSchema
  >

  export const UsersListPublicKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListPublicKeysForUserParams = z.infer<
    typeof UsersListPublicKeysForUserParamsSchema
  >

  export const UsersListPublicKeysForUserResponseSchema =
    z.array(KeySimpleSchema)
  export type UsersListPublicKeysForUserResponse = z.infer<
    typeof UsersListPublicKeysForUserResponseSchema
  >

  export const OrgsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type OrgsListForUserParams = z.infer<
    typeof OrgsListForUserParamsSchema
  >

  export const OrgsListForUserResponseSchema = z.array(OrganizationSimpleSchema)
  export type OrgsListForUserResponse = z.infer<
    typeof OrgsListForUserResponseSchema
  >

  export const PackagesListPackagesForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    visibility: z
      .enum(['public', 'private', 'internal'])
      .describe(
        'The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."'
      )
      .optional(),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30)
  })
  export type PackagesListPackagesForUserParams = z.infer<
    typeof PackagesListPackagesForUserParamsSchema
  >

  export const PackagesListPackagesForUserResponseSchema =
    z.array(PackageSchema)
  export type PackagesListPackagesForUserResponse = z.infer<
    typeof PackagesListPackagesForUserResponseSchema
  >

  export const PackagesGetPackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesGetPackageForUserParams = z.infer<
    typeof PackagesGetPackageForUserParamsSchema
  >

  export const PackagesGetPackageForUserResponseSchema = PackageSchema
  export type PackagesGetPackageForUserResponse = z.infer<
    typeof PackagesGetPackageForUserResponseSchema
  >

  export const PackagesDeletePackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesDeletePackageForUserParams = z.infer<
    typeof PackagesDeletePackageForUserParamsSchema
  >

  export type PackagesDeletePackageForUserResponse = undefined

  export const PackagesRestorePackageForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    token: z.string().describe('package token').optional()
  })
  export type PackagesRestorePackageForUserParams = z.infer<
    typeof PackagesRestorePackageForUserParamsSchema
  >

  export type PackagesRestorePackageForUserResponse = undefined

  export const PackagesGetAllPackageVersionsForPackageOwnedByUserParamsSchema =
    z.object({
      package_type: z
        .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
        .describe(
          "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
        ),
      package_name: z.string().describe('The name of the package.'),
      username: z.string().describe('The handle for the GitHub user account.')
    })
  export type PackagesGetAllPackageVersionsForPackageOwnedByUserParams =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByUserParamsSchema
    >

  export const PackagesGetAllPackageVersionsForPackageOwnedByUserResponseSchema =
    z.array(PackageVersionSchema)
  export type PackagesGetAllPackageVersionsForPackageOwnedByUserResponse =
    z.infer<
      typeof PackagesGetAllPackageVersionsForPackageOwnedByUserResponseSchema
    >

  export const PackagesGetPackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.'),
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type PackagesGetPackageVersionForUserParams = z.infer<
    typeof PackagesGetPackageVersionForUserParamsSchema
  >

  export const PackagesGetPackageVersionForUserResponseSchema =
    PackageVersionSchema
  export type PackagesGetPackageVersionForUserResponse = z.infer<
    typeof PackagesGetPackageVersionForUserResponseSchema
  >

  export const PackagesDeletePackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesDeletePackageVersionForUserParams = z.infer<
    typeof PackagesDeletePackageVersionForUserParamsSchema
  >

  export type PackagesDeletePackageVersionForUserResponse = undefined

  export const PackagesRestorePackageVersionForUserParamsSchema = z.object({
    package_type: z
      .enum(['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container'])
      .describe(
        "The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."
      ),
    package_name: z.string().describe('The name of the package.'),
    username: z.string().describe('The handle for the GitHub user account.'),
    package_version_id: z
      .number()
      .int()
      .describe('Unique identifier of the package version.')
  })
  export type PackagesRestorePackageVersionForUserParams = z.infer<
    typeof PackagesRestorePackageVersionForUserParamsSchema
  >

  export type PackagesRestorePackageVersionForUserResponse = undefined

  export const ProjectsListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    state: z
      .enum(['open', 'closed', 'all'])
      .describe('Indicates the state of the projects to return.')
      .default('open'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ProjectsListForUserParams = z.infer<
    typeof ProjectsListForUserParamsSchema
  >

  export const ProjectsListForUserResponseSchema = z.array(ProjectSchema)
  export type ProjectsListForUserResponse = z.infer<
    typeof ProjectsListForUserResponseSchema
  >

  export const ActivityListReceivedEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReceivedEventsForUserParams = z.infer<
    typeof ActivityListReceivedEventsForUserParamsSchema
  >

  export const ActivityListReceivedEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListReceivedEventsForUserResponse = z.infer<
    typeof ActivityListReceivedEventsForUserResponseSchema
  >

  export const ActivityListReceivedPublicEventsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReceivedPublicEventsForUserParams = z.infer<
    typeof ActivityListReceivedPublicEventsForUserParamsSchema
  >

  export const ActivityListReceivedPublicEventsForUserResponseSchema =
    z.array(EventSchema)
  export type ActivityListReceivedPublicEventsForUserResponse = z.infer<
    typeof ActivityListReceivedPublicEventsForUserResponseSchema
  >

  export const ReposListForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    type: z
      .enum(['all', 'owner', 'member'])
      .describe('Limit results to repositories of the specified type.')
      .default('owner'),
    sort: z
      .enum(['created', 'updated', 'pushed', 'full_name'])
      .describe('The property to sort the results by.')
      .default('full_name'),
    direction: z
      .enum(['asc', 'desc'])
      .describe(
        'The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.'
      )
      .optional(),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ReposListForUserParams = z.infer<
    typeof ReposListForUserParamsSchema
  >

  export const ReposListForUserResponseSchema = z.array(MinimalRepositorySchema)
  export type ReposListForUserResponse = z.infer<
    typeof ReposListForUserResponseSchema
  >

  export const BillingGetGithubActionsBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetGithubActionsBillingUserParams = z.infer<
    typeof BillingGetGithubActionsBillingUserParamsSchema
  >

  export const BillingGetGithubActionsBillingUserResponseSchema =
    ActionsBillingUsageSchema
  export type BillingGetGithubActionsBillingUserResponse = z.infer<
    typeof BillingGetGithubActionsBillingUserResponseSchema
  >

  export const BillingGetGithubPackagesBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetGithubPackagesBillingUserParams = z.infer<
    typeof BillingGetGithubPackagesBillingUserParamsSchema
  >

  export const BillingGetGithubPackagesBillingUserResponseSchema =
    PackagesBillingUsageSchema
  export type BillingGetGithubPackagesBillingUserResponse = z.infer<
    typeof BillingGetGithubPackagesBillingUserResponseSchema
  >

  export const BillingGetSharedStorageBillingUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.')
  })
  export type BillingGetSharedStorageBillingUserParams = z.infer<
    typeof BillingGetSharedStorageBillingUserParamsSchema
  >

  export const BillingGetSharedStorageBillingUserResponseSchema =
    CombinedBillingUsageSchema
  export type BillingGetSharedStorageBillingUserResponse = z.infer<
    typeof BillingGetSharedStorageBillingUserResponseSchema
  >

  export const UsersListSocialAccountsForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListSocialAccountsForUserParams = z.infer<
    typeof UsersListSocialAccountsForUserParamsSchema
  >

  export const UsersListSocialAccountsForUserResponseSchema =
    z.array(SocialAccountSchema)
  export type UsersListSocialAccountsForUserResponse = z.infer<
    typeof UsersListSocialAccountsForUserResponseSchema
  >

  export const UsersListSshSigningKeysForUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type UsersListSshSigningKeysForUserParams = z.infer<
    typeof UsersListSshSigningKeysForUserParamsSchema
  >

  export const UsersListSshSigningKeysForUserResponseSchema =
    z.array(SshSigningKeySchema)
  export type UsersListSshSigningKeysForUserResponse = z.infer<
    typeof UsersListSshSigningKeysForUserResponseSchema
  >

  export const ActivityListReposStarredByUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    sort: z
      .enum(['created', 'updated'])
      .describe(
        'The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.'
      )
      .default('created'),
    direction: z
      .enum(['asc', 'desc'])
      .describe('The direction to sort the results by.')
      .default('desc'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReposStarredByUserParams = z.infer<
    typeof ActivityListReposStarredByUserParamsSchema
  >

  export const ActivityListReposStarredByUserResponseSchema = z.union([
    z.array(StarredRepositorySchema),
    z.array(RepositorySchema)
  ])
  export type ActivityListReposStarredByUserResponse = z.infer<
    typeof ActivityListReposStarredByUserResponseSchema
  >

  export const ActivityListReposWatchedByUserParamsSchema = z.object({
    username: z.string().describe('The handle for the GitHub user account.'),
    per_page: z
      .number()
      .int()
      .describe(
        'The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(30),
    page: z
      .number()
      .int()
      .describe(
        'The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."'
      )
      .default(1)
  })
  export type ActivityListReposWatchedByUserParams = z.infer<
    typeof ActivityListReposWatchedByUserParamsSchema
  >

  export const ActivityListReposWatchedByUserResponseSchema = z.array(
    MinimalRepositorySchema
  )
  export type ActivityListReposWatchedByUserResponse = z.infer<
    typeof ActivityListReposWatchedByUserResponseSchema
  >

  export const MetaGetAllVersionsParamsSchema = z.object({})
  export type MetaGetAllVersionsParams = z.infer<
    typeof MetaGetAllVersionsParamsSchema
  >

  export const MetaGetAllVersionsResponseSchema = z.array(z.string().date())
  export type MetaGetAllVersionsResponse = z.infer<
    typeof MetaGetAllVersionsResponseSchema
  >

  export const MetaGetZenParamsSchema = z.object({})
  export type MetaGetZenParams = z.infer<typeof MetaGetZenParamsSchema>

  export type MetaGetZenResponse = undefined
}

/**
 * Agentic Github client.
 *
 * GitHub's v3 REST API.
 */
export class GithubClient extends AIFunctionsProvider {
  protected readonly ky: KyInstance

  protected readonly apiBaseUrl: string

  constructor({
    apiBaseUrl = github.apiBaseUrl,
    ky = defaultKy
  }: {
    apiKey?: string
    apiBaseUrl?: string
    ky?: KyInstance
  } = {}) {
    super()

    this.apiBaseUrl = apiBaseUrl

    this.ky = ky.extend({
      prefixUrl: apiBaseUrl
    })
  }

  /**
   * Get Hypermedia links to resources accessible in GitHub's REST API.
   */
  @aiFunction({
    name: 'meta_root',
    description: `Get Hypermedia links to resources accessible in GitHub's REST API.`,
    inputSchema: github.MetaRootParamsSchema
  })
  async metaRoot(
    _params: github.MetaRootParams
  ): Promise<github.MetaRootResponse> {
    return this.ky.get('/').json<github.MetaRootResponse>()
  }

  /**
 * Lists all global security advisories that match the specified parameters. If no other parameters are defined, the request will return only GitHub-reviewed advisories that are not malware.

By default, all responses will exclude advisories for malware, because malware are not standard vulnerabilities. To list advisories for malware, you must include the `type` parameter in your request, with the value `malware`. For more information about the different types of security advisories, see "[About the GitHub Advisory database](https://docs.github.com/code-security/security-advisories/global-security-advisories/about-the-github-advisory-database#about-types-of-security-advisories).".
 */
  @aiFunction({
    name: 'security_advisories_list_global_advisories',
    description: `Lists all global security advisories that match the specified parameters. If no other parameters are defined, the request will return only GitHub-reviewed advisories that are not malware.

By default, all responses will exclude advisories for malware, because malware are not standard vulnerabilities. To list advisories for malware, you must include the \`type\` parameter in your request, with the value \`malware\`. For more information about the different types of security advisories, see "[About the GitHub Advisory database](https://docs.github.com/code-security/security-advisories/global-security-advisories/about-the-github-advisory-database#about-types-of-security-advisories).".`,
    inputSchema: github.SecurityAdvisoriesListGlobalAdvisoriesParamsSchema
  })
  async securityAdvisoriesListGlobalAdvisories(
    params: github.SecurityAdvisoriesListGlobalAdvisoriesParams
  ): Promise<github.SecurityAdvisoriesListGlobalAdvisoriesResponse> {
    return this.ky
      .get('/advisories', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'ghsa_id',
            'type',
            'cve_id',
            'ecosystem',
            'severity',
            'cwes',
            'is_withdrawn',
            'affects',
            'published',
            'updated',
            'modified',
            'epss_percentage',
            'epss_percentile',
            'before',
            'after',
            'direction',
            'per_page',
            'sort'
          )
        )
      })
      .json<github.SecurityAdvisoriesListGlobalAdvisoriesResponse>()
  }

  /**
   * Gets a global security advisory using its GitHub Security Advisory (GHSA) identifier.
   */
  @aiFunction({
    name: 'security_advisories_get_global_advisory',
    description: `Gets a global security advisory using its GitHub Security Advisory (GHSA) identifier.`,
    inputSchema: github.SecurityAdvisoriesGetGlobalAdvisoryParamsSchema
  })
  async securityAdvisoriesGetGlobalAdvisory(
    params: github.SecurityAdvisoriesGetGlobalAdvisoryParams
  ): Promise<github.SecurityAdvisoriesGetGlobalAdvisoryResponse> {
    return this.ky
      .get(`/advisories/${params.ghsa_id}`)
      .json<github.SecurityAdvisoriesGetGlobalAdvisoryResponse>()
  }

  /**
 * Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/rest/apps/apps#list-installations-for-the-authenticated-app)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_authenticated',
    description: `Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the \`installations_count\` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/rest/apps/apps#list-installations-for-the-authenticated-app)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetAuthenticatedParamsSchema
  })
  async appsGetAuthenticated(
    _params: github.AppsGetAuthenticatedParams
  ): Promise<github.AppsGetAuthenticatedResponse> {
    return this.ky.get('/app').json<github.AppsGetAuthenticatedResponse>()
  }

  /**
   * Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
   */
  @aiFunction({
    name: 'apps_create_from_manifest',
    description: `Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary \`code\` used to retrieve the GitHub App's \`id\`, \`pem\` (private key), and \`webhook_secret\`.`,
    inputSchema: github.AppsCreateFromManifestParamsSchema
  })
  async appsCreateFromManifest(
    params: github.AppsCreateFromManifestParams
  ): Promise<github.AppsCreateFromManifestResponse> {
    return this.ky
      .post(`/app-manifests/${params.code}/conversions`)
      .json<github.AppsCreateFromManifestResponse>()
  }

  /**
 * Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_webhook_config_for_app',
    description: `Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetWebhookConfigForAppParamsSchema
  })
  async appsGetWebhookConfigForApp(
    _params: github.AppsGetWebhookConfigForAppParams
  ): Promise<github.AppsGetWebhookConfigForAppResponse> {
    return this.ky
      .get('/app/hook/config')
      .json<github.AppsGetWebhookConfigForAppResponse>()
  }

  /**
 * Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_update_webhook_config_for_app',
    description: `Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsUpdateWebhookConfigForAppParamsSchema
  })
  async appsUpdateWebhookConfigForApp(
    params: github.AppsUpdateWebhookConfigForAppParams
  ): Promise<github.AppsUpdateWebhookConfigForAppResponse> {
    return this.ky
      .patch('/app/hook/config', {
        json: pick(params, 'url', 'content_type', 'secret', 'insecure_ssl')
      })
      .json<github.AppsUpdateWebhookConfigForAppResponse>()
  }

  /**
 * Returns a list of webhook deliveries for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_webhook_deliveries',
    description: `Returns a list of webhook deliveries for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsListWebhookDeliveriesParamsSchema
  })
  async appsListWebhookDeliveries(
    params: github.AppsListWebhookDeliveriesParams
  ): Promise<github.AppsListWebhookDeliveriesResponse> {
    return this.ky
      .get('/app/hook/deliveries', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'cursor'))
      })
      .json<github.AppsListWebhookDeliveriesResponse>()
  }

  /**
 * Returns a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_webhook_delivery',
    description: `Returns a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetWebhookDeliveryParamsSchema
  })
  async appsGetWebhookDelivery(
    params: github.AppsGetWebhookDeliveryParams
  ): Promise<github.AppsGetWebhookDeliveryResponse> {
    return this.ky
      .get(`/app/hook/deliveries/${params.delivery_id}`)
      .json<github.AppsGetWebhookDeliveryResponse>()
  }

  /**
 * Redeliver a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_redeliver_webhook_delivery',
    description: `Redeliver a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsRedeliverWebhookDeliveryParamsSchema
  })
  async appsRedeliverWebhookDelivery(
    params: github.AppsRedeliverWebhookDeliveryParams
  ): Promise<github.AppsRedeliverWebhookDeliveryResponse> {
    return this.ky
      .post(`/app/hook/deliveries/${params.delivery_id}/attempts`)
      .json<github.AppsRedeliverWebhookDeliveryResponse>()
  }

  /**
   * Lists all the pending installation requests for the authenticated GitHub App.
   */
  @aiFunction({
    name: 'apps_list_installation_requests_for_authenticated_app',
    description: `Lists all the pending installation requests for the authenticated GitHub App.`,
    inputSchema:
      github.AppsListInstallationRequestsForAuthenticatedAppParamsSchema
  })
  async appsListInstallationRequestsForAuthenticatedApp(
    params: github.AppsListInstallationRequestsForAuthenticatedAppParams
  ): Promise<github.AppsListInstallationRequestsForAuthenticatedAppResponse> {
    return this.ky
      .get('/app/installation-requests', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListInstallationRequestsForAuthenticatedAppResponse>()
  }

  /**
 * The permissions the installation has are included under the `permissions` key.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_installations',
    description: `The permissions the installation has are included under the \`permissions\` key.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsListInstallationsParamsSchema
  })
  async appsListInstallations(
    params: github.AppsListInstallationsParams
  ): Promise<github.AppsListInstallationsResponse> {
    return this.ky
      .get('/app/installations', {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'since', 'outdated')
        )
      })
      .json<github.AppsListInstallationsResponse>()
  }

  /**
 * Enables an authenticated GitHub App to find an installation's information using the installation id.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_installation',
    description: `Enables an authenticated GitHub App to find an installation's information using the installation id.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetInstallationParamsSchema
  })
  async appsGetInstallation(
    params: github.AppsGetInstallationParams
  ): Promise<github.AppsGetInstallationResponse> {
    return this.ky
      .get(`/app/installations/${params.installation_id}`)
      .json<github.AppsGetInstallationResponse>()
  }

  /**
 * Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/rest/apps/apps#suspend-an-app-installation)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_delete_installation',
    description: `Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/rest/apps/apps#suspend-an-app-installation)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsDeleteInstallationParamsSchema
  })
  async appsDeleteInstallation(
    params: github.AppsDeleteInstallationParams
  ): Promise<github.AppsDeleteInstallationResponse> {
    return this.ky
      .delete(`/app/installations/${params.installation_id}`)
      .json<github.AppsDeleteInstallationResponse>()
  }

  /**
 * Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access.

Optionally, you can use the `repositories` or `repository_ids` body parameters to specify individual repositories that the installation access token can access. If you don't use `repositories` or `repository_ids` to grant access to specific repositories, the installation access token will have access to all repositories that the installation was granted access to. The installation access token cannot be granted access to repositories that the installation was not granted access to. Up to 500 repositories can be listed in this manner.

Optionally, use the `permissions` body parameter to specify the permissions that the installation access token should have. If `permissions` is not specified, the installation access token will have all of the permissions that were granted to the app. The installation access token cannot be granted permissions that the app was not granted.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_create_installation_access_token',
    description: `Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of \`401 - Unauthorized\`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access.

Optionally, you can use the \`repositories\` or \`repository_ids\` body parameters to specify individual repositories that the installation access token can access. If you don't use \`repositories\` or \`repository_ids\` to grant access to specific repositories, the installation access token will have access to all repositories that the installation was granted access to. The installation access token cannot be granted access to repositories that the installation was not granted access to. Up to 500 repositories can be listed in this manner.

Optionally, use the \`permissions\` body parameter to specify the permissions that the installation access token should have. If \`permissions\` is not specified, the installation access token will have all of the permissions that were granted to the app. The installation access token cannot be granted permissions that the app was not granted.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsCreateInstallationAccessTokenParamsSchema
  })
  async appsCreateInstallationAccessToken(
    params: github.AppsCreateInstallationAccessTokenParams
  ): Promise<github.AppsCreateInstallationAccessTokenResponse> {
    return this.ky
      .post(`/app/installations/${params.installation_id}/access_tokens`, {
        json: pick(params, 'repositories', 'repository_ids', 'permissions')
      })
      .json<github.AppsCreateInstallationAccessTokenResponse>()
  }

  /**
 * Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_suspend_installation',
    description: `Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsSuspendInstallationParamsSchema
  })
  async appsSuspendInstallation(
    params: github.AppsSuspendInstallationParams
  ): Promise<github.AppsSuspendInstallationResponse> {
    return this.ky
      .put(`/app/installations/${params.installation_id}/suspended`)
      .json<github.AppsSuspendInstallationResponse>()
  }

  /**
 * Removes a GitHub App installation suspension.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_unsuspend_installation',
    description: `Removes a GitHub App installation suspension.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsUnsuspendInstallationParamsSchema
  })
  async appsUnsuspendInstallation(
    params: github.AppsUnsuspendInstallationParams
  ): Promise<github.AppsUnsuspendInstallationResponse> {
    return this.ky
      .delete(`/app/installations/${params.installation_id}/suspended`)
      .json<github.AppsUnsuspendInstallationResponse>()
  }

  /**
 * OAuth and GitHub application owners can revoke a grant for their application and a specific user. You must provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.
Deleting an application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
 */
  @aiFunction({
    name: 'apps_delete_authorization',
    description: `OAuth and GitHub application owners can revoke a grant for their application and a specific user. You must provide a valid OAuth \`access_token\` as an input parameter and the grant for the token's owner will be deleted.
Deleting an application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).`,
    inputSchema: github.AppsDeleteAuthorizationParamsSchema
  })
  async appsDeleteAuthorization(
    params: github.AppsDeleteAuthorizationParams
  ): Promise<github.AppsDeleteAuthorizationResponse> {
    return this.ky
      .delete(`/applications/${params.client_id}/grant`, {
        json: pick(params, 'access_token')
      })
      .json<github.AppsDeleteAuthorizationResponse>()
  }

  /**
   * OAuth applications and GitHub applications with OAuth authorizations can use this API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. Invalid tokens will return `404 NOT FOUND`.
   */
  @aiFunction({
    name: 'apps_check_token',
    description: `OAuth applications and GitHub applications with OAuth authorizations can use this API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. Invalid tokens will return \`404 NOT FOUND\`.`,
    inputSchema: github.AppsCheckTokenParamsSchema
  })
  async appsCheckToken(
    params: github.AppsCheckTokenParams
  ): Promise<github.AppsCheckTokenResponse> {
    return this.ky
      .post(`/applications/${params.client_id}/token`, {
        json: pick(params, 'access_token')
      })
      .json<github.AppsCheckTokenResponse>()
  }

  /**
   * OAuth  or GitHub application owners can revoke a single token for an OAuth application or a GitHub application with an OAuth authorization.
   */
  @aiFunction({
    name: 'apps_delete_token',
    description: `OAuth  or GitHub application owners can revoke a single token for an OAuth application or a GitHub application with an OAuth authorization.`,
    inputSchema: github.AppsDeleteTokenParamsSchema
  })
  async appsDeleteToken(
    params: github.AppsDeleteTokenParams
  ): Promise<github.AppsDeleteTokenResponse> {
    return this.ky
      .delete(`/applications/${params.client_id}/token`, {
        json: pick(params, 'access_token')
      })
      .json<github.AppsDeleteTokenResponse>()
  }

  /**
   * OAuth applications and GitHub applications with OAuth authorizations can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. Invalid tokens will return `404 NOT FOUND`.
   */
  @aiFunction({
    name: 'apps_reset_token',
    description: `OAuth applications and GitHub applications with OAuth authorizations can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. Invalid tokens will return \`404 NOT FOUND\`.`,
    inputSchema: github.AppsResetTokenParamsSchema
  })
  async appsResetToken(
    params: github.AppsResetTokenParams
  ): Promise<github.AppsResetTokenResponse> {
    return this.ky
      .patch(`/applications/${params.client_id}/token`, {
        json: pick(params, 'access_token')
      })
      .json<github.AppsResetTokenResponse>()
  }

  /**
 * Use a non-scoped user access token to create a repository-scoped and/or permission-scoped user access token. You can specify
which repositories the token can access and which permissions are granted to the
token.

Invalid tokens will return `404 NOT FOUND`.
 */
  @aiFunction({
    name: 'apps_scope_token',
    description: `Use a non-scoped user access token to create a repository-scoped and/or permission-scoped user access token. You can specify
which repositories the token can access and which permissions are granted to the
token.

Invalid tokens will return \`404 NOT FOUND\`.`,
    inputSchema: github.AppsScopeTokenParamsSchema
  })
  async appsScopeToken(
    params: github.AppsScopeTokenParams
  ): Promise<github.AppsScopeTokenResponse> {
    return this.ky
      .post(`/applications/${params.client_id}/token/scoped`, {
        json: pick(
          params,
          'access_token',
          'target',
          'target_id',
          'repositories',
          'repository_ids',
          'permissions'
        )
      })
      .json<github.AppsScopeTokenResponse>()
  }

  /**
 * > [!NOTE]
> The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
 */
  @aiFunction({
    name: 'apps_get_by_slug',
    description: `> [!NOTE]
> The \`:app_slug\` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., \`https://github.com/settings/apps/:app_slug\`).`,
    inputSchema: github.AppsGetBySlugParamsSchema
  })
  async appsGetBySlug(
    params: github.AppsGetBySlugParams
  ): Promise<github.AppsGetBySlugResponse> {
    return this.ky
      .get(`/apps/${params.app_slug}`)
      .json<github.AppsGetBySlugResponse>()
  }

  /**
   * Gets a GitHub Classroom assignment. Assignment will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.
   */
  @aiFunction({
    name: 'classroom_get_an_assignment',
    description: `Gets a GitHub Classroom assignment. Assignment will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.`,
    inputSchema: github.ClassroomGetAnAssignmentParamsSchema
  })
  async classroomGetAnAssignment(
    params: github.ClassroomGetAnAssignmentParams
  ): Promise<github.ClassroomGetAnAssignmentResponse> {
    return this.ky
      .get(`/assignments/${params.assignment_id}`)
      .json<github.ClassroomGetAnAssignmentResponse>()
  }

  /**
   * Lists any assignment repositories that have been created by students accepting a GitHub Classroom assignment. Accepted assignments will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.
   */
  @aiFunction({
    name: 'classroom_list_accepted_assignments_for_an_assignment',
    description: `Lists any assignment repositories that have been created by students accepting a GitHub Classroom assignment. Accepted assignments will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.`,
    inputSchema:
      github.ClassroomListAcceptedAssignmentsForAnAssignmentParamsSchema
  })
  async classroomListAcceptedAssignmentsForAnAssignment(
    params: github.ClassroomListAcceptedAssignmentsForAnAssignmentParams
  ): Promise<github.ClassroomListAcceptedAssignmentsForAnAssignmentResponse> {
    return this.ky
      .get(`/assignments/${params.assignment_id}/accepted_assignments`, {
        searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
      })
      .json<github.ClassroomListAcceptedAssignmentsForAnAssignmentResponse>()
  }

  /**
   * Gets grades for a GitHub Classroom assignment. Grades will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.
   */
  @aiFunction({
    name: 'classroom_get_assignment_grades',
    description: `Gets grades for a GitHub Classroom assignment. Grades will only be returned if the current user is an administrator of the GitHub Classroom for the assignment.`,
    inputSchema: github.ClassroomGetAssignmentGradesParamsSchema
  })
  async classroomGetAssignmentGrades(
    params: github.ClassroomGetAssignmentGradesParams
  ): Promise<github.ClassroomGetAssignmentGradesResponse> {
    return this.ky
      .get(`/assignments/${params.assignment_id}/grades`)
      .json<github.ClassroomGetAssignmentGradesResponse>()
  }

  /**
   * Lists GitHub Classroom classrooms for the current user. Classrooms will only be returned if the current user is an administrator of one or more GitHub Classrooms.
   */
  @aiFunction({
    name: 'classroom_list_classrooms',
    description: `Lists GitHub Classroom classrooms for the current user. Classrooms will only be returned if the current user is an administrator of one or more GitHub Classrooms.`,
    inputSchema: github.ClassroomListClassroomsParamsSchema
  })
  async classroomListClassrooms(
    params: github.ClassroomListClassroomsParams
  ): Promise<github.ClassroomListClassroomsResponse> {
    return this.ky
      .get('/classrooms', {
        searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
      })
      .json<github.ClassroomListClassroomsResponse>()
  }

  /**
   * Gets a GitHub Classroom classroom for the current user. Classroom will only be returned if the current user is an administrator of the GitHub Classroom.
   */
  @aiFunction({
    name: 'classroom_get_a_classroom',
    description: `Gets a GitHub Classroom classroom for the current user. Classroom will only be returned if the current user is an administrator of the GitHub Classroom.`,
    inputSchema: github.ClassroomGetAclassroomParamsSchema
  })
  async classroomGetAClassroom(
    params: github.ClassroomGetAclassroomParams
  ): Promise<github.ClassroomGetAclassroomResponse> {
    return this.ky
      .get(`/classrooms/${params.classroom_id}`)
      .json<github.ClassroomGetAclassroomResponse>()
  }

  /**
   * Lists GitHub Classroom assignments for a classroom. Assignments will only be returned if the current user is an administrator of the GitHub Classroom.
   */
  @aiFunction({
    name: 'classroom_list_assignments_for_a_classroom',
    description: `Lists GitHub Classroom assignments for a classroom. Assignments will only be returned if the current user is an administrator of the GitHub Classroom.`,
    inputSchema: github.ClassroomListAssignmentsForAclassroomParamsSchema
  })
  async classroomListAssignmentsForAClassroom(
    params: github.ClassroomListAssignmentsForAclassroomParams
  ): Promise<github.ClassroomListAssignmentsForAclassroomResponse> {
    return this.ky
      .get(`/classrooms/${params.classroom_id}/assignments`, {
        searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
      })
      .json<github.ClassroomListAssignmentsForAclassroomResponse>()
  }

  /**
   * Returns array of all GitHub's codes of conduct.
   */
  @aiFunction({
    name: 'codes_of_conduct_get_all_codes_of_conduct',
    description: `Returns array of all GitHub's codes of conduct.`,
    inputSchema: github.CodesOfConductGetAllCodesOfConductParamsSchema
  })
  async codesOfConductGetAllCodesOfConduct(
    _params: github.CodesOfConductGetAllCodesOfConductParams
  ): Promise<github.CodesOfConductGetAllCodesOfConductResponse> {
    return this.ky
      .get('/codes_of_conduct')
      .json<github.CodesOfConductGetAllCodesOfConductResponse>()
  }

  /**
   * Returns information about the specified GitHub code of conduct.
   */
  @aiFunction({
    name: 'codes_of_conduct_get_conduct_code',
    description: `Returns information about the specified GitHub code of conduct.`,
    inputSchema: github.CodesOfConductGetConductCodeParamsSchema
  })
  async codesOfConductGetConductCode(
    params: github.CodesOfConductGetConductCodeParams
  ): Promise<github.CodesOfConductGetConductCodeResponse> {
    return this.ky
      .get(`/codes_of_conduct/${params.key}`)
      .json<github.CodesOfConductGetConductCodeResponse>()
  }

  /**
   * Lists all the emojis available to use on GitHub.
   */
  @aiFunction({
    name: 'emojis_get',
    description: `Lists all the emojis available to use on GitHub.`,
    inputSchema: github.EmojisGetParamsSchema
  })
  async emojisGet(
    _params: github.EmojisGetParams
  ): Promise<github.EmojisGetResponse> {
    return this.ky.get('/emojis').json<github.EmojisGetResponse>()
  }

  /**
 * Lists all code security configurations available in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_configurations_for_enterprise',
    description: `Lists all code security configurations available in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:enterprise\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetConfigurationsForEnterpriseParamsSchema
  })
  async codeSecurityGetConfigurationsForEnterprise(
    params: github.CodeSecurityGetConfigurationsForEnterpriseParams
  ): Promise<github.CodeSecurityGetConfigurationsForEnterpriseResponse> {
    return this.ky
      .get(
        `/enterprises/${params.enterprise}/code-security/configurations`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'before', 'after')
          )
        }
      )
      .json<github.CodeSecurityGetConfigurationsForEnterpriseResponse>()
  }

  /**
 * Creates a code security configuration in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_create_configuration_for_enterprise',
    description: `Creates a code security configuration in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:enterprise\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityCreateConfigurationForEnterpriseParamsSchema
  })
  async codeSecurityCreateConfigurationForEnterprise(
    params: github.CodeSecurityCreateConfigurationForEnterpriseParams
  ): Promise<github.CodeSecurityCreateConfigurationForEnterpriseResponse> {
    return this.ky
      .post(
        `/enterprises/${params.enterprise}/code-security/configurations`,
        {
          json: pick(
            params,
            'name',
            'description',
            'advanced_security',
            'dependency_graph',
            'dependency_graph_autosubmit_action',
            'dependency_graph_autosubmit_action_options',
            'dependabot_alerts',
            'dependabot_security_updates',
            'code_scanning_default_setup',
            'code_scanning_default_setup_options',
            'code_scanning_delegated_alert_dismissal',
            'secret_scanning',
            'secret_scanning_push_protection',
            'secret_scanning_validity_checks',
            'secret_scanning_non_provider_patterns',
            'secret_scanning_generic_secrets',
            'secret_scanning_delegated_alert_dismissal',
            'private_vulnerability_reporting',
            'enforcement'
          )
        }
      )
      .json<github.CodeSecurityCreateConfigurationForEnterpriseResponse>()
  }

  /**
 * Lists the default code security configurations for an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_default_configurations_for_enterprise',
    description: `Lists the default code security configurations for an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:enterprise\` scope to use this endpoint.`,
    inputSchema:
      github.CodeSecurityGetDefaultConfigurationsForEnterpriseParamsSchema
  })
  async codeSecurityGetDefaultConfigurationsForEnterprise(
    params: github.CodeSecurityGetDefaultConfigurationsForEnterpriseParams
  ): Promise<github.CodeSecurityGetDefaultConfigurationsForEnterpriseResponse> {
    return this.ky
      .get(
        `/enterprises/${params.enterprise}/code-security/configurations/defaults`
      )
      .json<github.CodeSecurityGetDefaultConfigurationsForEnterpriseResponse>()
  }

  /**
 * Gets a code security configuration available in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_single_configuration_for_enterprise',
    description: `Gets a code security configuration available in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:enterprise\` scope to use this endpoint.`,
    inputSchema:
      github.CodeSecurityGetSingleConfigurationForEnterpriseParamsSchema
  })
  async codeSecurityGetSingleConfigurationForEnterprise(
    params: github.CodeSecurityGetSingleConfigurationForEnterpriseParams
  ): Promise<github.CodeSecurityGetSingleConfigurationForEnterpriseResponse> {
    return this.ky
      .get(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}`,
        {}
      )
      .json<github.CodeSecurityGetSingleConfigurationForEnterpriseResponse>()
  }

  /**
 * Deletes a code security configuration from an enterprise.
Repositories attached to the configuration will retain their settings but will no longer be associated with
the configuration.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_delete_configuration_for_enterprise',
    description: `Deletes a code security configuration from an enterprise.
Repositories attached to the configuration will retain their settings but will no longer be associated with
the configuration.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:enterprise\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityDeleteConfigurationForEnterpriseParamsSchema
  })
  async codeSecurityDeleteConfigurationForEnterprise(
    params: github.CodeSecurityDeleteConfigurationForEnterpriseParams
  ): Promise<github.CodeSecurityDeleteConfigurationForEnterpriseResponse> {
    return this.ky
      .delete(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}`,
        {}
      )
      .json<github.CodeSecurityDeleteConfigurationForEnterpriseResponse>()
  }

  /**
 * Updates a code security configuration in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_update_enterprise_configuration',
    description: `Updates a code security configuration in an enterprise.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:enterprise\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityUpdateEnterpriseConfigurationParamsSchema
  })
  async codeSecurityUpdateEnterpriseConfiguration(
    params: github.CodeSecurityUpdateEnterpriseConfigurationParams
  ): Promise<github.CodeSecurityUpdateEnterpriseConfigurationResponse> {
    return this.ky
      .patch(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}`,
        {
          json: pick(
            params,
            'name',
            'description',
            'advanced_security',
            'dependency_graph',
            'dependency_graph_autosubmit_action',
            'dependency_graph_autosubmit_action_options',
            'dependabot_alerts',
            'dependabot_security_updates',
            'code_scanning_default_setup',
            'code_scanning_default_setup_options',
            'code_scanning_delegated_alert_dismissal',
            'secret_scanning',
            'secret_scanning_push_protection',
            'secret_scanning_validity_checks',
            'secret_scanning_non_provider_patterns',
            'secret_scanning_generic_secrets',
            'secret_scanning_delegated_alert_dismissal',
            'private_vulnerability_reporting',
            'enforcement'
          )
        }
      )
      .json<github.CodeSecurityUpdateEnterpriseConfigurationResponse>()
  }

  /**
 * Attaches an enterprise code security configuration to repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.

If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_attach_enterprise_configuration',
    description: `Attaches an enterprise code security configuration to repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.

If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:enterprise\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityAttachEnterpriseConfigurationParamsSchema
  })
  async codeSecurityAttachEnterpriseConfiguration(
    params: github.CodeSecurityAttachEnterpriseConfigurationParams
  ): Promise<github.CodeSecurityAttachEnterpriseConfigurationResponse> {
    return this.ky
      .post(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}/attach`,
        {
          json: pick(params, 'scope')
        }
      )
      .json<github.CodeSecurityAttachEnterpriseConfigurationResponse>()
  }

  /**
 * Sets a code security configuration as a default to be applied to new repositories in your enterprise.

This configuration will be applied by default to the matching repository type when created, but only for organizations within the enterprise that do not already have a default code security configuration set.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_set_configuration_as_default_for_enterprise',
    description: `Sets a code security configuration as a default to be applied to new repositories in your enterprise.

This configuration will be applied by default to the matching repository type when created, but only for organizations within the enterprise that do not already have a default code security configuration set.

The authenticated user must be an administrator for the enterprise to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:enterprise\` scope to use this endpoint.`,
    inputSchema:
      github.CodeSecuritySetConfigurationAsDefaultForEnterpriseParamsSchema
  })
  async codeSecuritySetConfigurationAsDefaultForEnterprise(
    params: github.CodeSecuritySetConfigurationAsDefaultForEnterpriseParams
  ): Promise<github.CodeSecuritySetConfigurationAsDefaultForEnterpriseResponse> {
    return this.ky
      .put(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}/defaults`,
        {
          json: pick(params, 'default_for_new_repos')
        }
      )
      .json<github.CodeSecuritySetConfigurationAsDefaultForEnterpriseResponse>()
  }

  /**
 * Lists the repositories associated with an enterprise code security configuration in an organization.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_repositories_for_enterprise_configuration',
    description: `Lists the repositories associated with an enterprise code security configuration in an organization.

The authenticated user must be an administrator of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:enterprise\` scope to use this endpoint.`,
    inputSchema:
      github.CodeSecurityGetRepositoriesForEnterpriseConfigurationParamsSchema
  })
  async codeSecurityGetRepositoriesForEnterpriseConfiguration(
    params: github.CodeSecurityGetRepositoriesForEnterpriseConfigurationParams
  ): Promise<github.CodeSecurityGetRepositoriesForEnterpriseConfigurationResponse> {
    return this.ky
      .get(
        `/enterprises/${params.enterprise}/code-security/configurations/${params.configuration_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'before', 'after', 'status')
          )
        }
      )
      .json<github.CodeSecurityGetRepositoriesForEnterpriseConfigurationResponse>()
  }

  /**
 * Lists Dependabot alerts for repositories that are owned by the specified enterprise.

The authenticated user must be a member of the enterprise to use this endpoint.

Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_list_alerts_for_enterprise',
    description: `Lists Dependabot alerts for repositories that are owned by the specified enterprise.

The authenticated user must be a member of the enterprise to use this endpoint.

Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint.`,
    inputSchema: github.DependabotListAlertsForEnterpriseParamsSchema
  })
  async dependabotListAlertsForEnterprise(
    params: github.DependabotListAlertsForEnterpriseParams
  ): Promise<github.DependabotListAlertsForEnterpriseResponse> {
    return this.ky
      .get(`/enterprises/${params.enterprise}/dependabot/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'severity',
            'ecosystem',
            'package',
            'epss_percentage',
            'scope',
            'sort',
            'direction',
            'before',
            'after',
            'first',
            'last',
            'per_page'
          )
        )
      })
      .json<github.DependabotListAlertsForEnterpriseResponse>()
  }

  /**
 * Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.

Alerts are only returned for organizations in the enterprise for which the authenticated user is an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).

The authenticated user must be a member of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope or `security_events` scope to use this endpoint.
 */
  @aiFunction({
    name: 'secret_scanning_list_alerts_for_enterprise',
    description: `Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.

Alerts are only returned for organizations in the enterprise for which the authenticated user is an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).

The authenticated user must be a member of the enterprise in order to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope or \`security_events\` scope to use this endpoint.`,
    inputSchema: github.SecretScanningListAlertsForEnterpriseParamsSchema
  })
  async secretScanningListAlertsForEnterprise(
    params: github.SecretScanningListAlertsForEnterpriseParams
  ): Promise<github.SecretScanningListAlertsForEnterpriseResponse> {
    return this.ky
      .get(`/enterprises/${params.enterprise}/secret-scanning/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'secret_type',
            'resolution',
            'sort',
            'direction',
            'per_page',
            'before',
            'after',
            'validity',
            'is_publicly_leaked',
            'is_multi_repo'
          )
        )
      })
      .json<github.SecretScanningListAlertsForEnterpriseResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_public_events',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListPublicEventsParamsSchema
  })
  async activityListPublicEvents(
    params: github.ActivityListPublicEventsParams
  ): Promise<github.ActivityListPublicEventsResponse> {
    return this.ky
      .get('/events', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListPublicEventsResponse>()
  }

  /**
 * Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.

*   **Timeline**: The GitHub global public timeline
*   **User**: The public timeline for any user, using `uri_template`. For more information, see "[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
*   **Current user public**: The public timeline for the authenticated user
*   **Current user**: The private timeline for the authenticated user
*   **Current user actor**: The private timeline for activity created by the authenticated user
*   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
*   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.

By default, timeline resources are returned in JSON. You can specify the `application/atom+xml` type in the `Accept` header to return timeline resources in Atom format. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

> [!NOTE]
> Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.
 */
  @aiFunction({
    name: 'activity_get_feeds',
    description: `Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.

*   **Timeline**: The GitHub global public timeline
*   **User**: The public timeline for any user, using \`uri_template\`. For more information, see "[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
*   **Current user public**: The public timeline for the authenticated user
*   **Current user**: The private timeline for the authenticated user
*   **Current user actor**: The private timeline for activity created by the authenticated user
*   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
*   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.

By default, timeline resources are returned in JSON. You can specify the \`application/atom+xml\` type in the \`Accept\` header to return timeline resources in Atom format. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

> [!NOTE]
> Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.`,
    inputSchema: github.ActivityGetFeedsParamsSchema
  })
  async activityGetFeeds(
    _params: github.ActivityGetFeedsParams
  ): Promise<github.ActivityGetFeedsResponse> {
    return this.ky.get('/feeds').json<github.ActivityGetFeedsResponse>()
  }

  /**
   * Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:.
   */
  @aiFunction({
    name: 'gists_list',
    description: `Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:.`,
    inputSchema: github.GistsListParamsSchema
  })
  async gistsList(
    params: github.GistsListParams
  ): Promise<github.GistsListResponse> {
    return this.ky
      .get('/gists', {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'per_page', 'page')
        )
      })
      .json<github.GistsListResponse>()
  }

  /**
 * Allows you to add a new gist with one or more files.

> [!NOTE]
> Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
 */
  @aiFunction({
    name: 'gists_create',
    description: `Allows you to add a new gist with one or more files.

> [!NOTE]
> Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.`,
    inputSchema: github.GistsCreateParamsSchema
  })
  async gistsCreate(
    params: github.GistsCreateParams
  ): Promise<github.GistsCreateResponse> {
    return this.ky
      .post('/gists', {
        json: pick(params, 'description', 'files', 'public')
      })
      .json<github.GistsCreateResponse>()
  }

  /**
 * List public gists sorted by most recently updated to least recently updated.

Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
 */
  @aiFunction({
    name: 'gists_list_public',
    description: `List public gists sorted by most recently updated to least recently updated.

Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.`,
    inputSchema: github.GistsListPublicParamsSchema
  })
  async gistsListPublic(
    params: github.GistsListPublicParams
  ): Promise<github.GistsListPublicResponse> {
    return this.ky
      .get('/gists/public', {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'per_page', 'page')
        )
      })
      .json<github.GistsListPublicResponse>()
  }

  /**
   * List the authenticated user's starred gists:.
   */
  @aiFunction({
    name: 'gists_list_starred',
    description: `List the authenticated user's starred gists:.`,
    inputSchema: github.GistsListStarredParamsSchema
  })
  async gistsListStarred(
    params: github.GistsListStarredParams
  ): Promise<github.GistsListStarredResponse> {
    return this.ky
      .get('/gists/starred', {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'per_page', 'page')
        )
      })
      .json<github.GistsListStarredResponse>()
  }

  /**
 * Gets a specified gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_get',
    description: `Gets a specified gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsGetParamsSchema
  })
  async gistsGet(
    params: github.GistsGetParams
  ): Promise<github.GistsGetResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}`)
      .json<github.GistsGetResponse>()
  }

  /**
   * Delete a gist.
   */
  @aiFunction({
    name: 'gists_delete',
    description: `Delete a gist.`,
    inputSchema: github.GistsDeleteParamsSchema
  })
  async gistsDelete(
    params: github.GistsDeleteParams
  ): Promise<github.GistsDeleteResponse> {
    return this.ky
      .delete(`/gists/${params.gist_id}`)
      .json<github.GistsDeleteResponse>()
  }

  /**
 * Allows you to update a gist's description and to update, delete, or rename gist files. Files
from the previous version of the gist that aren't explicitly changed during an edit
are unchanged.

At least one of `description` or `files` is required.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_update',
    description: `Allows you to update a gist's description and to update, delete, or rename gist files. Files
from the previous version of the gist that aren't explicitly changed during an edit
are unchanged.

At least one of \`description\` or \`files\` is required.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsUpdateParamsSchema
  })
  async gistsUpdate(
    params: github.GistsUpdateParams
  ): Promise<github.GistsUpdateResponse> {
    return this.ky
      .patch(`/gists/${params.gist_id}`, {
        json: pick(params, 'description', 'files')
      })
      .json<github.GistsUpdateResponse>()
  }

  /**
 * Lists the comments on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_list_comments',
    description: `Lists the comments on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsListCommentsParamsSchema
  })
  async gistsListComments(
    params: github.GistsListCommentsParams
  ): Promise<github.GistsListCommentsResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/comments`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.GistsListCommentsResponse>()
  }

  /**
 * Creates a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_create_comment',
    description: `Creates a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsCreateCommentParamsSchema
  })
  async gistsCreateComment(
    params: github.GistsCreateCommentParams
  ): Promise<github.GistsCreateCommentResponse> {
    return this.ky
      .post(`/gists/${params.gist_id}/comments`, {
        json: pick(params, 'body')
      })
      .json<github.GistsCreateCommentResponse>()
  }

  /**
 * Gets a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_get_comment',
    description: `Gets a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsGetCommentParamsSchema
  })
  async gistsGetComment(
    params: github.GistsGetCommentParams
  ): Promise<github.GistsGetCommentResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/comments/${params.comment_id}`, {})
      .json<github.GistsGetCommentResponse>()
  }

  /**
   * Delete a gist comment.
   */
  @aiFunction({
    name: 'gists_delete_comment',
    description: `Delete a gist comment.`,
    inputSchema: github.GistsDeleteCommentParamsSchema
  })
  async gistsDeleteComment(
    params: github.GistsDeleteCommentParams
  ): Promise<github.GistsDeleteCommentResponse> {
    return this.ky
      .delete(
        `/gists/${params.gist_id}/comments/${params.comment_id}`,
        {}
      )
      .json<github.GistsDeleteCommentResponse>()
  }

  /**
 * Updates a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_update_comment',
    description: `Updates a comment on a gist.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsUpdateCommentParamsSchema
  })
  async gistsUpdateComment(
    params: github.GistsUpdateCommentParams
  ): Promise<github.GistsUpdateCommentResponse> {
    return this.ky
      .patch(`/gists/${params.gist_id}/comments/${params.comment_id}`, {
        json: pick(params, 'body')
      })
      .json<github.GistsUpdateCommentResponse>()
  }

  /**
   * List gist commits.
   */
  @aiFunction({
    name: 'gists_list_commits',
    description: `List gist commits.`,
    inputSchema: github.GistsListCommitsParamsSchema
  })
  async gistsListCommits(
    params: github.GistsListCommitsParams
  ): Promise<github.GistsListCommitsResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/commits`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.GistsListCommitsResponse>()
  }

  /**
   * List gist forks.
   */
  @aiFunction({
    name: 'gists_list_forks',
    description: `List gist forks.`,
    inputSchema: github.GistsListForksParamsSchema
  })
  async gistsListForks(
    params: github.GistsListForksParams
  ): Promise<github.GistsListForksResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/forks`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.GistsListForksResponse>()
  }

  /**
   * Fork a gist.
   */
  @aiFunction({
    name: 'gists_fork',
    description: `Fork a gist.`,
    inputSchema: github.GistsForkParamsSchema
  })
  async gistsFork(
    params: github.GistsForkParams
  ): Promise<github.GistsForkResponse> {
    return this.ky
      .post(`/gists/${params.gist_id}/forks`)
      .json<github.GistsForkResponse>()
  }

  /**
   * Check if a gist is starred.
   */
  @aiFunction({
    name: 'gists_check_is_starred',
    description: `Check if a gist is starred.`,
    inputSchema: github.GistsCheckIsStarredParamsSchema
  })
  async gistsCheckIsStarred(
    params: github.GistsCheckIsStarredParams
  ): Promise<github.GistsCheckIsStarredResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/star`)
      .json<github.GistsCheckIsStarredResponse>()
  }

  /**
   * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
   */
  @aiFunction({
    name: 'gists_star',
    description: `Note that you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.GistsStarParamsSchema
  })
  async gistsStar(
    params: github.GistsStarParams
  ): Promise<github.GistsStarResponse> {
    return this.ky
      .put(`/gists/${params.gist_id}/star`)
      .json<github.GistsStarResponse>()
  }

  /**
   * Unstar a gist.
   */
  @aiFunction({
    name: 'gists_unstar',
    description: `Unstar a gist.`,
    inputSchema: github.GistsUnstarParamsSchema
  })
  async gistsUnstar(
    params: github.GistsUnstarParams
  ): Promise<github.GistsUnstarResponse> {
    return this.ky
      .delete(`/gists/${params.gist_id}/star`)
      .json<github.GistsUnstarResponse>()
  }

  /**
 * Gets a specified gist revision.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
 */
  @aiFunction({
    name: 'gists_get_revision',
    description: `Gets a specified gist revision.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.base64+json\`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.`,
    inputSchema: github.GistsGetRevisionParamsSchema
  })
  async gistsGetRevision(
    params: github.GistsGetRevisionParams
  ): Promise<github.GistsGetRevisionResponse> {
    return this.ky
      .get(`/gists/${params.gist_id}/${params.sha}`, {})
      .json<github.GistsGetRevisionResponse>()
  }

  /**
   * List all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/repos/repos#create-a-repository-for-the-authenticated-user).
   */
  @aiFunction({
    name: 'gitignore_get_all_templates',
    description: `List all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/repos/repos#create-a-repository-for-the-authenticated-user).`,
    inputSchema: github.GitignoreGetAllTemplatesParamsSchema
  })
  async gitignoreGetAllTemplates(
    _params: github.GitignoreGetAllTemplatesParams
  ): Promise<github.GitignoreGetAllTemplatesResponse> {
    return this.ky
      .get('/gitignore/templates')
      .json<github.GitignoreGetAllTemplatesResponse>()
  }

  /**
 * Get the content of a gitignore template.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw .gitignore contents.
 */
  @aiFunction({
    name: 'gitignore_get_template',
    description: `Get the content of a gitignore template.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw .gitignore contents.`,
    inputSchema: github.GitignoreGetTemplateParamsSchema
  })
  async gitignoreGetTemplate(
    params: github.GitignoreGetTemplateParams
  ): Promise<github.GitignoreGetTemplateResponse> {
    return this.ky
      .get(`/gitignore/templates/${params.name}`)
      .json<github.GitignoreGetTemplateResponse>()
  }

  /**
   * List repositories that an app installation can access.
   */
  @aiFunction({
    name: 'apps_list_repos_accessible_to_installation',
    description: `List repositories that an app installation can access.`,
    inputSchema: github.AppsListReposAccessibleToInstallationParamsSchema
  })
  async appsListReposAccessibleToInstallation(
    params: github.AppsListReposAccessibleToInstallationParams
  ): Promise<github.AppsListReposAccessibleToInstallationResponse> {
    return this.ky
      .get('/installation/repositories', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListReposAccessibleToInstallationResponse>()
  }

  /**
 * Revokes the installation token you're using to authenticate as an installation and access this endpoint.

Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/rest/apps/apps#create-an-installation-access-token-for-an-app)" endpoint.
 */
  @aiFunction({
    name: 'apps_revoke_installation_access_token',
    description: `Revokes the installation token you're using to authenticate as an installation and access this endpoint.

Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/rest/apps/apps#create-an-installation-access-token-for-an-app)" endpoint.`,
    inputSchema: github.AppsRevokeInstallationAccessTokenParamsSchema
  })
  async appsRevokeInstallationAccessToken(
    _params: github.AppsRevokeInstallationAccessTokenParams
  ): Promise<github.AppsRevokeInstallationAccessTokenResponse> {
    return this.ky
      .delete('/installation/token')
      .json<github.AppsRevokeInstallationAccessTokenResponse>()
  }

  /**
 * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
necessarily assigned to you.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list',
    description: `List issues assigned to the authenticated user across all visible repositories including owned repositories, member
repositories, and organization repositories. You can use the \`filter\` query parameter to fetch issues that are not
necessarily assigned to you.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the \`pull_request\` key. Be aware that the \`id\` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListParamsSchema
  })
  async issuesList(
    params: github.IssuesListParams
  ): Promise<github.IssuesListResponse> {
    return this.ky
      .get('/issues', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'filter',
            'state',
            'labels',
            'sort',
            'direction',
            'since',
            'collab',
            'orgs',
            'owned',
            'pulls',
            'per_page',
            'page'
          )
        )
      })
      .json<github.IssuesListResponse>()
  }

  /**
   * Lists the most commonly used licenses on GitHub. For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository).".
   */
  @aiFunction({
    name: 'licenses_get_all_commonly_used',
    description: `Lists the most commonly used licenses on GitHub. For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository).".`,
    inputSchema: github.LicensesGetAllCommonlyUsedParamsSchema
  })
  async licensesGetAllCommonlyUsed(
    params: github.LicensesGetAllCommonlyUsedParams
  ): Promise<github.LicensesGetAllCommonlyUsedResponse> {
    return this.ky
      .get('/licenses', {
        searchParams: sanitizeSearchParams(
          pick(params, 'featured', 'per_page', 'page')
        )
      })
      .json<github.LicensesGetAllCommonlyUsedResponse>()
  }

  /**
   * Gets information about a specific license. For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository).".
   */
  @aiFunction({
    name: 'licenses_get',
    description: `Gets information about a specific license. For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository).".`,
    inputSchema: github.LicensesGetParamsSchema
  })
  async licensesGet(
    params: github.LicensesGetParams
  ): Promise<github.LicensesGetResponse> {
    return this.ky
      .get(`/licenses/${params.license}`)
      .json<github.LicensesGetResponse>()
  }

  /**
   * Render a Markdown document.
   */
  @aiFunction({
    name: 'markdown_render',
    description: `Render a Markdown document.`,
    inputSchema: github.MarkdownRenderParamsSchema
  })
  async markdownRender(
    params: github.MarkdownRenderParams
  ): Promise<github.MarkdownRenderResponse> {
    return this.ky
      .post('/markdown', {
        json: pick(params, 'text', 'mode', 'context')
      })
      .json<github.MarkdownRenderResponse>()
  }

  /**
   * You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain format like a README.md file. Markdown content must be 400 KB or less.
   */
  @aiFunction({
    name: 'markdown_render_raw',
    description: `You must send Markdown as plain text (using a \`Content-Type\` header of \`text/plain\` or \`text/x-markdown\`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain format like a README.md file. Markdown content must be 400 KB or less.`,
    inputSchema: github.MarkdownRenderRawParamsSchema
  })
  async markdownRenderRaw(
    _params: github.MarkdownRenderRawParams
  ): Promise<github.MarkdownRenderRawResponse> {
    return this.ky
      .post('/markdown/raw')
      .json<github.MarkdownRenderRawResponse>()
  }

  /**
 * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_subscription_plan_for_account',
    description: `Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsGetSubscriptionPlanForAccountParamsSchema
  })
  async appsGetSubscriptionPlanForAccount(
    params: github.AppsGetSubscriptionPlanForAccountParams
  ): Promise<github.AppsGetSubscriptionPlanForAccountResponse> {
    return this.ky
      .get(`/marketplace_listing/accounts/${params.account_id}`)
      .json<github.AppsGetSubscriptionPlanForAccountResponse>()
  }

  /**
 * Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_plans',
    description: `Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsListPlansParamsSchema
  })
  async appsListPlans(
    params: github.AppsListPlansParams
  ): Promise<github.AppsListPlansResponse> {
    return this.ky
      .get('/marketplace_listing/plans', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListPlansResponse>()
  }

  /**
 * Returns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_accounts_for_plan',
    description: `Returns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsListAccountsForPlanParamsSchema
  })
  async appsListAccountsForPlan(
    params: github.AppsListAccountsForPlanParams
  ): Promise<github.AppsListAccountsForPlanResponse> {
    return this.ky
      .get(`/marketplace_listing/plans/${params.plan_id}/accounts`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.AppsListAccountsForPlanResponse>()
  }

  /**
 * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_subscription_plan_for_account_stubbed',
    description: `Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsGetSubscriptionPlanForAccountStubbedParamsSchema
  })
  async appsGetSubscriptionPlanForAccountStubbed(
    params: github.AppsGetSubscriptionPlanForAccountStubbedParams
  ): Promise<github.AppsGetSubscriptionPlanForAccountStubbedResponse> {
    return this.ky
      .get(`/marketplace_listing/stubbed/accounts/${params.account_id}`)
      .json<github.AppsGetSubscriptionPlanForAccountStubbedResponse>()
  }

  /**
 * Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_plans_stubbed',
    description: `Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsListPlansStubbedParamsSchema
  })
  async appsListPlansStubbed(
    params: github.AppsListPlansStubbedParams
  ): Promise<github.AppsListPlansStubbedResponse> {
    return this.ky
      .get('/marketplace_listing/stubbed/plans', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListPlansStubbedResponse>()
  }

  /**
 * Returns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.
 */
  @aiFunction({
    name: 'apps_list_accounts_for_plan_stubbed',
    description: `Returns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth apps must use [basic authentication](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) with their client ID and client secret to access this endpoint.`,
    inputSchema: github.AppsListAccountsForPlanStubbedParamsSchema
  })
  async appsListAccountsForPlanStubbed(
    params: github.AppsListAccountsForPlanStubbedParams
  ): Promise<github.AppsListAccountsForPlanStubbedResponse> {
    return this.ky
      .get(`/marketplace_listing/stubbed/plans/${params.plan_id}/accounts`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.AppsListAccountsForPlanStubbedResponse>()
  }

  /**
 * Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/)."

The API's response also includes a list of GitHub's domain names.

The values shown in the documentation's response are example values. You must always query the API directly to get the latest values.

> [!NOTE]
> This endpoint returns both IPv4 and IPv6 addresses. However, not all features support IPv6. You should refer to the specific documentation for each feature to determine if IPv6 is supported.
 */
  @aiFunction({
    name: 'meta_get',
    description: `Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/)."

The API's response also includes a list of GitHub's domain names.

The values shown in the documentation's response are example values. You must always query the API directly to get the latest values.

> [!NOTE]
> This endpoint returns both IPv4 and IPv6 addresses. However, not all features support IPv6. You should refer to the specific documentation for each feature to determine if IPv6 is supported.`,
    inputSchema: github.MetaGetParamsSchema
  })
  async metaGet(
    _params: github.MetaGetParams
  ): Promise<github.MetaGetResponse> {
    return this.ky.get('/meta').json<github.MetaGetResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_public_events_for_repo_network',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListPublicEventsForRepoNetworkParamsSchema
  })
  async activityListPublicEventsForRepoNetwork(
    params: github.ActivityListPublicEventsForRepoNetworkParams
  ): Promise<github.ActivityListPublicEventsForRepoNetworkResponse> {
    return this.ky
      .get(`/networks/${params.owner}/${params.repo}/events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListPublicEventsForRepoNetworkResponse>()
  }

  /**
   * List all notifications for the current user, sorted by most recently updated.
   */
  @aiFunction({
    name: 'activity_list_notifications_for_authenticated_user',
    description: `List all notifications for the current user, sorted by most recently updated.`,
    inputSchema:
      github.ActivityListNotificationsForAuthenticatedUserParamsSchema
  })
  async activityListNotificationsForAuthenticatedUser(
    params: github.ActivityListNotificationsForAuthenticatedUserParams
  ): Promise<github.ActivityListNotificationsForAuthenticatedUserResponse> {
    return this.ky
      .get('/notifications', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'all',
            'participating',
            'since',
            'before',
            'page',
            'per_page'
          )
        )
      })
      .json<github.ActivityListNotificationsForAuthenticatedUserResponse>()
  }

  /**
   * Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
   */
  @aiFunction({
    name: 'activity_mark_notifications_as_read',
    description: `Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a \`202 Accepted\` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter \`all=false\`.`,
    inputSchema: github.ActivityMarkNotificationsAsReadParamsSchema
  })
  async activityMarkNotificationsAsRead(
    params: github.ActivityMarkNotificationsAsReadParams
  ): Promise<github.ActivityMarkNotificationsAsReadResponse> {
    return this.ky
      .put('/notifications', {
        json: pick(params, 'last_read_at', 'read')
      })
      .json<github.ActivityMarkNotificationsAsReadResponse>()
  }

  /**
   * Gets information about a notification thread.
   */
  @aiFunction({
    name: 'activity_get_thread',
    description: `Gets information about a notification thread.`,
    inputSchema: github.ActivityGetThreadParamsSchema
  })
  async activityGetThread(
    params: github.ActivityGetThreadParams
  ): Promise<github.ActivityGetThreadResponse> {
    return this.ky
      .get(`/notifications/threads/${params.thread_id}`)
      .json<github.ActivityGetThreadResponse>()
  }

  /**
   * Marks a thread as "done." Marking a thread as "done" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.
   */
  @aiFunction({
    name: 'activity_mark_thread_as_done',
    description: `Marks a thread as "done." Marking a thread as "done" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.`,
    inputSchema: github.ActivityMarkThreadAsDoneParamsSchema
  })
  async activityMarkThreadAsDone(
    params: github.ActivityMarkThreadAsDoneParams
  ): Promise<github.ActivityMarkThreadAsDoneResponse> {
    return this.ky
      .delete(`/notifications/threads/${params.thread_id}`)
      .json<github.ActivityMarkThreadAsDoneResponse>()
  }

  /**
   * Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.
   */
  @aiFunction({
    name: 'activity_mark_thread_as_read',
    description: `Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.`,
    inputSchema: github.ActivityMarkThreadAsReadParamsSchema
  })
  async activityMarkThreadAsRead(
    params: github.ActivityMarkThreadAsReadParams
  ): Promise<github.ActivityMarkThreadAsReadResponse> {
    return this.ky
      .patch(`/notifications/threads/${params.thread_id}`)
      .json<github.ActivityMarkThreadAsReadResponse>()
  }

  /**
 * This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).

Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
 */
  @aiFunction({
    name: 'activity_get_thread_subscription_for_authenticated_user',
    description: `This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).

Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.`,
    inputSchema:
      github.ActivityGetThreadSubscriptionForAuthenticatedUserParamsSchema
  })
  async activityGetThreadSubscriptionForAuthenticatedUser(
    params: github.ActivityGetThreadSubscriptionForAuthenticatedUserParams
  ): Promise<github.ActivityGetThreadSubscriptionForAuthenticatedUserResponse> {
    return this.ky
      .get(`/notifications/threads/${params.thread_id}/subscription`)
      .json<github.ActivityGetThreadSubscriptionForAuthenticatedUserResponse>()
  }

  /**
 * If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.

You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.

Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.
 */
  @aiFunction({
    name: 'activity_set_thread_subscription',
    description: `If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.

You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.

Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.`,
    inputSchema: github.ActivitySetThreadSubscriptionParamsSchema
  })
  async activitySetThreadSubscription(
    params: github.ActivitySetThreadSubscriptionParams
  ): Promise<github.ActivitySetThreadSubscriptionResponse> {
    return this.ky
      .put(`/notifications/threads/${params.thread_id}/subscription`, {
        json: pick(params, 'ignored')
      })
      .json<github.ActivitySetThreadSubscriptionResponse>()
  }

  /**
   * Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set `ignore` to `true`.
   */
  @aiFunction({
    name: 'activity_delete_thread_subscription',
    description: `Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set \`ignore\` to \`true\`.`,
    inputSchema: github.ActivityDeleteThreadSubscriptionParamsSchema
  })
  async activityDeleteThreadSubscription(
    params: github.ActivityDeleteThreadSubscriptionParams
  ): Promise<github.ActivityDeleteThreadSubscriptionResponse> {
    return this.ky
      .delete(`/notifications/threads/${params.thread_id}/subscription`)
      .json<github.ActivityDeleteThreadSubscriptionResponse>()
  }

  /**
   * Get the octocat as ASCII art.
   */
  @aiFunction({
    name: 'meta_get_octocat',
    description: `Get the octocat as ASCII art.`,
    inputSchema: github.MetaGetOctocatParamsSchema
  })
  async metaGetOctocat(
    params: github.MetaGetOctocatParams
  ): Promise<github.MetaGetOctocatResponse> {
    return this.ky
      .get('/octocat', {
        searchParams: sanitizeSearchParams(params)
      })
      .json<github.MetaGetOctocatResponse>()
  }

  /**
 * Lists all organizations, in the order that they were created.

> [!NOTE]
> Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of organizations.
 */
  @aiFunction({
    name: 'orgs_list',
    description: `Lists all organizations, in the order that they were created.

> [!NOTE]
> Pagination is powered exclusively by the \`since\` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of organizations.`,
    inputSchema: github.OrgsListParamsSchema
  })
  async orgsList(
    params: github.OrgsListParams
  ): Promise<github.OrgsListResponse> {
    return this.ky
      .get('/organizations', {
        searchParams: sanitizeSearchParams(pick(params, 'since', 'per_page'))
      })
      .json<github.OrgsListResponse>()
  }

  /**
 * Gets a report of the total usage for an organization. To use this endpoint, you must be an administrator of an organization within an enterprise or an organization account.

**Note:** This endpoint is only available to organizations with access to the enhanced billing platform. For more information, see "[About the enhanced billing platform](https://docs.github.com/billing/using-the-new-billing-platform).".
 */
  @aiFunction({
    name: 'billing_get_github_billing_usage_report_org',
    description: `Gets a report of the total usage for an organization. To use this endpoint, you must be an administrator of an organization within an enterprise or an organization account.

**Note:** This endpoint is only available to organizations with access to the enhanced billing platform. For more information, see "[About the enhanced billing platform](https://docs.github.com/billing/using-the-new-billing-platform).".`,
    inputSchema: github.BillingGetGithubBillingUsageReportOrgParamsSchema
  })
  async billingGetGithubBillingUsageReportOrg(
    params: github.BillingGetGithubBillingUsageReportOrgParams
  ): Promise<github.BillingGetGithubBillingUsageReportOrgResponse> {
    return this.ky
      .get(`/organizations/${params.org}/settings/billing/usage`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'year', 'month', 'day', 'hour')
        )
      })
      .json<github.BillingGetGithubBillingUsageReportOrgResponse>()
  }

  /**
 * Gets information about an organization.

When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, outside collaborators, guest collaborators, repository collaborators, or everyone with access to any repository within the organization to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).

To see the full details about an organization, the authenticated user must be an organization owner.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to see the full details about an organization.

To see information about an organization's GitHub plan, GitHub Apps need the `Organization plan` permission.
 */
  @aiFunction({
    name: 'orgs_get',
    description: `Gets information about an organization.

When the value of \`two_factor_requirement_enabled\` is \`true\`, the organization requires all members, billing managers, outside collaborators, guest collaborators, repository collaborators, or everyone with access to any repository within the organization to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).

To see the full details about an organization, the authenticated user must be an organization owner.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to see the full details about an organization.

To see information about an organization's GitHub plan, GitHub Apps need the \`Organization plan\` permission.`,
    inputSchema: github.OrgsGetParamsSchema
  })
  async orgsGet(params: github.OrgsGetParams): Promise<github.OrgsGetResponse> {
    return this.ky.get(`/orgs/${params.org}`).json<github.OrgsGetResponse>()
  }

  /**
 * Deletes an organization and all its repositories.

The organization login will be unavailable for 90 days after deletion.

Please review the Terms of Service regarding account deletion before using this endpoint:

https://docs.github.com/site-policy/github-terms/github-terms-of-service.
 */
  @aiFunction({
    name: 'orgs_delete',
    description: `Deletes an organization and all its repositories.

The organization login will be unavailable for 90 days after deletion.

Please review the Terms of Service regarding account deletion before using this endpoint:

https://docs.github.com/site-policy/github-terms/github-terms-of-service.`,
    inputSchema: github.OrgsDeleteParamsSchema
  })
  async orgsDelete(
    params: github.OrgsDeleteParams
  ): Promise<github.OrgsDeleteResponse> {
    return this.ky
      .delete(`/orgs/${params.org}`)
      .json<github.OrgsDeleteResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** GitHub will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).

> [!WARNING]
> **Closing down notice:** Code security product enablement for new repositories through the organization API is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations#set-a-code-security-configuration-as-a-default-for-an-organization) to set defaults instead. For more information on setting a default security configuration, see the [changelog](https://github.blog/changelog/2024-07-09-sunsetting-security-settings-defaults-parameters-in-the-organizations-rest-api/).

Updates the organization's profile and member privileges.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` or `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_update',
    description: `> [!WARNING]
> **Closing down notice:** GitHub will replace and discontinue \`members_allowed_repository_creation_type\` in favor of more granular permissions. The new input parameters are \`members_can_create_public_repositories\`, \`members_can_create_private_repositories\` for all organizations and \`members_can_create_internal_repositories\` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).

> [!WARNING]
> **Closing down notice:** Code security product enablement for new repositories through the organization API is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations#set-a-code-security-configuration-as-a-default-for-an-organization) to set defaults instead. For more information on setting a default security configuration, see the [changelog](https://github.blog/changelog/2024-07-09-sunsetting-security-settings-defaults-parameters-in-the-organizations-rest-api/).

Updates the organization's profile and member privileges.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` or \`repo\` scope to use this endpoint.`,
    inputSchema: github.OrgsUpdateParamsSchema
  })
  async orgsUpdate(
    params: github.OrgsUpdateParams
  ): Promise<github.OrgsUpdateResponse> {
    return this.ky
      .patch(`/orgs/${params.org}`, {
        json: pick(
          params,
          'billing_email',
          'company',
          'email',
          'twitter_username',
          'location',
          'name',
          'description',
          'has_organization_projects',
          'has_repository_projects',
          'default_repository_permission',
          'members_can_create_repositories',
          'members_can_create_internal_repositories',
          'members_can_create_private_repositories',
          'members_can_create_public_repositories',
          'members_allowed_repository_creation_type',
          'members_can_create_pages',
          'members_can_create_public_pages',
          'members_can_create_private_pages',
          'members_can_fork_private_repositories',
          'web_commit_signoff_required',
          'blog',
          'advanced_security_enabled_for_new_repositories',
          'dependabot_alerts_enabled_for_new_repositories',
          'dependabot_security_updates_enabled_for_new_repositories',
          'dependency_graph_enabled_for_new_repositories',
          'secret_scanning_enabled_for_new_repositories',
          'secret_scanning_push_protection_enabled_for_new_repositories',
          'secret_scanning_push_protection_custom_link_enabled',
          'secret_scanning_push_protection_custom_link',
          'deploy_keys_enabled_for_repositories'
        )
      })
      .json<github.OrgsUpdateResponse>()
  }

  /**
 * Gets the total GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

OAuth tokens and personal access tokens (classic) need the `read:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_actions_cache_usage_for_org',
    description: `Gets the total GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

OAuth tokens and personal access tokens (classic) need the \`read:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetActionsCacheUsageForOrgParamsSchema
  })
  async actionsGetActionsCacheUsageForOrg(
    params: github.ActionsGetActionsCacheUsageForOrgParams
  ): Promise<github.ActionsGetActionsCacheUsageForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/cache/usage`)
      .json<github.ActionsGetActionsCacheUsageForOrgResponse>()
  }

  /**
 * Lists repositories and their GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

OAuth tokens and personal access tokens (classic) need the `read:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_actions_cache_usage_by_repo_for_org',
    description: `Lists repositories and their GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

OAuth tokens and personal access tokens (classic) need the \`read:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetActionsCacheUsageByRepoForOrgParamsSchema
  })
  async actionsGetActionsCacheUsageByRepoForOrg(
    params: github.ActionsGetActionsCacheUsageByRepoForOrgParams
  ): Promise<github.ActionsGetActionsCacheUsageByRepoForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/cache/usage-by-repository`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsGetActionsCacheUsageByRepoForOrgResponse>()
  }

  /**
 * Lists all GitHub-hosted runners configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `manage_runner:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_hosted_runners_for_org',
    description: `Lists all GitHub-hosted runners configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`manage_runner:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsListHostedRunnersForOrgParamsSchema
  })
  async actionsListHostedRunnersForOrg(
    params: github.ActionsListHostedRunnersForOrgParams
  ): Promise<github.ActionsListHostedRunnersForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListHostedRunnersForOrgResponse>()
  }

  /**
 * Creates a GitHub-hosted runner for an organization.
OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_hosted_runner_for_org',
    description: `Creates a GitHub-hosted runner for an organization.
OAuth tokens and personal access tokens (classic) need the \`manage_runners:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateHostedRunnerForOrgParamsSchema
  })
  async actionsCreateHostedRunnerForOrg(
    params: github.ActionsCreateHostedRunnerForOrgParams
  ): Promise<github.ActionsCreateHostedRunnerForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/hosted-runners`, {
        json: pick(
          params,
          'name',
          'image',
          'size',
          'runner_group_id',
          'maximum_runners',
          'enable_static_ip'
        )
      })
      .json<github.ActionsCreateHostedRunnerForOrgResponse>()
  }

  /**
   * Get the list of GitHub-owned images available for GitHub-hosted runners for an organization.
   */
  @aiFunction({
    name: 'actions_get_hosted_runners_github_owned_images_for_org',
    description: `Get the list of GitHub-owned images available for GitHub-hosted runners for an organization.`,
    inputSchema:
      github.ActionsGetHostedRunnersGithubOwnedImagesForOrgParamsSchema
  })
  async actionsGetHostedRunnersGithubOwnedImagesForOrg(
    params: github.ActionsGetHostedRunnersGithubOwnedImagesForOrgParams
  ): Promise<github.ActionsGetHostedRunnersGithubOwnedImagesForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners/images/github-owned`)
      .json<github.ActionsGetHostedRunnersGithubOwnedImagesForOrgResponse>()
  }

  /**
   * Get the list of partner images available for GitHub-hosted runners for an organization.
   */
  @aiFunction({
    name: 'actions_get_hosted_runners_partner_images_for_org',
    description: `Get the list of partner images available for GitHub-hosted runners for an organization.`,
    inputSchema: github.ActionsGetHostedRunnersPartnerImagesForOrgParamsSchema
  })
  async actionsGetHostedRunnersPartnerImagesForOrg(
    params: github.ActionsGetHostedRunnersPartnerImagesForOrgParams
  ): Promise<github.ActionsGetHostedRunnersPartnerImagesForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners/images/partner`)
      .json<github.ActionsGetHostedRunnersPartnerImagesForOrgResponse>()
  }

  /**
   * Get the GitHub-hosted runners limits for an organization.
   */
  @aiFunction({
    name: 'actions_get_hosted_runners_limits_for_org',
    description: `Get the GitHub-hosted runners limits for an organization.`,
    inputSchema: github.ActionsGetHostedRunnersLimitsForOrgParamsSchema
  })
  async actionsGetHostedRunnersLimitsForOrg(
    params: github.ActionsGetHostedRunnersLimitsForOrgParams
  ): Promise<github.ActionsGetHostedRunnersLimitsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners/limits`)
      .json<github.ActionsGetHostedRunnersLimitsForOrgResponse>()
  }

  /**
   * Get the list of machine specs available for GitHub-hosted runners for an organization.
   */
  @aiFunction({
    name: 'actions_get_hosted_runners_machine_specs_for_org',
    description: `Get the list of machine specs available for GitHub-hosted runners for an organization.`,
    inputSchema: github.ActionsGetHostedRunnersMachineSpecsForOrgParamsSchema
  })
  async actionsGetHostedRunnersMachineSpecsForOrg(
    params: github.ActionsGetHostedRunnersMachineSpecsForOrgParams
  ): Promise<github.ActionsGetHostedRunnersMachineSpecsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners/machine-sizes`)
      .json<github.ActionsGetHostedRunnersMachineSpecsForOrgResponse>()
  }

  /**
   * Get the list of platforms available for GitHub-hosted runners for an organization.
   */
  @aiFunction({
    name: 'actions_get_hosted_runners_platforms_for_org',
    description: `Get the list of platforms available for GitHub-hosted runners for an organization.`,
    inputSchema: github.ActionsGetHostedRunnersPlatformsForOrgParamsSchema
  })
  async actionsGetHostedRunnersPlatformsForOrg(
    params: github.ActionsGetHostedRunnersPlatformsForOrgParams
  ): Promise<github.ActionsGetHostedRunnersPlatformsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/hosted-runners/platforms`)
      .json<github.ActionsGetHostedRunnersPlatformsForOrgResponse>()
  }

  /**
 * Gets a GitHub-hosted runner configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_hosted_runner_for_org',
    description: `Gets a GitHub-hosted runner configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`manage_runners:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetHostedRunnerForOrgParamsSchema
  })
  async actionsGetHostedRunnerForOrg(
    params: github.ActionsGetHostedRunnerForOrgParams
  ): Promise<github.ActionsGetHostedRunnerForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/hosted-runners/${params.hosted_runner_id}`,
        {}
      )
      .json<github.ActionsGetHostedRunnerForOrgResponse>()
  }

  /**
   * Deletes a GitHub-hosted runner for an organization.
   */
  @aiFunction({
    name: 'actions_delete_hosted_runner_for_org',
    description: `Deletes a GitHub-hosted runner for an organization.`,
    inputSchema: github.ActionsDeleteHostedRunnerForOrgParamsSchema
  })
  async actionsDeleteHostedRunnerForOrg(
    params: github.ActionsDeleteHostedRunnerForOrgParams
  ): Promise<github.ActionsDeleteHostedRunnerForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/hosted-runners/${params.hosted_runner_id}`,
        {}
      )
      .json<github.ActionsDeleteHostedRunnerForOrgResponse>()
  }

  /**
 * Updates a GitHub-hosted runner for an organization.
OAuth app tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_update_hosted_runner_for_org',
    description: `Updates a GitHub-hosted runner for an organization.
OAuth app tokens and personal access tokens (classic) need the \`manage_runners:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsUpdateHostedRunnerForOrgParamsSchema
  })
  async actionsUpdateHostedRunnerForOrg(
    params: github.ActionsUpdateHostedRunnerForOrgParams
  ): Promise<github.ActionsUpdateHostedRunnerForOrgResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/actions/hosted-runners/${params.hosted_runner_id}`,
        {
          json: pick(
            params,
            'name',
            'runner_group_id',
            'maximum_runners',
            'enable_static_ip'
          )
        }
      )
      .json<github.ActionsUpdateHostedRunnerForOrgResponse>()
  }

  /**
 * Gets the customization template for an OpenID Connect (OIDC) subject claim.

OAuth app tokens and personal access tokens (classic) need the `read:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'oidc_get_oidc_custom_sub_template_for_org',
    description: `Gets the customization template for an OpenID Connect (OIDC) subject claim.

OAuth app tokens and personal access tokens (classic) need the \`read:org\` scope to use this endpoint.`,
    inputSchema: github.OidcGetOidcCustomSubTemplateForOrgParamsSchema
  })
  async oidcGetOidcCustomSubTemplateForOrg(
    params: github.OidcGetOidcCustomSubTemplateForOrgParams
  ): Promise<github.OidcGetOidcCustomSubTemplateForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/oidc/customization/sub`)
      .json<github.OidcGetOidcCustomSubTemplateForOrgResponse>()
  }

  /**
 * Creates or updates the customization template for an OpenID Connect (OIDC) subject claim.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'oidc_update_oidc_custom_sub_template_for_org',
    description: `Creates or updates the customization template for an OpenID Connect (OIDC) subject claim.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.OidcUpdateOidcCustomSubTemplateForOrgParamsSchema
  })
  async oidcUpdateOidcCustomSubTemplateForOrg(
    params: github.OidcUpdateOidcCustomSubTemplateForOrgParams
  ): Promise<github.OidcUpdateOidcCustomSubTemplateForOrgResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/oidc/customization/sub`, {
        json: pick(params, 'include_claim_keys')
      })
      .json<github.OidcUpdateOidcCustomSubTemplateForOrgResponse>()
  }

  /**
 * Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_github_actions_permissions_organization',
    description: `Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsGetGithubActionsPermissionsOrganizationParamsSchema
  })
  async actionsGetGithubActionsPermissionsOrganization(
    params: github.ActionsGetGithubActionsPermissionsOrganizationParams
  ): Promise<github.ActionsGetGithubActionsPermissionsOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/permissions`)
      .json<github.ActionsGetGithubActionsPermissionsOrganizationResponse>()
  }

  /**
 * Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_github_actions_permissions_organization',
    description: `Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetGithubActionsPermissionsOrganizationParamsSchema
  })
  async actionsSetGithubActionsPermissionsOrganization(
    params: github.ActionsSetGithubActionsPermissionsOrganizationParams
  ): Promise<github.ActionsSetGithubActionsPermissionsOrganizationResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/permissions`, {
        json: pick(params, 'enabled_repositories', 'allowed_actions')
      })
      .json<github.ActionsSetGithubActionsPermissionsOrganizationResponse>()
  }

  /**
 * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_selected_repositories_enabled_github_actions_organization',
    description: `Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for \`enabled_repositories\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
  })
  async actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
    params: github.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
  ): Promise<github.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/permissions/repositories`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse>()
  }

  /**
 * Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."


OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_selected_repositories_enabled_github_actions_organization',
    description: `Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for \`enabled_repositories\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."


OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamsSchema
  })
  async actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
    params: github.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
  ): Promise<github.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/permissions/repositories`, {
        json: pick(params, 'selected_repository_ids')
      })
      .json<github.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse>()
  }

  /**
 * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_enable_selected_repository_github_actions_organization',
    description: `Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for \`enabled_repositories\` must be must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsEnableSelectedRepositoryGithubActionsOrganizationParamsSchema
  })
  async actionsEnableSelectedRepositoryGithubActionsOrganization(
    params: github.ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
  ): Promise<github.ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/permissions/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse>()
  }

  /**
 * Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_disable_selected_repository_github_actions_organization',
    description: `Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for \`enabled_repositories\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsDisableSelectedRepositoryGithubActionsOrganizationParamsSchema
  })
  async actionsDisableSelectedRepositoryGithubActionsOrganization(
    params: github.ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
  ): Promise<github.ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/permissions/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse>()
  }

  /**
 * Gets the selected actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_allowed_actions_organization',
    description: `Gets the selected actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for \`allowed_actions\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetAllowedActionsOrganizationParamsSchema
  })
  async actionsGetAllowedActionsOrganization(
    params: github.ActionsGetAllowedActionsOrganizationParams
  ): Promise<github.ActionsGetAllowedActionsOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/permissions/selected-actions`)
      .json<github.ActionsGetAllowedActionsOrganizationResponse>()
  }

  /**
 * Sets the actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_allowed_actions_organization',
    description: `Sets the actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for \`allowed_actions\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetAllowedActionsOrganizationParamsSchema
  })
  async actionsSetAllowedActionsOrganization(
    params: github.ActionsSetAllowedActionsOrganizationParams
  ): Promise<github.ActionsSetAllowedActionsOrganizationResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/permissions/selected-actions`, {
        json: pick(
          params,
          'github_owned_allowed',
          'verified_allowed',
          'patterns_allowed'
        )
      })
      .json<github.ActionsSetAllowedActionsOrganizationResponse>()
  }

  /**
 * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_github_actions_default_workflow_permissions_organization',
    description: `Gets the default workflow permissions granted to the \`GITHUB_TOKEN\` when running workflows in an organization,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
  })
  async actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
    params: github.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParams
  ): Promise<github.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/permissions/workflow`)
      .json<github.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse>()
  }

  /**
 * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions
can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_github_actions_default_workflow_permissions_organization',
    description: `Sets the default workflow permissions granted to the \`GITHUB_TOKEN\` when running workflows in an organization, and sets if GitHub Actions
can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamsSchema
  })
  async actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
    params: github.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParams
  ): Promise<github.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/permissions/workflow`, {
        json: pick(
          params,
          'default_workflow_permissions',
          'can_approve_pull_request_reviews'
        )
      })
      .json<github.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse>()
  }

  /**
 * Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_self_hosted_runner_groups_for_org',
    description: `Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsListSelfHostedRunnerGroupsForOrgParamsSchema
  })
  async actionsListSelfHostedRunnerGroupsForOrg(
    params: github.ActionsListSelfHostedRunnerGroupsForOrgParams
  ): Promise<github.ActionsListSelfHostedRunnerGroupsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/runner-groups`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'visible_to_repository')
        )
      })
      .json<github.ActionsListSelfHostedRunnerGroupsForOrgResponse>()
  }

  /**
 * Creates a new self-hosted runner group for an organization.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_self_hosted_runner_group_for_org',
    description: `Creates a new self-hosted runner group for an organization.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateSelfHostedRunnerGroupForOrgParamsSchema
  })
  async actionsCreateSelfHostedRunnerGroupForOrg(
    params: github.ActionsCreateSelfHostedRunnerGroupForOrgParams
  ): Promise<github.ActionsCreateSelfHostedRunnerGroupForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/runner-groups`, {
        json: pick(
          params,
          'name',
          'visibility',
          'selected_repository_ids',
          'runners',
          'allows_public_repositories',
          'restricted_to_workflows',
          'selected_workflows',
          'network_configuration_id'
        )
      })
      .json<github.ActionsCreateSelfHostedRunnerGroupForOrgResponse>()
  }

  /**
 * Gets a specific self-hosted runner group for an organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_self_hosted_runner_group_for_org',
    description: `Gets a specific self-hosted runner group for an organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetSelfHostedRunnerGroupForOrgParamsSchema
  })
  async actionsGetSelfHostedRunnerGroupForOrg(
    params: github.ActionsGetSelfHostedRunnerGroupForOrgParams
  ): Promise<github.ActionsGetSelfHostedRunnerGroupForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}`,
        {}
      )
      .json<github.ActionsGetSelfHostedRunnerGroupForOrgResponse>()
  }

  /**
 * Deletes a self-hosted runner group for an organization.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_self_hosted_runner_group_from_org',
    description: `Deletes a self-hosted runner group for an organization.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteSelfHostedRunnerGroupFromOrgParamsSchema
  })
  async actionsDeleteSelfHostedRunnerGroupFromOrg(
    params: github.ActionsDeleteSelfHostedRunnerGroupFromOrgParams
  ): Promise<github.ActionsDeleteSelfHostedRunnerGroupFromOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}`,
        {}
      )
      .json<github.ActionsDeleteSelfHostedRunnerGroupFromOrgResponse>()
  }

  /**
 * Updates the `name` and `visibility` of a self-hosted runner group in an organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_update_self_hosted_runner_group_for_org',
    description: `Updates the \`name\` and \`visibility\` of a self-hosted runner group in an organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsUpdateSelfHostedRunnerGroupForOrgParamsSchema
  })
  async actionsUpdateSelfHostedRunnerGroupForOrg(
    params: github.ActionsUpdateSelfHostedRunnerGroupForOrgParams
  ): Promise<github.ActionsUpdateSelfHostedRunnerGroupForOrgResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}`,
        {
          json: pick(
            params,
            'name',
            'visibility',
            'allows_public_repositories',
            'restricted_to_workflows',
            'selected_workflows',
            'network_configuration_id'
          )
        }
      )
      .json<github.ActionsUpdateSelfHostedRunnerGroupForOrgResponse>()
  }

  /**
 * Lists the GitHub-hosted runners in an organization group.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_github_hosted_runners_in_group_for_org',
    description: `Lists the GitHub-hosted runners in an organization group.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsListGithubHostedRunnersInGroupForOrgParamsSchema
  })
  async actionsListGithubHostedRunnersInGroupForOrg(
    params: github.ActionsListGithubHostedRunnersInGroupForOrgParams
  ): Promise<github.ActionsListGithubHostedRunnersInGroupForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/hosted-runners`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListGithubHostedRunnersInGroupForOrgResponse>()
  }

  /**
 * Lists the repositories with access to a self-hosted runner group configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_repo_access_to_self_hosted_runner_group_in_org',
    description: `Lists the repositories with access to a self-hosted runner group configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  })
  async actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
    params: github.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
  ): Promise<github.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse>()
  }

  /**
 * Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_repo_access_to_self_hosted_runner_group_in_org',
    description: `Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  })
  async actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
    params: github.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
  ): Promise<github.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/repositories`,
        {
          json: pick(params, 'selected_repository_ids')
        }
      )
      .json<github.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse>()
  }

  /**
 * Adds a repository to the list of repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_repo_access_to_self_hosted_runner_group_in_org',
    description: `Adds a repository to the list of repositories that can access a self-hosted runner group. The runner group must have \`visibility\` set to \`selected\`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  })
  async actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(
    params: github.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
  ): Promise<github.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse>()
  }

  /**
 * Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_remove_repo_access_to_self_hosted_runner_group_in_org',
    description: `Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have \`visibility\` set to \`selected\`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamsSchema
  })
  async actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
    params: github.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
  ): Promise<github.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse>()
  }

  /**
 * Lists self-hosted runners that are in a specific organization group.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_self_hosted_runners_in_group_for_org',
    description: `Lists self-hosted runners that are in a specific organization group.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsListSelfHostedRunnersInGroupForOrgParamsSchema
  })
  async actionsListSelfHostedRunnersInGroupForOrg(
    params: github.ActionsListSelfHostedRunnersInGroupForOrgParams
  ): Promise<github.ActionsListSelfHostedRunnersInGroupForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/runners`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListSelfHostedRunnersInGroupForOrgResponse>()
  }

  /**
 * Replaces the list of self-hosted runners that are part of an organization runner group.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_self_hosted_runners_in_group_for_org',
    description: `Replaces the list of self-hosted runners that are part of an organization runner group.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetSelfHostedRunnersInGroupForOrgParamsSchema
  })
  async actionsSetSelfHostedRunnersInGroupForOrg(
    params: github.ActionsSetSelfHostedRunnersInGroupForOrgParams
  ): Promise<github.ActionsSetSelfHostedRunnersInGroupForOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/runners`,
        {
          json: pick(params, 'runners')
        }
      )
      .json<github.ActionsSetSelfHostedRunnersInGroupForOrgResponse>()
  }

  /**
 * Adds a self-hosted runner to a runner group configured in an organization.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_self_hosted_runner_to_group_for_org',
    description: `Adds a self-hosted runner to a runner group configured in an organization.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsAddSelfHostedRunnerToGroupForOrgParamsSchema
  })
  async actionsAddSelfHostedRunnerToGroupForOrg(
    params: github.ActionsAddSelfHostedRunnerToGroupForOrgParams
  ): Promise<github.ActionsAddSelfHostedRunnerToGroupForOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/runners/${params.runner_id}`,
        {}
      )
      .json<github.ActionsAddSelfHostedRunnerToGroupForOrgResponse>()
  }

  /**
 * Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_remove_self_hosted_runner_from_group_for_org',
    description: `Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.ActionsRemoveSelfHostedRunnerFromGroupForOrgParamsSchema
  })
  async actionsRemoveSelfHostedRunnerFromGroupForOrg(
    params: github.ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
  ): Promise<github.ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runner-groups/${params.runner_group_id}/runners/${params.runner_id}`,
        {}
      )
      .json<github.ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse>()
  }

  /**
 * Lists all self-hosted runners configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_self_hosted_runners_for_org',
    description: `Lists all self-hosted runners configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListSelfHostedRunnersForOrgParamsSchema
  })
  async actionsListSelfHostedRunnersForOrg(
    params: github.ActionsListSelfHostedRunnersForOrgParams
  ): Promise<github.ActionsListSelfHostedRunnersForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/runners`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'name', 'per_page', 'page')
        )
      })
      .json<github.ActionsListSelfHostedRunnersForOrgResponse>()
  }

  /**
 * Lists binaries for the runner application that you can download and run.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.  If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_runner_applications_for_org',
    description: `Lists binaries for the runner application that you can download and run.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.  If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListRunnerApplicationsForOrgParamsSchema
  })
  async actionsListRunnerApplicationsForOrg(
    params: github.ActionsListRunnerApplicationsForOrgParams
  ): Promise<github.ActionsListRunnerApplicationsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/runners/downloads`)
      .json<github.ActionsListRunnerApplicationsForOrgResponse>()
  }

  /**
 * Generates a configuration that can be passed to the runner application at startup.

The authenticated user must have admin access to the organization.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_generate_runner_jitconfig_for_org',
    description: `Generates a configuration that can be passed to the runner application at startup.

The authenticated user must have admin access to the organization.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGenerateRunnerJitconfigForOrgParamsSchema
  })
  async actionsGenerateRunnerJitconfigForOrg(
    params: github.ActionsGenerateRunnerJitconfigForOrgParams
  ): Promise<github.ActionsGenerateRunnerJitconfigForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/runners/generate-jitconfig`, {
        json: pick(params, 'name', 'runner_group_id', 'labels', 'work_folder')
      })
      .json<github.ActionsGenerateRunnerJitconfigForOrgResponse>()
  }

  /**
 * Returns a token that you can pass to the `config` script. The token expires after one hour.

For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:

```
./config.sh --url https://github.com/octo-org --token TOKEN
```

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_registration_token_for_org',
    description: `Returns a token that you can pass to the \`config\` script. The token expires after one hour.

For example, you can replace \`TOKEN\` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:

\`\`\`
./config.sh --url https://github.com/octo-org --token TOKEN
\`\`\`

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateRegistrationTokenForOrgParamsSchema
  })
  async actionsCreateRegistrationTokenForOrg(
    params: github.ActionsCreateRegistrationTokenForOrgParams
  ): Promise<github.ActionsCreateRegistrationTokenForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/runners/registration-token`)
      .json<github.ActionsCreateRegistrationTokenForOrgResponse>()
  }

  /**
 * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.

For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:

```
./config.sh remove --token TOKEN
```

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_remove_token_for_org',
    description: `Returns a token that you can pass to the \`config\` script to remove a self-hosted runner from an organization. The token expires after one hour.

For example, you can replace \`TOKEN\` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:

\`\`\`
./config.sh remove --token TOKEN
\`\`\`

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateRemoveTokenForOrgParamsSchema
  })
  async actionsCreateRemoveTokenForOrg(
    params: github.ActionsCreateRemoveTokenForOrgParams
  ): Promise<github.ActionsCreateRemoveTokenForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/runners/remove-token`)
      .json<github.ActionsCreateRemoveTokenForOrgResponse>()
  }

  /**
 * Gets a specific self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_get_self_hosted_runner_for_org',
    description: `Gets a specific self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsGetSelfHostedRunnerForOrgParamsSchema
  })
  async actionsGetSelfHostedRunnerForOrg(
    params: github.ActionsGetSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsGetSelfHostedRunnerForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/runners/${params.runner_id}`, {})
      .json<github.ActionsGetSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_self_hosted_runner_from_org',
    description: `Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteSelfHostedRunnerFromOrgParamsSchema
  })
  async actionsDeleteSelfHostedRunnerFromOrg(
    params: github.ActionsDeleteSelfHostedRunnerFromOrgParams
  ): Promise<github.ActionsDeleteSelfHostedRunnerFromOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runners/${params.runner_id}`,
        {}
      )
      .json<github.ActionsDeleteSelfHostedRunnerFromOrgResponse>()
  }

  /**
 * Lists all labels for a self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_labels_for_self_hosted_runner_for_org',
    description: `Lists all labels for a self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListLabelsForSelfHostedRunnerForOrgParamsSchema
  })
  async actionsListLabelsForSelfHostedRunnerForOrg(
    params: github.ActionsListLabelsForSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsListLabelsForSelfHostedRunnerForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/runners/${params.runner_id}/labels`,
        {}
      )
      .json<github.ActionsListLabelsForSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Adds custom labels to a self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_custom_labels_to_self_hosted_runner_for_org',
    description: `Adds custom labels to a self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamsSchema
  })
  async actionsAddCustomLabelsToSelfHostedRunnerForOrg(
    params: github.ActionsAddCustomLabelsToSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/actions/runners/${params.runner_id}/labels`,
        {
          json: pick(params, 'labels')
        }
      )
      .json<github.ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_set_custom_labels_for_self_hosted_runner_for_org',
    description: `Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in an organization.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema:
      github.ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamsSchema
  })
  async actionsSetCustomLabelsForSelfHostedRunnerForOrg(
    params: github.ActionsSetCustomLabelsForSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/runners/${params.runner_id}/labels`,
        {
          json: pick(params, 'labels')
        }
      )
      .json<github.ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Remove all custom labels from a self-hosted runner configured in an
organization. Returns the remaining read-only labels from the runner.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_remove_all_custom_labels_from_self_hosted_runner_for_org',
    description: `Remove all custom labels from a self-hosted runner configured in an
organization. Returns the remaining read-only labels from the runner.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema:
      github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamsSchema
  })
  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
    params: github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runners/${params.runner_id}/labels`,
        {}
      )
      .json<github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Remove a custom label from a self-hosted runner configured
in an organization. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_remove_custom_label_from_self_hosted_runner_for_org',
    description: `Remove a custom label from a self-hosted runner configured
in an organization. Returns the remaining labels from the runner.

This endpoint returns a \`404 Not Found\` status if the custom label is not
present on the runner.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema:
      github.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamsSchema
  })
  async actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
    params: github.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParams
  ): Promise<github.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/runners/${params.runner_id}/labels/${params.name}`,
        {}
      )
      .json<github.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse>()
  }

  /**
 * Lists all secrets available in an organization without revealing their
encrypted values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_org_secrets',
    description: `Lists all secrets available in an organization without revealing their
encrypted values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListOrgSecretsParamsSchema
  })
  async actionsListOrgSecrets(
    params: github.ActionsListOrgSecretsParams
  ): Promise<github.ActionsListOrgSecretsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListOrgSecretsResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

The authenticated user must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_org_public_key',
    description: `Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

The authenticated user must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetOrgPublicKeyParamsSchema
  })
  async actionsGetOrgPublicKey(
    params: github.ActionsGetOrgPublicKeyParams
  ): Promise<github.ActionsGetOrgPublicKeyResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/secrets/public-key`)
      .json<github.ActionsGetOrgPublicKeyResponse>()
  }

  /**
 * Gets a single organization secret without revealing its encrypted value.

The authenticated user must have collaborator access to a repository to create, update, or read secrets

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_org_secret',
    description: `Gets a single organization secret without revealing its encrypted value.

The authenticated user must have collaborator access to a repository to create, update, or read secrets

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetOrgSecretParamsSchema
  })
  async actionsGetOrgSecret(
    params: github.ActionsGetOrgSecretParams
  ): Promise<github.ActionsGetOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsGetOrgSecretResponse>()
  }

  /**
 * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_or_update_org_secret',
    description: `Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateOrUpdateOrgSecretParamsSchema
  })
  async actionsCreateOrUpdateOrgSecret(
    params: github.ActionsCreateOrUpdateOrgSecretParams
  ): Promise<github.ActionsCreateOrUpdateOrgSecretResponse> {
    return this.ky
      .put(`/orgs/${params.org}/actions/secrets/${params.secret_name}`, {
        json: pick(
          params,
          'encrypted_value',
          'key_id',
          'visibility',
          'selected_repository_ids'
        )
      })
      .json<github.ActionsCreateOrUpdateOrgSecretResponse>()
  }

  /**
 * Deletes a secret in an organization using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_org_secret',
    description: `Deletes a secret in an organization using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteOrgSecretParamsSchema
  })
  async actionsDeleteOrgSecret(
    params: github.ActionsDeleteOrgSecretParams
  ): Promise<github.ActionsDeleteOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsDeleteOrgSecretResponse>()
  }

  /**
 * Lists all repositories that have been selected when the `visibility`
for repository access to a secret is set to `selected`.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_selected_repos_for_org_secret',
    description: `Lists all repositories that have been selected when the \`visibility\`
for repository access to a secret is set to \`selected\`.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListSelectedReposForOrgSecretParamsSchema
  })
  async actionsListSelectedReposForOrgSecret(
    params: github.ActionsListSelectedReposForOrgSecretParams
  ): Promise<github.ActionsListSelectedReposForOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ActionsListSelectedReposForOrgSecretResponse>()
  }

  /**
 * Replaces all repositories for an organization secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_set_selected_repos_for_org_secret',
    description: `Replaces all repositories for an organization secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsSetSelectedReposForOrgSecretParamsSchema
  })
  async actionsSetSelectedReposForOrgSecret(
    params: github.ActionsSetSelectedReposForOrgSecretParams
  ): Promise<github.ActionsSetSelectedReposForOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}/repositories`,
        {
          json: pick(params, 'selected_repository_ids')
        }
      )
      .json<github.ActionsSetSelectedReposForOrgSecretResponse>()
  }

  /**
 * Adds a repository to an organization secret when the `visibility` for
repository access is set to `selected`. For more information about setting the visibility, see [Create or
update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_selected_repo_to_org_secret',
    description: `Adds a repository to an organization secret when the \`visibility\` for
repository access is set to \`selected\`. For more information about setting the visibility, see [Create or
update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsAddSelectedRepoToOrgSecretParamsSchema
  })
  async actionsAddSelectedRepoToOrgSecret(
    params: github.ActionsAddSelectedRepoToOrgSecretParams
  ): Promise<github.ActionsAddSelectedRepoToOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsAddSelectedRepoToOrgSecretResponse>()
  }

  /**
 * Removes a repository from an organization secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_remove_selected_repo_from_org_secret',
    description: `Removes a repository from an organization secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsRemoveSelectedRepoFromOrgSecretParamsSchema
  })
  async actionsRemoveSelectedRepoFromOrgSecret(
    params: github.ActionsRemoveSelectedRepoFromOrgSecretParams
  ): Promise<github.ActionsRemoveSelectedRepoFromOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsRemoveSelectedRepoFromOrgSecretResponse>()
  }

  /**
 * Lists all organization variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_org_variables',
    description: `Lists all organization variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListOrgVariablesParamsSchema
  })
  async actionsListOrgVariables(
    params: github.ActionsListOrgVariablesParams
  ): Promise<github.ActionsListOrgVariablesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/variables`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListOrgVariablesResponse>()
  }

  /**
 * Creates an organization variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_org_variable',
    description: `Creates an organization variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateOrgVariableParamsSchema
  })
  async actionsCreateOrgVariable(
    params: github.ActionsCreateOrgVariableParams
  ): Promise<github.ActionsCreateOrgVariableResponse> {
    return this.ky
      .post(`/orgs/${params.org}/actions/variables`, {
        json: pick(
          params,
          'name',
          'value',
          'visibility',
          'selected_repository_ids'
        )
      })
      .json<github.ActionsCreateOrgVariableResponse>()
  }

  /**
 * Gets a specific variable in an organization.

The authenticated user must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_org_variable',
    description: `Gets a specific variable in an organization.

The authenticated user must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetOrgVariableParamsSchema
  })
  async actionsGetOrgVariable(
    params: github.ActionsGetOrgVariableParams
  ): Promise<github.ActionsGetOrgVariableResponse> {
    return this.ky
      .get(`/orgs/${params.org}/actions/variables/${params.name}`, {})
      .json<github.ActionsGetOrgVariableResponse>()
  }

  /**
 * Deletes an organization variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_org_variable',
    description: `Deletes an organization variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the\`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteOrgVariableParamsSchema
  })
  async actionsDeleteOrgVariable(
    params: github.ActionsDeleteOrgVariableParams
  ): Promise<github.ActionsDeleteOrgVariableResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/actions/variables/${params.name}`, {})
      .json<github.ActionsDeleteOrgVariableResponse>()
  }

  /**
 * Updates an organization variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_update_org_variable',
    description: `Updates an organization variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsUpdateOrgVariableParamsSchema
  })
  async actionsUpdateOrgVariable(
    params: github.ActionsUpdateOrgVariableParams
  ): Promise<github.ActionsUpdateOrgVariableResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/actions/variables/${params.name}`, {
        json: pick(
          params,
          'name',
          'value',
          'visibility',
          'selected_repository_ids'
        )
      })
      .json<github.ActionsUpdateOrgVariableResponse>()
  }

  /**
 * Lists all repositories that can access an organization variable
that is available to selected repositories.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_list_selected_repos_for_org_variable',
    description: `Lists all repositories that can access an organization variable
that is available to selected repositories.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsListSelectedReposForOrgVariableParamsSchema
  })
  async actionsListSelectedReposForOrgVariable(
    params: github.ActionsListSelectedReposForOrgVariableParams
  ): Promise<github.ActionsListSelectedReposForOrgVariableResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/actions/variables/${params.name}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ActionsListSelectedReposForOrgVariableResponse>()
  }

  /**
 * Replaces all repositories for an organization variable that is available
to selected repositories. Organization variables that are available to selected
repositories have their `visibility` field set to `selected`.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_set_selected_repos_for_org_variable',
    description: `Replaces all repositories for an organization variable that is available
to selected repositories. Organization variables that are available to selected
repositories have their \`visibility\` field set to \`selected\`.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsSetSelectedReposForOrgVariableParamsSchema
  })
  async actionsSetSelectedReposForOrgVariable(
    params: github.ActionsSetSelectedReposForOrgVariableParams
  ): Promise<github.ActionsSetSelectedReposForOrgVariableResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/variables/${params.name}/repositories`,
        {
          json: pick(params, 'selected_repository_ids')
        }
      )
      .json<github.ActionsSetSelectedReposForOrgVariableResponse>()
  }

  /**
 * Adds a repository to an organization variable that is available to selected repositories.
Organization variables that are available to selected repositories have their `visibility` field set to `selected`.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_selected_repo_to_org_variable',
    description: `Adds a repository to an organization variable that is available to selected repositories.
Organization variables that are available to selected repositories have their \`visibility\` field set to \`selected\`.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsAddSelectedRepoToOrgVariableParamsSchema
  })
  async actionsAddSelectedRepoToOrgVariable(
    params: github.ActionsAddSelectedRepoToOrgVariableParams
  ): Promise<github.ActionsAddSelectedRepoToOrgVariableResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/actions/variables/${params.name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsAddSelectedRepoToOrgVariableResponse>()
  }

  /**
 * Removes a repository from an organization variable that is
available to selected repositories. Organization variables that are available to
selected repositories have their `visibility` field set to `selected`.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
 */
  @aiFunction({
    name: 'actions_remove_selected_repo_from_org_variable',
    description: `Removes a repository from an organization variable that is
available to selected repositories. Organization variables that are available to
selected repositories have their \`visibility\` field set to \`selected\`.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint. If the repository is private, the \`repo\` scope is also required.`,
    inputSchema: github.ActionsRemoveSelectedRepoFromOrgVariableParamsSchema
  })
  async actionsRemoveSelectedRepoFromOrgVariable(
    params: github.ActionsRemoveSelectedRepoFromOrgVariableParams
  ): Promise<github.ActionsRemoveSelectedRepoFromOrgVariableResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/actions/variables/${params.name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.ActionsRemoveSelectedRepoFromOrgVariableResponse>()
  }

  /**
 * List a collection of artifact attestations with a given subject digest that are associated with repositories owned by an organization.

The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
 */
  @aiFunction({
    name: 'orgs_list_attestations',
    description: `List a collection of artifact attestations with a given subject digest that are associated with repositories owned by an organization.

The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the \`attestations:read\` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI \`attestation verify\` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).`,
    inputSchema: github.OrgsListAttestationsParamsSchema
  })
  async orgsListAttestations(
    params: github.OrgsListAttestationsParams
  ): Promise<github.OrgsListAttestationsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/attestations/${params.subject_digest}`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'before', 'after', 'predicate_type')
        )
      })
      .json<github.OrgsListAttestationsResponse>()
  }

  /**
   * List the users blocked by an organization.
   */
  @aiFunction({
    name: 'orgs_list_blocked_users',
    description: `List the users blocked by an organization.`,
    inputSchema: github.OrgsListBlockedUsersParamsSchema
  })
  async orgsListBlockedUsers(
    params: github.OrgsListBlockedUsersParams
  ): Promise<github.OrgsListBlockedUsersResponse> {
    return this.ky
      .get(`/orgs/${params.org}/blocks`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListBlockedUsersResponse>()
  }

  /**
   * Returns a 204 if the given user is blocked by the given organization. Returns a 404 if the organization is not blocking the user, or if the user account has been identified as spam by GitHub.
   */
  @aiFunction({
    name: 'orgs_check_blocked_user',
    description: `Returns a 204 if the given user is blocked by the given organization. Returns a 404 if the organization is not blocking the user, or if the user account has been identified as spam by GitHub.`,
    inputSchema: github.OrgsCheckBlockedUserParamsSchema
  })
  async orgsCheckBlockedUser(
    params: github.OrgsCheckBlockedUserParams
  ): Promise<github.OrgsCheckBlockedUserResponse> {
    return this.ky
      .get(`/orgs/${params.org}/blocks/${params.username}`, {})
      .json<github.OrgsCheckBlockedUserResponse>()
  }

  /**
   * Blocks the given user on behalf of the specified organization and returns a 204. If the organization cannot block the given user a 422 is returned.
   */
  @aiFunction({
    name: 'orgs_block_user',
    description: `Blocks the given user on behalf of the specified organization and returns a 204. If the organization cannot block the given user a 422 is returned.`,
    inputSchema: github.OrgsBlockUserParamsSchema
  })
  async orgsBlockUser(
    params: github.OrgsBlockUserParams
  ): Promise<github.OrgsBlockUserResponse> {
    return this.ky
      .put(`/orgs/${params.org}/blocks/${params.username}`, {})
      .json<github.OrgsBlockUserResponse>()
  }

  /**
   * Unblocks the given user on behalf of the specified organization.
   */
  @aiFunction({
    name: 'orgs_unblock_user',
    description: `Unblocks the given user on behalf of the specified organization.`,
    inputSchema: github.OrgsUnblockUserParamsSchema
  })
  async orgsUnblockUser(
    params: github.OrgsUnblockUserParams
  ): Promise<github.OrgsUnblockUserResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/blocks/${params.username}`, {})
      .json<github.OrgsUnblockUserResponse>()
  }

  /**
 * Lists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `security_events` or `repo`s cope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_list_alerts_for_org',
    description: `Lists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` or \`repo\`s cope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningListAlertsForOrgParamsSchema
  })
  async codeScanningListAlertsForOrg(
    params: github.CodeScanningListAlertsForOrgParams
  ): Promise<github.CodeScanningListAlertsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/code-scanning/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'tool_name',
            'tool_guid',
            'before',
            'after',
            'page',
            'per_page',
            'direction',
            'state',
            'sort',
            'severity'
          )
        )
      })
      .json<github.CodeScanningListAlertsForOrgResponse>()
  }

  /**
 * Lists all code security configurations available in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_configurations_for_org',
    description: `Lists all code security configurations available in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetConfigurationsForOrgParamsSchema
  })
  async codeSecurityGetConfigurationsForOrg(
    params: github.CodeSecurityGetConfigurationsForOrgParams
  ): Promise<github.CodeSecurityGetConfigurationsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/code-security/configurations`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'target_type', 'per_page', 'before', 'after')
        )
      })
      .json<github.CodeSecurityGetConfigurationsForOrgResponse>()
  }

  /**
 * Creates a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_create_configuration',
    description: `Creates a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityCreateConfigurationParamsSchema
  })
  async codeSecurityCreateConfiguration(
    params: github.CodeSecurityCreateConfigurationParams
  ): Promise<github.CodeSecurityCreateConfigurationResponse> {
    return this.ky
      .post(`/orgs/${params.org}/code-security/configurations`, {
        json: pick(
          params,
          'name',
          'description',
          'advanced_security',
          'dependency_graph',
          'dependency_graph_autosubmit_action',
          'dependency_graph_autosubmit_action_options',
          'dependabot_alerts',
          'dependabot_security_updates',
          'code_scanning_default_setup',
          'code_scanning_default_setup_options',
          'code_scanning_delegated_alert_dismissal',
          'secret_scanning',
          'secret_scanning_push_protection',
          'secret_scanning_delegated_bypass',
          'secret_scanning_delegated_bypass_options',
          'secret_scanning_validity_checks',
          'secret_scanning_non_provider_patterns',
          'secret_scanning_generic_secrets',
          'secret_scanning_delegated_alert_dismissal',
          'private_vulnerability_reporting',
          'enforcement'
        )
      })
      .json<github.CodeSecurityCreateConfigurationResponse>()
  }

  /**
 * Lists the default code security configurations for an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_default_configurations',
    description: `Lists the default code security configurations for an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetDefaultConfigurationsParamsSchema
  })
  async codeSecurityGetDefaultConfigurations(
    params: github.CodeSecurityGetDefaultConfigurationsParams
  ): Promise<github.CodeSecurityGetDefaultConfigurationsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/code-security/configurations/defaults`)
      .json<github.CodeSecurityGetDefaultConfigurationsResponse>()
  }

  /**
 * Detach code security configuration(s) from a set of repositories.
Repositories will retain their settings but will no longer be associated with the configuration.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_detach_configuration',
    description: `Detach code security configuration(s) from a set of repositories.
Repositories will retain their settings but will no longer be associated with the configuration.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityDetachConfigurationParamsSchema
  })
  async codeSecurityDetachConfiguration(
    params: github.CodeSecurityDetachConfigurationParams
  ): Promise<github.CodeSecurityDetachConfigurationResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/code-security/configurations/detach`, {
        json: pick(params, 'selected_repository_ids')
      })
      .json<github.CodeSecurityDetachConfigurationResponse>()
  }

  /**
 * Gets a code security configuration available in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_configuration',
    description: `Gets a code security configuration available in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetConfigurationParamsSchema
  })
  async codeSecurityGetConfiguration(
    params: github.CodeSecurityGetConfigurationParams
  ): Promise<github.CodeSecurityGetConfigurationResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}`,
        {}
      )
      .json<github.CodeSecurityGetConfigurationResponse>()
  }

  /**
 * Deletes the desired code security configuration from an organization.
Repositories attached to the configuration will retain their settings but will no longer be associated with
the configuration.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_delete_configuration',
    description: `Deletes the desired code security configuration from an organization.
Repositories attached to the configuration will retain their settings but will no longer be associated with
the configuration.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityDeleteConfigurationParamsSchema
  })
  async codeSecurityDeleteConfiguration(
    params: github.CodeSecurityDeleteConfigurationParams
  ): Promise<github.CodeSecurityDeleteConfigurationResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}`,
        {}
      )
      .json<github.CodeSecurityDeleteConfigurationResponse>()
  }

  /**
 * Updates a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_update_configuration',
    description: `Updates a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityUpdateConfigurationParamsSchema
  })
  async codeSecurityUpdateConfiguration(
    params: github.CodeSecurityUpdateConfigurationParams
  ): Promise<github.CodeSecurityUpdateConfigurationResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}`,
        {
          json: pick(
            params,
            'name',
            'description',
            'advanced_security',
            'dependency_graph',
            'dependency_graph_autosubmit_action',
            'dependency_graph_autosubmit_action_options',
            'dependabot_alerts',
            'dependabot_security_updates',
            'code_scanning_default_setup',
            'code_scanning_default_setup_options',
            'code_scanning_delegated_alert_dismissal',
            'secret_scanning',
            'secret_scanning_push_protection',
            'secret_scanning_delegated_bypass',
            'secret_scanning_delegated_bypass_options',
            'secret_scanning_validity_checks',
            'secret_scanning_non_provider_patterns',
            'secret_scanning_generic_secrets',
            'secret_scanning_delegated_alert_dismissal',
            'private_vulnerability_reporting',
            'enforcement'
          )
        }
      )
      .json<github.CodeSecurityUpdateConfigurationResponse>()
  }

  /**
 * Attach a code security configuration to a set of repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.

If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_attach_configuration',
    description: `Attach a code security configuration to a set of repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.

If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityAttachConfigurationParamsSchema
  })
  async codeSecurityAttachConfiguration(
    params: github.CodeSecurityAttachConfigurationParams
  ): Promise<github.CodeSecurityAttachConfigurationResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}/attach`,
        {
          json: pick(params, 'scope', 'selected_repository_ids')
        }
      )
      .json<github.CodeSecurityAttachConfigurationResponse>()
  }

  /**
 * Sets a code security configuration as a default to be applied to new repositories in your organization.

This configuration will be applied to the matching repository type (all, none, public, private and internal) by default when they are created.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_set_configuration_as_default',
    description: `Sets a code security configuration as a default to be applied to new repositories in your organization.

This configuration will be applied to the matching repository type (all, none, public, private and internal) by default when they are created.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecuritySetConfigurationAsDefaultParamsSchema
  })
  async codeSecuritySetConfigurationAsDefault(
    params: github.CodeSecuritySetConfigurationAsDefaultParams
  ): Promise<github.CodeSecuritySetConfigurationAsDefaultResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}/defaults`,
        {
          json: pick(params, 'default_for_new_repos')
        }
      )
      .json<github.CodeSecuritySetConfigurationAsDefaultResponse>()
  }

  /**
 * Lists the repositories associated with a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_repositories_for_configuration',
    description: `Lists the repositories associated with a code security configuration in an organization.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`write:org\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetRepositoriesForConfigurationParamsSchema
  })
  async codeSecurityGetRepositoriesForConfiguration(
    params: github.CodeSecurityGetRepositoriesForConfigurationParams
  ): Promise<github.CodeSecurityGetRepositoriesForConfigurationResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/code-security/configurations/${params.configuration_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'before', 'after', 'status')
          )
        }
      )
      .json<github.CodeSecurityGetRepositoriesForConfigurationResponse>()
  }

  /**
 * Lists the codespaces associated to a specified organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_in_organization',
    description: `Lists the codespaces associated to a specified organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListInOrganizationParamsSchema
  })
  async codespacesListInOrganization(
    params: github.CodespacesListInOrganizationParams
  ): Promise<github.CodespacesListInOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/codespaces`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesListInOrganizationResponse>()
  }

  /**
 * Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility.
OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_set_codespaces_access',
    description: `Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility.
OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesSetCodespacesAccessParamsSchema
  })
  async codespacesSetCodespacesAccess(
    params: github.CodespacesSetCodespacesAccessParams
  ): Promise<github.CodespacesSetCodespacesAccessResponse> {
    return this.ky
      .put(`/orgs/${params.org}/codespaces/access`, {
        json: pick(params, 'visibility', 'selected_usernames')
      })
      .json<github.CodespacesSetCodespacesAccessResponse>()
  }

  /**
 * Codespaces for the specified users will be billed to the organization.

To use this endpoint, the access settings for the organization must be set to `selected_members`.
For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_set_codespaces_access_users',
    description: `Codespaces for the specified users will be billed to the organization.

To use this endpoint, the access settings for the organization must be set to \`selected_members\`.
For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesSetCodespacesAccessUsersParamsSchema
  })
  async codespacesSetCodespacesAccessUsers(
    params: github.CodespacesSetCodespacesAccessUsersParams
  ): Promise<github.CodespacesSetCodespacesAccessUsersResponse> {
    return this.ky
      .post(`/orgs/${params.org}/codespaces/access/selected_users`, {
        json: pick(params, 'selected_usernames')
      })
      .json<github.CodespacesSetCodespacesAccessUsersResponse>()
  }

  /**
 * Codespaces for the specified users will no longer be billed to the organization.

To use this endpoint, the access settings for the organization must be set to `selected_members`.
For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_delete_codespaces_access_users',
    description: `Codespaces for the specified users will no longer be billed to the organization.

To use this endpoint, the access settings for the organization must be set to \`selected_members\`.
For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesDeleteCodespacesAccessUsersParamsSchema
  })
  async codespacesDeleteCodespacesAccessUsers(
    params: github.CodespacesDeleteCodespacesAccessUsersParams
  ): Promise<github.CodespacesDeleteCodespacesAccessUsersResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/codespaces/access/selected_users`, {
        json: pick(params, 'selected_usernames')
      })
      .json<github.CodespacesDeleteCodespacesAccessUsersResponse>()
  }

  /**
 * Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_org_secrets',
    description: `Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListOrgSecretsParamsSchema
  })
  async codespacesListOrgSecrets(
    params: github.CodespacesListOrgSecretsParams
  ): Promise<github.CodespacesListOrgSecretsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/codespaces/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesListOrgSecretsResponse>()
  }

  /**
 * Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets.
OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_org_public_key',
    description: `Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets.
OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetOrgPublicKeyParamsSchema
  })
  async codespacesGetOrgPublicKey(
    params: github.CodespacesGetOrgPublicKeyParams
  ): Promise<github.CodespacesGetOrgPublicKeyResponse> {
    return this.ky
      .get(`/orgs/${params.org}/codespaces/secrets/public-key`)
      .json<github.CodespacesGetOrgPublicKeyResponse>()
  }

  /**
 * Gets an organization development environment secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_org_secret',
    description: `Gets an organization development environment secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetOrgSecretParamsSchema
  })
  async codespacesGetOrgSecret(
    params: github.CodespacesGetOrgSecretParams
  ): Promise<github.CodespacesGetOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}`,
        {}
      )
      .json<github.CodespacesGetOrgSecretResponse>()
  }

  /**
 * Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_create_or_update_org_secret',
    description: `Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesCreateOrUpdateOrgSecretParamsSchema
  })
  async codespacesCreateOrUpdateOrgSecret(
    params: github.CodespacesCreateOrUpdateOrgSecretParams
  ): Promise<github.CodespacesCreateOrUpdateOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}`,
        {
          json: pick(
            params,
            'encrypted_value',
            'key_id',
            'visibility',
            'selected_repository_ids'
          )
        }
      )
      .json<github.CodespacesCreateOrUpdateOrgSecretResponse>()
  }

  /**
 * Deletes an organization development environment secret using the secret name.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_delete_org_secret',
    description: `Deletes an organization development environment secret using the secret name.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesDeleteOrgSecretParamsSchema
  })
  async codespacesDeleteOrgSecret(
    params: github.CodespacesDeleteOrgSecretParams
  ): Promise<github.CodespacesDeleteOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}`,
        {}
      )
      .json<github.CodespacesDeleteOrgSecretResponse>()
  }

  /**
 * Lists all repositories that have been selected when the `visibility`
for repository access to a secret is set to `selected`.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_selected_repos_for_org_secret',
    description: `Lists all repositories that have been selected when the \`visibility\`
for repository access to a secret is set to \`selected\`.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListSelectedReposForOrgSecretParamsSchema
  })
  async codespacesListSelectedReposForOrgSecret(
    params: github.CodespacesListSelectedReposForOrgSecretParams
  ): Promise<github.CodespacesListSelectedReposForOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.CodespacesListSelectedReposForOrgSecretResponse>()
  }

  /**
 * Replaces all repositories for an organization development environment secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_set_selected_repos_for_org_secret',
    description: `Replaces all repositories for an organization development environment secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesSetSelectedReposForOrgSecretParamsSchema
  })
  async codespacesSetSelectedReposForOrgSecret(
    params: github.CodespacesSetSelectedReposForOrgSecretParams
  ): Promise<github.CodespacesSetSelectedReposForOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}/repositories`,
        {
          json: pick(params, 'selected_repository_ids')
        }
      )
      .json<github.CodespacesSetSelectedReposForOrgSecretResponse>()
  }

  /**
 * Adds a repository to an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_add_selected_repo_to_org_secret',
    description: `Adds a repository to an organization development environment secret when the \`visibility\` for repository access is set to \`selected\`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesAddSelectedRepoToOrgSecretParamsSchema
  })
  async codespacesAddSelectedRepoToOrgSecret(
    params: github.CodespacesAddSelectedRepoToOrgSecretParams
  ): Promise<github.CodespacesAddSelectedRepoToOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.CodespacesAddSelectedRepoToOrgSecretResponse>()
  }

  /**
 * Removes a repository from an organization development environment secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_remove_selected_repo_from_org_secret',
    description: `Removes a repository from an organization development environment secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesRemoveSelectedRepoFromOrgSecretParamsSchema
  })
  async codespacesRemoveSelectedRepoFromOrgSecret(
    params: github.CodespacesRemoveSelectedRepoFromOrgSecretParams
  ): Promise<github.CodespacesRemoveSelectedRepoFromOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/codespaces/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.CodespacesRemoveSelectedRepoFromOrgSecretResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets information about an organization's Copilot subscription, including seat breakdown
and feature policies. To configure these settings, go to your organization's settings on GitHub.com.
For more information, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-policies-for-copilot-business-in-your-organization)."

Only organization owners can view details about the organization's Copilot Business or Copilot Enterprise subscription.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `read:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_get_copilot_organization_details',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets information about an organization's Copilot subscription, including seat breakdown
and feature policies. To configure these settings, go to your organization's settings on GitHub.com.
For more information, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-policies-for-copilot-business-in-your-organization)."

Only organization owners can view details about the organization's Copilot Business or Copilot Enterprise subscription.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`read:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotGetCopilotOrganizationDetailsParamsSchema
  })
  async copilotGetCopilotOrganizationDetails(
    params: github.CopilotGetCopilotOrganizationDetailsParams
  ): Promise<github.CopilotGetCopilotOrganizationDetailsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/copilot/billing`)
      .json<github.CopilotGetCopilotOrganizationDetailsResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Lists all Copilot seats for which an organization with a Copilot Business or Copilot Enterprise subscription is currently being billed.
Only organization owners can view assigned seats.

Each seat object contains information about the assigned user's most recent Copilot activity. Users must have telemetry enabled in their IDE for Copilot in the IDE activity to be reflected in `last_activity_at`.
For more information about activity data, see "[Reviewing user activity data for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/reviewing-activity-related-to-github-copilot-in-your-organization/reviewing-user-activity-data-for-copilot-in-your-organization)."

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `read:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_list_copilot_seats',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Lists all Copilot seats for which an organization with a Copilot Business or Copilot Enterprise subscription is currently being billed.
Only organization owners can view assigned seats.

Each seat object contains information about the assigned user's most recent Copilot activity. Users must have telemetry enabled in their IDE for Copilot in the IDE activity to be reflected in \`last_activity_at\`.
For more information about activity data, see "[Reviewing user activity data for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/reviewing-activity-related-to-github-copilot-in-your-organization/reviewing-user-activity-data-for-copilot-in-your-organization)."

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`read:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotListCopilotSeatsParamsSchema
  })
  async copilotListCopilotSeats(
    params: github.CopilotListCopilotSeatsParams
  ): Promise<github.CopilotListCopilotSeatsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/copilot/billing/seats`, {
        searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
      })
      .json<github.CopilotListCopilotSeatsResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Purchases a GitHub Copilot seat for all users within each specified team.
The organization will be billed for each seat based on the organization's Copilot plan. For more information about Copilot pricing, see "[About billing for GitHub Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/about-billing-for-github-copilot-in-your-organization)."

Only organization owners can purchase Copilot seats for their organization members. The organization must have a Copilot Business or Copilot Enterprise subscription and a configured suggestion matching policy.
For more information about setting up a Copilot subscription, see "[Subscribing to Copilot for your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/subscribing-to-copilot-for-your-organization)."
For more information about setting a suggestion matching policy, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/setting-policies-for-copilot-in-your-organization/managing-policies-for-copilot-in-your-organization#policies-for-suggestion-matching)."

The response contains the total number of new seats that were created and existing seats that were refreshed.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_add_copilot_seats_for_teams',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Purchases a GitHub Copilot seat for all users within each specified team.
The organization will be billed for each seat based on the organization's Copilot plan. For more information about Copilot pricing, see "[About billing for GitHub Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/about-billing-for-github-copilot-in-your-organization)."

Only organization owners can purchase Copilot seats for their organization members. The organization must have a Copilot Business or Copilot Enterprise subscription and a configured suggestion matching policy.
For more information about setting up a Copilot subscription, see "[Subscribing to Copilot for your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/subscribing-to-copilot-for-your-organization)."
For more information about setting a suggestion matching policy, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/setting-policies-for-copilot-in-your-organization/managing-policies-for-copilot-in-your-organization#policies-for-suggestion-matching)."

The response contains the total number of new seats that were created and existing seats that were refreshed.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`admin:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotAddCopilotSeatsForTeamsParamsSchema
  })
  async copilotAddCopilotSeatsForTeams(
    params: github.CopilotAddCopilotSeatsForTeamsParams
  ): Promise<github.CopilotAddCopilotSeatsForTeamsResponse> {
    return this.ky
      .post(`/orgs/${params.org}/copilot/billing/selected_teams`, {
        json: pick(params, 'selected_teams')
      })
      .json<github.CopilotAddCopilotSeatsForTeamsResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Sets seats for all members of each team specified to "pending cancellation".
This will cause the members of the specified team(s) to lose access to GitHub Copilot at the end of the current billing cycle unless they retain access through another team.
For more information about disabling access to Copilot, see "[Revoking access to Copilot for members of your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-access-to-github-copilot-in-your-organization/revoking-access-to-copilot-for-members-of-your-organization)."

Only organization owners can cancel Copilot seats for their organization members.

The response contains the total number of seats set to "pending cancellation".

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_cancel_copilot_seat_assignment_for_teams',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Sets seats for all members of each team specified to "pending cancellation".
This will cause the members of the specified team(s) to lose access to GitHub Copilot at the end of the current billing cycle unless they retain access through another team.
For more information about disabling access to Copilot, see "[Revoking access to Copilot for members of your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-access-to-github-copilot-in-your-organization/revoking-access-to-copilot-for-members-of-your-organization)."

Only organization owners can cancel Copilot seats for their organization members.

The response contains the total number of seats set to "pending cancellation".

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`admin:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotCancelCopilotSeatAssignmentForTeamsParamsSchema
  })
  async copilotCancelCopilotSeatAssignmentForTeams(
    params: github.CopilotCancelCopilotSeatAssignmentForTeamsParams
  ): Promise<github.CopilotCancelCopilotSeatAssignmentForTeamsResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/copilot/billing/selected_teams`, {
        json: pick(params, 'selected_teams')
      })
      .json<github.CopilotCancelCopilotSeatAssignmentForTeamsResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Purchases a GitHub Copilot seat for each user specified.
The organization will be billed for each seat based on the organization's Copilot plan. For more information about Copilot pricing, see "[About billing for GitHub Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/about-billing-for-github-copilot-in-your-organization)."

Only organization owners can purchase Copilot seats for their organization members. The organization must have a Copilot Business or Copilot Enterprise subscription and a configured suggestion matching policy.
For more information about setting up a Copilot subscription, see "[Subscribing to Copilot for your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/subscribing-to-copilot-for-your-organization)."
For more information about setting a suggestion matching policy, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/setting-policies-for-copilot-in-your-organization/managing-policies-for-copilot-in-your-organization#policies-for-suggestion-matching)."

The response contains the total number of new seats that were created and existing seats that were refreshed.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_add_copilot_seats_for_users',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Purchases a GitHub Copilot seat for each user specified.
The organization will be billed for each seat based on the organization's Copilot plan. For more information about Copilot pricing, see "[About billing for GitHub Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/about-billing-for-github-copilot-in-your-organization)."

Only organization owners can purchase Copilot seats for their organization members. The organization must have a Copilot Business or Copilot Enterprise subscription and a configured suggestion matching policy.
For more information about setting up a Copilot subscription, see "[Subscribing to Copilot for your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-the-copilot-subscription-for-your-organization/subscribing-to-copilot-for-your-organization)."
For more information about setting a suggestion matching policy, see "[Managing policies for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/setting-policies-for-copilot-in-your-organization/managing-policies-for-copilot-in-your-organization#policies-for-suggestion-matching)."

The response contains the total number of new seats that were created and existing seats that were refreshed.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`admin:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotAddCopilotSeatsForUsersParamsSchema
  })
  async copilotAddCopilotSeatsForUsers(
    params: github.CopilotAddCopilotSeatsForUsersParams
  ): Promise<github.CopilotAddCopilotSeatsForUsersResponse> {
    return this.ky
      .post(`/orgs/${params.org}/copilot/billing/selected_users`, {
        json: pick(params, 'selected_usernames')
      })
      .json<github.CopilotAddCopilotSeatsForUsersResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Sets seats for all users specified to "pending cancellation".
This will cause the specified users to lose access to GitHub Copilot at the end of the current billing cycle unless they retain access through team membership.
For more information about disabling access to Copilot, see "[Revoking access to Copilot for members of your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-access-to-github-copilot-in-your-organization/revoking-access-to-copilot-for-members-of-your-organization)."

Only organization owners can cancel Copilot seats for their organization members.

The response contains the total number of seats set to "pending cancellation".

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_cancel_copilot_seat_assignment_for_users',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Sets seats for all users specified to "pending cancellation".
This will cause the specified users to lose access to GitHub Copilot at the end of the current billing cycle unless they retain access through team membership.
For more information about disabling access to Copilot, see "[Revoking access to Copilot for members of your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/managing-access-to-github-copilot-in-your-organization/revoking-access-to-copilot-for-members-of-your-organization)."

Only organization owners can cancel Copilot seats for their organization members.

The response contains the total number of seats set to "pending cancellation".

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`admin:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotCancelCopilotSeatAssignmentForUsersParamsSchema
  })
  async copilotCancelCopilotSeatAssignmentForUsers(
    params: github.CopilotCancelCopilotSeatAssignmentForUsersParams
  ): Promise<github.CopilotCancelCopilotSeatAssignmentForUsersResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/copilot/billing/selected_users`, {
        json: pick(params, 'selected_usernames')
      })
      .json<github.CopilotCancelCopilotSeatAssignmentForUsersResponse>()
  }

  /**
 * Use this endpoint to see a breakdown of aggregated metrics for various GitHub Copilot features. See the response schema tab for detailed metrics definitions.

> [!NOTE]
> This endpoint will only return results for a given day if the organization contained **five or more members with active Copilot licenses** on that day, as evaluated at the end of that day.

The response contains metrics for up to 28 days prior. Metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

To access this endpoint, the Copilot Metrics API access policy must be enabled for the organization.
Only organization owners and owners and billing managers of the parent enterprise can view Copilot metrics.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot`, `read:org`, or `read:enterprise` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_copilot_metrics_for_organization',
    description: `Use this endpoint to see a breakdown of aggregated metrics for various GitHub Copilot features. See the response schema tab for detailed metrics definitions.

> [!NOTE]
> This endpoint will only return results for a given day if the organization contained **five or more members with active Copilot licenses** on that day, as evaluated at the end of that day.

The response contains metrics for up to 28 days prior. Metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

To access this endpoint, the Copilot Metrics API access policy must be enabled for the organization.
Only organization owners and owners and billing managers of the parent enterprise can view Copilot metrics.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\`, \`read:org\`, or \`read:enterprise\` scopes to use this endpoint.`,
    inputSchema: github.CopilotCopilotMetricsForOrganizationParamsSchema
  })
  async copilotCopilotMetricsForOrganization(
    params: github.CopilotCopilotMetricsForOrganizationParams
  ): Promise<github.CopilotCopilotMetricsForOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/copilot/metrics`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'until', 'page', 'per_page')
        )
      })
      .json<github.CopilotCopilotMetricsForOrganizationResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is closing down. It will be accessible throughout February 2025, but will not return any new data after February 1st.

You can use this endpoint to see a daily breakdown of aggregated usage metrics for Copilot completions and Copilot Chat in the IDE
across an organization, with a further breakdown of suggestions, acceptances, and number of active users by editor and language for each day.
See the response schema tab for detailed metrics definitions.

The response contains metrics for up to 28 days prior. Usage metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

Organization owners, and owners and billing managers of the parent enterprise, can view Copilot usage metrics.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot`, `read:org`, or `read:enterprise` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_usage_metrics_for_org',
    description: `> [!NOTE]
> This endpoint is closing down. It will be accessible throughout February 2025, but will not return any new data after February 1st.

You can use this endpoint to see a daily breakdown of aggregated usage metrics for Copilot completions and Copilot Chat in the IDE
across an organization, with a further breakdown of suggestions, acceptances, and number of active users by editor and language for each day.
See the response schema tab for detailed metrics definitions.

The response contains metrics for up to 28 days prior. Usage metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

Organization owners, and owners and billing managers of the parent enterprise, can view Copilot usage metrics.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\`, \`read:org\`, or \`read:enterprise\` scopes to use this endpoint.`,
    inputSchema: github.CopilotUsageMetricsForOrgParamsSchema
  })
  async copilotUsageMetricsForOrg(
    params: github.CopilotUsageMetricsForOrgParams
  ): Promise<github.CopilotUsageMetricsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/copilot/usage`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'until', 'page', 'per_page')
        )
      })
      .json<github.CopilotUsageMetricsForOrgResponse>()
  }

  /**
 * Lists Dependabot alerts for an organization.

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'dependabot_list_alerts_for_org',
    description: `Lists Dependabot alerts for an organization.

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.DependabotListAlertsForOrgParamsSchema
  })
  async dependabotListAlertsForOrg(
    params: github.DependabotListAlertsForOrgParams
  ): Promise<github.DependabotListAlertsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/dependabot/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'severity',
            'ecosystem',
            'package',
            'epss_percentage',
            'scope',
            'sort',
            'direction',
            'before',
            'after',
            'first',
            'last',
            'per_page'
          )
        )
      })
      .json<github.DependabotListAlertsForOrgResponse>()
  }

  /**
 * Lists all secrets available in an organization without revealing their
encrypted values.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_list_org_secrets',
    description: `Lists all secrets available in an organization without revealing their
encrypted values.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotListOrgSecretsParamsSchema
  })
  async dependabotListOrgSecrets(
    params: github.DependabotListOrgSecretsParams
  ): Promise<github.DependabotListOrgSecretsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/dependabot/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.DependabotListOrgSecretsResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_get_org_public_key',
    description: `Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotGetOrgPublicKeyParamsSchema
  })
  async dependabotGetOrgPublicKey(
    params: github.DependabotGetOrgPublicKeyParams
  ): Promise<github.DependabotGetOrgPublicKeyResponse> {
    return this.ky
      .get(`/orgs/${params.org}/dependabot/secrets/public-key`)
      .json<github.DependabotGetOrgPublicKeyResponse>()
  }

  /**
 * Gets a single organization secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_get_org_secret',
    description: `Gets a single organization secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotGetOrgSecretParamsSchema
  })
  async dependabotGetOrgSecret(
    params: github.DependabotGetOrgSecretParams
  ): Promise<github.DependabotGetOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}`,
        {}
      )
      .json<github.DependabotGetOrgSecretResponse>()
  }

  /**
 * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_create_or_update_org_secret',
    description: `Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotCreateOrUpdateOrgSecretParamsSchema
  })
  async dependabotCreateOrUpdateOrgSecret(
    params: github.DependabotCreateOrUpdateOrgSecretParams
  ): Promise<github.DependabotCreateOrUpdateOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}`,
        {
          json: pick(
            params,
            'encrypted_value',
            'key_id',
            'visibility',
            'selected_repository_ids'
          )
        }
      )
      .json<github.DependabotCreateOrUpdateOrgSecretResponse>()
  }

  /**
 * Deletes a secret in an organization using the secret name.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_delete_org_secret',
    description: `Deletes a secret in an organization using the secret name.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotDeleteOrgSecretParamsSchema
  })
  async dependabotDeleteOrgSecret(
    params: github.DependabotDeleteOrgSecretParams
  ): Promise<github.DependabotDeleteOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}`,
        {}
      )
      .json<github.DependabotDeleteOrgSecretResponse>()
  }

  /**
 * Lists all repositories that have been selected when the `visibility`
for repository access to a secret is set to `selected`.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_list_selected_repos_for_org_secret',
    description: `Lists all repositories that have been selected when the \`visibility\`
for repository access to a secret is set to \`selected\`.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotListSelectedReposForOrgSecretParamsSchema
  })
  async dependabotListSelectedReposForOrgSecret(
    params: github.DependabotListSelectedReposForOrgSecretParams
  ): Promise<github.DependabotListSelectedReposForOrgSecretResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.DependabotListSelectedReposForOrgSecretResponse>()
  }

  /**
 * Replaces all repositories for an organization secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_set_selected_repos_for_org_secret',
    description: `Replaces all repositories for an organization secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotSetSelectedReposForOrgSecretParamsSchema
  })
  async dependabotSetSelectedReposForOrgSecret(
    params: github.DependabotSetSelectedReposForOrgSecretParams
  ): Promise<github.DependabotSetSelectedReposForOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}/repositories`,
        {
          json: pick(params, 'selected_repository_ids')
        }
      )
      .json<github.DependabotSetSelectedReposForOrgSecretResponse>()
  }

  /**
 * Adds a repository to an organization secret when the `visibility` for
repository access is set to `selected`. The visibility is set when you [Create or
update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_add_selected_repo_to_org_secret',
    description: `Adds a repository to an organization secret when the \`visibility\` for
repository access is set to \`selected\`. The visibility is set when you [Create or
update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotAddSelectedRepoToOrgSecretParamsSchema
  })
  async dependabotAddSelectedRepoToOrgSecret(
    params: github.DependabotAddSelectedRepoToOrgSecretParams
  ): Promise<github.DependabotAddSelectedRepoToOrgSecretResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.DependabotAddSelectedRepoToOrgSecretResponse>()
  }

  /**
 * Removes a repository from an organization secret when the `visibility`
for repository access is set to `selected`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_remove_selected_repo_from_org_secret',
    description: `Removes a repository from an organization secret when the \`visibility\`
for repository access is set to \`selected\`. The visibility is set when you [Create
or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.DependabotRemoveSelectedRepoFromOrgSecretParamsSchema
  })
  async dependabotRemoveSelectedRepoFromOrgSecret(
    params: github.DependabotRemoveSelectedRepoFromOrgSecretParams
  ): Promise<github.DependabotRemoveSelectedRepoFromOrgSecretResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/dependabot/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.DependabotRemoveSelectedRepoFromOrgSecretResponse>()
  }

  /**
 * Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
 */
  @aiFunction({
    name: 'packages_list_docker_migration_conflicting_packages_for_organization',
    description: `Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint.`,
    inputSchema:
      github.PackagesListDockerMigrationConflictingPackagesForOrganizationParamsSchema
  })
  async packagesListDockerMigrationConflictingPackagesForOrganization(
    params: github.PackagesListDockerMigrationConflictingPackagesForOrganizationParams
  ): Promise<github.PackagesListDockerMigrationConflictingPackagesForOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/docker/conflicts`)
      .json<github.PackagesListDockerMigrationConflictingPackagesForOrganizationResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_public_org_events',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListPublicOrgEventsParamsSchema
  })
  async activityListPublicOrgEvents(
    params: github.ActivityListPublicOrgEventsParams
  ): Promise<github.ActivityListPublicOrgEventsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListPublicOrgEventsResponse>()
  }

  /**
   * The return hash contains `failed_at` and `failed_reason` fields which represent the time at which the invitation failed and the reason for the failure.
   */
  @aiFunction({
    name: 'orgs_list_failed_invitations',
    description: `The return hash contains \`failed_at\` and \`failed_reason\` fields which represent the time at which the invitation failed and the reason for the failure.`,
    inputSchema: github.OrgsListFailedInvitationsParamsSchema
  })
  async orgsListFailedInvitations(
    params: github.OrgsListFailedInvitationsParams
  ): Promise<github.OrgsListFailedInvitationsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/failed_invitations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListFailedInvitationsResponse>()
  }

  /**
 * List webhooks for an organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_list_webhooks',
    description: `List webhooks for an organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsListWebhooksParamsSchema
  })
  async orgsListWebhooks(
    params: github.OrgsListWebhooksParams
  ): Promise<github.OrgsListWebhooksResponse> {
    return this.ky
      .get(`/orgs/${params.org}/hooks`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListWebhooksResponse>()
  }

  /**
 * Create a hook that posts payloads in JSON format.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or
edit webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_create_webhook',
    description: `Create a hook that posts payloads in JSON format.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or
edit webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsCreateWebhookParamsSchema
  })
  async orgsCreateWebhook(
    params: github.OrgsCreateWebhookParams
  ): Promise<github.OrgsCreateWebhookResponse> {
    return this.ky
      .post(`/orgs/${params.org}/hooks`, {
        json: pick(params, 'name', 'config', 'events', 'active')
      })
      .json<github.OrgsCreateWebhookResponse>()
  }

  /**
 * Returns a webhook configured in an organization. To get only the webhook
`config` properties, see "[Get a webhook configuration for an organization](/rest/orgs/webhooks#get-a-webhook-configuration-for-an-organization).

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_get_webhook',
    description: `Returns a webhook configured in an organization. To get only the webhook
\`config\` properties, see "[Get a webhook configuration for an organization](/rest/orgs/webhooks#get-a-webhook-configuration-for-an-organization).

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsGetWebhookParamsSchema
  })
  async orgsGetWebhook(
    params: github.OrgsGetWebhookParams
  ): Promise<github.OrgsGetWebhookResponse> {
    return this.ky
      .get(`/orgs/${params.org}/hooks/${params.hook_id}`, {})
      .json<github.OrgsGetWebhookResponse>()
  }

  /**
 * Delete a webhook for an organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_delete_webhook',
    description: `Delete a webhook for an organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsDeleteWebhookParamsSchema
  })
  async orgsDeleteWebhook(
    params: github.OrgsDeleteWebhookParams
  ): Promise<github.OrgsDeleteWebhookResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/hooks/${params.hook_id}`, {})
      .json<github.OrgsDeleteWebhookResponse>()
  }

  /**
 * Updates a webhook configured in an organization. When you update a webhook,
the `secret` will be overwritten. If you previously had a `secret` set, you must
provide the same `secret` or set a new `secret` or the secret will be removed. If
you are only updating individual webhook `config` properties, use "[Update a webhook
configuration for an organization](/rest/orgs/webhooks#update-a-webhook-configuration-for-an-organization)".

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_update_webhook',
    description: `Updates a webhook configured in an organization. When you update a webhook,
the \`secret\` will be overwritten. If you previously had a \`secret\` set, you must
provide the same \`secret\` or set a new \`secret\` or the secret will be removed. If
you are only updating individual webhook \`config\` properties, use "[Update a webhook
configuration for an organization](/rest/orgs/webhooks#update-a-webhook-configuration-for-an-organization)".

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsUpdateWebhookParamsSchema
  })
  async orgsUpdateWebhook(
    params: github.OrgsUpdateWebhookParams
  ): Promise<github.OrgsUpdateWebhookResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/hooks/${params.hook_id}`, {
        json: pick(params, 'config', 'events', 'active', 'name')
      })
      .json<github.OrgsUpdateWebhookResponse>()
  }

  /**
 * Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/orgs/webhooks#get-an-organization-webhook)."

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_get_webhook_config_for_org',
    description: `Returns the webhook configuration for an organization. To get more information about the webhook, including the \`active\` state and \`events\`, use "[Get an organization webhook ](/rest/orgs/webhooks#get-an-organization-webhook)."

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsGetWebhookConfigForOrgParamsSchema
  })
  async orgsGetWebhookConfigForOrg(
    params: github.OrgsGetWebhookConfigForOrgParams
  ): Promise<github.OrgsGetWebhookConfigForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/hooks/${params.hook_id}/config`, {})
      .json<github.OrgsGetWebhookConfigForOrgResponse>()
  }

  /**
 * Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/orgs/webhooks#update-an-organization-webhook)."

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_update_webhook_config_for_org',
    description: `Updates the webhook configuration for an organization. To update more information about the webhook, including the \`active\` state and \`events\`, use "[Update an organization webhook ](/rest/orgs/webhooks#update-an-organization-webhook)."

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsUpdateWebhookConfigForOrgParamsSchema
  })
  async orgsUpdateWebhookConfigForOrg(
    params: github.OrgsUpdateWebhookConfigForOrgParams
  ): Promise<github.OrgsUpdateWebhookConfigForOrgResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/hooks/${params.hook_id}/config`, {
        json: pick(params, 'url', 'content_type', 'secret', 'insecure_ssl')
      })
      .json<github.OrgsUpdateWebhookConfigForOrgResponse>()
  }

  /**
 * Returns a list of webhook deliveries for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_list_webhook_deliveries',
    description: `Returns a list of webhook deliveries for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsListWebhookDeliveriesParamsSchema
  })
  async orgsListWebhookDeliveries(
    params: github.OrgsListWebhookDeliveriesParams
  ): Promise<github.OrgsListWebhookDeliveriesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/hooks/${params.hook_id}/deliveries`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'cursor'))
      })
      .json<github.OrgsListWebhookDeliveriesResponse>()
  }

  /**
 * Returns a delivery for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_get_webhook_delivery',
    description: `Returns a delivery for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsGetWebhookDeliveryParamsSchema
  })
  async orgsGetWebhookDelivery(
    params: github.OrgsGetWebhookDeliveryParams
  ): Promise<github.OrgsGetWebhookDeliveryResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/hooks/${params.hook_id}/deliveries/${params.delivery_id}`,
        {}
      )
      .json<github.OrgsGetWebhookDeliveryResponse>()
  }

  /**
 * Redeliver a delivery for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_redeliver_webhook_delivery',
    description: `Redeliver a delivery for a webhook configured in an organization.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsRedeliverWebhookDeliveryParamsSchema
  })
  async orgsRedeliverWebhookDelivery(
    params: github.OrgsRedeliverWebhookDeliveryParams
  ): Promise<github.OrgsRedeliverWebhookDeliveryResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/hooks/${params.hook_id}/deliveries/${params.delivery_id}/attempts`,
        {}
      )
      .json<github.OrgsRedeliverWebhookDeliveryResponse>()
  }

  /**
 * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event)
to be sent to the hook.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
 */
  @aiFunction({
    name: 'orgs_ping_webhook',
    description: `This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event)
to be sent to the hook.

You must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need \`admin:org_hook\` scope. OAuth apps cannot list, view, or edit
webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.`,
    inputSchema: github.OrgsPingWebhookParamsSchema
  })
  async orgsPingWebhook(
    params: github.OrgsPingWebhookParams
  ): Promise<github.OrgsPingWebhookResponse> {
    return this.ky
      .post(`/orgs/${params.org}/hooks/${params.hook_id}/pings`, {})
      .json<github.OrgsPingWebhookResponse>()
  }

  /**
   * Get API request count statistics for an actor broken down by route within a specified time frame.
   */
  @aiFunction({
    name: 'api_insights_get_route_stats_by_actor',
    description: `Get API request count statistics for an actor broken down by route within a specified time frame.`,
    inputSchema: github.ApiInsightsGetRouteStatsByActorParamsSchema
  })
  async apiInsightsGetRouteStatsByActor(
    params: github.ApiInsightsGetRouteStatsByActorParams
  ): Promise<github.ApiInsightsGetRouteStatsByActorResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/route-stats/${params.actor_type}/${params.actor_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'min_timestamp',
              'max_timestamp',
              'page',
              'per_page',
              'direction',
              'sort',
              'api_route_substring'
            )
          )
        }
      )
      .json<github.ApiInsightsGetRouteStatsByActorResponse>()
  }

  /**
   * Get API request statistics for all subjects within an organization within a specified time frame. Subjects can be users or GitHub Apps.
   */
  @aiFunction({
    name: 'api_insights_get_subject_stats',
    description: `Get API request statistics for all subjects within an organization within a specified time frame. Subjects can be users or GitHub Apps.`,
    inputSchema: github.ApiInsightsGetSubjectStatsParamsSchema
  })
  async apiInsightsGetSubjectStats(
    params: github.ApiInsightsGetSubjectStatsParams
  ): Promise<github.ApiInsightsGetSubjectStatsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/insights/api/subject-stats`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'min_timestamp',
            'max_timestamp',
            'page',
            'per_page',
            'direction',
            'sort',
            'subject_name_substring'
          )
        )
      })
      .json<github.ApiInsightsGetSubjectStatsResponse>()
  }

  /**
   * Get overall statistics of API requests made within an organization by all users and apps within a specified time frame.
   */
  @aiFunction({
    name: 'api_insights_get_summary_stats',
    description: `Get overall statistics of API requests made within an organization by all users and apps within a specified time frame.`,
    inputSchema: github.ApiInsightsGetSummaryStatsParamsSchema
  })
  async apiInsightsGetSummaryStats(
    params: github.ApiInsightsGetSummaryStatsParams
  ): Promise<github.ApiInsightsGetSummaryStatsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/insights/api/summary-stats`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'min_timestamp', 'max_timestamp')
        )
      })
      .json<github.ApiInsightsGetSummaryStatsResponse>()
  }

  /**
   * Get overall statistics of API requests within the organization for a user.
   */
  @aiFunction({
    name: 'api_insights_get_summary_stats_by_user',
    description: `Get overall statistics of API requests within the organization for a user.`,
    inputSchema: github.ApiInsightsGetSummaryStatsByUserParamsSchema
  })
  async apiInsightsGetSummaryStatsByUser(
    params: github.ApiInsightsGetSummaryStatsByUserParams
  ): Promise<github.ApiInsightsGetSummaryStatsByUserResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/summary-stats/users/${params.user_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'min_timestamp', 'max_timestamp')
          )
        }
      )
      .json<github.ApiInsightsGetSummaryStatsByUserResponse>()
  }

  /**
   * Get overall statistics of API requests within the organization made by a specific actor. Actors can be GitHub App installations, OAuth apps or other tokens on behalf of a user.
   */
  @aiFunction({
    name: 'api_insights_get_summary_stats_by_actor',
    description: `Get overall statistics of API requests within the organization made by a specific actor. Actors can be GitHub App installations, OAuth apps or other tokens on behalf of a user.`,
    inputSchema: github.ApiInsightsGetSummaryStatsByActorParamsSchema
  })
  async apiInsightsGetSummaryStatsByActor(
    params: github.ApiInsightsGetSummaryStatsByActorParams
  ): Promise<github.ApiInsightsGetSummaryStatsByActorResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/summary-stats/${params.actor_type}/${params.actor_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'min_timestamp', 'max_timestamp')
          )
        }
      )
      .json<github.ApiInsightsGetSummaryStatsByActorResponse>()
  }

  /**
   * Get the number of API requests and rate-limited requests made within an organization over a specified time period.
   */
  @aiFunction({
    name: 'api_insights_get_time_stats',
    description: `Get the number of API requests and rate-limited requests made within an organization over a specified time period.`,
    inputSchema: github.ApiInsightsGetTimeStatsParamsSchema
  })
  async apiInsightsGetTimeStats(
    params: github.ApiInsightsGetTimeStatsParams
  ): Promise<github.ApiInsightsGetTimeStatsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/insights/api/time-stats`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'min_timestamp', 'max_timestamp', 'timestamp_increment')
        )
      })
      .json<github.ApiInsightsGetTimeStatsResponse>()
  }

  /**
   * Get the number of API requests and rate-limited requests made within an organization by a specific user over a specified time period.
   */
  @aiFunction({
    name: 'api_insights_get_time_stats_by_user',
    description: `Get the number of API requests and rate-limited requests made within an organization by a specific user over a specified time period.`,
    inputSchema: github.ApiInsightsGetTimeStatsByUserParamsSchema
  })
  async apiInsightsGetTimeStatsByUser(
    params: github.ApiInsightsGetTimeStatsByUserParams
  ): Promise<github.ApiInsightsGetTimeStatsByUserResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/time-stats/users/${params.user_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'min_timestamp',
              'max_timestamp',
              'timestamp_increment'
            )
          )
        }
      )
      .json<github.ApiInsightsGetTimeStatsByUserResponse>()
  }

  /**
   * Get the number of API requests and rate-limited requests made within an organization by a specific actor within a specified time period.
   */
  @aiFunction({
    name: 'api_insights_get_time_stats_by_actor',
    description: `Get the number of API requests and rate-limited requests made within an organization by a specific actor within a specified time period.`,
    inputSchema: github.ApiInsightsGetTimeStatsByActorParamsSchema
  })
  async apiInsightsGetTimeStatsByActor(
    params: github.ApiInsightsGetTimeStatsByActorParams
  ): Promise<github.ApiInsightsGetTimeStatsByActorResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/time-stats/${params.actor_type}/${params.actor_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'min_timestamp',
              'max_timestamp',
              'timestamp_increment'
            )
          )
        }
      )
      .json<github.ApiInsightsGetTimeStatsByActorResponse>()
  }

  /**
   * Get API usage statistics within an organization for a user broken down by the type of access.
   */
  @aiFunction({
    name: 'api_insights_get_user_stats',
    description: `Get API usage statistics within an organization for a user broken down by the type of access.`,
    inputSchema: github.ApiInsightsGetUserStatsParamsSchema
  })
  async apiInsightsGetUserStats(
    params: github.ApiInsightsGetUserStatsParams
  ): Promise<github.ApiInsightsGetUserStatsResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/insights/api/user-stats/${params.user_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'min_timestamp',
              'max_timestamp',
              'page',
              'per_page',
              'direction',
              'sort',
              'actor_name_substring'
            )
          )
        }
      )
      .json<github.ApiInsightsGetUserStatsResponse>()
  }

  /**
 * Enables an authenticated GitHub App to find the organization's installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_org_installation',
    description: `Enables an authenticated GitHub App to find the organization's installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetOrgInstallationParamsSchema
  })
  async appsGetOrgInstallation(
    params: github.AppsGetOrgInstallationParams
  ): Promise<github.AppsGetOrgInstallationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/installation`)
      .json<github.AppsGetOrgInstallationResponse>()
  }

  /**
 * Lists all GitHub Apps in an organization. The installation count includes
all GitHub Apps installed on repositories in the organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:read` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_app_installations',
    description: `Lists all GitHub Apps in an organization. The installation count includes
all GitHub Apps installed on repositories in the organization.

The authenticated user must be an organization owner to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:read\` scope to use this endpoint.`,
    inputSchema: github.OrgsListAppInstallationsParamsSchema
  })
  async orgsListAppInstallations(
    params: github.OrgsListAppInstallationsParams
  ): Promise<github.OrgsListAppInstallationsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/installations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListAppInstallationsResponse>()
  }

  /**
   * Shows which type of GitHub user can interact with this organization and when the restriction expires. If there is no restrictions, you will see an empty response.
   */
  @aiFunction({
    name: 'interactions_get_restrictions_for_org',
    description: `Shows which type of GitHub user can interact with this organization and when the restriction expires. If there is no restrictions, you will see an empty response.`,
    inputSchema: github.InteractionsGetRestrictionsForOrgParamsSchema
  })
  async interactionsGetRestrictionsForOrg(
    params: github.InteractionsGetRestrictionsForOrgParams
  ): Promise<github.InteractionsGetRestrictionsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/interaction-limits`)
      .json<github.InteractionsGetRestrictionsForOrgResponse>()
  }

  /**
   * Temporarily restricts interactions to a certain type of GitHub user in any public repository in the given organization. You must be an organization owner to set these restrictions. Setting the interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories owned by the organization.
   */
  @aiFunction({
    name: 'interactions_set_restrictions_for_org',
    description: `Temporarily restricts interactions to a certain type of GitHub user in any public repository in the given organization. You must be an organization owner to set these restrictions. Setting the interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories owned by the organization.`,
    inputSchema: github.InteractionsSetRestrictionsForOrgParamsSchema
  })
  async interactionsSetRestrictionsForOrg(
    params: github.InteractionsSetRestrictionsForOrgParams
  ): Promise<github.InteractionsSetRestrictionsForOrgResponse> {
    return this.ky
      .put(`/orgs/${params.org}/interaction-limits`, {
        json: pick(params, 'limit', 'expiry')
      })
      .json<github.InteractionsSetRestrictionsForOrgResponse>()
  }

  /**
   * Removes all interaction restrictions from public repositories in the given organization. You must be an organization owner to remove restrictions.
   */
  @aiFunction({
    name: 'interactions_remove_restrictions_for_org',
    description: `Removes all interaction restrictions from public repositories in the given organization. You must be an organization owner to remove restrictions.`,
    inputSchema: github.InteractionsRemoveRestrictionsForOrgParamsSchema
  })
  async interactionsRemoveRestrictionsForOrg(
    params: github.InteractionsRemoveRestrictionsForOrgParams
  ): Promise<github.InteractionsRemoveRestrictionsForOrgResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/interaction-limits`)
      .json<github.InteractionsRemoveRestrictionsForOrgResponse>()
  }

  /**
 * The return hash contains a `role` field which refers to the Organization
Invitation role and will be one of the following values: `direct_member`, `admin`,
`billing_manager`, or `hiring_manager`. If the invitee is not a GitHub
member, the `login` field in the return hash will be `null`.
 */
  @aiFunction({
    name: 'orgs_list_pending_invitations',
    description: `The return hash contains a \`role\` field which refers to the Organization
Invitation role and will be one of the following values: \`direct_member\`, \`admin\`,
\`billing_manager\`, or \`hiring_manager\`. If the invitee is not a GitHub
member, the \`login\` field in the return hash will be \`null\`.`,
    inputSchema: github.OrgsListPendingInvitationsParamsSchema
  })
  async orgsListPendingInvitations(
    params: github.OrgsListPendingInvitationsParams
  ): Promise<github.OrgsListPendingInvitationsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/invitations`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'role', 'invitation_source')
        )
      })
      .json<github.OrgsListPendingInvitationsResponse>()
  }

  /**
 * Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".
 */
  @aiFunction({
    name: 'orgs_create_invitation',
    description: `Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".`,
    inputSchema: github.OrgsCreateInvitationParamsSchema
  })
  async orgsCreateInvitation(
    params: github.OrgsCreateInvitationParams
  ): Promise<github.OrgsCreateInvitationResponse> {
    return this.ky
      .post(`/orgs/${params.org}/invitations`, {
        json: pick(params, 'invitee_id', 'email', 'role', 'team_ids')
      })
      .json<github.OrgsCreateInvitationResponse>()
  }

  /**
 * Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
 */
  @aiFunction({
    name: 'orgs_cancel_invitation',
    description: `Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).`,
    inputSchema: github.OrgsCancelInvitationParamsSchema
  })
  async orgsCancelInvitation(
    params: github.OrgsCancelInvitationParams
  ): Promise<github.OrgsCancelInvitationResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/invitations/${params.invitation_id}`,
        {}
      )
      .json<github.OrgsCancelInvitationResponse>()
  }

  /**
   * List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner.
   */
  @aiFunction({
    name: 'orgs_list_invitation_teams',
    description: `List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner.`,
    inputSchema: github.OrgsListInvitationTeamsParamsSchema
  })
  async orgsListInvitationTeams(
    params: github.OrgsListInvitationTeamsParams
  ): Promise<github.OrgsListInvitationTeamsResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/invitations/${params.invitation_id}/teams`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.OrgsListInvitationTeamsResponse>()
  }

  /**
   * Lists all issue types for an organization. OAuth app tokens and personal access tokens (classic) need the read:org scope to use this endpoint.
   */
  @aiFunction({
    name: 'orgs_list_issue_types',
    description: `Lists all issue types for an organization. OAuth app tokens and personal access tokens (classic) need the read:org scope to use this endpoint.`,
    inputSchema: github.OrgsListIssueTypesParamsSchema
  })
  async orgsListIssueTypes(
    params: github.OrgsListIssueTypesParams
  ): Promise<github.OrgsListIssueTypesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/issue-types`)
      .json<github.OrgsListIssueTypesResponse>()
  }

  /**
 * Create a new issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_create_issue_type',
    description: `Create a new issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsCreateIssueTypeParamsSchema
  })
  async orgsCreateIssueType(
    params: github.OrgsCreateIssueTypeParams
  ): Promise<github.OrgsCreateIssueTypeResponse> {
    return this.ky
      .post(`/orgs/${params.org}/issue-types`, {
        json: pick(
          params,
          'name',
          'is_enabled',
          'is_private',
          'description',
          'color'
        )
      })
      .json<github.OrgsCreateIssueTypeResponse>()
  }

  /**
 * Updates an issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_update_issue_type',
    description: `Updates an issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsUpdateIssueTypeParamsSchema
  })
  async orgsUpdateIssueType(
    params: github.OrgsUpdateIssueTypeParams
  ): Promise<github.OrgsUpdateIssueTypeResponse> {
    return this.ky
      .put(`/orgs/${params.org}/issue-types/${params.issue_type_id}`, {
        json: pick(
          params,
          'name',
          'is_enabled',
          'is_private',
          'description',
          'color'
        )
      })
      .json<github.OrgsUpdateIssueTypeResponse>()
  }

  /**
 * Deletes an issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_delete_issue_type',
    description: `Deletes an issue type for an organization.

You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).

To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsDeleteIssueTypeParamsSchema
  })
  async orgsDeleteIssueType(
    params: github.OrgsDeleteIssueTypeParams
  ): Promise<github.OrgsDeleteIssueTypeResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/issue-types/${params.issue_type_id}`,
        {}
      )
      .json<github.OrgsDeleteIssueTypeResponse>()
  }

  /**
 * List issues in an organization assigned to the authenticated user.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_for_org',
    description: `List issues in an organization assigned to the authenticated user.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the \`pull_request\` key. Be aware that the \`id\` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListForOrgParamsSchema
  })
  async issuesListForOrg(
    params: github.IssuesListForOrgParams
  ): Promise<github.IssuesListForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/issues`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'filter',
            'state',
            'labels',
            'type',
            'sort',
            'direction',
            'since',
            'per_page',
            'page'
          )
        )
      })
      .json<github.IssuesListForOrgResponse>()
  }

  /**
   * List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.
   */
  @aiFunction({
    name: 'orgs_list_members',
    description: `List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.`,
    inputSchema: github.OrgsListMembersParamsSchema
  })
  async orgsListMembers(
    params: github.OrgsListMembersParams
  ): Promise<github.OrgsListMembersResponse> {
    return this.ky
      .get(`/orgs/${params.org}/members`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'filter', 'role', 'per_page', 'page')
        )
      })
      .json<github.OrgsListMembersResponse>()
  }

  /**
   * Check if a user is, publicly or privately, a member of the organization.
   */
  @aiFunction({
    name: 'orgs_check_membership_for_user',
    description: `Check if a user is, publicly or privately, a member of the organization.`,
    inputSchema: github.OrgsCheckMembershipForUserParamsSchema
  })
  async orgsCheckMembershipForUser(
    params: github.OrgsCheckMembershipForUserParams
  ): Promise<github.OrgsCheckMembershipForUserResponse> {
    return this.ky
      .get(`/orgs/${params.org}/members/${params.username}`, {})
      .json<github.OrgsCheckMembershipForUserResponse>()
  }

  /**
   * Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.
   */
  @aiFunction({
    name: 'orgs_remove_member',
    description: `Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.`,
    inputSchema: github.OrgsRemoveMemberParamsSchema
  })
  async orgsRemoveMember(
    params: github.OrgsRemoveMemberParams
  ): Promise<github.OrgsRemoveMemberResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/members/${params.username}`, {})
      .json<github.OrgsRemoveMemberResponse>()
  }

  /**
 * Lists the codespaces that a member of an organization has for repositories in that organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_codespaces_for_user_in_org',
    description: `Lists the codespaces that a member of an organization has for repositories in that organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetCodespacesForUserInOrgParamsSchema
  })
  async codespacesGetCodespacesForUserInOrg(
    params: github.CodespacesGetCodespacesForUserInOrgParams
  ): Promise<github.CodespacesGetCodespacesForUserInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/members/${params.username}/codespaces`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesGetCodespacesForUserInOrgResponse>()
  }

  /**
 * Deletes a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_delete_from_organization',
    description: `Deletes a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesDeleteFromOrganizationParamsSchema
  })
  async codespacesDeleteFromOrganization(
    params: github.CodespacesDeleteFromOrganizationParams
  ): Promise<github.CodespacesDeleteFromOrganizationResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/members/${params.username}/codespaces/${params.codespace_name}`,
        {}
      )
      .json<github.CodespacesDeleteFromOrganizationResponse>()
  }

  /**
 * Stops a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_stop_in_organization',
    description: `Stops a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.CodespacesStopInOrganizationParamsSchema
  })
  async codespacesStopInOrganization(
    params: github.CodespacesStopInOrganizationParams
  ): Promise<github.CodespacesStopInOrganizationResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/members/${params.username}/codespaces/${params.codespace_name}/stop`,
        {}
      )
      .json<github.CodespacesStopInOrganizationResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets the GitHub Copilot seat details for a member of an organization who currently has access to GitHub Copilot.

The seat object contains information about the user's most recent Copilot activity. Users must have telemetry enabled in their IDE for Copilot in the IDE activity to be reflected in `last_activity_at`.
For more information about activity data, see "[Reviewing user activity data for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/reviewing-activity-related-to-github-copilot-in-your-organization/reviewing-user-activity-data-for-copilot-in-your-organization)."

Only organization owners can view Copilot seat assignment details for members of their organization.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `read:org` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_get_copilot_seat_details_for_user',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets the GitHub Copilot seat details for a member of an organization who currently has access to GitHub Copilot.

The seat object contains information about the user's most recent Copilot activity. Users must have telemetry enabled in their IDE for Copilot in the IDE activity to be reflected in \`last_activity_at\`.
For more information about activity data, see "[Reviewing user activity data for Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-github-copilot-in-your-organization/reviewing-activity-related-to-github-copilot-in-your-organization/reviewing-user-activity-data-for-copilot-in-your-organization)."

Only organization owners can view Copilot seat assignment details for members of their organization.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\` or \`read:org\` scopes to use this endpoint.`,
    inputSchema: github.CopilotGetCopilotSeatDetailsForUserParamsSchema
  })
  async copilotGetCopilotSeatDetailsForUser(
    params: github.CopilotGetCopilotSeatDetailsForUserParams
  ): Promise<github.CopilotGetCopilotSeatDetailsForUserResponse> {
    return this.ky
      .get(`/orgs/${params.org}/members/${params.username}/copilot`, {})
      .json<github.CopilotGetCopilotSeatDetailsForUserResponse>()
  }

  /**
   * In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status.
   */
  @aiFunction({
    name: 'orgs_get_membership_for_user',
    description: `In order to get a user's membership with an organization, the authenticated user must be an organization member. The \`state\` parameter in the response can be used to identify the user's membership status.`,
    inputSchema: github.OrgsGetMembershipForUserParamsSchema
  })
  async orgsGetMembershipForUser(
    params: github.OrgsGetMembershipForUserParams
  ): Promise<github.OrgsGetMembershipForUserResponse> {
    return this.ky
      .get(`/orgs/${params.org}/memberships/${params.username}`, {})
      .json<github.OrgsGetMembershipForUserResponse>()
  }

  /**
 * Only authenticated organization owners can add a member to the organization or update the member's role.

*   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/orgs/members#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.

*   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.

**Rate limits**

To prevent abuse, organization owners are limited to creating 50 organization invitations for an organization within a 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
 */
  @aiFunction({
    name: 'orgs_set_membership_for_user',
    description: `Only authenticated organization owners can add a member to the organization or update the member's role.

*   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/orgs/members#get-organization-membership-for-a-user) will be \`pending\` until they accept the invitation.

*   Authenticated users can _update_ a user's membership by passing the \`role\` parameter. If the authenticated user changes a member's role to \`admin\`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to \`member\`, no email will be sent.

**Rate limits**

To prevent abuse, organization owners are limited to creating 50 organization invitations for an organization within a 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.`,
    inputSchema: github.OrgsSetMembershipForUserParamsSchema
  })
  async orgsSetMembershipForUser(
    params: github.OrgsSetMembershipForUserParams
  ): Promise<github.OrgsSetMembershipForUserResponse> {
    return this.ky
      .put(`/orgs/${params.org}/memberships/${params.username}`, {
        json: pick(params, 'role')
      })
      .json<github.OrgsSetMembershipForUserResponse>()
  }

  /**
 * In order to remove a user's membership with an organization, the authenticated user must be an organization owner.

If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
 */
  @aiFunction({
    name: 'orgs_remove_membership_for_user',
    description: `In order to remove a user's membership with an organization, the authenticated user must be an organization owner.

If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.`,
    inputSchema: github.OrgsRemoveMembershipForUserParamsSchema
  })
  async orgsRemoveMembershipForUser(
    params: github.OrgsRemoveMembershipForUserParams
  ): Promise<github.OrgsRemoveMembershipForUserResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/memberships/${params.username}`, {})
      .json<github.OrgsRemoveMembershipForUserResponse>()
  }

  /**
 * Lists the most recent migrations, including both exports (which can be started through the REST API) and imports (which cannot be started using the REST API).

A list of `repositories` is only returned for export migrations.
 */
  @aiFunction({
    name: 'migrations_list_for_org',
    description: `Lists the most recent migrations, including both exports (which can be started through the REST API) and imports (which cannot be started using the REST API).

A list of \`repositories\` is only returned for export migrations.`,
    inputSchema: github.MigrationsListForOrgParamsSchema
  })
  async migrationsListForOrg(
    params: github.MigrationsListForOrgParams
  ): Promise<github.MigrationsListForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/migrations`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'exclude')
        )
      })
      .json<github.MigrationsListForOrgResponse>()
  }

  /**
   * Initiates the generation of a migration archive.
   */
  @aiFunction({
    name: 'migrations_start_for_org',
    description: `Initiates the generation of a migration archive.`,
    inputSchema: github.MigrationsStartForOrgParamsSchema
  })
  async migrationsStartForOrg(
    params: github.MigrationsStartForOrgParams
  ): Promise<github.MigrationsStartForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/migrations`, {
        json: pick(
          params,
          'repositories',
          'lock_repositories',
          'exclude_metadata',
          'exclude_git_data',
          'exclude_attachments',
          'exclude_releases',
          'exclude_owner_projects',
          'org_metadata_only',
          'exclude'
        )
      })
      .json<github.MigrationsStartForOrgResponse>()
  }

  /**
 * Fetches the status of a migration.

The `state` of a migration can be one of the following values:

*   `pending`, which means the migration hasn't started yet.
*   `exporting`, which means the migration is in progress.
*   `exported`, which means the migration finished successfully.
*   `failed`, which means the migration failed.
 */
  @aiFunction({
    name: 'migrations_get_status_for_org',
    description: `Fetches the status of a migration.

The \`state\` of a migration can be one of the following values:

*   \`pending\`, which means the migration hasn't started yet.
*   \`exporting\`, which means the migration is in progress.
*   \`exported\`, which means the migration finished successfully.
*   \`failed\`, which means the migration failed.`,
    inputSchema: github.MigrationsGetStatusForOrgParamsSchema
  })
  async migrationsGetStatusForOrg(
    params: github.MigrationsGetStatusForOrgParams
  ): Promise<github.MigrationsGetStatusForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/migrations/${params.migration_id}`, {
        searchParams: sanitizeSearchParams(pick(params, 'exclude'))
      })
      .json<github.MigrationsGetStatusForOrgResponse>()
  }

  /**
   * Fetches the URL to a migration archive.
   */
  @aiFunction({
    name: 'migrations_download_archive_for_org',
    description: `Fetches the URL to a migration archive.`,
    inputSchema: github.MigrationsDownloadArchiveForOrgParamsSchema
  })
  async migrationsDownloadArchiveForOrg(
    params: github.MigrationsDownloadArchiveForOrgParams
  ): Promise<github.MigrationsDownloadArchiveForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/migrations/${params.migration_id}/archive`,
        {}
      )
      .json<github.MigrationsDownloadArchiveForOrgResponse>()
  }

  /**
   * Deletes a previous migration archive. Migration archives are automatically deleted after seven days.
   */
  @aiFunction({
    name: 'migrations_delete_archive_for_org',
    description: `Deletes a previous migration archive. Migration archives are automatically deleted after seven days.`,
    inputSchema: github.MigrationsDeleteArchiveForOrgParamsSchema
  })
  async migrationsDeleteArchiveForOrg(
    params: github.MigrationsDeleteArchiveForOrgParams
  ): Promise<github.MigrationsDeleteArchiveForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/migrations/${params.migration_id}/archive`,
        {}
      )
      .json<github.MigrationsDeleteArchiveForOrgResponse>()
  }

  /**
   * Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/repos/repos#delete-a-repository) when the migration is complete and you no longer need the source data.
   */
  @aiFunction({
    name: 'migrations_unlock_repo_for_org',
    description: `Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/repos/repos#delete-a-repository) when the migration is complete and you no longer need the source data.`,
    inputSchema: github.MigrationsUnlockRepoForOrgParamsSchema
  })
  async migrationsUnlockRepoForOrg(
    params: github.MigrationsUnlockRepoForOrgParams
  ): Promise<github.MigrationsUnlockRepoForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/migrations/${params.migration_id}/repos/${params.repo_name}/lock`,
        {}
      )
      .json<github.MigrationsUnlockRepoForOrgResponse>()
  }

  /**
   * List all the repositories for this organization migration.
   */
  @aiFunction({
    name: 'migrations_list_repos_for_org',
    description: `List all the repositories for this organization migration.`,
    inputSchema: github.MigrationsListReposForOrgParamsSchema
  })
  async migrationsListReposForOrg(
    params: github.MigrationsListReposForOrgParams
  ): Promise<github.MigrationsListReposForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/migrations/${params.migration_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.MigrationsListReposForOrgResponse>()
  }

  /**
 * Lists the organization roles available in this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, the authenticated user must be one of:

- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permissions of `read_organization_custom_org_role` in the organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_org_roles',
    description: `Lists the organization roles available in this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, the authenticated user must be one of:

- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permissions of \`read_organization_custom_org_role\` in the organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsListOrgRolesParamsSchema
  })
  async orgsListOrgRoles(
    params: github.OrgsListOrgRolesParams
  ): Promise<github.OrgsListOrgRolesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/organization-roles`)
      .json<github.OrgsListOrgRolesResponse>()
  }

  /**
 * Removes all assigned organization roles from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_revoke_all_org_roles_team',
    description: `Removes all assigned organization roles from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsRevokeAllOrgRolesTeamParamsSchema
  })
  async orgsRevokeAllOrgRolesTeam(
    params: github.OrgsRevokeAllOrgRolesTeamParams
  ): Promise<github.OrgsRevokeAllOrgRolesTeamResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/organization-roles/teams/${params.team_slug}`,
        {}
      )
      .json<github.OrgsRevokeAllOrgRolesTeamResponse>()
  }

  /**
 * Assigns an organization role to a team in an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_assign_team_to_org_role',
    description: `Assigns an organization role to a team in an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsAssignTeamToOrgRoleParamsSchema
  })
  async orgsAssignTeamToOrgRole(
    params: github.OrgsAssignTeamToOrgRoleParams
  ): Promise<github.OrgsAssignTeamToOrgRoleResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/organization-roles/teams/${params.team_slug}/${params.role_id}`,
        {}
      )
      .json<github.OrgsAssignTeamToOrgRoleResponse>()
  }

  /**
 * Removes an organization role from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_revoke_org_role_team',
    description: `Removes an organization role from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsRevokeOrgRoleTeamParamsSchema
  })
  async orgsRevokeOrgRoleTeam(
    params: github.OrgsRevokeOrgRoleTeamParams
  ): Promise<github.OrgsRevokeOrgRoleTeamResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/organization-roles/teams/${params.team_slug}/${params.role_id}`,
        {}
      )
      .json<github.OrgsRevokeOrgRoleTeamResponse>()
  }

  /**
 * Revokes all assigned organization roles from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_revoke_all_org_roles_user',
    description: `Revokes all assigned organization roles from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsRevokeAllOrgRolesUserParamsSchema
  })
  async orgsRevokeAllOrgRolesUser(
    params: github.OrgsRevokeAllOrgRolesUserParams
  ): Promise<github.OrgsRevokeAllOrgRolesUserResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/organization-roles/users/${params.username}`,
        {}
      )
      .json<github.OrgsRevokeAllOrgRolesUserResponse>()
  }

  /**
 * Assigns an organization role to a member of an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_assign_user_to_org_role',
    description: `Assigns an organization role to a member of an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsAssignUserToOrgRoleParamsSchema
  })
  async orgsAssignUserToOrgRole(
    params: github.OrgsAssignUserToOrgRoleParams
  ): Promise<github.OrgsAssignUserToOrgRoleResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/organization-roles/users/${params.username}/${params.role_id}`,
        {}
      )
      .json<github.OrgsAssignUserToOrgRoleResponse>()
  }

  /**
 * Remove an organization role from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_revoke_org_role_user',
    description: `Remove an organization role from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

The authenticated user must be an administrator for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsRevokeOrgRoleUserParamsSchema
  })
  async orgsRevokeOrgRoleUser(
    params: github.OrgsRevokeOrgRoleUserParams
  ): Promise<github.OrgsRevokeOrgRoleUserResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/organization-roles/users/${params.username}/${params.role_id}`,
        {}
      )
      .json<github.OrgsRevokeOrgRoleUserResponse>()
  }

  /**
 * Gets an organization role that is available to this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, the authenticated user must be one of:

- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permissions of `read_organization_custom_org_role` in the organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_get_org_role',
    description: `Gets an organization role that is available to this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, the authenticated user must be one of:

- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permissions of \`read_organization_custom_org_role\` in the organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsGetOrgRoleParamsSchema
  })
  async orgsGetOrgRole(
    params: github.OrgsGetOrgRoleParams
  ): Promise<github.OrgsGetOrgRoleResponse> {
    return this.ky
      .get(`/orgs/${params.org}/organization-roles/${params.role_id}`, {})
      .json<github.OrgsGetOrgRoleResponse>()
  }

  /**
 * Lists the teams that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, you must be an administrator for the organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_org_role_teams',
    description: `Lists the teams that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, you must be an administrator for the organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsListOrgRoleTeamsParamsSchema
  })
  async orgsListOrgRoleTeams(
    params: github.OrgsListOrgRoleTeamsParams
  ): Promise<github.OrgsListOrgRoleTeamsResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/organization-roles/${params.role_id}/teams`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.OrgsListOrgRoleTeamsResponse>()
  }

  /**
 * Lists organization members that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, you must be an administrator for the organization.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_org_role_users',
    description: `Lists organization members that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."

To use this endpoint, you must be an administrator for the organization.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.OrgsListOrgRoleUsersParamsSchema
  })
  async orgsListOrgRoleUsers(
    params: github.OrgsListOrgRoleUsersParams
  ): Promise<github.OrgsListOrgRoleUsersResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/organization-roles/${params.role_id}/users`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.OrgsListOrgRoleUsersResponse>()
  }

  /**
   * List all users who are outside collaborators of an organization.
   */
  @aiFunction({
    name: 'orgs_list_outside_collaborators',
    description: `List all users who are outside collaborators of an organization.`,
    inputSchema: github.OrgsListOutsideCollaboratorsParamsSchema
  })
  async orgsListOutsideCollaborators(
    params: github.OrgsListOutsideCollaboratorsParams
  ): Promise<github.OrgsListOutsideCollaboratorsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/outside_collaborators`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'filter', 'per_page', 'page')
        )
      })
      .json<github.OrgsListOutsideCollaboratorsResponse>()
  }

  /**
   * When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).".
   */
  @aiFunction({
    name: 'orgs_convert_member_to_outside_collaborator',
    description: `When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).".`,
    inputSchema: github.OrgsConvertMemberToOutsideCollaboratorParamsSchema
  })
  async orgsConvertMemberToOutsideCollaborator(
    params: github.OrgsConvertMemberToOutsideCollaboratorParams
  ): Promise<github.OrgsConvertMemberToOutsideCollaboratorResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/outside_collaborators/${params.username}`,
        {
          json: pick(params, 'async')
        }
      )
      .json<github.OrgsConvertMemberToOutsideCollaboratorResponse>()
  }

  /**
   * Removing a user from this list will remove them from all the organization's repositories.
   */
  @aiFunction({
    name: 'orgs_remove_outside_collaborator',
    description: `Removing a user from this list will remove them from all the organization's repositories.`,
    inputSchema: github.OrgsRemoveOutsideCollaboratorParamsSchema
  })
  async orgsRemoveOutsideCollaborator(
    params: github.OrgsRemoveOutsideCollaboratorParams
  ): Promise<github.OrgsRemoveOutsideCollaboratorResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/outside_collaborators/${params.username}`,
        {}
      )
      .json<github.OrgsRemoveOutsideCollaboratorResponse>()
  }

  /**
 * Lists packages in an organization readable by the user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_list_packages_for_organization',
    description: `Lists packages in an organization readable by the user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesListPackagesForOrganizationParamsSchema
  })
  async packagesListPackagesForOrganization(
    params: github.PackagesListPackagesForOrganizationParams
  ): Promise<github.PackagesListPackagesForOrganizationResponse> {
    return this.ky
      .get(`/orgs/${params.org}/packages`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'package_type', 'visibility', 'page', 'per_page')
        )
      })
      .json<github.PackagesListPackagesForOrganizationResponse>()
  }

  /**
 * Gets a specific package in an organization.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_for_organization',
    description: `Gets a specific package in an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesGetPackageForOrganizationParamsSchema
  })
  async packagesGetPackageForOrganization(
    params: github.PackagesGetPackageForOrganizationParams
  ): Promise<github.PackagesGetPackageForOrganizationResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesGetPackageForOrganizationResponse>()
  }

  /**
 * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_for_org',
    description: `Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint. If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesDeletePackageForOrgParamsSchema
  })
  async packagesDeletePackageForOrg(
    params: github.PackagesDeletePackageForOrgParams
  ): Promise<github.PackagesDeletePackageForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesDeletePackageForOrgResponse>()
  }

  /**
 * Restores an entire package in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_for_org',
    description: `Restores an entire package in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

The authenticated user must have admin permissions in the organization to use this endpoint. If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesRestorePackageForOrgParamsSchema
  })
  async packagesRestorePackageForOrg(
    params: github.PackagesRestorePackageForOrgParams
  ): Promise<github.PackagesRestorePackageForOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}/restore`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'token'))
        }
      )
      .json<github.PackagesRestorePackageForOrgResponse>()
  }

  /**
 * Lists package versions for a package owned by an organization.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_all_package_versions_for_package_owned_by_org',
    description: `Lists package versions for a package owned by an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesGetAllPackageVersionsForPackageOwnedByOrgParamsSchema
  })
  async packagesGetAllPackageVersionsForPackageOwnedByOrg(
    params: github.PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
  ): Promise<github.PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}/versions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'page', 'per_page', 'state')
          )
        }
      )
      .json<github.PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse>()
  }

  /**
 * Gets a specific package version in an organization.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_version_for_organization',
    description: `Gets a specific package version in an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesGetPackageVersionForOrganizationParamsSchema
  })
  async packagesGetPackageVersionForOrganization(
    params: github.PackagesGetPackageVersionForOrganizationParams
  ): Promise<github.PackagesGetPackageVersionForOrganizationResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesGetPackageVersionForOrganizationResponse>()
  }

  /**
 * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_version_for_org',
    description: `Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint. If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesDeletePackageVersionForOrgParamsSchema
  })
  async packagesDeletePackageVersionForOrg(
    params: github.PackagesDeletePackageVersionForOrgParams
  ): Promise<github.PackagesDeletePackageVersionForOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesDeletePackageVersionForOrgResponse>()
  }

  /**
 * Restores a specific package version in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_version_for_org',
    description: `Restores a specific package version in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

The authenticated user must have admin permissions in the organization to use this endpoint. If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesRestorePackageVersionForOrgParamsSchema
  })
  async packagesRestorePackageVersionForOrg(
    params: github.PackagesRestorePackageVersionForOrgParams
  ): Promise<github.PackagesRestorePackageVersionForOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}/restore`,
        {}
      )
      .json<github.PackagesRestorePackageVersionForOrgResponse>()
  }

  /**
 * Lists requests from organization members to access organization resources with a fine-grained personal access token.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_pat_grant_requests',
    description: `Lists requests from organization members to access organization resources with a fine-grained personal access token.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsListPatGrantRequestsParamsSchema
  })
  async orgsListPatGrantRequests(
    params: github.OrgsListPatGrantRequestsParams
  ): Promise<github.OrgsListPatGrantRequestsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/personal-access-token-requests`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'per_page',
            'page',
            'sort',
            'direction',
            'owner',
            'repository',
            'permission',
            'last_used_before',
            'last_used_after',
            'token_id'
          )
        )
      })
      .json<github.OrgsListPatGrantRequestsResponse>()
  }

  /**
 * Approves or denies multiple pending requests to access organization resources via a fine-grained personal access token.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_review_pat_grant_requests_in_bulk',
    description: `Approves or denies multiple pending requests to access organization resources via a fine-grained personal access token.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsReviewPatGrantRequestsInBulkParamsSchema
  })
  async orgsReviewPatGrantRequestsInBulk(
    params: github.OrgsReviewPatGrantRequestsInBulkParams
  ): Promise<github.OrgsReviewPatGrantRequestsInBulkResponse> {
    return this.ky
      .post(`/orgs/${params.org}/personal-access-token-requests`, {
        json: pick(params, 'pat_request_ids', 'action', 'reason')
      })
      .json<github.OrgsReviewPatGrantRequestsInBulkResponse>()
  }

  /**
 * Approves or denies a pending request to access organization resources via a fine-grained personal access token.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_review_pat_grant_request',
    description: `Approves or denies a pending request to access organization resources via a fine-grained personal access token.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsReviewPatGrantRequestParamsSchema
  })
  async orgsReviewPatGrantRequest(
    params: github.OrgsReviewPatGrantRequestParams
  ): Promise<github.OrgsReviewPatGrantRequestResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/personal-access-token-requests/${params.pat_request_id}`,
        {
          json: pick(params, 'action', 'reason')
        }
      )
      .json<github.OrgsReviewPatGrantRequestResponse>()
  }

  /**
 * Lists the repositories a fine-grained personal access token request is requesting access to.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_pat_grant_request_repositories',
    description: `Lists the repositories a fine-grained personal access token request is requesting access to.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsListPatGrantRequestRepositoriesParamsSchema
  })
  async orgsListPatGrantRequestRepositories(
    params: github.OrgsListPatGrantRequestRepositoriesParams
  ): Promise<github.OrgsListPatGrantRequestRepositoriesResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/personal-access-token-requests/${params.pat_request_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.OrgsListPatGrantRequestRepositoriesResponse>()
  }

  /**
 * Lists approved fine-grained personal access tokens owned by organization members that can access organization resources.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_pat_grants',
    description: `Lists approved fine-grained personal access tokens owned by organization members that can access organization resources.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsListPatGrantsParamsSchema
  })
  async orgsListPatGrants(
    params: github.OrgsListPatGrantsParams
  ): Promise<github.OrgsListPatGrantsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/personal-access-tokens`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'per_page',
            'page',
            'sort',
            'direction',
            'owner',
            'repository',
            'permission',
            'last_used_before',
            'last_used_after',
            'token_id'
          )
        )
      })
      .json<github.OrgsListPatGrantsResponse>()
  }

  /**
 * Updates the access organization members have to organization resources via fine-grained personal access tokens. Limited to revoking a token's existing access.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_update_pat_accesses',
    description: `Updates the access organization members have to organization resources via fine-grained personal access tokens. Limited to revoking a token's existing access.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsUpdatePatAccessesParamsSchema
  })
  async orgsUpdatePatAccesses(
    params: github.OrgsUpdatePatAccessesParams
  ): Promise<github.OrgsUpdatePatAccessesResponse> {
    return this.ky
      .post(`/orgs/${params.org}/personal-access-tokens`, {
        json: pick(params, 'action', 'pat_ids')
      })
      .json<github.OrgsUpdatePatAccessesResponse>()
  }

  /**
 * Updates the access an organization member has to organization resources via a fine-grained personal access token. Limited to revoking the token's existing access. Limited to revoking a token's existing access.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_update_pat_access',
    description: `Updates the access an organization member has to organization resources via a fine-grained personal access token. Limited to revoking the token's existing access. Limited to revoking a token's existing access.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsUpdatePatAccessParamsSchema
  })
  async orgsUpdatePatAccess(
    params: github.OrgsUpdatePatAccessParams
  ): Promise<github.OrgsUpdatePatAccessResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/personal-access-tokens/${params.pat_id}`,
        {
          json: pick(params, 'action')
        }
      )
      .json<github.OrgsUpdatePatAccessResponse>()
  }

  /**
 * Lists the repositories a fine-grained personal access token has access to.

Only GitHub Apps can use this endpoint.
 */
  @aiFunction({
    name: 'orgs_list_pat_grant_repositories',
    description: `Lists the repositories a fine-grained personal access token has access to.

Only GitHub Apps can use this endpoint.`,
    inputSchema: github.OrgsListPatGrantRepositoriesParamsSchema
  })
  async orgsListPatGrantRepositories(
    params: github.OrgsListPatGrantRepositoriesParams
  ): Promise<github.OrgsListPatGrantRepositoriesResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/personal-access-tokens/${params.pat_id}/repositories`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.OrgsListPatGrantRepositoriesResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Lists all private registry configurations available at the organization-level without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_list_org_private_registries',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Lists all private registry configurations available at the organization-level without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesListOrgPrivateRegistriesParamsSchema
  })
  async privateRegistriesListOrgPrivateRegistries(
    params: github.PrivateRegistriesListOrgPrivateRegistriesParams
  ): Promise<github.PrivateRegistriesListOrgPrivateRegistriesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/private-registries`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.PrivateRegistriesListOrgPrivateRegistriesResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Creates a private registry configuration with an encrypted value for an organization. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_create_org_private_registry',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Creates a private registry configuration with an encrypted value for an organization. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesCreateOrgPrivateRegistryParamsSchema
  })
  async privateRegistriesCreateOrgPrivateRegistry(
    params: github.PrivateRegistriesCreateOrgPrivateRegistryParams
  ): Promise<github.PrivateRegistriesCreateOrgPrivateRegistryResponse> {
    return this.ky
      .post(`/orgs/${params.org}/private-registries`, {
        json: pick(
          params,
          'registry_type',
          'username',
          'encrypted_value',
          'key_id',
          'visibility',
          'selected_repository_ids'
        )
      })
      .json<github.PrivateRegistriesCreateOrgPrivateRegistryResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets the org public key, which is needed to encrypt private registry secrets. You need to encrypt a secret before you can create or update secrets.

OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_get_org_public_key',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Gets the org public key, which is needed to encrypt private registry secrets. You need to encrypt a secret before you can create or update secrets.

OAuth tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesGetOrgPublicKeyParamsSchema
  })
  async privateRegistriesGetOrgPublicKey(
    params: github.PrivateRegistriesGetOrgPublicKeyParams
  ): Promise<github.PrivateRegistriesGetOrgPublicKeyResponse> {
    return this.ky
      .get(`/orgs/${params.org}/private-registries/public-key`)
      .json<github.PrivateRegistriesGetOrgPublicKeyResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Get the configuration of a single private registry defined for an organization, omitting its encrypted value.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_get_org_private_registry',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Get the configuration of a single private registry defined for an organization, omitting its encrypted value.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesGetOrgPrivateRegistryParamsSchema
  })
  async privateRegistriesGetOrgPrivateRegistry(
    params: github.PrivateRegistriesGetOrgPrivateRegistryParams
  ): Promise<github.PrivateRegistriesGetOrgPrivateRegistryResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/private-registries/${params.secret_name}`,
        {}
      )
      .json<github.PrivateRegistriesGetOrgPrivateRegistryResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Delete a private registry configuration at the organization-level.

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_delete_org_private_registry',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Delete a private registry configuration at the organization-level.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesDeleteOrgPrivateRegistryParamsSchema
  })
  async privateRegistriesDeleteOrgPrivateRegistry(
    params: github.PrivateRegistriesDeleteOrgPrivateRegistryParams
  ): Promise<github.PrivateRegistriesDeleteOrgPrivateRegistryResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/private-registries/${params.secret_name}`,
        {}
      )
      .json<github.PrivateRegistriesDeleteOrgPrivateRegistryResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is in public preview and is subject to change.

Updates a private registry configuration with an encrypted value for an organization. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'private_registries_update_org_private_registry',
    description: `> [!NOTE]
> This endpoint is in public preview and is subject to change.

Updates a private registry configuration with an encrypted value for an organization. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.PrivateRegistriesUpdateOrgPrivateRegistryParamsSchema
  })
  async privateRegistriesUpdateOrgPrivateRegistry(
    params: github.PrivateRegistriesUpdateOrgPrivateRegistryParams
  ): Promise<github.PrivateRegistriesUpdateOrgPrivateRegistryResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/private-registries/${params.secret_name}`,
        {
          json: pick(
            params,
            'registry_type',
            'username',
            'encrypted_value',
            'key_id',
            'visibility',
            'selected_repository_ids'
          )
        }
      )
      .json<github.PrivateRegistriesUpdateOrgPrivateRegistryResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_for_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListForOrgParamsSchema
  })
  async projectsListForOrg(
    params: github.ProjectsListForOrgParams
  ): Promise<github.ProjectsListForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/projects`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'state', 'per_page', 'page')
        )
      })
      .json<github.ProjectsListForOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_create_for_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsCreateForOrgParamsSchema
  })
  async projectsCreateForOrg(
    params: github.ProjectsCreateForOrgParams
  ): Promise<github.ProjectsCreateForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/projects`, {
        json: pick(params, 'name', 'body')
      })
      .json<github.ProjectsCreateForOrgResponse>()
  }

  /**
 * Gets all custom properties defined for an organization.
Organization members can read these properties.
 */
  @aiFunction({
    name: 'orgs_get_all_custom_properties',
    description: `Gets all custom properties defined for an organization.
Organization members can read these properties.`,
    inputSchema: github.OrgsGetAllCustomPropertiesParamsSchema
  })
  async orgsGetAllCustomProperties(
    params: github.OrgsGetAllCustomPropertiesParams
  ): Promise<github.OrgsGetAllCustomPropertiesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/properties/schema`)
      .json<github.OrgsGetAllCustomPropertiesResponse>()
  }

  /**
 * Creates new or updates existing custom properties defined for an organization in a batch.

If the property already exists, the existing property will be replaced with the new values.
Missing optional values will fall back to default values, previous values will be overwritten.
E.g. if a property exists with `values_editable_by: org_and_repo_actors` and it's updated without specifying `values_editable_by`, it will be updated to default value `org_actors`.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
 */
  @aiFunction({
    name: 'orgs_create_or_update_custom_properties',
    description: `Creates new or updates existing custom properties defined for an organization in a batch.

If the property already exists, the existing property will be replaced with the new values.
Missing optional values will fall back to default values, previous values will be overwritten.
E.g. if a property exists with \`values_editable_by: org_and_repo_actors\` and it's updated without specifying \`values_editable_by\`, it will be updated to default value \`org_actors\`.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of \`custom_properties_org_definitions_manager\` in the organization.`,
    inputSchema: github.OrgsCreateOrUpdateCustomPropertiesParamsSchema
  })
  async orgsCreateOrUpdateCustomProperties(
    params: github.OrgsCreateOrUpdateCustomPropertiesParams
  ): Promise<github.OrgsCreateOrUpdateCustomPropertiesResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/properties/schema`, {
        json: pick(params, 'properties')
      })
      .json<github.OrgsCreateOrUpdateCustomPropertiesResponse>()
  }

  /**
 * Gets a custom property that is defined for an organization.
Organization members can read these properties.
 */
  @aiFunction({
    name: 'orgs_get_custom_property',
    description: `Gets a custom property that is defined for an organization.
Organization members can read these properties.`,
    inputSchema: github.OrgsGetCustomPropertyParamsSchema
  })
  async orgsGetCustomProperty(
    params: github.OrgsGetCustomPropertyParams
  ): Promise<github.OrgsGetCustomPropertyResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/properties/schema/${params.custom_property_name}`,
        {}
      )
      .json<github.OrgsGetCustomPropertyResponse>()
  }

  /**
 * Creates a new or updates an existing custom property that is defined for an organization.

To use this endpoint, the authenticated user must be one of:
- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
 */
  @aiFunction({
    name: 'orgs_create_or_update_custom_property',
    description: `Creates a new or updates an existing custom property that is defined for an organization.

To use this endpoint, the authenticated user must be one of:
- An administrator for the organization.
- A user, or a user on a team, with the fine-grained permission of \`custom_properties_org_definitions_manager\` in the organization.`,
    inputSchema: github.OrgsCreateOrUpdateCustomPropertyParamsSchema
  })
  async orgsCreateOrUpdateCustomProperty(
    params: github.OrgsCreateOrUpdateCustomPropertyParams
  ): Promise<github.OrgsCreateOrUpdateCustomPropertyResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/properties/schema/${params.custom_property_name}`,
        {
          json: pick(
            params,
            'value_type',
            'required',
            'default_value',
            'description',
            'allowed_values',
            'values_editable_by'
          )
        }
      )
      .json<github.OrgsCreateOrUpdateCustomPropertyResponse>()
  }

  /**
 * Removes a custom property that is defined for an organization.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
 */
  @aiFunction({
    name: 'orgs_remove_custom_property',
    description: `Removes a custom property that is defined for an organization.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of \`custom_properties_org_definitions_manager\` in the organization.`,
    inputSchema: github.OrgsRemoveCustomPropertyParamsSchema
  })
  async orgsRemoveCustomProperty(
    params: github.OrgsRemoveCustomPropertyParams
  ): Promise<github.OrgsRemoveCustomPropertyResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/properties/schema/${params.custom_property_name}`,
        {}
      )
      .json<github.OrgsRemoveCustomPropertyResponse>()
  }

  /**
 * Lists organization repositories with all of their custom property values.
Organization members can read these properties.
 */
  @aiFunction({
    name: 'orgs_list_custom_properties_values_for_repos',
    description: `Lists organization repositories with all of their custom property values.
Organization members can read these properties.`,
    inputSchema: github.OrgsListCustomPropertiesValuesForReposParamsSchema
  })
  async orgsListCustomPropertiesValuesForRepos(
    params: github.OrgsListCustomPropertiesValuesForReposParams
  ): Promise<github.OrgsListCustomPropertiesValuesForReposResponse> {
    return this.ky
      .get(`/orgs/${params.org}/properties/values`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'repository_query')
        )
      })
      .json<github.OrgsListCustomPropertiesValuesForReposResponse>()
  }

  /**
 * Create new or update existing custom property values for repositories in a batch that belong to an organization.
Each target repository will have its custom property values updated to match the values provided in the request.

A maximum of 30 repositories can be updated in a single request.

Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_values_editor` in the organization.
 */
  @aiFunction({
    name: 'orgs_create_or_update_custom_properties_values_for_repos',
    description: `Create new or update existing custom property values for repositories in a batch that belong to an organization.
Each target repository will have its custom property values updated to match the values provided in the request.

A maximum of 30 repositories can be updated in a single request.

Using a value of \`null\` for a custom property will remove or 'unset' the property value from the repository.

To use this endpoint, the authenticated user must be one of:
  - An administrator for the organization.
  - A user, or a user on a team, with the fine-grained permission of \`custom_properties_org_values_editor\` in the organization.`,
    inputSchema:
      github.OrgsCreateOrUpdateCustomPropertiesValuesForReposParamsSchema
  })
  async orgsCreateOrUpdateCustomPropertiesValuesForRepos(
    params: github.OrgsCreateOrUpdateCustomPropertiesValuesForReposParams
  ): Promise<github.OrgsCreateOrUpdateCustomPropertiesValuesForReposResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/properties/values`, {
        json: pick(params, 'repository_names', 'properties')
      })
      .json<github.OrgsCreateOrUpdateCustomPropertiesValuesForReposResponse>()
  }

  /**
   * Members of an organization can choose to have their membership publicized or not.
   */
  @aiFunction({
    name: 'orgs_list_public_members',
    description: `Members of an organization can choose to have their membership publicized or not.`,
    inputSchema: github.OrgsListPublicMembersParamsSchema
  })
  async orgsListPublicMembers(
    params: github.OrgsListPublicMembersParams
  ): Promise<github.OrgsListPublicMembersResponse> {
    return this.ky
      .get(`/orgs/${params.org}/public_members`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListPublicMembersResponse>()
  }

  /**
   * Check if the provided user is a public member of the organization.
   */
  @aiFunction({
    name: 'orgs_check_public_membership_for_user',
    description: `Check if the provided user is a public member of the organization.`,
    inputSchema: github.OrgsCheckPublicMembershipForUserParamsSchema
  })
  async orgsCheckPublicMembershipForUser(
    params: github.OrgsCheckPublicMembershipForUserParams
  ): Promise<github.OrgsCheckPublicMembershipForUserResponse> {
    return this.ky
      .get(`/orgs/${params.org}/public_members/${params.username}`, {})
      .json<github.OrgsCheckPublicMembershipForUserResponse>()
  }

  /**
 * The user can publicize their own membership. (A user cannot publicize the membership for another user.)

Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
 */
  @aiFunction({
    name: 'orgs_set_public_membership_for_authenticated_user',
    description: `The user can publicize their own membership. (A user cannot publicize the membership for another user.)

Note that you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.OrgsSetPublicMembershipForAuthenticatedUserParamsSchema
  })
  async orgsSetPublicMembershipForAuthenticatedUser(
    params: github.OrgsSetPublicMembershipForAuthenticatedUserParams
  ): Promise<github.OrgsSetPublicMembershipForAuthenticatedUserResponse> {
    return this.ky
      .put(`/orgs/${params.org}/public_members/${params.username}`, {})
      .json<github.OrgsSetPublicMembershipForAuthenticatedUserResponse>()
  }

  /**
   * Removes the public membership for the authenticated user from the specified organization, unless public visibility is enforced by default.
   */
  @aiFunction({
    name: 'orgs_remove_public_membership_for_authenticated_user',
    description: `Removes the public membership for the authenticated user from the specified organization, unless public visibility is enforced by default.`,
    inputSchema:
      github.OrgsRemovePublicMembershipForAuthenticatedUserParamsSchema
  })
  async orgsRemovePublicMembershipForAuthenticatedUser(
    params: github.OrgsRemovePublicMembershipForAuthenticatedUserParams
  ): Promise<github.OrgsRemovePublicMembershipForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/public_members/${params.username}`, {})
      .json<github.OrgsRemovePublicMembershipForAuthenticatedUserResponse>()
  }

  /**
 * Lists repositories for the specified organization.

> [!NOTE]
> In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
 */
  @aiFunction({
    name: 'repos_list_for_org',
    description: `Lists repositories for the specified organization.

> [!NOTE]
> In order to see the \`security_and_analysis\` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".`,
    inputSchema: github.ReposListForOrgParamsSchema
  })
  async reposListForOrg(
    params: github.ReposListForOrgParams
  ): Promise<github.ReposListForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/repos`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'type', 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.ReposListForOrgResponse>()
  }

  /**
 * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.

OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
 */
  @aiFunction({
    name: 'repos_create_in_org',
    description: `Creates a new repository in the specified organization. The authenticated user must be a member of the organization.

OAuth app tokens and personal access tokens (classic) need the \`public_repo\` or \`repo\` scope to create a public repository, and \`repo\` scope to create a private repository.`,
    inputSchema: github.ReposCreateInOrgParamsSchema
  })
  async reposCreateInOrg(
    params: github.ReposCreateInOrgParams
  ): Promise<github.ReposCreateInOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/repos`, {
        json: pick(
          params,
          'name',
          'description',
          'homepage',
          'private',
          'visibility',
          'has_issues',
          'has_projects',
          'has_wiki',
          'has_downloads',
          'is_template',
          'team_id',
          'auto_init',
          'gitignore_template',
          'license_template',
          'allow_squash_merge',
          'allow_merge_commit',
          'allow_rebase_merge',
          'allow_auto_merge',
          'delete_branch_on_merge',
          'use_squash_pr_title_as_default',
          'squash_merge_commit_title',
          'squash_merge_commit_message',
          'merge_commit_title',
          'merge_commit_message',
          'custom_properties'
        )
      })
      .json<github.ReposCreateInOrgResponse>()
  }

  /**
   * Get all the repository rulesets for an organization.
   */
  @aiFunction({
    name: 'repos_get_org_rulesets',
    description: `Get all the repository rulesets for an organization.`,
    inputSchema: github.ReposGetOrgRulesetsParamsSchema
  })
  async reposGetOrgRulesets(
    params: github.ReposGetOrgRulesetsParams
  ): Promise<github.ReposGetOrgRulesetsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/rulesets`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'targets')
        )
      })
      .json<github.ReposGetOrgRulesetsResponse>()
  }

  /**
   * Create a repository ruleset for an organization.
   */
  @aiFunction({
    name: 'repos_create_org_ruleset',
    description: `Create a repository ruleset for an organization.`,
    inputSchema: github.ReposCreateOrgRulesetParamsSchema
  })
  async reposCreateOrgRuleset(
    params: github.ReposCreateOrgRulesetParams
  ): Promise<github.ReposCreateOrgRulesetResponse> {
    return this.ky
      .post(`/orgs/${params.org}/rulesets`, {
        json: pick(
          params,
          'name',
          'target',
          'enforcement',
          'bypass_actors',
          'conditions',
          'rules'
        )
      })
      .json<github.ReposCreateOrgRulesetResponse>()
  }

  /**
 * Lists suites of rule evaluations at the organization level.
For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets).".
 */
  @aiFunction({
    name: 'repos_get_org_rule_suites',
    description: `Lists suites of rule evaluations at the organization level.
For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets).".`,
    inputSchema: github.ReposGetOrgRuleSuitesParamsSchema
  })
  async reposGetOrgRuleSuites(
    params: github.ReposGetOrgRuleSuitesParams
  ): Promise<github.ReposGetOrgRuleSuitesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/rulesets/rule-suites`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'ref',
            'repository_name',
            'time_period',
            'actor_name',
            'rule_suite_result',
            'per_page',
            'page'
          )
        )
      })
      .json<github.ReposGetOrgRuleSuitesResponse>()
  }

  /**
 * Gets information about a suite of rule evaluations from within an organization.
For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets).".
 */
  @aiFunction({
    name: 'repos_get_org_rule_suite',
    description: `Gets information about a suite of rule evaluations from within an organization.
For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets).".`,
    inputSchema: github.ReposGetOrgRuleSuiteParamsSchema
  })
  async reposGetOrgRuleSuite(
    params: github.ReposGetOrgRuleSuiteParams
  ): Promise<github.ReposGetOrgRuleSuiteResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/rulesets/rule-suites/${params.rule_suite_id}`,
        {}
      )
      .json<github.ReposGetOrgRuleSuiteResponse>()
  }

  /**
 * Get a repository ruleset for an organization.

**Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
making the API request has write access to the ruleset.
 */
  @aiFunction({
    name: 'repos_get_org_ruleset',
    description: `Get a repository ruleset for an organization.

**Note:** To prevent leaking sensitive information, the \`bypass_actors\` property is only returned if the user
making the API request has write access to the ruleset.`,
    inputSchema: github.ReposGetOrgRulesetParamsSchema
  })
  async reposGetOrgRuleset(
    params: github.ReposGetOrgRulesetParams
  ): Promise<github.ReposGetOrgRulesetResponse> {
    return this.ky
      .get(`/orgs/${params.org}/rulesets/${params.ruleset_id}`, {})
      .json<github.ReposGetOrgRulesetResponse>()
  }

  /**
   * Update a ruleset for an organization.
   */
  @aiFunction({
    name: 'repos_update_org_ruleset',
    description: `Update a ruleset for an organization.`,
    inputSchema: github.ReposUpdateOrgRulesetParamsSchema
  })
  async reposUpdateOrgRuleset(
    params: github.ReposUpdateOrgRulesetParams
  ): Promise<github.ReposUpdateOrgRulesetResponse> {
    return this.ky
      .put(`/orgs/${params.org}/rulesets/${params.ruleset_id}`, {
        json: pick(
          params,
          'name',
          'target',
          'enforcement',
          'bypass_actors',
          'conditions',
          'rules'
        )
      })
      .json<github.ReposUpdateOrgRulesetResponse>()
  }

  /**
   * Delete a ruleset for an organization.
   */
  @aiFunction({
    name: 'repos_delete_org_ruleset',
    description: `Delete a ruleset for an organization.`,
    inputSchema: github.ReposDeleteOrgRulesetParamsSchema
  })
  async reposDeleteOrgRuleset(
    params: github.ReposDeleteOrgRulesetParams
  ): Promise<github.ReposDeleteOrgRulesetResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/rulesets/${params.ruleset_id}`, {})
      .json<github.ReposDeleteOrgRulesetResponse>()
  }

  /**
   * Get the history of an organization ruleset.
   */
  @aiFunction({
    name: 'orgs_get_org_ruleset_history',
    description: `Get the history of an organization ruleset.`,
    inputSchema: github.OrgsGetOrgRulesetHistoryParamsSchema
  })
  async orgsGetOrgRulesetHistory(
    params: github.OrgsGetOrgRulesetHistoryParams
  ): Promise<github.OrgsGetOrgRulesetHistoryResponse> {
    return this.ky
      .get(`/orgs/${params.org}/rulesets/${params.ruleset_id}/history`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsGetOrgRulesetHistoryResponse>()
  }

  /**
   * Get a version of an organization ruleset.
   */
  @aiFunction({
    name: 'orgs_get_org_ruleset_version',
    description: `Get a version of an organization ruleset.`,
    inputSchema: github.OrgsGetOrgRulesetVersionParamsSchema
  })
  async orgsGetOrgRulesetVersion(
    params: github.OrgsGetOrgRulesetVersionParams
  ): Promise<github.OrgsGetOrgRulesetVersionResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/rulesets/${params.ruleset_id}/history/${params.version_id}`,
        {}
      )
      .json<github.OrgsGetOrgRulesetVersionResponse>()
  }

  /**
 * Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_list_alerts_for_org',
    description: `Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningListAlertsForOrgParamsSchema
  })
  async secretScanningListAlertsForOrg(
    params: github.SecretScanningListAlertsForOrgParams
  ): Promise<github.SecretScanningListAlertsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/secret-scanning/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'secret_type',
            'resolution',
            'sort',
            'direction',
            'page',
            'per_page',
            'before',
            'after',
            'validity',
            'is_publicly_leaked',
            'is_multi_repo'
          )
        )
      })
      .json<github.SecretScanningListAlertsForOrgResponse>()
  }

  /**
 * Lists repository security advisories for an organization.

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
 */
  @aiFunction({
    name: 'security_advisories_list_org_repository_advisories',
    description: `Lists repository security advisories for an organization.

The authenticated user must be an owner or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:write\` scope to use this endpoint.`,
    inputSchema:
      github.SecurityAdvisoriesListOrgRepositoryAdvisoriesParamsSchema
  })
  async securityAdvisoriesListOrgRepositoryAdvisories(
    params: github.SecurityAdvisoriesListOrgRepositoryAdvisoriesParams
  ): Promise<github.SecurityAdvisoriesListOrgRepositoryAdvisoriesResponse> {
    return this.ky
      .get(`/orgs/${params.org}/security-advisories`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'direction',
            'sort',
            'before',
            'after',
            'per_page',
            'state'
          )
        )
      })
      .json<github.SecurityAdvisoriesListOrgRepositoryAdvisoriesResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
 */
  @aiFunction({
    name: 'orgs_list_security_manager_teams',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.`,
    inputSchema: github.OrgsListSecurityManagerTeamsParamsSchema
  })
  async orgsListSecurityManagerTeams(
    params: github.OrgsListSecurityManagerTeamsParams
  ): Promise<github.OrgsListSecurityManagerTeamsResponse> {
    return this.ky
      .get(`/orgs/${params.org}/security-managers`)
      .json<github.OrgsListSecurityManagerTeamsResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
 */
  @aiFunction({
    name: 'orgs_add_security_manager_team',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.`,
    inputSchema: github.OrgsAddSecurityManagerTeamParamsSchema
  })
  async orgsAddSecurityManagerTeam(
    params: github.OrgsAddSecurityManagerTeamParams
  ): Promise<github.OrgsAddSecurityManagerTeamResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/security-managers/teams/${params.team_slug}`,
        {}
      )
      .json<github.OrgsAddSecurityManagerTeamResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
 */
  @aiFunction({
    name: 'orgs_remove_security_manager_team',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.`,
    inputSchema: github.OrgsRemoveSecurityManagerTeamParamsSchema
  })
  async orgsRemoveSecurityManagerTeam(
    params: github.OrgsRemoveSecurityManagerTeamParams
  ): Promise<github.OrgsRemoveSecurityManagerTeamResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/security-managers/teams/${params.team_slug}`,
        {}
      )
      .json<github.OrgsRemoveSecurityManagerTeamResponse>()
  }

  /**
 * Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

OAuth app tokens and personal access tokens (classic) need the `repo` or `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_github_actions_billing_org',
    description: `Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.BillingGetGithubActionsBillingOrgParamsSchema
  })
  async billingGetGithubActionsBillingOrg(
    params: github.BillingGetGithubActionsBillingOrgParams
  ): Promise<github.BillingGetGithubActionsBillingOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/settings/billing/actions`)
      .json<github.BillingGetGithubActionsBillingOrgResponse>()
  }

  /**
 * Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the `repo` or `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_github_packages_billing_org',
    description: `Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.BillingGetGithubPackagesBillingOrgParamsSchema
  })
  async billingGetGithubPackagesBillingOrg(
    params: github.BillingGetGithubPackagesBillingOrgParams
  ): Promise<github.BillingGetGithubPackagesBillingOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/settings/billing/packages`)
      .json<github.BillingGetGithubPackagesBillingOrgResponse>()
  }

  /**
 * Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the `repo` or `admin:org` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_shared_storage_billing_org',
    description: `Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`admin:org\` scope to use this endpoint.`,
    inputSchema: github.BillingGetSharedStorageBillingOrgParamsSchema
  })
  async billingGetSharedStorageBillingOrg(
    params: github.BillingGetSharedStorageBillingOrgParams
  ): Promise<github.BillingGetSharedStorageBillingOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/settings/billing/shared-storage`)
      .json<github.BillingGetSharedStorageBillingOrgResponse>()
  }

  /**
 * Lists all hosted compute network configurations configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `read:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_list_network_configurations_for_org',
    description: `Lists all hosted compute network configurations configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:network_configurations\` scope to use this endpoint.`,
    inputSchema: github.HostedComputeListNetworkConfigurationsForOrgParamsSchema
  })
  async hostedComputeListNetworkConfigurationsForOrg(
    params: github.HostedComputeListNetworkConfigurationsForOrgParams
  ): Promise<github.HostedComputeListNetworkConfigurationsForOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/settings/network-configurations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.HostedComputeListNetworkConfigurationsForOrgResponse>()
  }

  /**
 * Creates a hosted compute network configuration for an organization.

OAuth app tokens and personal access tokens (classic) need the `write:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_create_network_configuration_for_org',
    description: `Creates a hosted compute network configuration for an organization.

OAuth app tokens and personal access tokens (classic) need the \`write:network_configurations\` scope to use this endpoint.`,
    inputSchema:
      github.HostedComputeCreateNetworkConfigurationForOrgParamsSchema
  })
  async hostedComputeCreateNetworkConfigurationForOrg(
    params: github.HostedComputeCreateNetworkConfigurationForOrgParams
  ): Promise<github.HostedComputeCreateNetworkConfigurationForOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/settings/network-configurations`, {
        json: pick(params, 'name', 'compute_service', 'network_settings_ids')
      })
      .json<github.HostedComputeCreateNetworkConfigurationForOrgResponse>()
  }

  /**
 * Gets a hosted compute network configuration configured in an organization.

OAuth app tokens and personal access tokens (classic) need the `read:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_get_network_configuration_for_org',
    description: `Gets a hosted compute network configuration configured in an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:network_configurations\` scope to use this endpoint.`,
    inputSchema: github.HostedComputeGetNetworkConfigurationForOrgParamsSchema
  })
  async hostedComputeGetNetworkConfigurationForOrg(
    params: github.HostedComputeGetNetworkConfigurationForOrgParams
  ): Promise<github.HostedComputeGetNetworkConfigurationForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/settings/network-configurations/${params.network_configuration_id}`,
        {}
      )
      .json<github.HostedComputeGetNetworkConfigurationForOrgResponse>()
  }

  /**
 * Deletes a hosted compute network configuration from an organization.

OAuth app tokens and personal access tokens (classic) need the `write:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_delete_network_configuration_from_org',
    description: `Deletes a hosted compute network configuration from an organization.

OAuth app tokens and personal access tokens (classic) need the \`write:network_configurations\` scope to use this endpoint.`,
    inputSchema:
      github.HostedComputeDeleteNetworkConfigurationFromOrgParamsSchema
  })
  async hostedComputeDeleteNetworkConfigurationFromOrg(
    params: github.HostedComputeDeleteNetworkConfigurationFromOrgParams
  ): Promise<github.HostedComputeDeleteNetworkConfigurationFromOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/settings/network-configurations/${params.network_configuration_id}`,
        {}
      )
      .json<github.HostedComputeDeleteNetworkConfigurationFromOrgResponse>()
  }

  /**
 * Updates a hosted compute network configuration for an organization.

OAuth app tokens and personal access tokens (classic) need the `write:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_update_network_configuration_for_org',
    description: `Updates a hosted compute network configuration for an organization.

OAuth app tokens and personal access tokens (classic) need the \`write:network_configurations\` scope to use this endpoint.`,
    inputSchema:
      github.HostedComputeUpdateNetworkConfigurationForOrgParamsSchema
  })
  async hostedComputeUpdateNetworkConfigurationForOrg(
    params: github.HostedComputeUpdateNetworkConfigurationForOrgParams
  ): Promise<github.HostedComputeUpdateNetworkConfigurationForOrgResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/settings/network-configurations/${params.network_configuration_id}`,
        {
          json: pick(params, 'name', 'compute_service', 'network_settings_ids')
        }
      )
      .json<github.HostedComputeUpdateNetworkConfigurationForOrgResponse>()
  }

  /**
 * Gets a hosted compute network settings resource configured for an organization.

OAuth app tokens and personal access tokens (classic) need the `read:network_configurations` scope to use this endpoint.
 */
  @aiFunction({
    name: 'hosted_compute_get_network_settings_for_org',
    description: `Gets a hosted compute network settings resource configured for an organization.

OAuth app tokens and personal access tokens (classic) need the \`read:network_configurations\` scope to use this endpoint.`,
    inputSchema: github.HostedComputeGetNetworkSettingsForOrgParamsSchema
  })
  async hostedComputeGetNetworkSettingsForOrg(
    params: github.HostedComputeGetNetworkSettingsForOrgParams
  ): Promise<github.HostedComputeGetNetworkSettingsForOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/settings/network-settings/${params.network_settings_id}`,
        {}
      )
      .json<github.HostedComputeGetNetworkSettingsForOrgResponse>()
  }

  /**
 * Use this endpoint to see a breakdown of aggregated metrics for various GitHub Copilot features. See the response schema tab for detailed metrics definitions.

> [!NOTE]
> This endpoint will only return results for a given day if the team had **five or more members with active Copilot licenses** on that day, as evaluated at the end of that day.

The response contains metrics for up to 28 days prior. Metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

To access this endpoint, the Copilot Metrics API access policy must be enabled for the organization containing the team within GitHub settings.
Only organization owners for the organization that contains this team and owners and billing managers of the parent enterprise can view Copilot metrics for a team.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot`, `read:org`, or `read:enterprise` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_copilot_metrics_for_team',
    description: `Use this endpoint to see a breakdown of aggregated metrics for various GitHub Copilot features. See the response schema tab for detailed metrics definitions.

> [!NOTE]
> This endpoint will only return results for a given day if the team had **five or more members with active Copilot licenses** on that day, as evaluated at the end of that day.

The response contains metrics for up to 28 days prior. Metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

To access this endpoint, the Copilot Metrics API access policy must be enabled for the organization containing the team within GitHub settings.
Only organization owners for the organization that contains this team and owners and billing managers of the parent enterprise can view Copilot metrics for a team.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\`, \`read:org\`, or \`read:enterprise\` scopes to use this endpoint.`,
    inputSchema: github.CopilotCopilotMetricsForTeamParamsSchema
  })
  async copilotCopilotMetricsForTeam(
    params: github.CopilotCopilotMetricsForTeamParams
  ): Promise<github.CopilotCopilotMetricsForTeamResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/team/${params.team_slug}/copilot/metrics`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'since', 'until', 'page', 'per_page')
          )
        }
      )
      .json<github.CopilotCopilotMetricsForTeamResponse>()
  }

  /**
 * > [!NOTE]
> This endpoint is closing down. It will be accessible throughout February 2025, but will not return any new data after February 1st.

You can use this endpoint to see a daily breakdown of aggregated usage metrics for Copilot completions and Copilot Chat in the IDE
for users within a team, with a further breakdown of suggestions, acceptances, and number of active users by editor and language for each day.
See the response schema tab for detailed metrics definitions.

The response contains metrics for up to 28 days prior. Usage metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

> [!NOTE]
> This endpoint will only return results for a given day if the team had five or more members with active Copilot licenses, as evaluated at the end of that day.

Organization owners for the organization that contains this team, and owners and billing managers of the parent enterprise can view Copilot usage metrics for a team.

OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot`, `read:org`, or `read:enterprise` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'copilot_usage_metrics_for_team',
    description: `> [!NOTE]
> This endpoint is closing down. It will be accessible throughout February 2025, but will not return any new data after February 1st.

You can use this endpoint to see a daily breakdown of aggregated usage metrics for Copilot completions and Copilot Chat in the IDE
for users within a team, with a further breakdown of suggestions, acceptances, and number of active users by editor and language for each day.
See the response schema tab for detailed metrics definitions.

The response contains metrics for up to 28 days prior. Usage metrics are processed once per day for the previous day,
and the response will only include data up until yesterday. In order for an end user to be counted towards these metrics,
they must have telemetry enabled in their IDE.

> [!NOTE]
> This endpoint will only return results for a given day if the team had five or more members with active Copilot licenses, as evaluated at the end of that day.

Organization owners for the organization that contains this team, and owners and billing managers of the parent enterprise can view Copilot usage metrics for a team.

OAuth app tokens and personal access tokens (classic) need either the \`manage_billing:copilot\`, \`read:org\`, or \`read:enterprise\` scopes to use this endpoint.`,
    inputSchema: github.CopilotUsageMetricsForTeamParamsSchema
  })
  async copilotUsageMetricsForTeam(
    params: github.CopilotUsageMetricsForTeamParams
  ): Promise<github.CopilotUsageMetricsForTeamResponse> {
    return this.ky
      .get(`/orgs/${params.org}/team/${params.team_slug}/copilot/usage`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'until', 'page', 'per_page')
        )
      })
      .json<github.CopilotUsageMetricsForTeamResponse>()
  }

  /**
   * Lists all teams in an organization that are visible to the authenticated user.
   */
  @aiFunction({
    name: 'teams_list',
    description: `Lists all teams in an organization that are visible to the authenticated user.`,
    inputSchema: github.TeamsListParamsSchema
  })
  async teamsList(
    params: github.TeamsListParams
  ): Promise<github.TeamsListResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListResponse>()
  }

  /**
 * To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://docs.github.com/articles/setting-team-creation-permissions-in-your-organization)."

When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/about-teams)".
 */
  @aiFunction({
    name: 'teams_create',
    description: `To create a team, the authenticated user must be a member or owner of \`{org}\`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://docs.github.com/articles/setting-team-creation-permissions-in-your-organization)."

When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of \`maintainers\`. For more information, see "[About teams](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/about-teams)".`,
    inputSchema: github.TeamsCreateParamsSchema
  })
  async teamsCreate(
    params: github.TeamsCreateParams
  ): Promise<github.TeamsCreateResponse> {
    return this.ky
      .post(`/orgs/${params.org}/teams`, {
        json: pick(
          params,
          'name',
          'description',
          'maintainers',
          'repo_names',
          'privacy',
          'notification_setting',
          'permission',
          'parent_team_id'
        )
      })
      .json<github.TeamsCreateResponse>()
  }

  /**
 * Gets a team using the team's `slug`. To create the `slug`, GitHub replaces special characters in the `name` string, changes all words to lowercase, and replaces spaces with a `-` separator. For example, `"My TEam Nme"` would become `my-team-name`.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.
 */
  @aiFunction({
    name: 'teams_get_by_name',
    description: `Gets a team using the team's \`slug\`. To create the \`slug\`, GitHub replaces special characters in the \`name\` string, changes all words to lowercase, and replaces spaces with a \`-\` separator. For example, \`"My TEam Nme"\` would become \`my-team-name\`.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}\`.`,
    inputSchema: github.TeamsGetByNameParamsSchema
  })
  async teamsGetByName(
    params: github.TeamsGetByNameParams
  ): Promise<github.TeamsGetByNameResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}`, {})
      .json<github.TeamsGetByNameResponse>()
  }

  /**
 * To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.
 */
  @aiFunction({
    name: 'teams_delete_in_org',
    description: `To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`DELETE /organizations/{org_id}/team/{team_id}\`.`,
    inputSchema: github.TeamsDeleteInOrgParamsSchema
  })
  async teamsDeleteInOrg(
    params: github.TeamsDeleteInOrgParams
  ): Promise<github.TeamsDeleteInOrgResponse> {
    return this.ky
      .delete(`/orgs/${params.org}/teams/${params.team_slug}`, {})
      .json<github.TeamsDeleteInOrgResponse>()
  }

  /**
 * To edit a team, the authenticated user must either be an organization owner or a team maintainer.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.
 */
  @aiFunction({
    name: 'teams_update_in_org',
    description: `To edit a team, the authenticated user must either be an organization owner or a team maintainer.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`PATCH /organizations/{org_id}/team/{team_id}\`.`,
    inputSchema: github.TeamsUpdateInOrgParamsSchema
  })
  async teamsUpdateInOrg(
    params: github.TeamsUpdateInOrgParams
  ): Promise<github.TeamsUpdateInOrgResponse> {
    return this.ky
      .patch(`/orgs/${params.org}/teams/${params.team_slug}`, {
        json: pick(
          params,
          'name',
          'description',
          'privacy',
          'notification_setting',
          'permission',
          'parent_team_id'
        )
      })
      .json<github.TeamsUpdateInOrgResponse>()
  }

  /**
 * List all discussions on a team's page.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_list_discussions_in_org',
    description: `List all discussions on a team's page.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/discussions\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsListDiscussionsInOrgParamsSchema
  })
  async teamsListDiscussionsInOrg(
    params: github.TeamsListDiscussionsInOrgParams
  ): Promise<github.TeamsListDiscussionsInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/discussions`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'direction', 'per_page', 'page', 'pinned')
        )
      })
      .json<github.TeamsListDiscussionsInOrgResponse>()
  }

  /**
 * Creates a new discussion post on a team's page.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_create_discussion_in_org',
    description: `Creates a new discussion post on a team's page.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`POST /organizations/{org_id}/team/{team_id}/discussions\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsCreateDiscussionInOrgParamsSchema
  })
  async teamsCreateDiscussionInOrg(
    params: github.TeamsCreateDiscussionInOrgParams
  ): Promise<github.TeamsCreateDiscussionInOrgResponse> {
    return this.ky
      .post(`/orgs/${params.org}/teams/${params.team_slug}/discussions`, {
        json: pick(params, 'title', 'body', 'private')
      })
      .json<github.TeamsCreateDiscussionInOrgResponse>()
  }

  /**
 * Get a specific discussion on a team's page.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_get_discussion_in_org',
    description: `Get a specific discussion on a team's page.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsGetDiscussionInOrgParamsSchema
  })
  async teamsGetDiscussionInOrg(
    params: github.TeamsGetDiscussionInOrgParams
  ): Promise<github.TeamsGetDiscussionInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}`,
        {}
      )
      .json<github.TeamsGetDiscussionInOrgResponse>()
  }

  /**
 * Delete a discussion from a team's page.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_delete_discussion_in_org',
    description: `Delete a discussion from a team's page.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsDeleteDiscussionInOrgParamsSchema
  })
  async teamsDeleteDiscussionInOrg(
    params: github.TeamsDeleteDiscussionInOrgParams
  ): Promise<github.TeamsDeleteDiscussionInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}`,
        {}
      )
      .json<github.TeamsDeleteDiscussionInOrgResponse>()
  }

  /**
 * Edits the title and body text of a discussion post. Only the parameters you provide are updated.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_update_discussion_in_org',
    description: `Edits the title and body text of a discussion post. Only the parameters you provide are updated.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsUpdateDiscussionInOrgParamsSchema
  })
  async teamsUpdateDiscussionInOrg(
    params: github.TeamsUpdateDiscussionInOrgParams
  ): Promise<github.TeamsUpdateDiscussionInOrgResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}`,
        {
          json: pick(params, 'title', 'body')
        }
      )
      .json<github.TeamsUpdateDiscussionInOrgResponse>()
  }

  /**
 * List all comments on a team discussion.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_list_discussion_comments_in_org',
    description: `List all comments on a team discussion.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsListDiscussionCommentsInOrgParamsSchema
  })
  async teamsListDiscussionCommentsInOrg(
    params: github.TeamsListDiscussionCommentsInOrgParams
  ): Promise<github.TeamsListDiscussionCommentsInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'direction', 'per_page', 'page')
          )
        }
      )
      .json<github.TeamsListDiscussionCommentsInOrgResponse>()
  }

  /**
 * Creates a new comment on a team discussion.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_create_discussion_comment_in_org',
    description: `Creates a new comment on a team discussion.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsCreateDiscussionCommentInOrgParamsSchema
  })
  async teamsCreateDiscussionCommentInOrg(
    params: github.TeamsCreateDiscussionCommentInOrgParams
  ): Promise<github.TeamsCreateDiscussionCommentInOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.TeamsCreateDiscussionCommentInOrgResponse>()
  }

  /**
 * Get a specific comment on a team discussion.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_get_discussion_comment_in_org',
    description: `Get a specific comment on a team discussion.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsGetDiscussionCommentInOrgParamsSchema
  })
  async teamsGetDiscussionCommentInOrg(
    params: github.TeamsGetDiscussionCommentInOrgParams
  ): Promise<github.TeamsGetDiscussionCommentInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {}
      )
      .json<github.TeamsGetDiscussionCommentInOrgResponse>()
  }

  /**
 * Deletes a comment on a team discussion.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_delete_discussion_comment_in_org',
    description: `Deletes a comment on a team discussion.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsDeleteDiscussionCommentInOrgParamsSchema
  })
  async teamsDeleteDiscussionCommentInOrg(
    params: github.TeamsDeleteDiscussionCommentInOrgParams
  ): Promise<github.TeamsDeleteDiscussionCommentInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {}
      )
      .json<github.TeamsDeleteDiscussionCommentInOrgResponse>()
  }

  /**
 * Edits the body text of a discussion comment.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_update_discussion_comment_in_org',
    description: `Edits the body text of a discussion comment.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsUpdateDiscussionCommentInOrgParamsSchema
  })
  async teamsUpdateDiscussionCommentInOrg(
    params: github.TeamsUpdateDiscussionCommentInOrgParams
  ): Promise<github.TeamsUpdateDiscussionCommentInOrgResponse> {
    return this.ky
      .patch(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.TeamsUpdateDiscussionCommentInOrgResponse>()
  }

  /**
 * List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_list_for_team_discussion_comment_in_org',
    description: `List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsListForTeamDiscussionCommentInOrgParamsSchema
  })
  async reactionsListForTeamDiscussionCommentInOrg(
    params: github.ReactionsListForTeamDiscussionCommentInOrgParams
  ): Promise<github.ReactionsListForTeamDiscussionCommentInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForTeamDiscussionCommentInOrgResponse>()
  }

  /**
 * Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_create_for_team_discussion_comment_in_org',
    description: `Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

A response with an HTTP \`200\` status means that you already added the reaction type to this team discussion comment.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsCreateForTeamDiscussionCommentInOrgParamsSchema
  })
  async reactionsCreateForTeamDiscussionCommentInOrg(
    params: github.ReactionsCreateForTeamDiscussionCommentInOrgParams
  ): Promise<github.ReactionsCreateForTeamDiscussionCommentInOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForTeamDiscussionCommentInOrgResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_delete_for_team_discussion_comment',
    description: `> [!NOTE]
> You can also specify a team or organization with \`team_id\` and \`org_id\` using the route \`DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id\`.

Delete a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsDeleteForTeamDiscussionCommentParamsSchema
  })
  async reactionsDeleteForTeamDiscussionComment(
    params: github.ReactionsDeleteForTeamDiscussionCommentParams
  ): Promise<github.ReactionsDeleteForTeamDiscussionCommentResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/comments/${params.comment_number}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForTeamDiscussionCommentResponse>()
  }

  /**
 * List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_list_for_team_discussion_in_org',
    description: `List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions\`.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsListForTeamDiscussionInOrgParamsSchema
  })
  async reactionsListForTeamDiscussionInOrg(
    params: github.ReactionsListForTeamDiscussionInOrgParams
  ): Promise<github.ReactionsListForTeamDiscussionInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForTeamDiscussionInOrgResponse>()
  }

  /**
 * Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

A response with an HTTP `200` status means that you already added the reaction type to this team discussion.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_create_for_team_discussion_in_org',
    description: `Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

A response with an HTTP \`200\` status means that you already added the reaction type to this team discussion.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions\`.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsCreateForTeamDiscussionInOrgParamsSchema
  })
  async reactionsCreateForTeamDiscussionInOrg(
    params: github.ReactionsCreateForTeamDiscussionInOrgParams
  ): Promise<github.ReactionsCreateForTeamDiscussionInOrgResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForTeamDiscussionInOrgResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_delete_for_team_discussion',
    description: `> [!NOTE]
> You can also specify a team or organization with \`team_id\` and \`org_id\` using the route \`DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id\`.

Delete a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsDeleteForTeamDiscussionParamsSchema
  })
  async reactionsDeleteForTeamDiscussion(
    params: github.ReactionsDeleteForTeamDiscussionParams
  ): Promise<github.ReactionsDeleteForTeamDiscussionResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/discussions/${params.discussion_number}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForTeamDiscussionResponse>()
  }

  /**
 * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/invitations`.
 */
  @aiFunction({
    name: 'teams_list_pending_invitations_in_org',
    description: `The return hash contains a \`role\` field which refers to the Organization Invitation role and will be one of the following values: \`direct_member\`, \`admin\`, \`billing_manager\`, \`hiring_manager\`, or \`reinstate\`. If the invitee is not a GitHub member, the \`login\` field in the return hash will be \`null\`.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/invitations\`.`,
    inputSchema: github.TeamsListPendingInvitationsInOrgParamsSchema
  })
  async teamsListPendingInvitationsInOrg(
    params: github.TeamsListPendingInvitationsInOrgParams
  ): Promise<github.TeamsListPendingInvitationsInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/invitations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListPendingInvitationsInOrgResponse>()
  }

  /**
 * Team members will include the members of child teams.

To list members in a team, the team must be visible to the authenticated user.
 */
  @aiFunction({
    name: 'teams_list_members_in_org',
    description: `Team members will include the members of child teams.

To list members in a team, the team must be visible to the authenticated user.`,
    inputSchema: github.TeamsListMembersInOrgParamsSchema
  })
  async teamsListMembersInOrg(
    params: github.TeamsListMembersInOrgParams
  ): Promise<github.TeamsListMembersInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/members`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'role', 'per_page', 'page')
        )
      })
      .json<github.TeamsListMembersInOrgResponse>()
  }

  /**
 * Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.

> [!NOTE]
> The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/teams/teams#create-a-team).
 */
  @aiFunction({
    name: 'teams_get_membership_for_user_in_org',
    description: `Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/memberships/{username}\`.

> [!NOTE]
> The response contains the \`state\` of the membership and the member's \`role\`.

The \`role\` for organization owners is set to \`maintainer\`. For more information about \`maintainer\` roles, see [Create a team](https://docs.github.com/rest/teams/teams#create-a-team).`,
    inputSchema: github.TeamsGetMembershipForUserInOrgParamsSchema
  })
  async teamsGetMembershipForUserInOrg(
    params: github.TeamsGetMembershipForUserInOrgParams
  ): Promise<github.TeamsGetMembershipForUserInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/memberships/${params.username}`,
        {}
      )
      .json<github.TeamsGetMembershipForUserInOrgResponse>()
  }

  /**
 * Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.
 */
  @aiFunction({
    name: 'teams_add_or_update_membership_for_user_in_org',
    description: `Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`PUT /organizations/{org_id}/team/{team_id}/memberships/{username}\`.`,
    inputSchema: github.TeamsAddOrUpdateMembershipForUserInOrgParamsSchema
  })
  async teamsAddOrUpdateMembershipForUserInOrg(
    params: github.TeamsAddOrUpdateMembershipForUserInOrgParams
  ): Promise<github.TeamsAddOrUpdateMembershipForUserInOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/teams/${params.team_slug}/memberships/${params.username}`,
        {
          json: pick(params, 'role')
        }
      )
      .json<github.TeamsAddOrUpdateMembershipForUserInOrgResponse>()
  }

  /**
 * To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.
 */
  @aiFunction({
    name: 'teams_remove_membership_for_user_in_org',
    description: `To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}\`.`,
    inputSchema: github.TeamsRemoveMembershipForUserInOrgParamsSchema
  })
  async teamsRemoveMembershipForUserInOrg(
    params: github.TeamsRemoveMembershipForUserInOrgParams
  ): Promise<github.TeamsRemoveMembershipForUserInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/memberships/${params.username}`,
        {}
      )
      .json<github.TeamsRemoveMembershipForUserInOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_list_projects_in_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsListProjectsInOrgParamsSchema
  })
  async teamsListProjectsInOrg(
    params: github.TeamsListProjectsInOrgParams
  ): Promise<github.TeamsListProjectsInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/projects`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListProjectsInOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_check_permissions_for_project_in_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsCheckPermissionsForProjectInOrgParamsSchema
  })
  async teamsCheckPermissionsForProjectInOrg(
    params: github.TeamsCheckPermissionsForProjectInOrgParams
  ): Promise<github.TeamsCheckPermissionsForProjectInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/projects/${params.project_id}`,
        {}
      )
      .json<github.TeamsCheckPermissionsForProjectInOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_add_or_update_project_permissions_in_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsAddOrUpdateProjectPermissionsInOrgParamsSchema
  })
  async teamsAddOrUpdateProjectPermissionsInOrg(
    params: github.TeamsAddOrUpdateProjectPermissionsInOrgParams
  ): Promise<github.TeamsAddOrUpdateProjectPermissionsInOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/teams/${params.team_slug}/projects/${params.project_id}`,
        {
          json: pick(params, 'permission')
        }
      )
      .json<github.TeamsAddOrUpdateProjectPermissionsInOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_remove_project_in_org',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsRemoveProjectInOrgParamsSchema
  })
  async teamsRemoveProjectInOrg(
    params: github.TeamsRemoveProjectInOrgParams
  ): Promise<github.TeamsRemoveProjectInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/projects/${params.project_id}`,
        {}
      )
      .json<github.TeamsRemoveProjectInOrgResponse>()
  }

  /**
 * Lists a team's repositories visible to the authenticated user.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
 */
  @aiFunction({
    name: 'teams_list_repos_in_org',
    description: `Lists a team's repositories visible to the authenticated user.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/repos\`.`,
    inputSchema: github.TeamsListReposInOrgParamsSchema
  })
  async teamsListReposInOrg(
    params: github.TeamsListReposInOrgParams
  ): Promise<github.TeamsListReposInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/repos`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListReposInOrgResponse>()
  }

  /**
 * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types/) via the `application/vnd.github.v3.repository+json` accept header.

If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.

If the repository is private, you must have at least `read` permission for that repository, and your token must have the `repo` or `admin:org` scope. Otherwise, you will receive a `404 Not Found` response status.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
 */
  @aiFunction({
    name: 'teams_check_permissions_for_repo_in_org',
    description: `Checks whether a team has \`admin\`, \`push\`, \`maintain\`, \`triage\`, or \`pull\` permission for a repository. Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types/) via the \`application/vnd.github.v3.repository+json\` accept header.

If a team doesn't have permission for the repository, you will receive a \`404 Not Found\` response status.

If the repository is private, you must have at least \`read\` permission for that repository, and your token must have the \`repo\` or \`admin:org\` scope. Otherwise, you will receive a \`404 Not Found\` response status.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}\`.`,
    inputSchema: github.TeamsCheckPermissionsForRepoInOrgParamsSchema
  })
  async teamsCheckPermissionsForRepoInOrg(
    params: github.TeamsCheckPermissionsForRepoInOrgParams
  ): Promise<github.TeamsCheckPermissionsForRepoInOrgResponse> {
    return this.ky
      .get(
        `/orgs/${params.org}/teams/${params.team_slug}/repos/${params.owner}/${params.repo}`,
        {}
      )
      .json<github.TeamsCheckPermissionsForRepoInOrgResponse>()
  }

  /**
 * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.

For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
 */
  @aiFunction({
    name: 'teams_add_or_update_repo_permissions_in_org',
    description: `To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a \`422 Unprocessable Entity\` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}\`.

For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".`,
    inputSchema: github.TeamsAddOrUpdateRepoPermissionsInOrgParamsSchema
  })
  async teamsAddOrUpdateRepoPermissionsInOrg(
    params: github.TeamsAddOrUpdateRepoPermissionsInOrgParams
  ): Promise<github.TeamsAddOrUpdateRepoPermissionsInOrgResponse> {
    return this.ky
      .put(
        `/orgs/${params.org}/teams/${params.team_slug}/repos/${params.owner}/${params.repo}`,
        {
          json: pick(params, 'permission')
        }
      )
      .json<github.TeamsAddOrUpdateRepoPermissionsInOrgResponse>()
  }

  /**
 * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
 */
  @aiFunction({
    name: 'teams_remove_repo_in_org',
    description: `If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}\`.`,
    inputSchema: github.TeamsRemoveRepoInOrgParamsSchema
  })
  async teamsRemoveRepoInOrg(
    params: github.TeamsRemoveRepoInOrgParams
  ): Promise<github.TeamsRemoveRepoInOrgResponse> {
    return this.ky
      .delete(
        `/orgs/${params.org}/teams/${params.team_slug}/repos/${params.owner}/${params.repo}`,
        {}
      )
      .json<github.TeamsRemoveRepoInOrgResponse>()
  }

  /**
 * Lists the child teams of the team specified by `{team_slug}`.

> [!NOTE]
> You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.
 */
  @aiFunction({
    name: 'teams_list_child_in_org',
    description: `Lists the child teams of the team specified by \`{team_slug}\`.

> [!NOTE]
> You can also specify a team by \`org_id\` and \`team_id\` using the route \`GET /organizations/{org_id}/team/{team_id}/teams\`.`,
    inputSchema: github.TeamsListChildInOrgParamsSchema
  })
  async teamsListChildInOrg(
    params: github.TeamsListChildInOrgParams
  ): Promise<github.TeamsListChildInOrgResponse> {
    return this.ky
      .get(`/orgs/${params.org}/teams/${params.team_slug}/teams`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListChildInOrgResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** The ability to enable or disable a security feature for all eligible repositories in an organization is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead. For more information, see the [changelog](https://github.blog/changelog/2024-07-22-deprecation-of-api-endpoint-to-enable-or-disable-a-security-feature-for-an-organization/).

Enables or disables the specified security feature for all eligible repositories in an organization. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

The authenticated user must be an organization owner or be member of a team with the security manager role to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `admin:org`, `write:org`, or `repo` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'orgs_enable_or_disable_security_product_on_all_org_repos',
    description: `> [!WARNING]
> **Closing down notice:** The ability to enable or disable a security feature for all eligible repositories in an organization is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead. For more information, see the [changelog](https://github.blog/changelog/2024-07-22-deprecation-of-api-endpoint-to-enable-or-disable-a-security-feature-for-an-organization/).

Enables or disables the specified security feature for all eligible repositories in an organization. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

The authenticated user must be an organization owner or be member of a team with the security manager role to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`admin:org\`, \`write:org\`, or \`repo\` scopes to use this endpoint.`,
    inputSchema:
      github.OrgsEnableOrDisableSecurityProductOnAllOrgReposParamsSchema
  })
  async orgsEnableOrDisableSecurityProductOnAllOrgRepos(
    params: github.OrgsEnableOrDisableSecurityProductOnAllOrgReposParams
  ): Promise<github.OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse> {
    return this.ky
      .post(
        `/orgs/${params.org}/${params.security_product}/${params.enablement}`,
        {
          json: pick(params, 'query_suite')
        }
      )
      .json<github.OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_get_card',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsGetCardParamsSchema
  })
  async projectsGetCard(
    params: github.ProjectsGetCardParams
  ): Promise<github.ProjectsGetCardResponse> {
    return this.ky
      .get(`/projects/columns/cards/${params.card_id}`)
      .json<github.ProjectsGetCardResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_delete_card',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsDeleteCardParamsSchema
  })
  async projectsDeleteCard(
    params: github.ProjectsDeleteCardParams
  ): Promise<github.ProjectsDeleteCardResponse> {
    return this.ky
      .delete(`/projects/columns/cards/${params.card_id}`)
      .json<github.ProjectsDeleteCardResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_update_card',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsUpdateCardParamsSchema
  })
  async projectsUpdateCard(
    params: github.ProjectsUpdateCardParams
  ): Promise<github.ProjectsUpdateCardResponse> {
    return this.ky
      .patch(`/projects/columns/cards/${params.card_id}`, {
        json: pick(params, 'note', 'archived')
      })
      .json<github.ProjectsUpdateCardResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_move_card',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsMoveCardParamsSchema
  })
  async projectsMoveCard(
    params: github.ProjectsMoveCardParams
  ): Promise<github.ProjectsMoveCardResponse> {
    return this.ky
      .post(`/projects/columns/cards/${params.card_id}/moves`, {
        json: pick(params, 'position', 'column_id')
      })
      .json<github.ProjectsMoveCardResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_get_column',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsGetColumnParamsSchema
  })
  async projectsGetColumn(
    params: github.ProjectsGetColumnParams
  ): Promise<github.ProjectsGetColumnResponse> {
    return this.ky
      .get(`/projects/columns/${params.column_id}`)
      .json<github.ProjectsGetColumnResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_delete_column',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsDeleteColumnParamsSchema
  })
  async projectsDeleteColumn(
    params: github.ProjectsDeleteColumnParams
  ): Promise<github.ProjectsDeleteColumnResponse> {
    return this.ky
      .delete(`/projects/columns/${params.column_id}`)
      .json<github.ProjectsDeleteColumnResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_update_column',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsUpdateColumnParamsSchema
  })
  async projectsUpdateColumn(
    params: github.ProjectsUpdateColumnParams
  ): Promise<github.ProjectsUpdateColumnResponse> {
    return this.ky
      .patch(`/projects/columns/${params.column_id}`, {
        json: pick(params, 'name')
      })
      .json<github.ProjectsUpdateColumnResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_cards',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListCardsParamsSchema
  })
  async projectsListCards(
    params: github.ProjectsListCardsParams
  ): Promise<github.ProjectsListCardsResponse> {
    return this.ky
      .get(`/projects/columns/${params.column_id}/cards`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'archived_state', 'per_page', 'page')
        )
      })
      .json<github.ProjectsListCardsResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_create_card',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    // TODO: Improve handling of union params
    inputSchema: github.ProjectsCreateCardParamsSchema as any
  })
  async projectsCreateCard(
    params: github.ProjectsCreateCardParams
  ): Promise<github.ProjectsCreateCardResponse> {
    return this.ky
      .post(`/projects/columns/${params.column_id}/cards`, {
        json: params
      })
      .json<github.ProjectsCreateCardResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_move_column',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsMoveColumnParamsSchema
  })
  async projectsMoveColumn(
    params: github.ProjectsMoveColumnParams
  ): Promise<github.ProjectsMoveColumnResponse> {
    return this.ky
      .post(`/projects/columns/${params.column_id}/moves`, {
        json: pick(params, 'position')
      })
      .json<github.ProjectsMoveColumnResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_get',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsGetParamsSchema
  })
  async projectsGet(
    params: github.ProjectsGetParams
  ): Promise<github.ProjectsGetResponse> {
    return this.ky
      .get(`/projects/${params.project_id}`)
      .json<github.ProjectsGetResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_delete',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsDeleteParamsSchema
  })
  async projectsDelete(
    params: github.ProjectsDeleteParams
  ): Promise<github.ProjectsDeleteResponse> {
    return this.ky
      .delete(`/projects/${params.project_id}`)
      .json<github.ProjectsDeleteResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_update',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsUpdateParamsSchema
  })
  async projectsUpdate(
    params: github.ProjectsUpdateParams
  ): Promise<github.ProjectsUpdateResponse> {
    return this.ky
      .patch(`/projects/${params.project_id}`, {
        json: pick(
          params,
          'name',
          'body',
          'state',
          'organization_permission',
          'private'
        )
      })
      .json<github.ProjectsUpdateResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_collaborators',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListCollaboratorsParamsSchema
  })
  async projectsListCollaborators(
    params: github.ProjectsListCollaboratorsParams
  ): Promise<github.ProjectsListCollaboratorsResponse> {
    return this.ky
      .get(`/projects/${params.project_id}/collaborators`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'affiliation', 'per_page', 'page')
        )
      })
      .json<github.ProjectsListCollaboratorsResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_add_collaborator',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsAddCollaboratorParamsSchema
  })
  async projectsAddCollaborator(
    params: github.ProjectsAddCollaboratorParams
  ): Promise<github.ProjectsAddCollaboratorResponse> {
    return this.ky
      .put(
        `/projects/${params.project_id}/collaborators/${params.username}`,
        {
          json: pick(params, 'permission')
        }
      )
      .json<github.ProjectsAddCollaboratorResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_remove_collaborator',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsRemoveCollaboratorParamsSchema
  })
  async projectsRemoveCollaborator(
    params: github.ProjectsRemoveCollaboratorParams
  ): Promise<github.ProjectsRemoveCollaboratorResponse> {
    return this.ky
      .delete(
        `/projects/${params.project_id}/collaborators/${params.username}`,
        {}
      )
      .json<github.ProjectsRemoveCollaboratorResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_get_permission_for_user',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsGetPermissionForUserParamsSchema
  })
  async projectsGetPermissionForUser(
    params: github.ProjectsGetPermissionForUserParams
  ): Promise<github.ProjectsGetPermissionForUserResponse> {
    return this.ky
      .get(
        `/projects/${params.project_id}/collaborators/${params.username}/permission`,
        {}
      )
      .json<github.ProjectsGetPermissionForUserResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_columns',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListColumnsParamsSchema
  })
  async projectsListColumns(
    params: github.ProjectsListColumnsParams
  ): Promise<github.ProjectsListColumnsResponse> {
    return this.ky
      .get(`/projects/${params.project_id}/columns`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ProjectsListColumnsResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_create_column',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsCreateColumnParamsSchema
  })
  async projectsCreateColumn(
    params: github.ProjectsCreateColumnParams
  ): Promise<github.ProjectsCreateColumnResponse> {
    return this.ky
      .post(`/projects/${params.project_id}/columns`, {
        json: pick(params, 'name')
      })
      .json<github.ProjectsCreateColumnResponse>()
  }

  /**
 * > [!NOTE]
> Accessing this endpoint does not count against your REST API rate limit.

Some categories of endpoints have custom rate limits that are separate from the rate limit governing the other REST API endpoints. For this reason, the API response categorizes your rate limit. Under `resources`, you'll see objects relating to different categories:
* The `core` object provides your rate limit status for all non-search-related resources in the REST API.
* The `search` object provides your rate limit status for the REST API for searching (excluding code searches). For more information, see "[Search](https://docs.github.com/rest/search/search)."
* The `code_search` object provides your rate limit status for the REST API for searching code. For more information, see "[Search code](https://docs.github.com/rest/search/search#search-code)."
* The `graphql` object provides your rate limit status for the GraphQL API. For more information, see "[Resource limitations](https://docs.github.com/graphql/overview/resource-limitations#rate-limit)."
* The `integration_manifest` object provides your rate limit status for the `POST /app-manifests/{code}/conversions` operation. For more information, see "[Creating a GitHub App from a manifest](https://docs.github.com/apps/creating-github-apps/setting-up-a-github-app/creating-a-github-app-from-a-manifest#3-you-exchange-the-temporary-code-to-retrieve-the-app-configuration)."
* The `dependency_snapshots` object provides your rate limit status for submitting snapshots to the dependency graph. For more information, see "[Dependency graph](https://docs.github.com/rest/dependency-graph)."
* The `code_scanning_upload` object provides your rate limit status for uploading SARIF results to code scanning. For more information, see "[Uploading a SARIF file to GitHub](https://docs.github.com/code-security/code-scanning/integrating-with-code-scanning/uploading-a-sarif-file-to-github)."
* The `actions_runner_registration` object provides your rate limit status for registering self-hosted runners in GitHub Actions. For more information, see "[Self-hosted runners](https://docs.github.com/rest/actions/self-hosted-runners)."
* The `source_import` object is no longer in use for any API endpoints, and it will be removed in the next API version. For more information about API versions, see "[API Versions](https://docs.github.com/rest/about-the-rest-api/api-versions)."

> [!NOTE]
> The `rate` object is closing down. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
 */
  @aiFunction({
    name: 'rate_limit_get',
    description: `> [!NOTE]
> Accessing this endpoint does not count against your REST API rate limit.

Some categories of endpoints have custom rate limits that are separate from the rate limit governing the other REST API endpoints. For this reason, the API response categorizes your rate limit. Under \`resources\`, you'll see objects relating to different categories:
* The \`core\` object provides your rate limit status for all non-search-related resources in the REST API.
* The \`search\` object provides your rate limit status for the REST API for searching (excluding code searches). For more information, see "[Search](https://docs.github.com/rest/search/search)."
* The \`code_search\` object provides your rate limit status for the REST API for searching code. For more information, see "[Search code](https://docs.github.com/rest/search/search#search-code)."
* The \`graphql\` object provides your rate limit status for the GraphQL API. For more information, see "[Resource limitations](https://docs.github.com/graphql/overview/resource-limitations#rate-limit)."
* The \`integration_manifest\` object provides your rate limit status for the \`POST /app-manifests/{code}/conversions\` operation. For more information, see "[Creating a GitHub App from a manifest](https://docs.github.com/apps/creating-github-apps/setting-up-a-github-app/creating-a-github-app-from-a-manifest#3-you-exchange-the-temporary-code-to-retrieve-the-app-configuration)."
* The \`dependency_snapshots\` object provides your rate limit status for submitting snapshots to the dependency graph. For more information, see "[Dependency graph](https://docs.github.com/rest/dependency-graph)."
* The \`code_scanning_upload\` object provides your rate limit status for uploading SARIF results to code scanning. For more information, see "[Uploading a SARIF file to GitHub](https://docs.github.com/code-security/code-scanning/integrating-with-code-scanning/uploading-a-sarif-file-to-github)."
* The \`actions_runner_registration\` object provides your rate limit status for registering self-hosted runners in GitHub Actions. For more information, see "[Self-hosted runners](https://docs.github.com/rest/actions/self-hosted-runners)."
* The \`source_import\` object is no longer in use for any API endpoints, and it will be removed in the next API version. For more information about API versions, see "[API Versions](https://docs.github.com/rest/about-the-rest-api/api-versions)."

> [!NOTE]
> The \`rate\` object is closing down. If you're writing new API client code or updating existing code, you should use the \`core\` object instead of the \`rate\` object. The \`core\` object contains the same information that is present in the \`rate\` object.`,
    inputSchema: github.RateLimitGetParamsSchema
  })
  async rateLimitGet(
    _params: github.RateLimitGetParams
  ): Promise<github.RateLimitGetResponse> {
    return this.ky.get('/rate_limit').json<github.RateLimitGetResponse>()
  }

  /**
 * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.

> [!NOTE]
> In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
 */
  @aiFunction({
    name: 'repos_get',
    description: `The \`parent\` and \`source\` objects are present when the repository is a fork. \`parent\` is the repository this repository was forked from, \`source\` is the ultimate source for the network.

> [!NOTE]
> In order to see the \`security_and_analysis\` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".`,
    inputSchema: github.ReposGetParamsSchema
  })
  async reposGet(
    params: github.ReposGetParams
  ): Promise<github.ReposGetResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}`, {})
      .json<github.ReposGetResponse>()
  }

  /**
 * Deleting a repository requires admin access.

If an organization owner has configured the organization to prevent members from deleting organization-owned
repositories, you will get a `403 Forbidden` response.

OAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_delete',
    description: `Deleting a repository requires admin access.

If an organization owner has configured the organization to prevent members from deleting organization-owned
repositories, you will get a \`403 Forbidden\` response.

OAuth app tokens and personal access tokens (classic) need the \`delete_repo\` scope to use this endpoint.`,
    inputSchema: github.ReposDeleteParamsSchema
  })
  async reposDelete(
    params: github.ReposDeleteParams
  ): Promise<github.ReposDeleteResponse> {
    return this.ky
      .delete(`/repos/${params.owner}/${params.repo}`, {})
      .json<github.ReposDeleteResponse>()
  }

  /**
   * **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.
   */
  @aiFunction({
    name: 'repos_update',
    description: `**Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.`,
    inputSchema: github.ReposUpdateParamsSchema
  })
  async reposUpdate(
    params: github.ReposUpdateParams
  ): Promise<github.ReposUpdateResponse> {
    return this.ky
      .patch(`/repos/${params.owner}/${params.repo}`, {
        json: pick(
          params,
          'name',
          'description',
          'homepage',
          'private',
          'visibility',
          'security_and_analysis',
          'has_issues',
          'has_projects',
          'has_wiki',
          'is_template',
          'default_branch',
          'allow_squash_merge',
          'allow_merge_commit',
          'allow_rebase_merge',
          'allow_auto_merge',
          'delete_branch_on_merge',
          'allow_update_branch',
          'use_squash_pr_title_as_default',
          'squash_merge_commit_title',
          'squash_merge_commit_message',
          'merge_commit_title',
          'merge_commit_message',
          'archived',
          'allow_forking',
          'web_commit_signoff_required'
        )
      })
      .json<github.ReposUpdateResponse>()
  }

  /**
 * Lists all artifacts for a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_list_artifacts_for_repo',
    description: `Lists all artifacts for a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsListArtifactsForRepoParamsSchema
  })
  async actionsListArtifactsForRepo(
    params: github.ActionsListArtifactsForRepoParams
  ): Promise<github.ActionsListArtifactsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/artifacts`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'name')
        )
      })
      .json<github.ActionsListArtifactsForRepoResponse>()
  }

  /**
 * Gets a specific artifact for a workflow run.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_artifact',
    description: `Gets a specific artifact for a workflow run.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetArtifactParamsSchema
  })
  async actionsGetArtifact(
    params: github.ActionsGetArtifactParams
  ): Promise<github.ActionsGetArtifactResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/artifacts/${params.artifact_id}`,
        {}
      )
      .json<github.ActionsGetArtifactResponse>()
  }

  /**
 * Deletes an artifact for a workflow run.
OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_artifact',
    description: `Deletes an artifact for a workflow run.
OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteArtifactParamsSchema
  })
  async actionsDeleteArtifact(
    params: github.ActionsDeleteArtifactParams
  ): Promise<github.ActionsDeleteArtifactResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/artifacts/${params.artifact_id}`,
        {}
      )
      .json<github.ActionsDeleteArtifactResponse>()
  }

  /**
 * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
the response header to find the URL for the download. The `:archive_format` must be `zip`.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_download_artifact',
    description: `Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for \`Location:\` in
the response header to find the URL for the download. The \`:archive_format\` must be \`zip\`.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDownloadArtifactParamsSchema
  })
  async actionsDownloadArtifact(
    params: github.ActionsDownloadArtifactParams
  ): Promise<github.ActionsDownloadArtifactResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/artifacts/${params.artifact_id}/${params.archive_format}`,
        {}
      )
      .json<github.ActionsDownloadArtifactResponse>()
  }

  /**
 * Gets GitHub Actions cache usage for a repository.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_actions_cache_usage',
    description: `Gets GitHub Actions cache usage for a repository.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetActionsCacheUsageParamsSchema
  })
  async actionsGetActionsCacheUsage(
    params: github.ActionsGetActionsCacheUsageParams
  ): Promise<github.ActionsGetActionsCacheUsageResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/cache/usage`,
        {}
      )
      .json<github.ActionsGetActionsCacheUsageResponse>()
  }

  /**
 * Lists the GitHub Actions caches for a repository.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_actions_cache_list',
    description: `Lists the GitHub Actions caches for a repository.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetActionsCacheListParamsSchema
  })
  async actionsGetActionsCacheList(
    params: github.ActionsGetActionsCacheListParams
  ): Promise<github.ActionsGetActionsCacheListResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/caches`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'ref', 'key', 'sort', 'direction')
        )
      })
      .json<github.ActionsGetActionsCacheListResponse>()
  }

  /**
 * Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to restrict deletions to caches that match both the provided key and the Git ref.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_actions_cache_by_key',
    description: `Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to restrict deletions to caches that match both the provided key and the Git ref.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteActionsCacheByKeyParamsSchema
  })
  async actionsDeleteActionsCacheByKey(
    params: github.ActionsDeleteActionsCacheByKeyParams
  ): Promise<github.ActionsDeleteActionsCacheByKeyResponse> {
    return this.ky
      .delete(`/repos/${params.owner}/${params.repo}/actions/caches`, {
        searchParams: sanitizeSearchParams(pick(params, 'key', 'ref'))
      })
      .json<github.ActionsDeleteActionsCacheByKeyResponse>()
  }

  /**
 * Deletes a GitHub Actions cache for a repository, using a cache ID.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_actions_cache_by_id',
    description: `Deletes a GitHub Actions cache for a repository, using a cache ID.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteActionsCacheByIdParamsSchema
  })
  async actionsDeleteActionsCacheById(
    params: github.ActionsDeleteActionsCacheByIdParams
  ): Promise<github.ActionsDeleteActionsCacheByIdResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/caches/${params.cache_id}`,
        {}
      )
      .json<github.ActionsDeleteActionsCacheByIdResponse>()
  }

  /**
 * Gets a specific job in a workflow run.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_job_for_workflow_run',
    description: `Gets a specific job in a workflow run.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetJobForWorkflowRunParamsSchema
  })
  async actionsGetJobForWorkflowRun(
    params: github.ActionsGetJobForWorkflowRunParams
  ): Promise<github.ActionsGetJobForWorkflowRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/jobs/${params.job_id}`,
        {}
      )
      .json<github.ActionsGetJobForWorkflowRunResponse>()
  }

  /**
 * Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
for `Location:` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_download_job_logs_for_workflow_run',
    description: `Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
for \`Location:\` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDownloadJobLogsForWorkflowRunParamsSchema
  })
  async actionsDownloadJobLogsForWorkflowRun(
    params: github.ActionsDownloadJobLogsForWorkflowRunParams
  ): Promise<github.ActionsDownloadJobLogsForWorkflowRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/jobs/${params.job_id}/logs`,
        {}
      )
      .json<github.ActionsDownloadJobLogsForWorkflowRunResponse>()
  }

  /**
 * Re-run a job and its dependent jobs in a workflow run.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_re_run_job_for_workflow_run',
    description: `Re-run a job and its dependent jobs in a workflow run.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsReRunJobForWorkflowRunParamsSchema
  })
  async actionsReRunJobForWorkflowRun(
    params: github.ActionsReRunJobForWorkflowRunParams
  ): Promise<github.ActionsReRunJobForWorkflowRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/jobs/${params.job_id}/rerun`,
        {
          json: pick(params, 'enable_debug_logging')
        }
      )
      .json<github.ActionsReRunJobForWorkflowRunResponse>()
  }

  /**
 * Gets the customization template for an OpenID Connect (OIDC) subject claim.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_custom_oidc_sub_claim_for_repo',
    description: `Gets the customization template for an OpenID Connect (OIDC) subject claim.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetCustomOidcSubClaimForRepoParamsSchema
  })
  async actionsGetCustomOidcSubClaimForRepo(
    params: github.ActionsGetCustomOidcSubClaimForRepoParams
  ): Promise<github.ActionsGetCustomOidcSubClaimForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/oidc/customization/sub`,
        {}
      )
      .json<github.ActionsGetCustomOidcSubClaimForRepoResponse>()
  }

  /**
 * Sets the customization template and `opt-in` or `opt-out` flag for an OpenID Connect (OIDC) subject claim for a repository.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_custom_oidc_sub_claim_for_repo',
    description: `Sets the customization template and \`opt-in\` or \`opt-out\` flag for an OpenID Connect (OIDC) subject claim for a repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetCustomOidcSubClaimForRepoParamsSchema
  })
  async actionsSetCustomOidcSubClaimForRepo(
    params: github.ActionsSetCustomOidcSubClaimForRepoParams
  ): Promise<github.ActionsSetCustomOidcSubClaimForRepoResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/oidc/customization/sub`,
        {
          json: pick(params, 'use_default', 'include_claim_keys')
        }
      )
      .json<github.ActionsSetCustomOidcSubClaimForRepoResponse>()
  }

  /**
 * Lists all organization secrets shared with a repository without revealing their encrypted
values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_repo_organization_secrets',
    description: `Lists all organization secrets shared with a repository without revealing their encrypted
values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListRepoOrganizationSecretsParamsSchema
  })
  async actionsListRepoOrganizationSecrets(
    params: github.ActionsListRepoOrganizationSecretsParams
  ): Promise<github.ActionsListRepoOrganizationSecretsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/organization-secrets`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListRepoOrganizationSecretsResponse>()
  }

  /**
 * Lists all organization variables shared with a repository.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_repo_organization_variables',
    description: `Lists all organization variables shared with a repository.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListRepoOrganizationVariablesParamsSchema
  })
  async actionsListRepoOrganizationVariables(
    params: github.ActionsListRepoOrganizationVariablesParams
  ): Promise<github.ActionsListRepoOrganizationVariablesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/organization-variables`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListRepoOrganizationVariablesResponse>()
  }

  /**
 * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_github_actions_permissions_repository',
    description: `Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetGithubActionsPermissionsRepositoryParamsSchema
  })
  async actionsGetGithubActionsPermissionsRepository(
    params: github.ActionsGetGithubActionsPermissionsRepositoryParams
  ): Promise<github.ActionsGetGithubActionsPermissionsRepositoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/permissions`,
        {}
      )
      .json<github.ActionsGetGithubActionsPermissionsRepositoryResponse>()
  }

  /**
 * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions and reusable workflows in the repository.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_github_actions_permissions_repository',
    description: `Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions and reusable workflows in the repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetGithubActionsPermissionsRepositoryParamsSchema
  })
  async actionsSetGithubActionsPermissionsRepository(
    params: github.ActionsSetGithubActionsPermissionsRepositoryParams
  ): Promise<github.ActionsSetGithubActionsPermissionsRepositoryResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/actions/permissions`, {
        json: pick(params, 'enabled', 'allowed_actions')
      })
      .json<github.ActionsSetGithubActionsPermissionsRepositoryResponse>()
  }

  /**
 * Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to private repositories.
For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_workflow_access_to_repository',
    description: `Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to private repositories.
For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetWorkflowAccessToRepositoryParamsSchema
  })
  async actionsGetWorkflowAccessToRepository(
    params: github.ActionsGetWorkflowAccessToRepositoryParams
  ): Promise<github.ActionsGetWorkflowAccessToRepositoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/permissions/access`,
        {}
      )
      .json<github.ActionsGetWorkflowAccessToRepositoryResponse>()
  }

  /**
 * Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to private repositories.
For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)".

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_workflow_access_to_repository',
    description: `Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to private repositories.
For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)".

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetWorkflowAccessToRepositoryParamsSchema
  })
  async actionsSetWorkflowAccessToRepository(
    params: github.ActionsSetWorkflowAccessToRepositoryParams
  ): Promise<github.ActionsSetWorkflowAccessToRepositoryResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/permissions/access`,
        {
          json: pick(params, 'access_level')
        }
      )
      .json<github.ActionsSetWorkflowAccessToRepositoryResponse>()
  }

  /**
 * Gets the settings for selected actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_allowed_actions_repository',
    description: `Gets the settings for selected actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository policy for \`allowed_actions\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetAllowedActionsRepositoryParamsSchema
  })
  async actionsGetAllowedActionsRepository(
    params: github.ActionsGetAllowedActionsRepositoryParams
  ): Promise<github.ActionsGetAllowedActionsRepositoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/permissions/selected-actions`,
        {}
      )
      .json<github.ActionsGetAllowedActionsRepositoryResponse>()
  }

  /**
 * Sets the actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_allowed_actions_repository',
    description: `Sets the actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository permission policy for \`allowed_actions\` must be configured to \`selected\`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsSetAllowedActionsRepositoryParamsSchema
  })
  async actionsSetAllowedActionsRepository(
    params: github.ActionsSetAllowedActionsRepositoryParams
  ): Promise<github.ActionsSetAllowedActionsRepositoryResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/permissions/selected-actions`,
        {
          json: pick(
            params,
            'github_owned_allowed',
            'verified_allowed',
            'patterns_allowed'
          )
        }
      )
      .json<github.ActionsSetAllowedActionsRepositoryResponse>()
  }

  /**
 * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,
as well as if GitHub Actions can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_github_actions_default_workflow_permissions_repository',
    description: `Gets the default workflow permissions granted to the \`GITHUB_TOKEN\` when running workflows in a repository,
as well as if GitHub Actions can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
  })
  async actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
    params: github.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParams
  ): Promise<github.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/permissions/workflow`,
        {}
      )
      .json<github.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse>()
  }

  /**
 * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions
can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_github_actions_default_workflow_permissions_repository',
    description: `Sets the default workflow permissions granted to the \`GITHUB_TOKEN\` when running workflows in a repository, and sets if GitHub Actions
can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamsSchema
  })
  async actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
    params: github.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParams
  ): Promise<github.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/permissions/workflow`,
        {
          json: pick(
            params,
            'default_workflow_permissions',
            'can_approve_pull_request_reviews'
          )
        }
      )
      .json<github.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse>()
  }

  /**
 * Lists all self-hosted runners configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_self_hosted_runners_for_repo',
    description: `Lists all self-hosted runners configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListSelfHostedRunnersForRepoParamsSchema
  })
  async actionsListSelfHostedRunnersForRepo(
    params: github.ActionsListSelfHostedRunnersForRepoParams
  ): Promise<github.ActionsListSelfHostedRunnersForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/runners`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'name', 'per_page', 'page')
        )
      })
      .json<github.ActionsListSelfHostedRunnersForRepoResponse>()
  }

  /**
 * Lists binaries for the runner application that you can download and run.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_runner_applications_for_repo',
    description: `Lists binaries for the runner application that you can download and run.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListRunnerApplicationsForRepoParamsSchema
  })
  async actionsListRunnerApplicationsForRepo(
    params: github.ActionsListRunnerApplicationsForRepoParams
  ): Promise<github.ActionsListRunnerApplicationsForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runners/downloads`,
        {}
      )
      .json<github.ActionsListRunnerApplicationsForRepoResponse>()
  }

  /**
 * Generates a configuration that can be passed to the runner application at startup.

The authenticated user must have admin access to the repository.

OAuth tokens and personal access tokens (classic) need the`repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_generate_runner_jitconfig_for_repo',
    description: `Generates a configuration that can be passed to the runner application at startup.

The authenticated user must have admin access to the repository.

OAuth tokens and personal access tokens (classic) need the\`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGenerateRunnerJitconfigForRepoParamsSchema
  })
  async actionsGenerateRunnerJitconfigForRepo(
    params: github.ActionsGenerateRunnerJitconfigForRepoParams
  ): Promise<github.ActionsGenerateRunnerJitconfigForRepoResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runners/generate-jitconfig`,
        {
          json: pick(params, 'name', 'runner_group_id', 'labels', 'work_folder')
        }
      )
      .json<github.ActionsGenerateRunnerJitconfigForRepoResponse>()
  }

  /**
 * Returns a token that you can pass to the `config` script. The token expires after one hour.

For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:

```
./config.sh --url https://github.com/octo-org --token TOKEN
```

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_registration_token_for_repo',
    description: `Returns a token that you can pass to the \`config\` script. The token expires after one hour.

For example, you can replace \`TOKEN\` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:

\`\`\`
./config.sh --url https://github.com/octo-org --token TOKEN
\`\`\`

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateRegistrationTokenForRepoParamsSchema
  })
  async actionsCreateRegistrationTokenForRepo(
    params: github.ActionsCreateRegistrationTokenForRepoParams
  ): Promise<github.ActionsCreateRegistrationTokenForRepoResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runners/registration-token`,
        {}
      )
      .json<github.ActionsCreateRegistrationTokenForRepoResponse>()
  }

  /**
 * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an repository. The token expires after one hour.

For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:

```
./config.sh remove --token TOKEN
```

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_remove_token_for_repo',
    description: `Returns a token that you can pass to the \`config\` script to remove a self-hosted runner from an repository. The token expires after one hour.

For example, you can replace \`TOKEN\` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:

\`\`\`
./config.sh remove --token TOKEN
\`\`\`

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateRemoveTokenForRepoParamsSchema
  })
  async actionsCreateRemoveTokenForRepo(
    params: github.ActionsCreateRemoveTokenForRepoParams
  ): Promise<github.ActionsCreateRemoveTokenForRepoResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runners/remove-token`,
        {}
      )
      .json<github.ActionsCreateRemoveTokenForRepoResponse>()
  }

  /**
 * Gets a specific self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_self_hosted_runner_for_repo',
    description: `Gets a specific self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetSelfHostedRunnerForRepoParamsSchema
  })
  async actionsGetSelfHostedRunnerForRepo(
    params: github.ActionsGetSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsGetSelfHostedRunnerForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}`,
        {}
      )
      .json<github.ActionsGetSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_self_hosted_runner_from_repo',
    description: `Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteSelfHostedRunnerFromRepoParamsSchema
  })
  async actionsDeleteSelfHostedRunnerFromRepo(
    params: github.ActionsDeleteSelfHostedRunnerFromRepoParams
  ): Promise<github.ActionsDeleteSelfHostedRunnerFromRepoResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}`,
        {}
      )
      .json<github.ActionsDeleteSelfHostedRunnerFromRepoResponse>()
  }

  /**
 * Lists all labels for a self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_labels_for_self_hosted_runner_for_repo',
    description: `Lists all labels for a self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListLabelsForSelfHostedRunnerForRepoParamsSchema
  })
  async actionsListLabelsForSelfHostedRunnerForRepo(
    params: github.ActionsListLabelsForSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsListLabelsForSelfHostedRunnerForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}/labels`,
        {}
      )
      .json<github.ActionsListLabelsForSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Adds custom labels to a self-hosted runner configured in a repository.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_add_custom_labels_to_self_hosted_runner_for_repo',
    description: `Adds custom labels to a self-hosted runner configured in a repository.

Authenticated users must have admin access to the organization to use this endpoint.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamsSchema
  })
  async actionsAddCustomLabelsToSelfHostedRunnerForRepo(
    params: github.ActionsAddCustomLabelsToSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}/labels`,
        {
          json: pick(params, 'labels')
        }
      )
      .json<github.ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_set_custom_labels_for_self_hosted_runner_for_repo',
    description: `Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in a repository.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamsSchema
  })
  async actionsSetCustomLabelsForSelfHostedRunnerForRepo(
    params: github.ActionsSetCustomLabelsForSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}/labels`,
        {
          json: pick(params, 'labels')
        }
      )
      .json<github.ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Remove all custom labels from a self-hosted runner configured in a
repository. Returns the remaining read-only labels from the runner.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_remove_all_custom_labels_from_self_hosted_runner_for_repo',
    description: `Remove all custom labels from a self-hosted runner configured in a
repository. Returns the remaining read-only labels from the runner.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamsSchema
  })
  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
    params: github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}/labels`,
        {}
      )
      .json<github.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Remove a custom label from a self-hosted runner configured
in a repository. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_remove_custom_label_from_self_hosted_runner_for_repo',
    description: `Remove a custom label from a self-hosted runner configured
in a repository. Returns the remaining labels from the runner.

This endpoint returns a \`404 Not Found\` status if the custom label is not
present on the runner.

Authenticated users must have admin access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema:
      github.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamsSchema
  })
  async actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
    params: github.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParams
  ): Promise<github.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/runners/${params.runner_id}/labels/${params.name}`,
        {}
      )
      .json<github.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse>()
  }

  /**
 * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.

This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`, `created`, `event`, `head_sha`, `status`.
 */
  @aiFunction({
    name: 'actions_list_workflow_runs_for_repo',
    description: `Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.

This endpoint will return up to 1,000 results for each search when using the following parameters: \`actor\`, \`branch\`, \`check_suite_id\`, \`created\`, \`event\`, \`head_sha\`, \`status\`.`,
    inputSchema: github.ActionsListWorkflowRunsForRepoParamsSchema
  })
  async actionsListWorkflowRunsForRepo(
    params: github.ActionsListWorkflowRunsForRepoParams
  ): Promise<github.ActionsListWorkflowRunsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/runs`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'actor',
            'branch',
            'event',
            'status',
            'per_page',
            'page',
            'created',
            'exclude_pull_requests',
            'check_suite_id',
            'head_sha'
          )
        )
      })
      .json<github.ActionsListWorkflowRunsForRepoResponse>()
  }

  /**
 * Gets a specific workflow run.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_workflow_run',
    description: `Gets a specific workflow run.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetWorkflowRunParamsSchema
  })
  async actionsGetWorkflowRun(
    params: github.ActionsGetWorkflowRunParams
  ): Promise<github.ActionsGetWorkflowRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'exclude_pull_requests')
          )
        }
      )
      .json<github.ActionsGetWorkflowRunResponse>()
  }

  /**
 * Deletes a specific workflow run.

Anyone with write access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_workflow_run',
    description: `Deletes a specific workflow run.

Anyone with write access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteWorkflowRunParamsSchema
  })
  async actionsDeleteWorkflowRun(
    params: github.ActionsDeleteWorkflowRunParams
  ): Promise<github.ActionsDeleteWorkflowRunResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}`,
        {}
      )
      .json<github.ActionsDeleteWorkflowRunResponse>()
  }

  /**
 * Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_reviews_for_run',
    description: `Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetReviewsForRunParamsSchema
  })
  async actionsGetReviewsForRun(
    params: github.ActionsGetReviewsForRunParams
  ): Promise<github.ActionsGetReviewsForRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/approvals`,
        {}
      )
      .json<github.ActionsGetReviewsForRunResponse>()
  }

  /**
 * Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_approve_workflow_run',
    description: `Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsApproveWorkflowRunParamsSchema
  })
  async actionsApproveWorkflowRun(
    params: github.ActionsApproveWorkflowRunParams
  ): Promise<github.ActionsApproveWorkflowRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/approve`,
        {}
      )
      .json<github.ActionsApproveWorkflowRunResponse>()
  }

  /**
 * Lists artifacts for a workflow run.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_list_workflow_run_artifacts',
    description: `Lists artifacts for a workflow run.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsListWorkflowRunArtifactsParamsSchema
  })
  async actionsListWorkflowRunArtifacts(
    params: github.ActionsListWorkflowRunArtifactsParams
  ): Promise<github.ActionsListWorkflowRunArtifactsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/artifacts`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'page', 'name')
          )
        }
      )
      .json<github.ActionsListWorkflowRunArtifactsResponse>()
  }

  /**
 * Gets a specific workflow run attempt.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_workflow_run_attempt',
    description: `Gets a specific workflow run attempt.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetWorkflowRunAttemptParamsSchema
  })
  async actionsGetWorkflowRunAttempt(
    params: github.ActionsGetWorkflowRunAttemptParams
  ): Promise<github.ActionsGetWorkflowRunAttemptResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/attempts/${params.attempt_number}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'exclude_pull_requests')
          )
        }
      )
      .json<github.ActionsGetWorkflowRunAttemptResponse>()
  }

  /**
 * Lists jobs for a specific workflow run attempt. You can use parameters to narrow the list of results. For more information
about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint  with a private repository.
 */
  @aiFunction({
    name: 'actions_list_jobs_for_workflow_run_attempt',
    description: `Lists jobs for a specific workflow run attempt. You can use parameters to narrow the list of results. For more information
about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint  with a private repository.`,
    inputSchema: github.ActionsListJobsForWorkflowRunAttemptParamsSchema
  })
  async actionsListJobsForWorkflowRunAttempt(
    params: github.ActionsListJobsForWorkflowRunAttemptParams
  ): Promise<github.ActionsListJobsForWorkflowRunAttemptResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/attempts/${params.attempt_number}/jobs`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListJobsForWorkflowRunAttemptResponse>()
  }

  /**
 * Gets a redirect URL to download an archive of log files for a specific workflow run attempt. This link expires after
1 minute. Look for `Location:` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_download_workflow_run_attempt_logs',
    description: `Gets a redirect URL to download an archive of log files for a specific workflow run attempt. This link expires after
1 minute. Look for \`Location:\` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDownloadWorkflowRunAttemptLogsParamsSchema
  })
  async actionsDownloadWorkflowRunAttemptLogs(
    params: github.ActionsDownloadWorkflowRunAttemptLogsParams
  ): Promise<github.ActionsDownloadWorkflowRunAttemptLogsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/attempts/${params.attempt_number}/logs`,
        {}
      )
      .json<github.ActionsDownloadWorkflowRunAttemptLogsResponse>()
  }

  /**
 * Cancels a workflow run using its `id`.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_cancel_workflow_run',
    description: `Cancels a workflow run using its \`id\`.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCancelWorkflowRunParamsSchema
  })
  async actionsCancelWorkflowRun(
    params: github.ActionsCancelWorkflowRunParams
  ): Promise<github.ActionsCancelWorkflowRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/cancel`,
        {}
      )
      .json<github.ActionsCancelWorkflowRunResponse>()
  }

  /**
 * Approve or reject custom deployment protection rules provided by a GitHub App for a workflow run. For more information, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

> [!NOTE]
> GitHub Apps can only review their own custom deployment protection rules. To approve or reject pending deployments that are waiting for review from a specific person or team, see [`POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments`](/rest/actions/workflow-runs#review-pending-deployments-for-a-workflow-run).

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_review_custom_gates_for_run',
    description: `Approve or reject custom deployment protection rules provided by a GitHub App for a workflow run. For more information, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

> [!NOTE]
> GitHub Apps can only review their own custom deployment protection rules. To approve or reject pending deployments that are waiting for review from a specific person or team, see [\`POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\`](/rest/actions/workflow-runs#review-pending-deployments-for-a-workflow-run).

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    // TODO: Improve handling of union params
    inputSchema: github.ActionsReviewCustomGatesForRunParamsSchema as any
  })
  async actionsReviewCustomGatesForRun(
    params: github.ActionsReviewCustomGatesForRunParams
  ): Promise<github.ActionsReviewCustomGatesForRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/deployment_protection_rule`,
        {
          json: params
        }
      )
      .json<github.ActionsReviewCustomGatesForRunResponse>()
  }

  /**
 * Cancels a workflow run and bypasses conditions that would otherwise cause a workflow execution to continue, such as an `always()` condition on a job.
You should only use this endpoint to cancel a workflow run when the workflow run is not responding to [`POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel`](/rest/actions/workflow-runs#cancel-a-workflow-run).

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_force_cancel_workflow_run',
    description: `Cancels a workflow run and bypasses conditions that would otherwise cause a workflow execution to continue, such as an \`always()\` condition on a job.
You should only use this endpoint to cancel a workflow run when the workflow run is not responding to [\`POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel\`](/rest/actions/workflow-runs#cancel-a-workflow-run).

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsForceCancelWorkflowRunParamsSchema
  })
  async actionsForceCancelWorkflowRun(
    params: github.ActionsForceCancelWorkflowRunParams
  ): Promise<github.ActionsForceCancelWorkflowRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/force-cancel`,
        {}
      )
      .json<github.ActionsForceCancelWorkflowRunResponse>()
  }

  /**
 * Lists jobs for a workflow run. You can use parameters to narrow the list of results. For more information
about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_list_jobs_for_workflow_run',
    description: `Lists jobs for a workflow run. You can use parameters to narrow the list of results. For more information
about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsListJobsForWorkflowRunParamsSchema
  })
  async actionsListJobsForWorkflowRun(
    params: github.ActionsListJobsForWorkflowRunParams
  ): Promise<github.ActionsListJobsForWorkflowRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/jobs`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'filter', 'per_page', 'page')
          )
        }
      )
      .json<github.ActionsListJobsForWorkflowRunResponse>()
  }

  /**
 * Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
`Location:` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_download_workflow_run_logs',
    description: `Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
\`Location:\` in the response header to find the URL for the download.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDownloadWorkflowRunLogsParamsSchema
  })
  async actionsDownloadWorkflowRunLogs(
    params: github.ActionsDownloadWorkflowRunLogsParams
  ): Promise<github.ActionsDownloadWorkflowRunLogsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/logs`,
        {}
      )
      .json<github.ActionsDownloadWorkflowRunLogsResponse>()
  }

  /**
 * Deletes all logs for a workflow run.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_workflow_run_logs',
    description: `Deletes all logs for a workflow run.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteWorkflowRunLogsParamsSchema
  })
  async actionsDeleteWorkflowRunLogs(
    params: github.ActionsDeleteWorkflowRunLogsParams
  ): Promise<github.ActionsDeleteWorkflowRunLogsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/logs`,
        {}
      )
      .json<github.ActionsDeleteWorkflowRunLogsResponse>()
  }

  /**
 * Get all deployment environments for a workflow run that are waiting for protection rules to pass.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_pending_deployments_for_run',
    description: `Get all deployment environments for a workflow run that are waiting for protection rules to pass.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetPendingDeploymentsForRunParamsSchema
  })
  async actionsGetPendingDeploymentsForRun(
    params: github.ActionsGetPendingDeploymentsForRunParams
  ): Promise<github.ActionsGetPendingDeploymentsForRunResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/pending_deployments`,
        {}
      )
      .json<github.ActionsGetPendingDeploymentsForRunResponse>()
  }

  /**
 * Approve or reject pending deployments that are waiting on approval by a required reviewer.

Required reviewers with read access to the repository contents and deployments can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_review_pending_deployments_for_run',
    description: `Approve or reject pending deployments that are waiting on approval by a required reviewer.

Required reviewers with read access to the repository contents and deployments can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsReviewPendingDeploymentsForRunParamsSchema
  })
  async actionsReviewPendingDeploymentsForRun(
    params: github.ActionsReviewPendingDeploymentsForRunParams
  ): Promise<github.ActionsReviewPendingDeploymentsForRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/pending_deployments`,
        {
          json: pick(params, 'environment_ids', 'state', 'comment')
        }
      )
      .json<github.ActionsReviewPendingDeploymentsForRunResponse>()
  }

  /**
 * Re-runs your workflow run using its `id`.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_re_run_workflow',
    description: `Re-runs your workflow run using its \`id\`.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsReRunWorkflowParamsSchema
  })
  async actionsReRunWorkflow(
    params: github.ActionsReRunWorkflowParams
  ): Promise<github.ActionsReRunWorkflowResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/rerun`,
        {
          json: pick(params, 'enable_debug_logging')
        }
      )
      .json<github.ActionsReRunWorkflowResponse>()
  }

  /**
 * Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of the workflow run.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_re_run_workflow_failed_jobs',
    description: `Re-run all of the failed jobs and their dependent jobs in a workflow run using the \`id\` of the workflow run.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsReRunWorkflowFailedJobsParamsSchema
  })
  async actionsReRunWorkflowFailedJobs(
    params: github.ActionsReRunWorkflowFailedJobsParams
  ): Promise<github.ActionsReRunWorkflowFailedJobsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/rerun-failed-jobs`,
        {
          json: pick(params, 'enable_debug_logging')
        }
      )
      .json<github.ActionsReRunWorkflowFailedJobsResponse>()
  }

  /**
 * > [!WARNING]
> This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.

Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_workflow_run_usage',
    description: `> [!WARNING]
> This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.

Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetWorkflowRunUsageParamsSchema
  })
  async actionsGetWorkflowRunUsage(
    params: github.ActionsGetWorkflowRunUsageParams
  ): Promise<github.ActionsGetWorkflowRunUsageResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/runs/${params.run_id}/timing`,
        {}
      )
      .json<github.ActionsGetWorkflowRunUsageResponse>()
  }

  /**
 * Lists all secrets available in a repository without revealing their encrypted
values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_repo_secrets',
    description: `Lists all secrets available in a repository without revealing their encrypted
values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListRepoSecretsParamsSchema
  })
  async actionsListRepoSecrets(
    params: github.ActionsListRepoSecretsParams
  ): Promise<github.ActionsListRepoSecretsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListRepoSecretsResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_repo_public_key',
    description: `Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetRepoPublicKeyParamsSchema
  })
  async actionsGetRepoPublicKey(
    params: github.ActionsGetRepoPublicKeyParams
  ): Promise<github.ActionsGetRepoPublicKeyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/secrets/public-key`,
        {}
      )
      .json<github.ActionsGetRepoPublicKeyResponse>()
  }

  /**
 * Gets a single repository secret without revealing its encrypted value.

The authenticated user must have collaborator access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_repo_secret',
    description: `Gets a single repository secret without revealing its encrypted value.

The authenticated user must have collaborator access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetRepoSecretParamsSchema
  })
  async actionsGetRepoSecret(
    params: github.ActionsGetRepoSecretParams
  ): Promise<github.ActionsGetRepoSecretResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsGetRepoSecretResponse>()
  }

  /**
 * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_or_update_repo_secret',
    description: `Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateOrUpdateRepoSecretParamsSchema
  })
  async actionsCreateOrUpdateRepoSecret(
    params: github.ActionsCreateOrUpdateRepoSecretParams
  ): Promise<github.ActionsCreateOrUpdateRepoSecretResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/secrets/${params.secret_name}`,
        {
          json: pick(params, 'encrypted_value', 'key_id')
        }
      )
      .json<github.ActionsCreateOrUpdateRepoSecretResponse>()
  }

  /**
 * Deletes a secret in a repository using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_repo_secret',
    description: `Deletes a secret in a repository using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteRepoSecretParamsSchema
  })
  async actionsDeleteRepoSecret(
    params: github.ActionsDeleteRepoSecretParams
  ): Promise<github.ActionsDeleteRepoSecretResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsDeleteRepoSecretResponse>()
  }

  /**
 * Lists all repository variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_repo_variables',
    description: `Lists all repository variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListRepoVariablesParamsSchema
  })
  async actionsListRepoVariables(
    params: github.ActionsListRepoVariablesParams
  ): Promise<github.ActionsListRepoVariablesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/variables`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListRepoVariablesResponse>()
  }

  /**
 * Creates a repository variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_repo_variable',
    description: `Creates a repository variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateRepoVariableParamsSchema
  })
  async actionsCreateRepoVariable(
    params: github.ActionsCreateRepoVariableParams
  ): Promise<github.ActionsCreateRepoVariableResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/actions/variables`, {
        json: pick(params, 'name', 'value')
      })
      .json<github.ActionsCreateRepoVariableResponse>()
  }

  /**
 * Gets a specific variable in a repository.

The authenticated user must have collaborator access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_repo_variable',
    description: `Gets a specific variable in a repository.

The authenticated user must have collaborator access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetRepoVariableParamsSchema
  })
  async actionsGetRepoVariable(
    params: github.ActionsGetRepoVariableParams
  ): Promise<github.ActionsGetRepoVariableResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/variables/${params.name}`,
        {}
      )
      .json<github.ActionsGetRepoVariableResponse>()
  }

  /**
 * Deletes a repository variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_repo_variable',
    description: `Deletes a repository variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteRepoVariableParamsSchema
  })
  async actionsDeleteRepoVariable(
    params: github.ActionsDeleteRepoVariableParams
  ): Promise<github.ActionsDeleteRepoVariableResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/actions/variables/${params.name}`,
        {}
      )
      .json<github.ActionsDeleteRepoVariableResponse>()
  }

  /**
 * Updates a repository variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_update_repo_variable',
    description: `Updates a repository variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsUpdateRepoVariableParamsSchema
  })
  async actionsUpdateRepoVariable(
    params: github.ActionsUpdateRepoVariableParams
  ): Promise<github.ActionsUpdateRepoVariableResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/actions/variables/${params.name}`,
        {
          json: pick(params, 'name', 'value')
        }
      )
      .json<github.ActionsUpdateRepoVariableResponse>()
  }

  /**
 * Lists the workflows in a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_list_repo_workflows',
    description: `Lists the workflows in a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsListRepoWorkflowsParamsSchema
  })
  async actionsListRepoWorkflows(
    params: github.ActionsListRepoWorkflowsParams
  ): Promise<github.ActionsListRepoWorkflowsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/actions/workflows`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActionsListRepoWorkflowsResponse>()
  }

  /**
 * Gets a specific workflow. You can replace `workflow_id` with the workflow
file name. For example, you could use `main.yaml`.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_workflow',
    description: `Gets a specific workflow. You can replace \`workflow_id\` with the workflow
file name. For example, you could use \`main.yaml\`.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetWorkflowParamsSchema
  })
  async actionsGetWorkflow(
    params: github.ActionsGetWorkflowParams
  ): Promise<github.ActionsGetWorkflowResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}`,
        {}
      )
      .json<github.ActionsGetWorkflowResponse>()
  }

  /**
 * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_disable_workflow',
    description: `Disables a workflow and sets the \`state\` of the workflow to \`disabled_manually\`. You can replace \`workflow_id\` with the workflow file name. For example, you could use \`main.yaml\`.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDisableWorkflowParamsSchema
  })
  async actionsDisableWorkflow(
    params: github.ActionsDisableWorkflowParams
  ): Promise<github.ActionsDisableWorkflowResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}/disable`,
        {}
      )
      .json<github.ActionsDisableWorkflowResponse>()
  }

  /**
 * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_workflow_dispatch',
    description: `You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace \`workflow_id\` with the workflow file name. For example, you could use \`main.yaml\`.

You must configure your GitHub Actions workflow to run when the [\`workflow_dispatch\` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The \`inputs\` are configured in the workflow file. For more information about how to configure the \`workflow_dispatch\` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateWorkflowDispatchParamsSchema
  })
  async actionsCreateWorkflowDispatch(
    params: github.ActionsCreateWorkflowDispatchParams
  ): Promise<github.ActionsCreateWorkflowDispatchResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}/dispatches`,
        {
          json: pick(params, 'ref', 'inputs')
        }
      )
      .json<github.ActionsCreateWorkflowDispatchResponse>()
  }

  /**
 * Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_enable_workflow',
    description: `Enables a workflow and sets the \`state\` of the workflow to \`active\`. You can replace \`workflow_id\` with the workflow file name. For example, you could use \`main.yaml\`.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsEnableWorkflowParamsSchema
  })
  async actionsEnableWorkflow(
    params: github.ActionsEnableWorkflowParams
  ): Promise<github.ActionsEnableWorkflowResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}/enable`,
        {}
      )
      .json<github.ActionsEnableWorkflowResponse>()
  }

  /**
 * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.

This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`, `created`, `event`, `head_sha`, `status`.
 */
  @aiFunction({
    name: 'actions_list_workflow_runs',
    description: `List all workflow runs for a workflow. You can replace \`workflow_id\` with the workflow file name. For example, you could use \`main.yaml\`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.

This endpoint will return up to 1,000 results for each search when using the following parameters: \`actor\`, \`branch\`, \`check_suite_id\`, \`created\`, \`event\`, \`head_sha\`, \`status\`.`,
    inputSchema: github.ActionsListWorkflowRunsParamsSchema
  })
  async actionsListWorkflowRuns(
    params: github.ActionsListWorkflowRunsParams
  ): Promise<github.ActionsListWorkflowRunsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}/runs`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'actor',
              'branch',
              'event',
              'status',
              'per_page',
              'page',
              'created',
              'exclude_pull_requests',
              'check_suite_id',
              'head_sha'
            )
          )
        }
      )
      .json<github.ActionsListWorkflowRunsResponse>()
  }

  /**
 * > [!WARNING]
> This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.

Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'actions_get_workflow_usage',
    description: `> [!WARNING]
> This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.

Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

You can replace \`workflow_id\` with the workflow file name. For example, you could use \`main.yaml\`.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ActionsGetWorkflowUsageParamsSchema
  })
  async actionsGetWorkflowUsage(
    params: github.ActionsGetWorkflowUsageParams
  ): Promise<github.ActionsGetWorkflowUsageResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/actions/workflows/${params.workflow_id}/timing`,
        {}
      )
      .json<github.ActionsGetWorkflowUsageResponse>()
  }

  /**
 * Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.

For more information about viewing repository activity,
see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository).".
 */
  @aiFunction({
    name: 'repos_list_activities',
    description: `Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.

For more information about viewing repository activity,
see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository).".`,
    inputSchema: github.ReposListActivitiesParamsSchema
  })
  async reposListActivities(
    params: github.ReposListActivitiesParams
  ): Promise<github.ReposListActivitiesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/activity`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'direction',
            'per_page',
            'before',
            'after',
            'ref',
            'actor',
            'time_period',
            'activity_type'
          )
        )
      })
      .json<github.ReposListActivitiesResponse>()
  }

  /**
   * Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
   */
  @aiFunction({
    name: 'issues_list_assignees',
    description: `Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.`,
    inputSchema: github.IssuesListAssigneesParamsSchema
  })
  async issuesListAssignees(
    params: github.IssuesListAssigneesParams
  ): Promise<github.IssuesListAssigneesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/assignees`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.IssuesListAssigneesResponse>()
  }

  /**
 * Checks if a user has permission to be assigned to an issue in this repository.

If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.

Otherwise a `404` status code is returned.
 */
  @aiFunction({
    name: 'issues_check_user_can_be_assigned',
    description: `Checks if a user has permission to be assigned to an issue in this repository.

If the \`assignee\` can be assigned to issues in the repository, a \`204\` header with no content is returned.

Otherwise a \`404\` status code is returned.`,
    inputSchema: github.IssuesCheckUserCanBeAssignedParamsSchema
  })
  async issuesCheckUserCanBeAssigned(
    params: github.IssuesCheckUserCanBeAssignedParams
  ): Promise<github.IssuesCheckUserCanBeAssignedResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/assignees/${params.assignee}`,
        {}
      )
      .json<github.IssuesCheckUserCanBeAssignedResponse>()
  }

  /**
 * Store an artifact attestation and associate it with a repository.

The authenticated user must have write permission to the repository and, if using a fine-grained access token, the `attestations:write` permission is required.

Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
 */
  @aiFunction({
    name: 'repos_create_attestation',
    description: `Store an artifact attestation and associate it with a repository.

The authenticated user must have write permission to the repository and, if using a fine-grained access token, the \`attestations:write\` permission is required.

Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).`,
    inputSchema: github.ReposCreateAttestationParamsSchema
  })
  async reposCreateAttestation(
    params: github.ReposCreateAttestationParams
  ): Promise<github.ReposCreateAttestationResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/attestations`, {
        json: pick(params, 'bundle')
      })
      .json<github.ReposCreateAttestationResponse>()
  }

  /**
 * List a collection of artifact attestations with a given subject digest that are associated with a repository.

The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the `attestations:read` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
 */
  @aiFunction({
    name: 'repos_list_attestations',
    description: `List a collection of artifact attestations with a given subject digest that are associated with a repository.

The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the \`attestations:read\` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI \`attestation verify\` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).`,
    inputSchema: github.ReposListAttestationsParamsSchema
  })
  async reposListAttestations(
    params: github.ReposListAttestationsParams
  ): Promise<github.ReposListAttestationsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/attestations/${params.subject_digest}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'before', 'after', 'predicate_type')
          )
        }
      )
      .json<github.ReposListAttestationsResponse>()
  }

  /**
 * Gets all autolinks that are configured for a repository.

Information about autolinks are only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_list_autolinks',
    description: `Gets all autolinks that are configured for a repository.

Information about autolinks are only available to repository administrators.`,
    inputSchema: github.ReposListAutolinksParamsSchema
  })
  async reposListAutolinks(
    params: github.ReposListAutolinksParams
  ): Promise<github.ReposListAutolinksResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/autolinks`, {})
      .json<github.ReposListAutolinksResponse>()
  }

  /**
   * Users with admin access to the repository can create an autolink.
   */
  @aiFunction({
    name: 'repos_create_autolink',
    description: `Users with admin access to the repository can create an autolink.`,
    inputSchema: github.ReposCreateAutolinkParamsSchema
  })
  async reposCreateAutolink(
    params: github.ReposCreateAutolinkParams
  ): Promise<github.ReposCreateAutolinkResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/autolinks`, {
        json: pick(params, 'key_prefix', 'url_template', 'is_alphanumeric')
      })
      .json<github.ReposCreateAutolinkResponse>()
  }

  /**
 * This returns a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_get_autolink',
    description: `This returns a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.`,
    inputSchema: github.ReposGetAutolinkParamsSchema
  })
  async reposGetAutolink(
    params: github.ReposGetAutolinkParams
  ): Promise<github.ReposGetAutolinkResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/autolinks/${params.autolink_id}`,
        {}
      )
      .json<github.ReposGetAutolinkResponse>()
  }

  /**
 * This deletes a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_delete_autolink',
    description: `This deletes a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.`,
    inputSchema: github.ReposDeleteAutolinkParamsSchema
  })
  async reposDeleteAutolink(
    params: github.ReposDeleteAutolinkParams
  ): Promise<github.ReposDeleteAutolinkResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/autolinks/${params.autolink_id}`,
        {}
      )
      .json<github.ReposDeleteAutolinkResponse>()
  }

  /**
   * Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
   */
  @aiFunction({
    name: 'repos_check_automated_security_fixes',
    description: `Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".`,
    inputSchema: github.ReposCheckAutomatedSecurityFixesParamsSchema
  })
  async reposCheckAutomatedSecurityFixes(
    params: github.ReposCheckAutomatedSecurityFixesParams
  ): Promise<github.ReposCheckAutomatedSecurityFixesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/automated-security-fixes`,
        {}
      )
      .json<github.ReposCheckAutomatedSecurityFixesResponse>()
  }

  /**
   * Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
   */
  @aiFunction({
    name: 'repos_enable_automated_security_fixes',
    description: `Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".`,
    inputSchema: github.ReposEnableAutomatedSecurityFixesParamsSchema
  })
  async reposEnableAutomatedSecurityFixes(
    params: github.ReposEnableAutomatedSecurityFixesParams
  ): Promise<github.ReposEnableAutomatedSecurityFixesResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/automated-security-fixes`,
        {}
      )
      .json<github.ReposEnableAutomatedSecurityFixesResponse>()
  }

  /**
   * Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
   */
  @aiFunction({
    name: 'repos_disable_automated_security_fixes',
    description: `Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".`,
    inputSchema: github.ReposDisableAutomatedSecurityFixesParamsSchema
  })
  async reposDisableAutomatedSecurityFixes(
    params: github.ReposDisableAutomatedSecurityFixesParams
  ): Promise<github.ReposDisableAutomatedSecurityFixesResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/automated-security-fixes`,
        {}
      )
      .json<github.ReposDisableAutomatedSecurityFixesResponse>()
  }

  /**
   * List branches.
   */
  @aiFunction({
    name: 'repos_list_branches',
    description: `List branches.`,
    inputSchema: github.ReposListBranchesParamsSchema
  })
  async reposListBranches(
    params: github.ReposListBranchesParams
  ): Promise<github.ReposListBranchesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/branches`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'protected', 'per_page', 'page')
        )
      })
      .json<github.ReposListBranchesResponse>()
  }

  /**
   * Get a branch.
   */
  @aiFunction({
    name: 'repos_get_branch',
    description: `Get a branch.`,
    inputSchema: github.ReposGetBranchParamsSchema
  })
  async reposGetBranch(
    params: github.ReposGetBranchParams
  ): Promise<github.ReposGetBranchResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}`,
        {}
      )
      .json<github.ReposGetBranchResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_get_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposGetBranchProtectionParamsSchema
  })
  async reposGetBranchProtection(
    params: github.ReposGetBranchProtectionParams
  ): Promise<github.ReposGetBranchProtectionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection`,
        {}
      )
      .json<github.ReposGetBranchProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Protecting a branch requires admin or owner permissions to the repository.

> [!NOTE]
> Passing new arrays of `users` and `teams` replaces their previous values.

> [!NOTE]
> The list of users, apps, and teams in total is limited to 100 items.
 */
  @aiFunction({
    name: 'repos_update_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Protecting a branch requires admin or owner permissions to the repository.

> [!NOTE]
> Passing new arrays of \`users\` and \`teams\` replaces their previous values.

> [!NOTE]
> The list of users, apps, and teams in total is limited to 100 items.`,
    inputSchema: github.ReposUpdateBranchProtectionParamsSchema
  })
  async reposUpdateBranchProtection(
    params: github.ReposUpdateBranchProtectionParams
  ): Promise<github.ReposUpdateBranchProtectionResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection`,
        {
          json: pick(
            params,
            'required_status_checks',
            'enforce_admins',
            'required_pull_request_reviews',
            'restrictions',
            'required_linear_history',
            'allow_force_pushes',
            'allow_deletions',
            'block_creations',
            'required_conversation_resolution',
            'lock_branch',
            'allow_fork_syncing'
          )
        }
      )
      .json<github.ReposUpdateBranchProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_delete_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposDeleteBranchProtectionParamsSchema
  })
  async reposDeleteBranchProtection(
    params: github.ReposDeleteBranchProtectionParams
  ): Promise<github.ReposDeleteBranchProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection`,
        {}
      )
      .json<github.ReposDeleteBranchProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_get_admin_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposGetAdminBranchProtectionParamsSchema
  })
  async reposGetAdminBranchProtection(
    params: github.ReposGetAdminBranchProtectionParams
  ): Promise<github.ReposGetAdminBranchProtectionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/enforce_admins`,
        {}
      )
      .json<github.ReposGetAdminBranchProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
 */
  @aiFunction({
    name: 'repos_set_admin_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.`,
    inputSchema: github.ReposSetAdminBranchProtectionParamsSchema
  })
  async reposSetAdminBranchProtection(
    params: github.ReposSetAdminBranchProtectionParams
  ): Promise<github.ReposSetAdminBranchProtectionResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/enforce_admins`,
        {}
      )
      .json<github.ReposSetAdminBranchProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
 */
  @aiFunction({
    name: 'repos_delete_admin_branch_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.`,
    inputSchema: github.ReposDeleteAdminBranchProtectionParamsSchema
  })
  async reposDeleteAdminBranchProtection(
    params: github.ReposDeleteAdminBranchProtectionParams
  ): Promise<github.ReposDeleteAdminBranchProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/enforce_admins`,
        {}
      )
      .json<github.ReposDeleteAdminBranchProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_get_pull_request_review_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposGetPullRequestReviewProtectionParamsSchema
  })
  async reposGetPullRequestReviewProtection(
    params: github.ReposGetPullRequestReviewProtectionParams
  ): Promise<github.ReposGetPullRequestReviewProtectionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_pull_request_reviews`,
        {}
      )
      .json<github.ReposGetPullRequestReviewProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_delete_pull_request_review_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposDeletePullRequestReviewProtectionParamsSchema
  })
  async reposDeletePullRequestReviewProtection(
    params: github.ReposDeletePullRequestReviewProtectionParams
  ): Promise<github.ReposDeletePullRequestReviewProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_pull_request_reviews`,
        {}
      )
      .json<github.ReposDeletePullRequestReviewProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.

> [!NOTE]
> Passing new arrays of `users` and `teams` replaces their previous values.
 */
  @aiFunction({
    name: 'repos_update_pull_request_review_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.

> [!NOTE]
> Passing new arrays of \`users\` and \`teams\` replaces their previous values.`,
    inputSchema: github.ReposUpdatePullRequestReviewProtectionParamsSchema
  })
  async reposUpdatePullRequestReviewProtection(
    params: github.ReposUpdatePullRequestReviewProtectionParams
  ): Promise<github.ReposUpdatePullRequestReviewProtectionResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_pull_request_reviews`,
        {
          json: pick(
            params,
            'dismissal_restrictions',
            'dismiss_stale_reviews',
            'require_code_owner_reviews',
            'required_approving_review_count',
            'require_last_push_approval',
            'bypass_pull_request_allowances'
          )
        }
      )
      .json<github.ReposUpdatePullRequestReviewProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.

> [!NOTE]
> You must enable branch protection to require signed commits.
 */
  @aiFunction({
    name: 'repos_get_commit_signature_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of \`true\` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.

> [!NOTE]
> You must enable branch protection to require signed commits.`,
    inputSchema: github.ReposGetCommitSignatureProtectionParamsSchema
  })
  async reposGetCommitSignatureProtection(
    params: github.ReposGetCommitSignatureProtectionParams
  ): Promise<github.ReposGetCommitSignatureProtectionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_signatures`,
        {}
      )
      .json<github.ReposGetCommitSignatureProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
 */
  @aiFunction({
    name: 'repos_create_commit_signature_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.`,
    inputSchema: github.ReposCreateCommitSignatureProtectionParamsSchema
  })
  async reposCreateCommitSignatureProtection(
    params: github.ReposCreateCommitSignatureProtectionParams
  ): Promise<github.ReposCreateCommitSignatureProtectionResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_signatures`,
        {}
      )
      .json<github.ReposCreateCommitSignatureProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
 */
  @aiFunction({
    name: 'repos_delete_commit_signature_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.`,
    inputSchema: github.ReposDeleteCommitSignatureProtectionParamsSchema
  })
  async reposDeleteCommitSignatureProtection(
    params: github.ReposDeleteCommitSignatureProtectionParams
  ): Promise<github.ReposDeleteCommitSignatureProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_signatures`,
        {}
      )
      .json<github.ReposDeleteCommitSignatureProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_get_status_checks_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposGetStatusChecksProtectionParamsSchema
  })
  async reposGetStatusChecksProtection(
    params: github.ReposGetStatusChecksProtectionParams
  ): Promise<github.ReposGetStatusChecksProtectionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks`,
        {}
      )
      .json<github.ReposGetStatusChecksProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_remove_status_check_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposRemoveStatusCheckProtectionParamsSchema
  })
  async reposRemoveStatusCheckProtection(
    params: github.ReposRemoveStatusCheckProtectionParams
  ): Promise<github.ReposRemoveStatusCheckProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks`,
        {}
      )
      .json<github.ReposRemoveStatusCheckProtectionResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
 */
  @aiFunction({
    name: 'repos_update_status_check_protection',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.`,
    inputSchema: github.ReposUpdateStatusCheckProtectionParamsSchema
  })
  async reposUpdateStatusCheckProtection(
    params: github.ReposUpdateStatusCheckProtectionParams
  ): Promise<github.ReposUpdateStatusCheckProtectionResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks`,
        {
          json: pick(params, 'strict', 'contexts', 'checks')
        }
      )
      .json<github.ReposUpdateStatusCheckProtectionResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_get_all_status_check_contexts',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    inputSchema: github.ReposGetAllStatusCheckContextsParamsSchema
  })
  async reposGetAllStatusCheckContexts(
    params: github.ReposGetAllStatusCheckContextsParams
  ): Promise<github.ReposGetAllStatusCheckContextsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks/contexts`,
        {}
      )
      .json<github.ReposGetAllStatusCheckContextsResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_add_status_check_contexts',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposAddStatusCheckContextsParamsSchema as any
  })
  async reposAddStatusCheckContexts(
    params: github.ReposAddStatusCheckContextsParams
  ): Promise<github.ReposAddStatusCheckContextsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks/contexts`,
        {
          json: params
        }
      )
      .json<github.ReposAddStatusCheckContextsResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_set_status_check_contexts',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposSetStatusCheckContextsParamsSchema as any
  })
  async reposSetStatusCheckContexts(
    params: github.ReposSetStatusCheckContextsParams
  ): Promise<github.ReposSetStatusCheckContextsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks/contexts`,
        {
          json: params
        }
      )
      .json<github.ReposSetStatusCheckContextsResponse>()
  }

  /**
   * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
   */
  @aiFunction({
    name: 'repos_remove_status_check_contexts',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposRemoveStatusCheckContextsParamsSchema as any
  })
  async reposRemoveStatusCheckContexts(
    params: github.ReposRemoveStatusCheckContextsParams
  ): Promise<github.ReposRemoveStatusCheckContextsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/required_status_checks/contexts`,
        {
          json: params
        }
      )
      .json<github.ReposRemoveStatusCheckContextsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists who has access to this protected branch.

> [!NOTE]
> Users, apps, and teams `restrictions` are only available for organization-owned repositories.
 */
  @aiFunction({
    name: 'repos_get_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists who has access to this protected branch.

> [!NOTE]
> Users, apps, and teams \`restrictions\` are only available for organization-owned repositories.`,
    inputSchema: github.ReposGetAccessRestrictionsParamsSchema
  })
  async reposGetAccessRestrictions(
    params: github.ReposGetAccessRestrictionsParams
  ): Promise<github.ReposGetAccessRestrictionsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions`,
        {}
      )
      .json<github.ReposGetAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Disables the ability to restrict who can push to this branch.
 */
  @aiFunction({
    name: 'repos_delete_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Disables the ability to restrict who can push to this branch.`,
    inputSchema: github.ReposDeleteAccessRestrictionsParamsSchema
  })
  async reposDeleteAccessRestrictions(
    params: github.ReposDeleteAccessRestrictionsParams
  ): Promise<github.ReposDeleteAccessRestrictionsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions`,
        {}
      )
      .json<github.ReposDeleteAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
 */
  @aiFunction({
    name: 'repos_get_apps_with_access_to_protected_branch',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.`,
    inputSchema: github.ReposGetAppsWithAccessToProtectedBranchParamsSchema
  })
  async reposGetAppsWithAccessToProtectedBranch(
    params: github.ReposGetAppsWithAccessToProtectedBranchParams
  ): Promise<github.ReposGetAppsWithAccessToProtectedBranchResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/apps`,
        {}
      )
      .json<github.ReposGetAppsWithAccessToProtectedBranchResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
 */
  @aiFunction({
    name: 'repos_add_app_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.`,
    inputSchema: github.ReposAddAppAccessRestrictionsParamsSchema
  })
  async reposAddAppAccessRestrictions(
    params: github.ReposAddAppAccessRestrictionsParams
  ): Promise<github.ReposAddAppAccessRestrictionsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/apps`,
        {
          json: pick(params, 'apps')
        }
      )
      .json<github.ReposAddAppAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
 */
  @aiFunction({
    name: 'repos_set_app_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.`,
    inputSchema: github.ReposSetAppAccessRestrictionsParamsSchema
  })
  async reposSetAppAccessRestrictions(
    params: github.ReposSetAppAccessRestrictionsParams
  ): Promise<github.ReposSetAppAccessRestrictionsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/apps`,
        {
          json: pick(params, 'apps')
        }
      )
      .json<github.ReposSetAppAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
 */
  @aiFunction({
    name: 'repos_remove_app_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.`,
    inputSchema: github.ReposRemoveAppAccessRestrictionsParamsSchema
  })
  async reposRemoveAppAccessRestrictions(
    params: github.ReposRemoveAppAccessRestrictionsParams
  ): Promise<github.ReposRemoveAppAccessRestrictionsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/apps`,
        {
          json: pick(params, 'apps')
        }
      )
      .json<github.ReposRemoveAppAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the teams who have push access to this branch. The list includes child teams.
 */
  @aiFunction({
    name: 'repos_get_teams_with_access_to_protected_branch',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the teams who have push access to this branch. The list includes child teams.`,
    inputSchema: github.ReposGetTeamsWithAccessToProtectedBranchParamsSchema
  })
  async reposGetTeamsWithAccessToProtectedBranch(
    params: github.ReposGetTeamsWithAccessToProtectedBranchParams
  ): Promise<github.ReposGetTeamsWithAccessToProtectedBranchResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/teams`,
        {}
      )
      .json<github.ReposGetTeamsWithAccessToProtectedBranchResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified teams push access for this branch. You can also give push access to child teams.
 */
  @aiFunction({
    name: 'repos_add_team_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified teams push access for this branch. You can also give push access to child teams.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposAddTeamAccessRestrictionsParamsSchema as any
  })
  async reposAddTeamAccessRestrictions(
    params: github.ReposAddTeamAccessRestrictionsParams
  ): Promise<github.ReposAddTeamAccessRestrictionsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/teams`,
        {
          json: params
        }
      )
      .json<github.ReposAddTeamAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
 */
  @aiFunction({
    name: 'repos_set_team_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposSetTeamAccessRestrictionsParamsSchema as any
  })
  async reposSetTeamAccessRestrictions(
    params: github.ReposSetTeamAccessRestrictionsParams
  ): Promise<github.ReposSetTeamAccessRestrictionsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/teams`,
        {
          json: params
        }
      )
      .json<github.ReposSetTeamAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a team to push to this branch. You can also remove push access for child teams.
 */
  @aiFunction({
    name: 'repos_remove_team_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a team to push to this branch. You can also remove push access for child teams.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposRemoveTeamAccessRestrictionsParamsSchema as any
  })
  async reposRemoveTeamAccessRestrictions(
    params: github.ReposRemoveTeamAccessRestrictionsParams
  ): Promise<github.ReposRemoveTeamAccessRestrictionsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/teams`,
        {
          json: params
        }
      )
      .json<github.ReposRemoveTeamAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the people who have push access to this branch.
 */
  @aiFunction({
    name: 'repos_get_users_with_access_to_protected_branch',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the people who have push access to this branch.`,
    inputSchema: github.ReposGetUsersWithAccessToProtectedBranchParamsSchema
  })
  async reposGetUsersWithAccessToProtectedBranch(
    params: github.ReposGetUsersWithAccessToProtectedBranchParams
  ): Promise<github.ReposGetUsersWithAccessToProtectedBranchResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/users`,
        {}
      )
      .json<github.ReposGetUsersWithAccessToProtectedBranchResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified people push access for this branch.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.
 */
  @aiFunction({
    name: 'repos_add_user_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified people push access for this branch.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| \`array\` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.`,
    inputSchema: github.ReposAddUserAccessRestrictionsParamsSchema
  })
  async reposAddUserAccessRestrictions(
    params: github.ReposAddUserAccessRestrictionsParams
  ): Promise<github.ReposAddUserAccessRestrictionsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/users`,
        {
          json: pick(params, 'users')
        }
      )
      .json<github.ReposAddUserAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.
 */
  @aiFunction({
    name: 'repos_set_user_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| \`array\` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.`,
    inputSchema: github.ReposSetUserAccessRestrictionsParamsSchema
  })
  async reposSetUserAccessRestrictions(
    params: github.ReposSetUserAccessRestrictionsParams
  ): Promise<github.ReposSetUserAccessRestrictionsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/users`,
        {
          json: pick(params, 'users')
        }
      )
      .json<github.ReposSetUserAccessRestrictionsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a user to push to this branch.

| Type    | Description                                                                                                                                   |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.
 */
  @aiFunction({
    name: 'repos_remove_user_access_restrictions',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a user to push to this branch.

| Type    | Description                                                                                                                                   |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| \`array\` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |.`,
    inputSchema: github.ReposRemoveUserAccessRestrictionsParamsSchema
  })
  async reposRemoveUserAccessRestrictions(
    params: github.ReposRemoveUserAccessRestrictionsParams
  ): Promise<github.ReposRemoveUserAccessRestrictionsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/protection/restrictions/users`,
        {
          json: pick(params, 'users')
        }
      )
      .json<github.ReposRemoveUserAccessRestrictionsResponse>()
  }

  /**
 * Renames a branch in a repository.

> [!NOTE]
> Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".

The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.

In order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission.
 */
  @aiFunction({
    name: 'repos_rename_branch',
    description: `Renames a branch in a repository.

> [!NOTE]
> Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".

The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.

In order to rename the default branch, fine-grained access tokens also need the \`administration:write\` repository permission.`,
    inputSchema: github.ReposRenameBranchParamsSchema
  })
  async reposRenameBranch(
    params: github.ReposRenameBranchParams
  ): Promise<github.ReposRenameBranchResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/branches/${params.branch}/rename`,
        {
          json: pick(params, 'new_name')
        }
      )
      .json<github.ReposRenameBranchResponse>()
  }

  /**
 * Creates a new check run for a specific commit in a repository.

To create a check run, you must use a GitHub App. OAuth apps and authenticated users are not able to create a check suite.

In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
 */
  @aiFunction({
    name: 'checks_create',
    description: `Creates a new check run for a specific commit in a repository.

To create a check run, you must use a GitHub App. OAuth apps and authenticated users are not able to create a check suite.

In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array.`,
    // TODO: Improve handling of union params
    inputSchema: github.ChecksCreateParamsSchema as any
  })
  async checksCreate(
    params: github.ChecksCreateParams
  ): Promise<github.ChecksCreateResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/check-runs`, {
        json: params
      })
      .json<github.ChecksCreateResponse>()
  }

  /**
 * Gets a single check run using its `id`.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_get',
    description: `Gets a single check run using its \`id\`.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksGetParamsSchema
  })
  async checksGet(
    params: github.ChecksGetParams
  ): Promise<github.ChecksGetResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/check-runs/${params.check_run_id}`,
        {}
      )
      .json<github.ChecksGetResponse>()
  }

  /**
 * Updates a check run for a specific commit in a repository.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

OAuth apps and personal access tokens (classic) cannot use this endpoint.
 */
  @aiFunction({
    name: 'checks_update',
    description: `Updates a check run for a specific commit in a repository.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array.

OAuth apps and personal access tokens (classic) cannot use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.ChecksUpdateParamsSchema as any
  })
  async checksUpdate(
    params: github.ChecksUpdateParams
  ): Promise<github.ChecksUpdateResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/check-runs/${params.check_run_id}`,
        {
          json: params
        }
      )
      .json<github.ChecksUpdateResponse>()
  }

  /**
 * Lists annotations for a check run using the annotation `id`.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_list_annotations',
    description: `Lists annotations for a check run using the annotation \`id\`.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksListAnnotationsParamsSchema
  })
  async checksListAnnotations(
    params: github.ChecksListAnnotationsParams
  ): Promise<github.ChecksListAnnotationsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/check-runs/${params.check_run_id}/annotations`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ChecksListAnnotationsResponse>()
  }

  /**
 * Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [`check_run` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) event with the action `rerequested`. When a check run is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.

For more information about how to re-run GitHub Actions jobs, see "[Re-run a job from a workflow run](https://docs.github.com/rest/actions/workflow-runs#re-run-a-job-from-a-workflow-run)".

OAuth apps and personal access tokens (classic) cannot use this endpoint.
 */
  @aiFunction({
    name: 'checks_rerequest_run',
    description: `Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [\`check_run\` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) event with the action \`rerequested\`. When a check run is \`rerequested\`, its \`status\` is reset to \`queued\` and the \`conclusion\` is cleared.

For more information about how to re-run GitHub Actions jobs, see "[Re-run a job from a workflow run](https://docs.github.com/rest/actions/workflow-runs#re-run-a-job-from-a-workflow-run)".

OAuth apps and personal access tokens (classic) cannot use this endpoint.`,
    inputSchema: github.ChecksRerequestRunParamsSchema
  })
  async checksRerequestRun(
    params: github.ChecksRerequestRunParams
  ): Promise<github.ChecksRerequestRunResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/check-runs/${params.check_run_id}/rerequest`,
        {}
      )
      .json<github.ChecksRerequestRunResponse>()
  }

  /**
 * Creates a check suite manually. By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/checks/runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/rest/checks/suites#update-repository-preferences-for-check-suites)".

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

OAuth apps and personal access tokens (classic) cannot use this endpoint.
 */
  @aiFunction({
    name: 'checks_create_suite',
    description: `Creates a check suite manually. By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/checks/runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/rest/checks/suites#update-repository-preferences-for-check-suites)".

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array and a \`null\` value for \`head_branch\`.

OAuth apps and personal access tokens (classic) cannot use this endpoint.`,
    inputSchema: github.ChecksCreateSuiteParamsSchema
  })
  async checksCreateSuite(
    params: github.ChecksCreateSuiteParams
  ): Promise<github.ChecksCreateSuiteResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/check-suites`, {
        json: pick(params, 'head_sha')
      })
      .json<github.ChecksCreateSuiteResponse>()
  }

  /**
 * Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/checks/suites#create-a-check-suite).
You must have admin permissions in the repository to set preferences for check suites.
 */
  @aiFunction({
    name: 'checks_set_suites_preferences',
    description: `Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/checks/suites#create-a-check-suite).
You must have admin permissions in the repository to set preferences for check suites.`,
    inputSchema: github.ChecksSetSuitesPreferencesParamsSchema
  })
  async checksSetSuitesPreferences(
    params: github.ChecksSetSuitesPreferencesParams
  ): Promise<github.ChecksSetSuitesPreferencesResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/check-suites/preferences`,
        {
          json: pick(params, 'auto_trigger_checks')
        }
      )
      .json<github.ChecksSetSuitesPreferencesResponse>()
  }

  /**
 * Gets a single check suite using its `id`.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_get_suite',
    description: `Gets a single check suite using its \`id\`.

> [!NOTE]
> The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array and a \`null\` value for \`head_branch\`.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksGetSuiteParamsSchema
  })
  async checksGetSuite(
    params: github.ChecksGetSuiteParams
  ): Promise<github.ChecksGetSuiteResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/check-suites/${params.check_suite_id}`,
        {}
      )
      .json<github.ChecksGetSuiteResponse>()
  }

  /**
 * Lists check runs for a check suite using its `id`.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_list_for_suite',
    description: `Lists check runs for a check suite using its \`id\`.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksListForSuiteParamsSchema
  })
  async checksListForSuite(
    params: github.ChecksListForSuiteParams
  ): Promise<github.ChecksListForSuiteResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/check-suites/${params.check_suite_id}/check-runs`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'check_name', 'status', 'filter', 'per_page', 'page')
          )
        }
      )
      .json<github.ChecksListForSuiteResponse>()
  }

  /**
 * Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.

OAuth apps and personal access tokens (classic) cannot use this endpoint.
 */
  @aiFunction({
    name: 'checks_rerequest_suite',
    description: `Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [\`check_suite\` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action \`rerequested\`. When a check suite is \`rerequested\`, its \`status\` is reset to \`queued\` and the \`conclusion\` is cleared.

OAuth apps and personal access tokens (classic) cannot use this endpoint.`,
    inputSchema: github.ChecksRerequestSuiteParamsSchema
  })
  async checksRerequestSuite(
    params: github.ChecksRerequestSuiteParams
  ): Promise<github.ChecksRerequestSuiteResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/check-suites/${params.check_suite_id}/rerequest`,
        {}
      )
      .json<github.ChecksRerequestSuiteResponse>()
  }

  /**
 * Lists code scanning alerts.

The response includes a `most_recent_instance` object.
This provides details of the most recent instance of this alert
for the default branch (or for the specified Git reference if you used `ref` in the request).

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_list_alerts_for_repo',
    description: `Lists code scanning alerts.

The response includes a \`most_recent_instance\` object.
This provides details of the most recent instance of this alert
for the default branch (or for the specified Git reference if you used \`ref\` in the request).

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningListAlertsForRepoParamsSchema
  })
  async codeScanningListAlertsForRepo(
    params: github.CodeScanningListAlertsForRepoParams
  ): Promise<github.CodeScanningListAlertsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/code-scanning/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'tool_name',
            'tool_guid',
            'page',
            'per_page',
            'ref',
            'pr',
            'direction',
            'before',
            'after',
            'sort',
            'state',
            'severity'
          )
        )
      })
      .json<github.CodeScanningListAlertsForRepoResponse>()
  }

  /**
 * Gets a single code scanning alert.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_alert',
    description: `Gets a single code scanning alert.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetAlertParamsSchema
  })
  async codeScanningGetAlert(
    params: github.CodeScanningGetAlertParams
  ): Promise<github.CodeScanningGetAlertResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}`,
        {}
      )
      .json<github.CodeScanningGetAlertResponse>()
  }

  /**
 * Updates the status of a single code scanning alert.
OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_update_alert',
    description: `Updates the status of a single code scanning alert.
OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningUpdateAlertParamsSchema
  })
  async codeScanningUpdateAlert(
    params: github.CodeScanningUpdateAlertParams
  ): Promise<github.CodeScanningUpdateAlertResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}`,
        {
          json: pick(
            params,
            'state',
            'dismissed_reason',
            'dismissed_comment',
            'create_request'
          )
        }
      )
      .json<github.CodeScanningUpdateAlertResponse>()
  }

  /**
 * Gets the status and description of an autofix for a code scanning alert.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_autofix',
    description: `Gets the status and description of an autofix for a code scanning alert.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetAutofixParamsSchema
  })
  async codeScanningGetAutofix(
    params: github.CodeScanningGetAutofixParams
  ): Promise<github.CodeScanningGetAutofixResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}/autofix`,
        {}
      )
      .json<github.CodeScanningGetAutofixResponse>()
  }

  /**
 * Creates an autofix for a code scanning alert.

If a new autofix is to be created as a result of this request or is currently being generated, then this endpoint will return a 202 Accepted response.

If an autofix already exists for a given alert, then this endpoint will return a 200 OK response.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_create_autofix',
    description: `Creates an autofix for a code scanning alert.

If a new autofix is to be created as a result of this request or is currently being generated, then this endpoint will return a 202 Accepted response.

If an autofix already exists for a given alert, then this endpoint will return a 200 OK response.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningCreateAutofixParamsSchema
  })
  async codeScanningCreateAutofix(
    params: github.CodeScanningCreateAutofixParams
  ): Promise<github.CodeScanningCreateAutofixResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}/autofix`,
        {}
      )
      .json<github.CodeScanningCreateAutofixResponse>()
  }

  /**
 * Commits an autofix for a code scanning alert.

If an autofix is committed as a result of this request, then this endpoint will return a 201 Created response.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_commit_autofix',
    description: `Commits an autofix for a code scanning alert.

If an autofix is committed as a result of this request, then this endpoint will return a 201 Created response.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningCommitAutofixParamsSchema
  })
  async codeScanningCommitAutofix(
    params: github.CodeScanningCommitAutofixParams
  ): Promise<github.CodeScanningCommitAutofixResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}/autofix/commits`,
        {
          json: pick(params, 'target_ref', 'message')
        }
      )
      .json<github.CodeScanningCommitAutofixResponse>()
  }

  /**
 * Lists all instances of the specified code scanning alert.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_list_alert_instances',
    description: `Lists all instances of the specified code scanning alert.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningListAlertInstancesParamsSchema
  })
  async codeScanningListAlertInstances(
    params: github.CodeScanningListAlertInstancesParams
  ): Promise<github.CodeScanningListAlertInstancesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/alerts/${params.alert_number}/instances`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'page', 'per_page', 'ref', 'pr')
          )
        }
      )
      .json<github.CodeScanningListAlertInstancesResponse>()
  }

  /**
 * Lists the details of all code scanning analyses for a repository,
starting with the most recent.
The response is paginated and you can use the `page` and `per_page` parameters
to list the analyses you're interested in.
By default 30 analyses are listed per page.

The `rules_count` field in the response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and `0` is returned in this field.

> [!WARNING]
> **Closing down notice:** The `tool_name` field is closing down and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_list_recent_analyses',
    description: `Lists the details of all code scanning analyses for a repository,
starting with the most recent.
The response is paginated and you can use the \`page\` and \`per_page\` parameters
to list the analyses you're interested in.
By default 30 analyses are listed per page.

The \`rules_count\` field in the response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and \`0\` is returned in this field.

> [!WARNING]
> **Closing down notice:** The \`tool_name\` field is closing down and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the \`tool\` field.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningListRecentAnalysesParamsSchema
  })
  async codeScanningListRecentAnalyses(
    params: github.CodeScanningListRecentAnalysesParams
  ): Promise<github.CodeScanningListRecentAnalysesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/analyses`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'tool_name',
              'tool_guid',
              'page',
              'per_page',
              'pr',
              'ref',
              'sarif_id',
              'direction',
              'sort'
            )
          )
        }
      )
      .json<github.CodeScanningListRecentAnalysesResponse>()
  }

  /**
 * Gets a specified code scanning analysis for a repository.

The default JSON response contains fields that describe the analysis.
This includes the Git reference and commit SHA to which the analysis relates,
the datetime of the analysis, the name of the code scanning tool,
and the number of alerts.

The `rules_count` field in the default response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and `0` is returned in this field.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/sarif+json`**: Instead of returning a summary of the analysis, this endpoint returns a subset of the analysis data that was uploaded. The data is formatted as [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html). It also returns additional data such as the `github/alertNumber` and `github/alertUrl` properties.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_analysis',
    description: `Gets a specified code scanning analysis for a repository.

The default JSON response contains fields that describe the analysis.
This includes the Git reference and commit SHA to which the analysis relates,
the datetime of the analysis, the name of the code scanning tool,
and the number of alerts.

The \`rules_count\` field in the default response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and \`0\` is returned in this field.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/sarif+json\`**: Instead of returning a summary of the analysis, this endpoint returns a subset of the analysis data that was uploaded. The data is formatted as [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html). It also returns additional data such as the \`github/alertNumber\` and \`github/alertUrl\` properties.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetAnalysisParamsSchema
  })
  async codeScanningGetAnalysis(
    params: github.CodeScanningGetAnalysisParams
  ): Promise<github.CodeScanningGetAnalysisResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/analyses/${params.analysis_id}`,
        {}
      )
      .json<github.CodeScanningGetAnalysisResponse>()
  }

  /**
 * Deletes a specified code scanning analysis from a repository.

You can delete one analysis at a time.
To delete a series of analyses, start with the most recent analysis and work backwards.
Conceptually, the process is similar to the undo function in a text editor.

When you list the analyses for a repository,
one or more will be identified as deletable in the response:

```
"deletable": true
```

An analysis is deletable when it's the most recent in a set of analyses.
Typically, a repository will have multiple sets of analyses
for each enabled code scanning tool,
where a set is determined by a unique combination of analysis values:

* `ref`
* `tool`
* `category`

If you attempt to delete an analysis that is not the most recent in a set,
you'll get a 400 response with the message:

```
Analysis specified is not deletable.
```

The response from a successful `DELETE` operation provides you with
two alternative URLs for deleting the next analysis in the set:
`next_analysis_url` and `confirm_delete_url`.
Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
in a set. This is a useful option if you want to preserve at least one analysis
for the specified tool in your repository.
Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
When you delete the last analysis in a set, the value of `next_analysis_url` and `confirm_delete_url`
in the 200 response is `null`.

As an example of the deletion process,
let's imagine that you added a workflow that configured a particular code scanning tool
to analyze the code in a repository. This tool has added 15 analyses:
10 on the default branch, and another 5 on a topic branch.
You therefore have two separate sets of analyses for this tool.
You've now decided that you want to remove all of the analyses for the tool.
To do this you must make 15 separate deletion requests.
To start, you must find an analysis that's identified as deletable.
Each set of analyses always has one that's identified as deletable.
Having found the deletable analysis for one of the two sets,
delete this analysis and then continue deleting the next analysis in the set until they're all deleted.
Then repeat the process for the second set.
The procedure therefore consists of a nested loop:

**Outer loop**:
* List the analyses for the repository, filtered by tool.
* Parse this list to find a deletable analysis. If found:

  **Inner loop**:
  * Delete the identified analysis.
  * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.

The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_delete_analysis',
    description: `Deletes a specified code scanning analysis from a repository.

You can delete one analysis at a time.
To delete a series of analyses, start with the most recent analysis and work backwards.
Conceptually, the process is similar to the undo function in a text editor.

When you list the analyses for a repository,
one or more will be identified as deletable in the response:

\`\`\`
"deletable": true
\`\`\`

An analysis is deletable when it's the most recent in a set of analyses.
Typically, a repository will have multiple sets of analyses
for each enabled code scanning tool,
where a set is determined by a unique combination of analysis values:

* \`ref\`
* \`tool\`
* \`category\`

If you attempt to delete an analysis that is not the most recent in a set,
you'll get a 400 response with the message:

\`\`\`
Analysis specified is not deletable.
\`\`\`

The response from a successful \`DELETE\` operation provides you with
two alternative URLs for deleting the next analysis in the set:
\`next_analysis_url\` and \`confirm_delete_url\`.
Use the \`next_analysis_url\` URL if you want to avoid accidentally deleting the final analysis
in a set. This is a useful option if you want to preserve at least one analysis
for the specified tool in your repository.
Use the \`confirm_delete_url\` URL if you are content to remove all analyses for a tool.
When you delete the last analysis in a set, the value of \`next_analysis_url\` and \`confirm_delete_url\`
in the 200 response is \`null\`.

As an example of the deletion process,
let's imagine that you added a workflow that configured a particular code scanning tool
to analyze the code in a repository. This tool has added 15 analyses:
10 on the default branch, and another 5 on a topic branch.
You therefore have two separate sets of analyses for this tool.
You've now decided that you want to remove all of the analyses for the tool.
To do this you must make 15 separate deletion requests.
To start, you must find an analysis that's identified as deletable.
Each set of analyses always has one that's identified as deletable.
Having found the deletable analysis for one of the two sets,
delete this analysis and then continue deleting the next analysis in the set until they're all deleted.
Then repeat the process for the second set.
The procedure therefore consists of a nested loop:

**Outer loop**:
* List the analyses for the repository, filtered by tool.
* Parse this list to find a deletable analysis. If found:

  **Inner loop**:
  * Delete the identified analysis.
  * Parse the response for the value of \`confirm_delete_url\` and, if found, use this in the next iteration.

The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the \`confirm_delete_url\` value. Alternatively, you could use the \`next_analysis_url\` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningDeleteAnalysisParamsSchema
  })
  async codeScanningDeleteAnalysis(
    params: github.CodeScanningDeleteAnalysisParams
  ): Promise<github.CodeScanningDeleteAnalysisResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/code-scanning/analyses/${params.analysis_id}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'confirm_delete'))
        }
      )
      .json<github.CodeScanningDeleteAnalysisResponse>()
  }

  /**
 * Lists the CodeQL databases that are available in a repository.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_list_codeql_databases',
    description: `Lists the CodeQL databases that are available in a repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningListCodeqlDatabasesParamsSchema
  })
  async codeScanningListCodeqlDatabases(
    params: github.CodeScanningListCodeqlDatabasesParams
  ): Promise<github.CodeScanningListCodeqlDatabasesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/databases`,
        {}
      )
      .json<github.CodeScanningListCodeqlDatabasesResponse>()
  }

  /**
 * Gets a CodeQL database for a language in a repository.

By default this endpoint returns JSON metadata about the CodeQL database. To
download the CodeQL database binary content, set the `Accept` header of the request
to [`application/zip`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types), and make sure
your HTTP client is configured to follow redirects or use the `Location` header
to make a second request to get the redirect URL.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_codeql_database',
    description: `Gets a CodeQL database for a language in a repository.

By default this endpoint returns JSON metadata about the CodeQL database. To
download the CodeQL database binary content, set the \`Accept\` header of the request
to [\`application/zip\`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types), and make sure
your HTTP client is configured to follow redirects or use the \`Location\` header
to make a second request to get the redirect URL.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetCodeqlDatabaseParamsSchema
  })
  async codeScanningGetCodeqlDatabase(
    params: github.CodeScanningGetCodeqlDatabaseParams
  ): Promise<github.CodeScanningGetCodeqlDatabaseResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/databases/${params.language}`,
        {}
      )
      .json<github.CodeScanningGetCodeqlDatabaseResponse>()
  }

  /**
 * Deletes a CodeQL database for a language in a repository.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_delete_codeql_database',
    description: `Deletes a CodeQL database for a language in a repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningDeleteCodeqlDatabaseParamsSchema
  })
  async codeScanningDeleteCodeqlDatabase(
    params: github.CodeScanningDeleteCodeqlDatabaseParams
  ): Promise<github.CodeScanningDeleteCodeqlDatabaseResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/databases/${params.language}`,
        {}
      )
      .json<github.CodeScanningDeleteCodeqlDatabaseResponse>()
  }

  /**
 * Creates a new CodeQL variant analysis, which will run a CodeQL query against one or more repositories.

Get started by learning more about [running CodeQL queries at scale with Multi-Repository Variant Analysis](https://docs.github.com/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries-at-scale-with-multi-repository-variant-analysis).

Use the `owner` and `repo` parameters in the URL to specify the controller repository that
will be used for running GitHub Actions workflows and storing the results of the CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_scanning_create_variant_analysis',
    description: `Creates a new CodeQL variant analysis, which will run a CodeQL query against one or more repositories.

Get started by learning more about [running CodeQL queries at scale with Multi-Repository Variant Analysis](https://docs.github.com/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries-at-scale-with-multi-repository-variant-analysis).

Use the \`owner\` and \`repo\` parameters in the URL to specify the controller repository that
will be used for running GitHub Actions workflows and storing the results of the CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.CodeScanningCreateVariantAnalysisParamsSchema as any
  })
  async codeScanningCreateVariantAnalysis(
    params: github.CodeScanningCreateVariantAnalysisParams
  ): Promise<github.CodeScanningCreateVariantAnalysisResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/variant-analyses`,
        {
          json: params
        }
      )
      .json<github.CodeScanningCreateVariantAnalysisResponse>()
  }

  /**
 * Gets the summary of a CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_variant_analysis',
    description: `Gets the summary of a CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetVariantAnalysisParamsSchema
  })
  async codeScanningGetVariantAnalysis(
    params: github.CodeScanningGetVariantAnalysisParams
  ): Promise<github.CodeScanningGetVariantAnalysisResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/variant-analyses/${params.codeql_variant_analysis_id}`,
        {}
      )
      .json<github.CodeScanningGetVariantAnalysisResponse>()
  }

  /**
 * Gets the analysis status of a repository in a CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_variant_analysis_repo_task',
    description: `Gets the analysis status of a repository in a CodeQL variant analysis.

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetVariantAnalysisRepoTaskParamsSchema
  })
  async codeScanningGetVariantAnalysisRepoTask(
    params: github.CodeScanningGetVariantAnalysisRepoTaskParams
  ): Promise<github.CodeScanningGetVariantAnalysisRepoTaskResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/codeql/variant-analyses/${params.codeql_variant_analysis_id}/repos/${params.repo_owner}/${params.repo_name}`,
        {}
      )
      .json<github.CodeScanningGetVariantAnalysisRepoTaskResponse>()
  }

  /**
 * Gets a code scanning default setup configuration.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_default_setup',
    description: `Gets a code scanning default setup configuration.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetDefaultSetupParamsSchema
  })
  async codeScanningGetDefaultSetup(
    params: github.CodeScanningGetDefaultSetupParams
  ): Promise<github.CodeScanningGetDefaultSetupResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/default-setup`,
        {}
      )
      .json<github.CodeScanningGetDefaultSetupResponse>()
  }

  /**
 * Updates a code scanning default setup configuration.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_update_default_setup',
    description: `Updates a code scanning default setup configuration.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningUpdateDefaultSetupParamsSchema
  })
  async codeScanningUpdateDefaultSetup(
    params: github.CodeScanningUpdateDefaultSetupParams
  ): Promise<github.CodeScanningUpdateDefaultSetupResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/code-scanning/default-setup`,
        {
          json: pick(
            params,
            'state',
            'runner_type',
            'runner_label',
            'query_suite',
            'languages'
          )
        }
      )
      .json<github.CodeScanningUpdateDefaultSetupResponse>()
  }

  /**
 * Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. For troubleshooting information, see "[Troubleshooting SARIF uploads](https://docs.github.com/code-security/code-scanning/troubleshooting-sarif)."

There are two places where you can upload code scanning results.
 - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
 - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."

You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:

```
gzip -c analysis-data.sarif | base64 -w0
```

SARIF upload supports a maximum number of entries per the following data objects, and an analysis will be rejected if any of these objects is above its maximum value. For some objects, there are additional values over which the entries will be ignored while keeping the most important entries whenever applicable.
To get the most out of your analysis when it includes data above the supported limits, try to optimize the analysis configuration. For example, for the CodeQL tool, identify and remove the most noisy queries. For more information, see "[SARIF results exceed one or more limits](https://docs.github.com/code-security/code-scanning/troubleshooting-sarif/results-exceed-limit)."


| **SARIF data**                   | **Maximum values** | **Additional limits**                                                            |
|----------------------------------|:------------------:|----------------------------------------------------------------------------------|
| Runs per file                    |         20         |                                                                                  |
| Results per run                  |       25,000       | Only the top 5,000 results will be included, prioritized by severity.            |
| Rules per run                    |       25,000       |                                                                                  |
| Tool extensions per run          |        100         |                                                                                  |
| Thread Flow Locations per result |       10,000       | Only the top 1,000 Thread Flow Locations will be included, using prioritization. |
| Location per result	             |       1,000        | Only 100 locations will be included.                                             |
| Tags per rule	                   |         20         | Only 10 tags will be included.                                                   |


The `202 Accepted` response includes an `id` value.
You can use this ID to check the status of the upload by using it in the `/sarifs/{sarif_id}` endpoint.
For more information, see "[Get information about a SARIF upload](/rest/code-scanning/code-scanning#get-information-about-a-sarif-upload)."

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.

This endpoint is limited to 1,000 requests per hour for each user or app installation calling it.
 */
  @aiFunction({
    name: 'code_scanning_upload_sarif',
    description: `Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. For troubleshooting information, see "[Troubleshooting SARIF uploads](https://docs.github.com/code-security/code-scanning/troubleshooting-sarif)."

There are two places where you can upload code scanning results.
 - If you upload to a pull request, for example \`--ref refs/pull/42/merge\` or \`--ref refs/pull/42/head\`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
 - If you upload to a branch, for example \`--ref refs/heads/my-branch\`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."

You must compress the SARIF-formatted analysis data that you want to upload, using \`gzip\`, and then encode it as a Base64 format string. For example:

\`\`\`
gzip -c analysis-data.sarif | base64 -w0
\`\`\`

SARIF upload supports a maximum number of entries per the following data objects, and an analysis will be rejected if any of these objects is above its maximum value. For some objects, there are additional values over which the entries will be ignored while keeping the most important entries whenever applicable.
To get the most out of your analysis when it includes data above the supported limits, try to optimize the analysis configuration. For example, for the CodeQL tool, identify and remove the most noisy queries. For more information, see "[SARIF results exceed one or more limits](https://docs.github.com/code-security/code-scanning/troubleshooting-sarif/results-exceed-limit)."


| **SARIF data**                   | **Maximum values** | **Additional limits**                                                            |
|----------------------------------|:------------------:|----------------------------------------------------------------------------------|
| Runs per file                    |         20         |                                                                                  |
| Results per run                  |       25,000       | Only the top 5,000 results will be included, prioritized by severity.            |
| Rules per run                    |       25,000       |                                                                                  |
| Tool extensions per run          |        100         |                                                                                  |
| Thread Flow Locations per result |       10,000       | Only the top 1,000 Thread Flow Locations will be included, using prioritization. |
| Location per result	             |       1,000        | Only 100 locations will be included.                                             |
| Tags per rule	                   |         20         | Only 10 tags will be included.                                                   |


The \`202 Accepted\` response includes an \`id\` value.
You can use this ID to check the status of the upload by using it in the \`/sarifs/{sarif_id}\` endpoint.
For more information, see "[Get information about a SARIF upload](/rest/code-scanning/code-scanning#get-information-about-a-sarif-upload)."

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.

This endpoint is limited to 1,000 requests per hour for each user or app installation calling it.`,
    inputSchema: github.CodeScanningUploadSarifParamsSchema
  })
  async codeScanningUploadSarif(
    params: github.CodeScanningUploadSarifParams
  ): Promise<github.CodeScanningUploadSarifResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/code-scanning/sarifs`,
        {
          json: pick(
            params,
            'commit_sha',
            'ref',
            'sarif',
            'checkout_uri',
            'started_at',
            'tool_name',
            'validate'
          )
        }
      )
      .json<github.CodeScanningUploadSarifResponse>()
  }

  /**
 * Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/code-scanning/code-scanning#get-a-code-scanning-analysis-for-a-repository)."
OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories.
 */
  @aiFunction({
    name: 'code_scanning_get_sarif',
    description: `Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/code-scanning/code-scanning#get-a-code-scanning-analysis-for-a-repository)."
OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint with private or public repositories, or the \`public_repo\` scope to use this endpoint with only public repositories.`,
    inputSchema: github.CodeScanningGetSarifParamsSchema
  })
  async codeScanningGetSarif(
    params: github.CodeScanningGetSarifParams
  ): Promise<github.CodeScanningGetSarifResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-scanning/sarifs/${params.sarif_id}`,
        {}
      )
      .json<github.CodeScanningGetSarifResponse>()
  }

  /**
 * Get the code security configuration that manages a repository's code security settings.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'code_security_get_configuration_for_repository',
    description: `Get the code security configuration that manages a repository's code security settings.

The authenticated user must be an administrator or security manager for the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.CodeSecurityGetConfigurationForRepositoryParamsSchema
  })
  async codeSecurityGetConfigurationForRepository(
    params: github.CodeSecurityGetConfigurationForRepositoryParams
  ): Promise<github.CodeSecurityGetConfigurationForRepositoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/code-security-configuration`,
        {}
      )
      .json<github.CodeSecurityGetConfigurationForRepositoryResponse>()
  }

  /**
 * List any syntax errors that are detected in the CODEOWNERS
file.

For more information about the correct CODEOWNERS syntax,
see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).".
 */
  @aiFunction({
    name: 'repos_codeowners_errors',
    description: `List any syntax errors that are detected in the CODEOWNERS
file.

For more information about the correct CODEOWNERS syntax,
see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).".`,
    inputSchema: github.ReposCodeownersErrorsParamsSchema
  })
  async reposCodeownersErrors(
    params: github.ReposCodeownersErrorsParams
  ): Promise<github.ReposCodeownersErrorsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/codeowners/errors`, {
        searchParams: sanitizeSearchParams(pick(params, 'ref'))
      })
      .json<github.ReposCodeownersErrorsResponse>()
  }

  /**
 * Lists the codespaces associated to a specified repository and the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_in_repository_for_authenticated_user',
    description: `Lists the codespaces associated to a specified repository and the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesListInRepositoryForAuthenticatedUserParamsSchema
  })
  async codespacesListInRepositoryForAuthenticatedUser(
    params: github.CodespacesListInRepositoryForAuthenticatedUserParams
  ): Promise<github.CodespacesListInRepositoryForAuthenticatedUserResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/codespaces`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesListInRepositoryForAuthenticatedUserResponse>()
  }

  /**
 * Creates a codespace owned by the authenticated user in the specified repository.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_create_with_repo_for_authenticated_user',
    description: `Creates a codespace owned by the authenticated user in the specified repository.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesCreateWithRepoForAuthenticatedUserParamsSchema
  })
  async codespacesCreateWithRepoForAuthenticatedUser(
    params: github.CodespacesCreateWithRepoForAuthenticatedUserParams
  ): Promise<github.CodespacesCreateWithRepoForAuthenticatedUserResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/codespaces`, {
        json: pick(
          params,
          'ref',
          'location',
          'geo',
          'client_ip',
          'machine',
          'devcontainer_path',
          'multi_repo_permissions_opt_out',
          'working_directory',
          'idle_timeout_minutes',
          'display_name',
          'retention_period_minutes'
        )
      })
      .json<github.CodespacesCreateWithRepoForAuthenticatedUserResponse>()
  }

  /**
 * Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files
specify launchpoint configurations for codespaces created within the repository.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_devcontainers_in_repository_for_authenticated_user',
    description: `Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files
specify launchpoint configurations for codespaces created within the repository.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamsSchema
  })
  async codespacesListDevcontainersInRepositoryForAuthenticatedUser(
    params: github.CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams
  ): Promise<github.CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/codespaces/devcontainers`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse>()
  }

  /**
 * List the machine types available for a given repository based on its configuration.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_repo_machines_for_authenticated_user',
    description: `List the machine types available for a given repository based on its configuration.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesRepoMachinesForAuthenticatedUserParamsSchema
  })
  async codespacesRepoMachinesForAuthenticatedUser(
    params: github.CodespacesRepoMachinesForAuthenticatedUserParams
  ): Promise<github.CodespacesRepoMachinesForAuthenticatedUserResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/codespaces/machines`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'location', 'client_ip', 'ref')
        )
      })
      .json<github.CodespacesRepoMachinesForAuthenticatedUserResponse>()
  }

  /**
 * Gets the default attributes for codespaces created by the user with the repository.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_pre_flight_with_repo_for_authenticated_user',
    description: `Gets the default attributes for codespaces created by the user with the repository.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesPreFlightWithRepoForAuthenticatedUserParamsSchema
  })
  async codespacesPreFlightWithRepoForAuthenticatedUser(
    params: github.CodespacesPreFlightWithRepoForAuthenticatedUserParams
  ): Promise<github.CodespacesPreFlightWithRepoForAuthenticatedUserResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/codespaces/new`, {
        searchParams: sanitizeSearchParams(pick(params, 'ref', 'client_ip'))
      })
      .json<github.CodespacesPreFlightWithRepoForAuthenticatedUserResponse>()
  }

  /**
 * Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_check_permissions_for_devcontainer',
    description: `Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesCheckPermissionsForDevcontainerParamsSchema
  })
  async codespacesCheckPermissionsForDevcontainer(
    params: github.CodespacesCheckPermissionsForDevcontainerParams
  ): Promise<github.CodespacesCheckPermissionsForDevcontainerResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/codespaces/permissions_check`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'ref', 'devcontainer_path')
          )
        }
      )
      .json<github.CodespacesCheckPermissionsForDevcontainerResponse>()
  }

  /**
 * Lists all development environment secrets available in a repository without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_repo_secrets',
    description: `Lists all development environment secrets available in a repository without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListRepoSecretsParamsSchema
  })
  async codespacesListRepoSecrets(
    params: github.CodespacesListRepoSecretsParams
  ): Promise<github.CodespacesListRepoSecretsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/codespaces/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesListRepoSecretsResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

If the repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_repo_public_key',
    description: `Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets.

If the repository is private, OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetRepoPublicKeyParamsSchema
  })
  async codespacesGetRepoPublicKey(
    params: github.CodespacesGetRepoPublicKeyParams
  ): Promise<github.CodespacesGetRepoPublicKeyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/codespaces/secrets/public-key`,
        {}
      )
      .json<github.CodespacesGetRepoPublicKeyResponse>()
  }

  /**
 * Gets a single repository development environment secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_repo_secret',
    description: `Gets a single repository development environment secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetRepoSecretParamsSchema
  })
  async codespacesGetRepoSecret(
    params: github.CodespacesGetRepoSecretParams
  ): Promise<github.CodespacesGetRepoSecretResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/codespaces/secrets/${params.secret_name}`,
        {}
      )
      .json<github.CodespacesGetRepoSecretResponse>()
  }

  /**
 * Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The associated user must be a repository admin.
 */
  @aiFunction({
    name: 'codespaces_create_or_update_repo_secret',
    description: `Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint. The associated user must be a repository admin.`,
    inputSchema: github.CodespacesCreateOrUpdateRepoSecretParamsSchema
  })
  async codespacesCreateOrUpdateRepoSecret(
    params: github.CodespacesCreateOrUpdateRepoSecretParams
  ): Promise<github.CodespacesCreateOrUpdateRepoSecretResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/codespaces/secrets/${params.secret_name}`,
        {
          json: pick(params, 'encrypted_value', 'key_id')
        }
      )
      .json<github.CodespacesCreateOrUpdateRepoSecretResponse>()
  }

  /**
 * Deletes a development environment secret in a repository using the secret name.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The associated user must be a repository admin.
 */
  @aiFunction({
    name: 'codespaces_delete_repo_secret',
    description: `Deletes a development environment secret in a repository using the secret name.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint. The associated user must be a repository admin.`,
    inputSchema: github.CodespacesDeleteRepoSecretParamsSchema
  })
  async codespacesDeleteRepoSecret(
    params: github.CodespacesDeleteRepoSecretParams
  ): Promise<github.CodespacesDeleteRepoSecretResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/codespaces/secrets/${params.secret_name}`,
        {}
      )
      .json<github.CodespacesDeleteRepoSecretResponse>()
  }

  /**
 * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
Organization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.

Team members will include the members of child teams.

The authenticated user must have push access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'repos_list_collaborators',
    description: `For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
Organization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.

Team members will include the members of child teams.

The authenticated user must have push access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:org\` and \`repo\` scopes to use this endpoint.`,
    inputSchema: github.ReposListCollaboratorsParamsSchema
  })
  async reposListCollaborators(
    params: github.ReposListCollaboratorsParams
  ): Promise<github.ReposListCollaboratorsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/collaborators`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'affiliation', 'permission', 'per_page', 'page')
        )
      })
      .json<github.ReposListCollaboratorsResponse>()
  }

  /**
 * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.

Team members will include the members of child teams.

The authenticated user must have push access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
 */
  @aiFunction({
    name: 'repos_check_collaborator',
    description: `For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.

Team members will include the members of child teams.

The authenticated user must have push access to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:org\` and \`repo\` scopes to use this endpoint.`,
    inputSchema: github.ReposCheckCollaboratorParamsSchema
  })
  async reposCheckCollaborator(
    params: github.ReposCheckCollaboratorParams
  ): Promise<github.ReposCheckCollaboratorResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/collaborators/${params.username}`,
        {}
      )
      .json<github.ReposCheckCollaboratorResponse>()
  }

  /**
 * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."

For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:

```
Cannot assign {member} permission of {role name}
```

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).

**Updating an existing collaborator's permission level**

The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.

**Rate limits**

You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
 */
  @aiFunction({
    name: 'repos_add_collaborator',
    description: `This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."

For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:

\`\`\`
Cannot assign {member} permission of {role name}
\`\`\`

Note that, if you choose not to pass any parameters, you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).

**Updating an existing collaborator's permission level**

The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different \`permission\` parameter. The response will be a \`204\`, with no other indication that the permission level changed.

**Rate limits**

You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.`,
    inputSchema: github.ReposAddCollaboratorParamsSchema
  })
  async reposAddCollaborator(
    params: github.ReposAddCollaboratorParams
  ): Promise<github.ReposAddCollaboratorResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/collaborators/${params.username}`,
        {
          json: pick(params, 'permission')
        }
      )
      .json<github.ReposAddCollaboratorResponse>()
  }

  /**
 * Removes a collaborator from a repository.

To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.

This endpoint also:
- Cancels any outstanding invitations
- Unasigns the user from any issues
- Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
- Unstars the repository
- Updates access permissions to packages

Removing a user as a collaborator has the following effects on forks:
 - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
 - If the user had their own fork of the repository, the fork will be deleted.
 - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.

> [!NOTE]
> A user can still have access to the repository through organization permissions like base repository permissions.

Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.

For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
 */
  @aiFunction({
    name: 'repos_remove_collaborator',
    description: `Removes a collaborator from a repository.

To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.

This endpoint also:
- Cancels any outstanding invitations
- Unasigns the user from any issues
- Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
- Unstars the repository
- Updates access permissions to packages

Removing a user as a collaborator has the following effects on forks:
 - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
 - If the user had their own fork of the repository, the fork will be deleted.
 - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.

> [!NOTE]
> A user can still have access to the repository through organization permissions like base repository permissions.

Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.

For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".`,
    inputSchema: github.ReposRemoveCollaboratorParamsSchema
  })
  async reposRemoveCollaborator(
    params: github.ReposRemoveCollaboratorParams
  ): Promise<github.ReposRemoveCollaboratorResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/collaborators/${params.username}`,
        {}
      )
      .json<github.ReposRemoveCollaboratorResponse>()
  }

  /**
 * Checks the repository permission of a collaborator. The possible repository
permissions are `admin`, `write`, `read`, and `none`.

*Note*: The `permission` attribute provides the legacy base roles of `admin`, `write`, `read`, and `none`, where the
`maintain` role is mapped to `write` and the `triage` role is mapped to `read`. To determine the role assigned to the
collaborator, see the `role_name` attribute, which will provide the full role name, including custom roles. The
`permissions` hash can also be used to determine which base level of access the collaborator has to the repository.
 */
  @aiFunction({
    name: 'repos_get_collaborator_permission_level',
    description: `Checks the repository permission of a collaborator. The possible repository
permissions are \`admin\`, \`write\`, \`read\`, and \`none\`.

*Note*: The \`permission\` attribute provides the legacy base roles of \`admin\`, \`write\`, \`read\`, and \`none\`, where the
\`maintain\` role is mapped to \`write\` and the \`triage\` role is mapped to \`read\`. To determine the role assigned to the
collaborator, see the \`role_name\` attribute, which will provide the full role name, including custom roles. The
\`permissions\` hash can also be used to determine which base level of access the collaborator has to the repository.`,
    inputSchema: github.ReposGetCollaboratorPermissionLevelParamsSchema
  })
  async reposGetCollaboratorPermissionLevel(
    params: github.ReposGetCollaboratorPermissionLevelParams
  ): Promise<github.ReposGetCollaboratorPermissionLevelResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/collaborators/${params.username}/permission`,
        {}
      )
      .json<github.ReposGetCollaboratorPermissionLevelResponse>()
  }

  /**
 * Lists the commit comments for a specified repository. Comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'repos_list_commit_comments_for_repo',
    description: `Lists the commit comments for a specified repository. Comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.ReposListCommitCommentsForRepoParamsSchema
  })
  async reposListCommitCommentsForRepo(
    params: github.ReposListCommitCommentsForRepoParams
  ): Promise<github.ReposListCommitCommentsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/comments`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListCommitCommentsForRepoResponse>()
  }

  /**
 * Gets a specified commit comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'repos_get_commit_comment',
    description: `Gets a specified commit comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.ReposGetCommitCommentParamsSchema
  })
  async reposGetCommitComment(
    params: github.ReposGetCommitCommentParams
  ): Promise<github.ReposGetCommitCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}`,
        {}
      )
      .json<github.ReposGetCommitCommentResponse>()
  }

  /**
   * Delete a commit comment.
   */
  @aiFunction({
    name: 'repos_delete_commit_comment',
    description: `Delete a commit comment.`,
    inputSchema: github.ReposDeleteCommitCommentParamsSchema
  })
  async reposDeleteCommitComment(
    params: github.ReposDeleteCommitCommentParams
  ): Promise<github.ReposDeleteCommitCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}`,
        {}
      )
      .json<github.ReposDeleteCommitCommentResponse>()
  }

  /**
 * Updates the contents of a specified commit comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'repos_update_commit_comment',
    description: `Updates the contents of a specified commit comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.ReposUpdateCommitCommentParamsSchema
  })
  async reposUpdateCommitComment(
    params: github.ReposUpdateCommitCommentParams
  ): Promise<github.ReposUpdateCommitCommentResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.ReposUpdateCommitCommentResponse>()
  }

  /**
   * List the reactions to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
   */
  @aiFunction({
    name: 'reactions_list_for_commit_comment',
    description: `List the reactions to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).`,
    inputSchema: github.ReactionsListForCommitCommentParamsSchema
  })
  async reactionsListForCommitComment(
    params: github.ReactionsListForCommitCommentParams
  ): Promise<github.ReactionsListForCommitCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForCommitCommentResponse>()
  }

  /**
   * Create a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
   */
  @aiFunction({
    name: 'reactions_create_for_commit_comment',
    description: `Create a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment). A response with an HTTP \`200\` status means that you already added the reaction type to this commit comment.`,
    inputSchema: github.ReactionsCreateForCommitCommentParamsSchema
  })
  async reactionsCreateForCommitComment(
    params: github.ReactionsCreateForCommitCommentParams
  ): Promise<github.ReactionsCreateForCommitCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForCommitCommentResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
 */
  @aiFunction({
    name: 'reactions_delete_for_commit_comment',
    description: `> [!NOTE]
> You can also specify a repository by \`repository_id\` using the route \`DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id\`.

Delete a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).`,
    inputSchema: github.ReactionsDeleteForCommitCommentParamsSchema
  })
  async reactionsDeleteForCommitComment(
    params: github.ReactionsDeleteForCommitCommentParams
  ): Promise<github.ReactionsDeleteForCommitCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/comments/${params.comment_id}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForCommitCommentResponse>()
  }

  /**
 * **Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'repos_list_commits',
    description: `**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.ReposListCommitsParamsSchema
  })
  async reposListCommits(
    params: github.ReposListCommitsParams
  ): Promise<github.ReposListCommitsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/commits`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'sha',
            'path',
            'author',
            'committer',
            'since',
            'until',
            'per_page',
            'page'
          )
        )
      })
      .json<github.ReposListCommitsResponse>()
  }

  /**
 * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
 */
  @aiFunction({
    name: 'repos_list_branches_for_head_commit',
    description: `Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.`,
    inputSchema: github.ReposListBranchesForHeadCommitParamsSchema
  })
  async reposListBranchesForHeadCommit(
    params: github.ReposListBranchesForHeadCommitParams
  ): Promise<github.ReposListBranchesForHeadCommitResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.commit_sha}/branches-where-head`,
        {}
      )
      .json<github.ReposListBranchesForHeadCommitResponse>()
  }

  /**
 * Lists the comments for a specified commit.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'repos_list_comments_for_commit',
    description: `Lists the comments for a specified commit.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.ReposListCommentsForCommitParamsSchema
  })
  async reposListCommentsForCommit(
    params: github.ReposListCommentsForCommitParams
  ): Promise<github.ReposListCommentsForCommitResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.commit_sha}/comments`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListCommentsForCommitResponse>()
  }

  /**
 * Create a comment for a commit using its `:commit_sha`.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'repos_create_commit_comment',
    description: `Create a comment for a commit using its \`:commit_sha\`.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.ReposCreateCommitCommentParamsSchema
  })
  async reposCreateCommitComment(
    params: github.ReposCreateCommitCommentParams
  ): Promise<github.ReposCreateCommitCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/commits/${params.commit_sha}/comments`,
        {
          json: pick(params, 'body', 'path', 'position', 'line')
        }
      )
      .json<github.ReposCreateCommitCommentResponse>()
  }

  /**
 * Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.

To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
 */
  @aiFunction({
    name: 'repos_list_pull_requests_associated_with_commit',
    description: `Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.

To list the open or merged pull requests associated with a branch, you can set the \`commit_sha\` parameter to the branch name.`,
    inputSchema: github.ReposListPullRequestsAssociatedWithCommitParamsSchema
  })
  async reposListPullRequestsAssociatedWithCommit(
    params: github.ReposListPullRequestsAssociatedWithCommitParams
  ): Promise<github.ReposListPullRequestsAssociatedWithCommitResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.commit_sha}/pulls`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListPullRequestsAssociatedWithCommitResponse>()
  }

  /**
 * Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.

> [!NOTE]
> If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.

- **`application/vnd.github.diff`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
- **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property. Larger diffs may time out and return a 5xx status code.
- **`application/vnd.github.sha`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'repos_get_commit',
    description: `Returns the contents of a single commit reference. You must have \`read\` access for the repository to use this endpoint.

> [!NOTE]
> If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.

- **\`application/vnd.github.diff\`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
- **\`application/vnd.github.patch\`**: Returns the patch of the commit. Diffs with binary data will have no \`patch\` property. Larger diffs may time out and return a 5xx status code.
- **\`application/vnd.github.sha\`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.

**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.ReposGetCommitParamsSchema
  })
  async reposGetCommit(
    params: github.ReposGetCommitParams
  ): Promise<github.ReposGetCommitResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.ref}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ReposGetCommitResponse>()
  }

  /**
 * Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

If there are more than 1000 check suites on a single git reference, this endpoint will limit check runs to the 1000 most recent check suites. To iterate over all possible check runs, use the [List check suites for a Git reference](https://docs.github.com/rest/reference/checks#list-check-suites-for-a-git-reference) endpoint and provide the `check_suite_id` parameter to the [List check runs in a check suite](https://docs.github.com/rest/reference/checks#list-check-runs-in-a-check-suite) endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_list_for_ref',
    description: `Lists check runs for a commit ref. The \`ref\` can be a SHA, branch name, or a tag name.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array.

If there are more than 1000 check suites on a single git reference, this endpoint will limit check runs to the 1000 most recent check suites. To iterate over all possible check runs, use the [List check suites for a Git reference](https://docs.github.com/rest/reference/checks#list-check-suites-for-a-git-reference) endpoint and provide the \`check_suite_id\` parameter to the [List check runs in a check suite](https://docs.github.com/rest/reference/checks#list-check-runs-in-a-check-suite) endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksListForRefParamsSchema
  })
  async checksListForRef(
    params: github.ChecksListForRefParams
  ): Promise<github.ChecksListForRefResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.ref}/check-runs`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'check_name',
              'status',
              'filter',
              'per_page',
              'page',
              'app_id'
            )
          )
        }
      )
      .json<github.ChecksListForRefResponse>()
  }

  /**
 * Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
 */
  @aiFunction({
    name: 'checks_list_suites_for_ref',
    description: `Lists check suites for a commit \`ref\`. The \`ref\` can be a SHA, branch name, or a tag name.

> [!NOTE]
> The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty \`pull_requests\` array and a \`null\` value for \`head_branch\`.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint on a private repository.`,
    inputSchema: github.ChecksListSuitesForRefParamsSchema
  })
  async checksListSuitesForRef(
    params: github.ChecksListSuitesForRefParams
  ): Promise<github.ChecksListSuitesForRefResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.ref}/check-suites`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'app_id', 'check_name', 'per_page', 'page')
          )
        }
      )
      .json<github.ChecksListSuitesForRefResponse>()
  }

  /**
 * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.


Additionally, a combined `state` is returned. The `state` is one of:

*   **failure** if any of the contexts report as `error` or `failure`
*   **pending** if there are no statuses or a context is `pending`
*   **success** if the latest status for all contexts is `success`.
 */
  @aiFunction({
    name: 'repos_get_combined_status_for_ref',
    description: `Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.


Additionally, a combined \`state\` is returned. The \`state\` is one of:

*   **failure** if any of the contexts report as \`error\` or \`failure\`
*   **pending** if there are no statuses or a context is \`pending\`
*   **success** if the latest status for all contexts is \`success\`.`,
    inputSchema: github.ReposGetCombinedStatusForRefParamsSchema
  })
  async reposGetCombinedStatusForRef(
    params: github.ReposGetCombinedStatusForRefParams
  ): Promise<github.ReposGetCombinedStatusForRefResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.ref}/status`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposGetCombinedStatusForRefResponse>()
  }

  /**
 * Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.

This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
 */
  @aiFunction({
    name: 'repos_list_commit_statuses_for_ref',
    description: `Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.

This resource is also available via a legacy route: \`GET /repos/:owner/:repo/statuses/:ref\`.`,
    inputSchema: github.ReposListCommitStatusesForRefParamsSchema
  })
  async reposListCommitStatusesForRef(
    params: github.ReposListCommitStatusesForRefParams
  ): Promise<github.ReposListCommitStatusesForRefResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/commits/${params.ref}/statuses`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListCommitStatusesForRefResponse>()
  }

  /**
 * Returns all community profile metrics for a repository. The repository cannot be a fork.

The returned metrics include an overall health score, the repository description, the presence of documentation, the
detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
README, and CONTRIBUTING files.

The `health_percentage` score is defined as a percentage of how many of
the recommended community health files are present. For more information, see
"[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."

`content_reports_enabled` is only returned for organization-owned repositories.
 */
  @aiFunction({
    name: 'repos_get_community_profile_metrics',
    description: `Returns all community profile metrics for a repository. The repository cannot be a fork.

The returned metrics include an overall health score, the repository description, the presence of documentation, the
detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
README, and CONTRIBUTING files.

The \`health_percentage\` score is defined as a percentage of how many of
the recommended community health files are present. For more information, see
"[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."

\`content_reports_enabled\` is only returned for organization-owned repositories.`,
    inputSchema: github.ReposGetCommunityProfileMetricsParamsSchema
  })
  async reposGetCommunityProfileMetrics(
    params: github.ReposGetCommunityProfileMetricsParams
  ): Promise<github.ReposGetCommunityProfileMetricsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/community/profile`, {})
      .json<github.ReposGetCommunityProfileMetricsResponse>()
  }

  /**
 * Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."

This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.diff`**: Returns the diff of the commit.
- **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property.

The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.

When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.

**Working with large comparisons**

To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:

- The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
- The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.

For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'repos_compare_commits',
    description: `Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."

This endpoint is equivalent to running the \`git log BASE..HEAD\` command, but it returns commits in a different order. The \`git log BASE..HEAD\` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.diff\`**: Returns the diff of the commit.
- **\`application/vnd.github.patch\`**: Returns the patch of the commit. Diffs with binary data will have no \`patch\` property.

The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a \`renamed\` status have a \`previous_filename\` field showing the previous filename of the file, and files with a \`modified\` status have a \`patch\` field showing the changes made to the file.

When calling this endpoint without any paging parameter (\`per_page\` or \`page\`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.

**Working with large comparisons**

To process a response with a large number of commits, use a query parameter (\`per_page\` or \`page\`) to paginate the results. When using pagination:

- The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
- The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.

For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."

**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The \`verification\` object includes the following fields:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.ReposCompareCommitsParamsSchema
  })
  async reposCompareCommits(
    params: github.ReposCompareCommitsParams
  ): Promise<github.ReposCompareCommitsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/compare/${params.basehead}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ReposCompareCommitsResponse>()
  }

  /**
 * Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.
- **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
- **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.

If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".

If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.

If the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null values.

**Notes**:

- To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
- This API has an upper limit of 1,000 files for a directory. If you need to retrieve
more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
- Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
- If the requested file's size is:
  - 1 MB or smaller: All features of this endpoint are supported.
  - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty
string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
  - Greater than 100 MB: This endpoint is not supported.
 */
  @aiFunction({
    name: 'repos_get_content',
    description: `Gets the contents of a file or directory in a repository. Specify the file path or directory with the \`path\` parameter. If you omit the \`path\` parameter, you will receive the contents of the repository's root directory.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw file contents for files and symlinks.
- **\`application/vnd.github.html+json\`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
- **\`application/vnd.github.object+json\`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an \`entries\` attribute containing the array of objects.

If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".

If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.

If the content is a submodule, the \`submodule_git_url\` field identifies the location of the submodule repository, and the \`sha\` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (\`git_url\` and \`_links["git"]\`) and the github.com URLs (\`html_url\` and \`_links["html"]\`) will have null values.

**Notes**:

- To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
- This API has an upper limit of 1,000 files for a directory. If you need to retrieve
more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
- Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
- If the requested file's size is:
  - 1 MB or smaller: All features of this endpoint are supported.
  - Between 1-100 MB: Only the \`raw\` or \`object\` custom media types are supported. Both will work as normal, except that when using the \`object\` media type, the \`content\` field will be an empty
string and the \`encoding\` field will be \`"none"\`. To get the contents of these larger files, use the \`raw\` media type.
  - Greater than 100 MB: This endpoint is not supported.`,
    inputSchema: github.ReposGetContentParamsSchema
  })
  async reposGetContent(
    params: github.ReposGetContentParams
  ): Promise<github.ReposGetContentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/contents/${params.path}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'ref'))
        }
      )
      .json<github.ReposGetContentResponse>()
  }

  /**
 * Creates a new file or replaces an existing file in a repository.

> [!NOTE]
> If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory.
 */
  @aiFunction({
    name: 'repos_create_or_update_file_contents',
    description: `Creates a new file or replaces an existing file in a repository.

> [!NOTE]
> If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint. The \`workflow\` scope is also required in order to modify files in the \`.github/workflows\` directory.`,
    inputSchema: github.ReposCreateOrUpdateFileContentsParamsSchema
  })
  async reposCreateOrUpdateFileContents(
    params: github.ReposCreateOrUpdateFileContentsParams
  ): Promise<github.ReposCreateOrUpdateFileContentsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/contents/${params.path}`,
        {
          json: pick(
            params,
            'message',
            'content',
            'sha',
            'branch',
            'committer',
            'author'
          )
        }
      )
      .json<github.ReposCreateOrUpdateFileContentsResponse>()
  }

  /**
 * Deletes a file in a repository.

You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.

The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.

You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.

> [!NOTE]
> If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
 */
  @aiFunction({
    name: 'repos_delete_file',
    description: `Deletes a file in a repository.

You can provide an additional \`committer\` parameter, which is an object containing information about the committer. Or, you can provide an \`author\` parameter, which is an object containing information about the author.

The \`author\` section is optional and is filled in with the \`committer\` information if omitted. If the \`committer\` information is omitted, the authenticated user's information is used.

You must provide values for both \`name\` and \`email\`, whether you choose to use \`author\` or \`committer\`. Otherwise, you'll receive a \`422\` status code.

> [!NOTE]
> If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.`,
    inputSchema: github.ReposDeleteFileParamsSchema
  })
  async reposDeleteFile(
    params: github.ReposDeleteFileParams
  ): Promise<github.ReposDeleteFileResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/contents/${params.path}`,
        {
          json: pick(params, 'message', 'sha', 'branch', 'committer', 'author')
        }
      )
      .json<github.ReposDeleteFileResponse>()
  }

  /**
 * Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.

GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
 */
  @aiFunction({
    name: 'repos_list_contributors',
    description: `Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.

GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.`,
    inputSchema: github.ReposListContributorsParamsSchema
  })
  async reposListContributors(
    params: github.ReposListContributorsParams
  ): Promise<github.ReposListContributorsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/contributors`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'anon', 'per_page', 'page')
        )
      })
      .json<github.ReposListContributorsResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
   */
  @aiFunction({
    name: 'dependabot_list_alerts_for_repo',
    description: `OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.DependabotListAlertsForRepoParamsSchema
  })
  async dependabotListAlertsForRepo(
    params: github.DependabotListAlertsForRepoParams
  ): Promise<github.DependabotListAlertsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/dependabot/alerts`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'severity',
            'ecosystem',
            'package',
            'manifest',
            'epss_percentage',
            'scope',
            'sort',
            'direction',
            'page',
            'per_page',
            'before',
            'after',
            'first',
            'last'
          )
        )
      })
      .json<github.DependabotListAlertsForRepoResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
   */
  @aiFunction({
    name: 'dependabot_get_alert',
    description: `OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.DependabotGetAlertParamsSchema
  })
  async dependabotGetAlert(
    params: github.DependabotGetAlertParams
  ): Promise<github.DependabotGetAlertResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/dependabot/alerts/${params.alert_number}`,
        {}
      )
      .json<github.DependabotGetAlertResponse>()
  }

  /**
 * The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."

OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'dependabot_update_alert',
    description: `The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."

OAuth app tokens and personal access tokens (classic) need the \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.DependabotUpdateAlertParamsSchema
  })
  async dependabotUpdateAlert(
    params: github.DependabotUpdateAlertParams
  ): Promise<github.DependabotUpdateAlertResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/dependabot/alerts/${params.alert_number}`,
        {
          json: pick(params, 'state', 'dismissed_reason', 'dismissed_comment')
        }
      )
      .json<github.DependabotUpdateAlertResponse>()
  }

  /**
 * Lists all secrets available in a repository without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_list_repo_secrets',
    description: `Lists all secrets available in a repository without revealing their encrypted
values.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.DependabotListRepoSecretsParamsSchema
  })
  async dependabotListRepoSecrets(
    params: github.DependabotListRepoSecretsParams
  ): Promise<github.DependabotListRepoSecretsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/dependabot/secrets`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.DependabotListRepoSecretsResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets. Anyone with read access
to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the repository is private.
 */
  @aiFunction({
    name: 'dependabot_get_repo_public_key',
    description: `Gets your public key, which you need to encrypt secrets. You need to
encrypt a secret before you can create or update secrets. Anyone with read access
to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint if the repository is private.`,
    inputSchema: github.DependabotGetRepoPublicKeyParamsSchema
  })
  async dependabotGetRepoPublicKey(
    params: github.DependabotGetRepoPublicKeyParams
  ): Promise<github.DependabotGetRepoPublicKeyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/dependabot/secrets/public-key`,
        {}
      )
      .json<github.DependabotGetRepoPublicKeyResponse>()
  }

  /**
 * Gets a single repository secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_get_repo_secret',
    description: `Gets a single repository secret without revealing its encrypted value.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.DependabotGetRepoSecretParamsSchema
  })
  async dependabotGetRepoSecret(
    params: github.DependabotGetRepoSecretParams
  ): Promise<github.DependabotGetRepoSecretResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/dependabot/secrets/${params.secret_name}`,
        {}
      )
      .json<github.DependabotGetRepoSecretResponse>()
  }

  /**
 * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_create_or_update_repo_secret',
    description: `Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.DependabotCreateOrUpdateRepoSecretParamsSchema
  })
  async dependabotCreateOrUpdateRepoSecret(
    params: github.DependabotCreateOrUpdateRepoSecretParams
  ): Promise<github.DependabotCreateOrUpdateRepoSecretResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/dependabot/secrets/${params.secret_name}`,
        {
          json: pick(params, 'encrypted_value', 'key_id')
        }
      )
      .json<github.DependabotCreateOrUpdateRepoSecretResponse>()
  }

  /**
 * Deletes a secret in a repository using the secret name.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependabot_delete_repo_secret',
    description: `Deletes a secret in a repository using the secret name.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.DependabotDeleteRepoSecretParamsSchema
  })
  async dependabotDeleteRepoSecret(
    params: github.DependabotDeleteRepoSecretParams
  ): Promise<github.DependabotDeleteRepoSecretResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/dependabot/secrets/${params.secret_name}`,
        {}
      )
      .json<github.DependabotDeleteRepoSecretResponse>()
  }

  /**
   * Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits.
   */
  @aiFunction({
    name: 'dependency_graph_diff_range',
    description: `Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits.`,
    inputSchema: github.DependencyGraphDiffRangeParamsSchema
  })
  async dependencyGraphDiffRange(
    params: github.DependencyGraphDiffRangeParams
  ): Promise<github.DependencyGraphDiffRangeResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/dependency-graph/compare/${params.basehead}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'name'))
        }
      )
      .json<github.DependencyGraphDiffRangeResponse>()
  }

  /**
   * Exports the software bill of materials (SBOM) for a repository in SPDX JSON format.
   */
  @aiFunction({
    name: 'dependency_graph_export_sbom',
    description: `Exports the software bill of materials (SBOM) for a repository in SPDX JSON format.`,
    inputSchema: github.DependencyGraphExportSbomParamsSchema
  })
  async dependencyGraphExportSbom(
    params: github.DependencyGraphExportSbomParams
  ): Promise<github.DependencyGraphExportSbomResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/dependency-graph/sbom`,
        {}
      )
      .json<github.DependencyGraphExportSbomResponse>()
  }

  /**
 * Create a new snapshot of a repository's dependencies.

The authenticated user must have access to the repository.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'dependency_graph_create_repository_snapshot',
    description: `Create a new snapshot of a repository's dependencies.

The authenticated user must have access to the repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.DependencyGraphCreateRepositorySnapshotParamsSchema
  })
  async dependencyGraphCreateRepositorySnapshot(
    params: github.DependencyGraphCreateRepositorySnapshotParams
  ): Promise<github.DependencyGraphCreateRepositorySnapshotResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/dependency-graph/snapshots`,
        {
          json: pick(
            params,
            'version',
            'job',
            'sha',
            'ref',
            'detector',
            'metadata',
            'manifests',
            'scanned'
          )
        }
      )
      .json<github.DependencyGraphCreateRepositorySnapshotResponse>()
  }

  /**
   * Simple filtering of deployments is available via query parameters:.
   */
  @aiFunction({
    name: 'repos_list_deployments',
    description: `Simple filtering of deployments is available via query parameters:.`,
    inputSchema: github.ReposListDeploymentsParamsSchema
  })
  async reposListDeployments(
    params: github.ReposListDeploymentsParams
  ): Promise<github.ReposListDeploymentsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/deployments`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sha', 'ref', 'task', 'environment', 'per_page', 'page')
        )
      })
      .json<github.ReposListDeploymentsResponse>()
  }

  /**
 * Deployments offer a few configurable parameters with certain defaults.

The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
before we merge a pull request.

The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
makes it easier to track which environments have requested deployments. The default environment is `production`.

The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
return a failure response.

By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
not require any contexts or create any commit statuses, the deployment will always succeed.

The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
field that will be passed on when a deployment event is dispatched.

The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
application with debugging enabled.

Merged branch response:

You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
a deployment. This auto-merge happens when:
*   Auto-merge option is enabled in the repository
*   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
*   There are no merge conflicts

If there are no new commits in the base branch, a new request to create a deployment should give a successful
response.

Merge conflict response:

This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.

Failed commit status checks:

This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_deployment',
    description: `Deployments offer a few configurable parameters with certain defaults.

The \`ref\` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
before we merge a pull request.

The \`environment\` parameter allows deployments to be issued to different runtime environments. Teams often have
multiple environments for verifying their applications, such as \`production\`, \`staging\`, and \`qa\`. This parameter
makes it easier to track which environments have requested deployments. The default environment is \`production\`.

The \`auto_merge\` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
return a failure response.

By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a \`success\`
state. The \`required_contexts\` parameter allows you to specify a subset of contexts that must be \`success\`, or to
specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
not require any contexts or create any commit statuses, the deployment will always succeed.

The \`payload\` parameter is available for any extra information that a deployment system might need. It is a JSON text
field that will be passed on when a deployment event is dispatched.

The \`task\` parameter is used by the deployment system to allow different execution paths. In the web world this might
be \`deploy:migrations\` to run schema changes on the system. In the compiled world this could be a flag to compile an
application with debugging enabled.

Merged branch response:

You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
a deployment. This auto-merge happens when:
*   Auto-merge option is enabled in the repository
*   Topic branch does not include the latest changes on the base branch, which is \`master\` in the response example
*   There are no merge conflicts

If there are no new commits in the base branch, a new request to create a deployment should give a successful
response.

Merge conflict response:

This error happens when the \`auto_merge\` option is enabled and when the default branch (in this case \`master\`), can't
be merged into the branch that's being deployed (in this case \`topic-branch\`), due to merge conflicts.

Failed commit status checks:

This error happens when the \`required_contexts\` parameter indicates that one or more contexts need to have a \`success\`
status for the commit to be deployed, but one or more of the required contexts do not have a state of \`success\`.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repo_deployment\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateDeploymentParamsSchema
  })
  async reposCreateDeployment(
    params: github.ReposCreateDeploymentParams
  ): Promise<github.ReposCreateDeploymentResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/deployments`, {
        json: pick(
          params,
          'ref',
          'task',
          'auto_merge',
          'required_contexts',
          'payload',
          'environment',
          'description',
          'transient_environment',
          'production_environment'
        )
      })
      .json<github.ReposCreateDeploymentResponse>()
  }

  /**
   * Get a deployment.
   */
  @aiFunction({
    name: 'repos_get_deployment',
    description: `Get a deployment.`,
    inputSchema: github.ReposGetDeploymentParamsSchema
  })
  async reposGetDeployment(
    params: github.ReposGetDeploymentParams
  ): Promise<github.ReposGetDeploymentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/deployments/${params.deployment_id}`,
        {}
      )
      .json<github.ReposGetDeploymentResponse>()
  }

  /**
 * If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.

To set a deployment as inactive, you must:

*   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
*   Mark the active deployment as inactive by adding any non-successful deployment status.

For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."

OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_delete_deployment',
    description: `If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.

To set a deployment as inactive, you must:

*   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
*   Mark the active deployment as inactive by adding any non-successful deployment status.

For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repo_deployment\` scope to use this endpoint.`,
    inputSchema: github.ReposDeleteDeploymentParamsSchema
  })
  async reposDeleteDeployment(
    params: github.ReposDeleteDeploymentParams
  ): Promise<github.ReposDeleteDeploymentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/deployments/${params.deployment_id}`,
        {}
      )
      .json<github.ReposDeleteDeploymentResponse>()
  }

  /**
   * Users with pull access can view deployment statuses for a deployment:.
   */
  @aiFunction({
    name: 'repos_list_deployment_statuses',
    description: `Users with pull access can view deployment statuses for a deployment:.`,
    inputSchema: github.ReposListDeploymentStatusesParamsSchema
  })
  async reposListDeploymentStatuses(
    params: github.ReposListDeploymentStatusesParams
  ): Promise<github.ReposListDeploymentStatusesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/deployments/${params.deployment_id}/statuses`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListDeploymentStatusesResponse>()
  }

  /**
 * Users with `push` access can create deployment statuses for a given deployment.

OAuth app tokens and personal access tokens (classic) need the `repo_deployment` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_deployment_status',
    description: `Users with \`push\` access can create deployment statuses for a given deployment.

OAuth app tokens and personal access tokens (classic) need the \`repo_deployment\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateDeploymentStatusParamsSchema
  })
  async reposCreateDeploymentStatus(
    params: github.ReposCreateDeploymentStatusParams
  ): Promise<github.ReposCreateDeploymentStatusResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/deployments/${params.deployment_id}/statuses`,
        {
          json: pick(
            params,
            'state',
            'target_url',
            'log_url',
            'description',
            'environment',
            'environment_url',
            'auto_inactive'
          )
        }
      )
      .json<github.ReposCreateDeploymentStatusResponse>()
  }

  /**
   * Users with pull access can view a deployment status for a deployment:.
   */
  @aiFunction({
    name: 'repos_get_deployment_status',
    description: `Users with pull access can view a deployment status for a deployment:.`,
    inputSchema: github.ReposGetDeploymentStatusParamsSchema
  })
  async reposGetDeploymentStatus(
    params: github.ReposGetDeploymentStatusParams
  ): Promise<github.ReposGetDeploymentStatusResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/deployments/${params.deployment_id}/statuses/${params.status_id}`,
        {}
      )
      .json<github.ReposGetDeploymentStatusResponse>()
  }

  /**
 * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."

The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.

This input example shows how you can use the `client_payload` as a test to debug your workflow.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_dispatch_event',
    description: `You can use this endpoint to trigger a webhook event called \`repository_dispatch\` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the \`repository_dispatch\` event occurs. For an example \`repository_dispatch\` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."

The \`client_payload\` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the \`client_payload\` can include a message that a user would like to send using a GitHub Actions workflow. Or the \`client_payload\` can be used as a test to debug your workflow.

This input example shows how you can use the \`client_payload\` as a test to debug your workflow.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateDispatchEventParamsSchema
  })
  async reposCreateDispatchEvent(
    params: github.ReposCreateDispatchEventParams
  ): Promise<github.ReposCreateDispatchEventResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/dispatches`, {
        json: pick(params, 'event_type', 'client_payload')
      })
      .json<github.ReposCreateDispatchEventResponse>()
  }

  /**
 * Lists the environments for a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_get_all_environments',
    description: `Lists the environments for a repository.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposGetAllEnvironmentsParamsSchema
  })
  async reposGetAllEnvironments(
    params: github.ReposGetAllEnvironmentsParams
  ): Promise<github.ReposGetAllEnvironmentsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/environments`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposGetAllEnvironmentsResponse>()
  }

  /**
 * > [!NOTE]
> To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_get_environment',
    description: `> [!NOTE]
> To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposGetEnvironmentParamsSchema
  })
  async reposGetEnvironment(
    params: github.ReposGetEnvironmentParams
  ): Promise<github.ReposGetEnvironmentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}`,
        {}
      )
      .json<github.ReposGetEnvironmentResponse>()
  }

  /**
 * Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."

> [!NOTE]
> To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."

> [!NOTE]
> To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_or_update_environment',
    description: `Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."

> [!NOTE]
> To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."

> [!NOTE]
> To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateOrUpdateEnvironmentParamsSchema
  })
  async reposCreateOrUpdateEnvironment(
    params: github.ReposCreateOrUpdateEnvironmentParams
  ): Promise<github.ReposCreateOrUpdateEnvironmentResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}`,
        {
          json: pick(
            params,
            'wait_timer',
            'prevent_self_review',
            'reviewers',
            'deployment_branch_policy'
          )
        }
      )
      .json<github.ReposCreateOrUpdateEnvironmentResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
   */
  @aiFunction({
    name: 'repos_delete_an_environment',
    description: `OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposDeleteAnEnvironmentParamsSchema
  })
  async reposDeleteAnEnvironment(
    params: github.ReposDeleteAnEnvironmentParams
  ): Promise<github.ReposDeleteAnEnvironmentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}`,
        {}
      )
      .json<github.ReposDeleteAnEnvironmentResponse>()
  }

  /**
 * Lists the deployment branch policies for an environment.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_list_deployment_branch_policies',
    description: `Lists the deployment branch policies for an environment.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposListDeploymentBranchPoliciesParamsSchema
  })
  async reposListDeploymentBranchPolicies(
    params: github.ReposListDeploymentBranchPoliciesParams
  ): Promise<github.ReposListDeploymentBranchPoliciesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment-branch-policies`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListDeploymentBranchPoliciesResponse>()
  }

  /**
 * Creates a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_deployment_branch_policy',
    description: `Creates a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateDeploymentBranchPolicyParamsSchema
  })
  async reposCreateDeploymentBranchPolicy(
    params: github.ReposCreateDeploymentBranchPolicyParams
  ): Promise<github.ReposCreateDeploymentBranchPolicyResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment-branch-policies`,
        {
          json: pick(params, 'name', 'type')
        }
      )
      .json<github.ReposCreateDeploymentBranchPolicyResponse>()
  }

  /**
 * Gets a deployment branch or tag policy for an environment.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_get_deployment_branch_policy',
    description: `Gets a deployment branch or tag policy for an environment.

Anyone with read access to the repository can use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposGetDeploymentBranchPolicyParamsSchema
  })
  async reposGetDeploymentBranchPolicy(
    params: github.ReposGetDeploymentBranchPolicyParams
  ): Promise<github.ReposGetDeploymentBranchPolicyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment-branch-policies/${params.branch_policy_id}`,
        {}
      )
      .json<github.ReposGetDeploymentBranchPolicyResponse>()
  }

  /**
 * Updates a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_update_deployment_branch_policy',
    description: `Updates a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposUpdateDeploymentBranchPolicyParamsSchema
  })
  async reposUpdateDeploymentBranchPolicy(
    params: github.ReposUpdateDeploymentBranchPolicyParams
  ): Promise<github.ReposUpdateDeploymentBranchPolicyResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment-branch-policies/${params.branch_policy_id}`,
        {
          json: pick(params, 'name')
        }
      )
      .json<github.ReposUpdateDeploymentBranchPolicyResponse>()
  }

  /**
 * Deletes a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_delete_deployment_branch_policy',
    description: `Deletes a deployment branch or tag policy for an environment.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposDeleteDeploymentBranchPolicyParamsSchema
  })
  async reposDeleteDeploymentBranchPolicy(
    params: github.ReposDeleteDeploymentBranchPolicyParams
  ): Promise<github.ReposDeleteDeploymentBranchPolicyResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment-branch-policies/${params.branch_policy_id}`,
        {}
      )
      .json<github.ReposDeleteDeploymentBranchPolicyResponse>()
  }

  /**
 * Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_get_all_deployment_protection_rules',
    description: `Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see the [documentation for the \`GET /apps/{app_slug}\` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposGetAllDeploymentProtectionRulesParamsSchema
  })
  async reposGetAllDeploymentProtectionRules(
    params: github.ReposGetAllDeploymentProtectionRulesParams
  ): Promise<github.ReposGetAllDeploymentProtectionRulesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment_protection_rules`,
        {}
      )
      .json<github.ReposGetAllDeploymentProtectionRulesResponse>()
  }

  /**
 * Enable a custom deployment protection rule for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_deployment_protection_rule',
    description: `Enable a custom deployment protection rule for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

For more information about the app that is providing this custom deployment rule, see the [documentation for the \`GET /apps/{app_slug}\` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposCreateDeploymentProtectionRuleParamsSchema
  })
  async reposCreateDeploymentProtectionRule(
    params: github.ReposCreateDeploymentProtectionRuleParams
  ): Promise<github.ReposCreateDeploymentProtectionRuleResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment_protection_rules`,
        {
          json: pick(params, 'integration_id')
        }
      )
      .json<github.ReposCreateDeploymentProtectionRuleResponse>()
  }

  /**
 * Gets all custom deployment protection rule integrations that are available for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_list_custom_deployment_rule_integrations',
    description: `Gets all custom deployment protection rule integrations that are available for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposListCustomDeploymentRuleIntegrationsParamsSchema
  })
  async reposListCustomDeploymentRuleIntegrations(
    params: github.ReposListCustomDeploymentRuleIntegrationsParams
  ): Promise<github.ReposListCustomDeploymentRuleIntegrationsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment_protection_rules/apps`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.ReposListCustomDeploymentRuleIntegrationsResponse>()
  }

  /**
 * Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_get_custom_deployment_protection_rule',
    description: `Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."

For more information about the app that is providing this custom deployment rule, see [\`GET /apps/{app_slug}\`](https://docs.github.com/rest/apps/apps#get-an-app).

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposGetCustomDeploymentProtectionRuleParamsSchema
  })
  async reposGetCustomDeploymentProtectionRule(
    params: github.ReposGetCustomDeploymentProtectionRuleParams
  ): Promise<github.ReposGetCustomDeploymentProtectionRuleResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment_protection_rules/${params.protection_rule_id}`,
        {}
      )
      .json<github.ReposGetCustomDeploymentProtectionRuleResponse>()
  }

  /**
 * Disables a custom deployment protection rule for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_disable_deployment_protection_rule',
    description: `Disables a custom deployment protection rule for an environment.

The authenticated user must have admin or owner permissions to the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposDisableDeploymentProtectionRuleParamsSchema
  })
  async reposDisableDeploymentProtectionRule(
    params: github.ReposDisableDeploymentProtectionRuleParams
  ): Promise<github.ReposDisableDeploymentProtectionRuleResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/deployment_protection_rules/${params.protection_rule_id}`,
        {}
      )
      .json<github.ReposDisableDeploymentProtectionRuleResponse>()
  }

  /**
 * Lists all secrets available in an environment without revealing their
encrypted values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_environment_secrets',
    description: `Lists all secrets available in an environment without revealing their
encrypted values.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListEnvironmentSecretsParamsSchema
  })
  async actionsListEnvironmentSecrets(
    params: github.ActionsListEnvironmentSecretsParams
  ): Promise<github.ActionsListEnvironmentSecretsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/secrets`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListEnvironmentSecretsResponse>()
  }

  /**
 * Get the public key for an environment, which you need to encrypt environment
secrets. You need to encrypt a secret before you can create or update secrets.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_environment_public_key',
    description: `Get the public key for an environment, which you need to encrypt environment
secrets. You need to encrypt a secret before you can create or update secrets.

Anyone with read access to the repository can use this endpoint.

If the repository is private, OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetEnvironmentPublicKeyParamsSchema
  })
  async actionsGetEnvironmentPublicKey(
    params: github.ActionsGetEnvironmentPublicKeyParams
  ): Promise<github.ActionsGetEnvironmentPublicKeyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/secrets/public-key`,
        {}
      )
      .json<github.ActionsGetEnvironmentPublicKeyResponse>()
  }

  /**
 * Gets a single environment secret without revealing its encrypted value.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_environment_secret',
    description: `Gets a single environment secret without revealing its encrypted value.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetEnvironmentSecretParamsSchema
  })
  async actionsGetEnvironmentSecret(
    params: github.ActionsGetEnvironmentSecretParams
  ): Promise<github.ActionsGetEnvironmentSecretResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsGetEnvironmentSecretResponse>()
  }

  /**
 * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_or_update_environment_secret',
    description: `Creates or updates an environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateOrUpdateEnvironmentSecretParamsSchema
  })
  async actionsCreateOrUpdateEnvironmentSecret(
    params: github.ActionsCreateOrUpdateEnvironmentSecretParams
  ): Promise<github.ActionsCreateOrUpdateEnvironmentSecretResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/secrets/${params.secret_name}`,
        {
          json: pick(params, 'encrypted_value', 'key_id')
        }
      )
      .json<github.ActionsCreateOrUpdateEnvironmentSecretResponse>()
  }

  /**
 * Deletes a secret in an environment using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_environment_secret',
    description: `Deletes a secret in an environment using the secret name.

Authenticated users must have collaborator access to a repository to create, update, or read secrets.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteEnvironmentSecretParamsSchema
  })
  async actionsDeleteEnvironmentSecret(
    params: github.ActionsDeleteEnvironmentSecretParams
  ): Promise<github.ActionsDeleteEnvironmentSecretResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/secrets/${params.secret_name}`,
        {}
      )
      .json<github.ActionsDeleteEnvironmentSecretResponse>()
  }

  /**
 * Lists all environment variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_list_environment_variables',
    description: `Lists all environment variables.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsListEnvironmentVariablesParamsSchema
  })
  async actionsListEnvironmentVariables(
    params: github.ActionsListEnvironmentVariablesParams
  ): Promise<github.ActionsListEnvironmentVariablesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/variables`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ActionsListEnvironmentVariablesResponse>()
  }

  /**
 * Create an environment variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_create_environment_variable',
    description: `Create an environment variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsCreateEnvironmentVariableParamsSchema
  })
  async actionsCreateEnvironmentVariable(
    params: github.ActionsCreateEnvironmentVariableParams
  ): Promise<github.ActionsCreateEnvironmentVariableResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/variables`,
        {
          json: pick(params, 'name', 'value')
        }
      )
      .json<github.ActionsCreateEnvironmentVariableResponse>()
  }

  /**
 * Gets a specific variable in an environment.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_get_environment_variable',
    description: `Gets a specific variable in an environment.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsGetEnvironmentVariableParamsSchema
  })
  async actionsGetEnvironmentVariable(
    params: github.ActionsGetEnvironmentVariableParams
  ): Promise<github.ActionsGetEnvironmentVariableResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/variables/${params.name}`,
        {}
      )
      .json<github.ActionsGetEnvironmentVariableResponse>()
  }

  /**
 * Deletes an environment variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_delete_environment_variable',
    description: `Deletes an environment variable using the variable name.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsDeleteEnvironmentVariableParamsSchema
  })
  async actionsDeleteEnvironmentVariable(
    params: github.ActionsDeleteEnvironmentVariableParams
  ): Promise<github.ActionsDeleteEnvironmentVariableResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/variables/${params.name}`,
        {}
      )
      .json<github.ActionsDeleteEnvironmentVariableResponse>()
  }

  /**
 * Updates an environment variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'actions_update_environment_variable',
    description: `Updates an environment variable that you can reference in a GitHub Actions workflow.

Authenticated users must have collaborator access to a repository to create, update, or read variables.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ActionsUpdateEnvironmentVariableParamsSchema
  })
  async actionsUpdateEnvironmentVariable(
    params: github.ActionsUpdateEnvironmentVariableParams
  ): Promise<github.ActionsUpdateEnvironmentVariableResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/environments/${params.environment_name}/variables/${params.name}`,
        {
          json: pick(params, 'name', 'value')
        }
      )
      .json<github.ActionsUpdateEnvironmentVariableResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_repo_events',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListRepoEventsParamsSchema
  })
  async activityListRepoEvents(
    params: github.ActivityListRepoEventsParams
  ): Promise<github.ActivityListRepoEventsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListRepoEventsResponse>()
  }

  /**
   * List forks.
   */
  @aiFunction({
    name: 'repos_list_forks',
    description: `List forks.`,
    inputSchema: github.ReposListForksParamsSchema
  })
  async reposListForks(
    params: github.ReposListForksParams
  ): Promise<github.ReposListForksResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/forks`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'per_page', 'page')
        )
      })
      .json<github.ReposListForksResponse>()
  }

  /**
 * Create a fork for the authenticated user.

> [!NOTE]
> Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).

> [!NOTE]
> Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.
 */
  @aiFunction({
    name: 'repos_create_fork',
    description: `Create a fork for the authenticated user.

> [!NOTE]
> Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).

> [!NOTE]
> Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.`,
    inputSchema: github.ReposCreateForkParamsSchema
  })
  async reposCreateFork(
    params: github.ReposCreateForkParams
  ): Promise<github.ReposCreateForkResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/forks`, {
        json: pick(params, 'organization', 'name', 'default_branch_only')
      })
      .json<github.ReposCreateForkResponse>()
  }

  /**
   * Create a blob.
   */
  @aiFunction({
    name: 'git_create_blob',
    description: `Create a blob.`,
    inputSchema: github.GitCreateBlobParamsSchema
  })
  async gitCreateBlob(
    params: github.GitCreateBlobParams
  ): Promise<github.GitCreateBlobResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/git/blobs`, {
        json: pick(params, 'content', 'encoding')
      })
      .json<github.GitCreateBlobResponse>()
  }

  /**
 * The `content` in the response will always be Base64 encoded.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw blob data.
- **`application/vnd.github+json`**: Returns a JSON representation of the blob with `content` as a base64 encoded string. This is the default if no media type is specified.

**Note** This endpoint supports blobs up to 100 megabytes in size.
 */
  @aiFunction({
    name: 'git_get_blob',
    description: `The \`content\` in the response will always be Base64 encoded.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw blob data.
- **\`application/vnd.github+json\`**: Returns a JSON representation of the blob with \`content\` as a base64 encoded string. This is the default if no media type is specified.

**Note** This endpoint supports blobs up to 100 megabytes in size.`,
    inputSchema: github.GitGetBlobParamsSchema
  })
  async gitGetBlob(
    params: github.GitGetBlobParams
  ): Promise<github.GitGetBlobResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/blobs/${params.file_sha}`,
        {}
      )
      .json<github.GitGetBlobResponse>()
  }

  /**
 * Creates a new Git [commit object](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'git_create_commit',
    description: `Creates a new Git [commit object](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).

**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.GitCreateCommitParamsSchema
  })
  async gitCreateCommit(
    params: github.GitCreateCommitParams
  ): Promise<github.GitCreateCommitResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/git/commits`, {
        json: pick(
          params,
          'message',
          'tree',
          'parents',
          'author',
          'committer',
          'signature'
        )
      })
      .json<github.GitCreateCommitResponse>()
  }

  /**
 * Gets a Git [commit object](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).

To get the contents of a commit, see "[Get a commit](/rest/commits/commits#get-a-commit)."

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'git_get_commit',
    description: `Gets a Git [commit object](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).

To get the contents of a commit, see "[Get a commit](/rest/commits/commits#get-a-commit)."

**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.GitGetCommitParamsSchema
  })
  async gitGetCommit(
    params: github.GitGetCommitParams
  ): Promise<github.GitGetCommitResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/commits/${params.commit_sha}`,
        {}
      )
      .json<github.GitGetCommitResponse>()
  }

  /**
 * Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.

When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.

> [!NOTE]
> You need to explicitly [request a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
 */
  @aiFunction({
    name: 'git_list_matching_refs',
    description: `Returns an array of references from your Git database that match the supplied name. The \`:ref\` in the URL must be formatted as \`heads/<branch name>\` for branches and \`tags/<tag name>\` for tags. If the \`:ref\` doesn't exist in the repository, but existing refs start with \`:ref\`, they will be returned as an array.

When you use this endpoint without providing a \`:ref\`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just \`heads\` and \`tags\`.

> [!NOTE]
> You need to explicitly [request a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

If you request matching references for a branch named \`feature\` but the branch \`feature\` doesn't exist, the response can still include other matching head refs that start with the word \`feature\`, such as \`featureA\` and \`featureB\`.`,
    inputSchema: github.GitListMatchingRefsParamsSchema
  })
  async gitListMatchingRefs(
    params: github.GitListMatchingRefsParams
  ): Promise<github.GitListMatchingRefsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/matching-refs/${params.ref}`,
        {}
      )
      .json<github.GitListMatchingRefsResponse>()
  }

  /**
 * Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.

> [!NOTE]
> You need to explicitly [request a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
 */
  @aiFunction({
    name: 'git_get_ref',
    description: `Returns a single reference from your Git database. The \`:ref\` in the URL must be formatted as \`heads/<branch name>\` for branches and \`tags/<tag name>\` for tags. If the \`:ref\` doesn't match an existing ref, a \`404\` is returned.

> [!NOTE]
> You need to explicitly [request a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".`,
    inputSchema: github.GitGetRefParamsSchema
  })
  async gitGetRef(
    params: github.GitGetRefParams
  ): Promise<github.GitGetRefResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/ref/${params.ref}`,
        {}
      )
      .json<github.GitGetRefResponse>()
  }

  /**
   * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
   */
  @aiFunction({
    name: 'git_create_ref',
    description: `Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.`,
    inputSchema: github.GitCreateRefParamsSchema
  })
  async gitCreateRef(
    params: github.GitCreateRefParams
  ): Promise<github.GitCreateRefResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/git/refs`, {
        json: pick(params, 'ref', 'sha')
      })
      .json<github.GitCreateRefResponse>()
  }

  /**
   * Deletes the provided reference.
   */
  @aiFunction({
    name: 'git_delete_ref',
    description: `Deletes the provided reference.`,
    inputSchema: github.GitDeleteRefParamsSchema
  })
  async gitDeleteRef(
    params: github.GitDeleteRefParams
  ): Promise<github.GitDeleteRefResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/git/refs/${params.ref}`,
        {}
      )
      .json<github.GitDeleteRefResponse>()
  }

  /**
   * Updates the provided reference to point to a new SHA. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
   */
  @aiFunction({
    name: 'git_update_ref',
    description: `Updates the provided reference to point to a new SHA. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.`,
    inputSchema: github.GitUpdateRefParamsSchema
  })
  async gitUpdateRef(
    params: github.GitUpdateRefParams
  ): Promise<github.GitUpdateRefResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/git/refs/${params.ref}`,
        {
          json: pick(params, 'sha', 'force')
        }
      )
      .json<github.GitUpdateRefResponse>()
  }

  /**
 * Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/git/refs#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/git/refs#create-a-reference) the tag reference - this call would be unnecessary.

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'git_create_tag',
    description: `Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/git/refs#create-a-reference) the \`refs/tags/[tag]\` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/git/refs#create-a-reference) the tag reference - this call would be unnecessary.

**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.GitCreateTagParamsSchema
  })
  async gitCreateTag(
    params: github.GitCreateTagParams
  ): Promise<github.GitCreateTagResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/git/tags`, {
        json: pick(params, 'tag', 'message', 'object', 'type', 'tagger')
      })
      .json<github.GitCreateTagResponse>()
  }

  /**
 * **Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |
| `verified_at` | `string` | The date the signature was verified by GitHub. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |.
 */
  @aiFunction({
    name: 'git_get_tag',
    description: `**Signature verification object**

The response will include a \`verification\` object that describes the result of verifying the commit's signature. The following fields are included in the \`verification\` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| \`verified\` | \`boolean\` | Indicates whether GitHub considers the signature in this commit to be verified. |
| \`reason\` | \`string\` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| \`signature\` | \`string\` | The signature that was extracted from the commit. |
| \`payload\` | \`string\` | The value that was signed. |
| \`verified_at\` | \`string\` | The date the signature was verified by GitHub. |

These are the possible values for \`reason\` in the \`verification\` object:

| Value | Description |
| ----- | ----------- |
| \`expired_key\` | The key that made the signature is expired. |
| \`not_signing_key\` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| \`gpgverify_error\` | There was an error communicating with the signature verification service. |
| \`gpgverify_unavailable\` | The signature verification service is currently unavailable. |
| \`unsigned\` | The object does not include a signature. |
| \`unknown_signature_type\` | A non-PGP signature was found in the commit. |
| \`no_user\` | No user was associated with the \`committer\` email address in the commit. |
| \`unverified_email\` | The \`committer\` email address in the commit was associated with a user, but the email address is not verified on their account. |
| \`bad_email\` | The \`committer\` email address in the commit is not included in the identities of the PGP key that made the signature. |
| \`unknown_key\` | The key that made the signature has not been registered with any user's account. |
| \`malformed_signature\` | There was an error parsing the signature. |
| \`invalid\` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| \`valid\` | None of the above errors applied, so the signature is considered to be verified. |.`,
    inputSchema: github.GitGetTagParamsSchema
  })
  async gitGetTag(
    params: github.GitGetTagParams
  ): Promise<github.GitGetTagResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/tags/${params.tag_sha}`,
        {}
      )
      .json<github.GitGetTagResponse>()
  }

  /**
 * The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.

If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/rest/git/commits#create-a-commit)" and "[Update a reference](https://docs.github.com/rest/git/refs#update-a-reference)."

Returns an error if you try to delete a file that does not exist.
 */
  @aiFunction({
    name: 'git_create_tree',
    description: `The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.

If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/rest/git/commits#create-a-commit)" and "[Update a reference](https://docs.github.com/rest/git/refs#update-a-reference)."

Returns an error if you try to delete a file that does not exist.`,
    inputSchema: github.GitCreateTreeParamsSchema
  })
  async gitCreateTree(
    params: github.GitCreateTreeParams
  ): Promise<github.GitCreateTreeResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/git/trees`, {
        json: pick(params, 'tree', 'base_tree')
      })
      .json<github.GitCreateTreeResponse>()
  }

  /**
 * Returns a single tree using the SHA1 value or ref name for that tree.

If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.

> [!NOTE]
> The limit for the `tree` array is 100,000 entries with a maximum size of 7 MB when using the `recursive` parameter.
 */
  @aiFunction({
    name: 'git_get_tree',
    description: `Returns a single tree using the SHA1 value or ref name for that tree.

If \`truncated\` is \`true\` in the response then the number of items in the \`tree\` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.

> [!NOTE]
> The limit for the \`tree\` array is 100,000 entries with a maximum size of 7 MB when using the \`recursive\` parameter.`,
    inputSchema: github.GitGetTreeParamsSchema
  })
  async gitGetTree(
    params: github.GitGetTreeParams
  ): Promise<github.GitGetTreeResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/git/trees/${params.tree_sha}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'recursive'))
        }
      )
      .json<github.GitGetTreeResponse>()
  }

  /**
   * Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
   */
  @aiFunction({
    name: 'repos_list_webhooks',
    description: `Lists webhooks for a repository. \`last response\` may return null if there have not been any deliveries within 30 days.`,
    inputSchema: github.ReposListWebhooksParamsSchema
  })
  async reposListWebhooks(
    params: github.ReposListWebhooksParams
  ): Promise<github.ReposListWebhooksResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/hooks`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListWebhooksResponse>()
  }

  /**
 * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
share the same `config` as long as those webhooks do not have any `events` that overlap.
 */
  @aiFunction({
    name: 'repos_create_webhook',
    description: `Repositories can have multiple webhooks installed. Each webhook should have a unique \`config\`. Multiple webhooks can
share the same \`config\` as long as those webhooks do not have any \`events\` that overlap.`,
    inputSchema: github.ReposCreateWebhookParamsSchema
  })
  async reposCreateWebhook(
    params: github.ReposCreateWebhookParams
  ): Promise<github.ReposCreateWebhookResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/hooks`, {
        json: pick(params, 'name', 'config', 'events', 'active')
      })
      .json<github.ReposCreateWebhookResponse>()
  }

  /**
   * Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository).".
   */
  @aiFunction({
    name: 'repos_get_webhook',
    description: `Returns a webhook configured in a repository. To get only the webhook \`config\` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository).".`,
    inputSchema: github.ReposGetWebhookParamsSchema
  })
  async reposGetWebhook(
    params: github.ReposGetWebhookParams
  ): Promise<github.ReposGetWebhookResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}`,
        {}
      )
      .json<github.ReposGetWebhookResponse>()
  }

  /**
 * Delete a webhook for an organization.

The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.
 */
  @aiFunction({
    name: 'repos_delete_webhook',
    description: `Delete a webhook for an organization.

The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.`,
    inputSchema: github.ReposDeleteWebhookParamsSchema
  })
  async reposDeleteWebhook(
    params: github.ReposDeleteWebhookParams
  ): Promise<github.ReposDeleteWebhookResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}`,
        {}
      )
      .json<github.ReposDeleteWebhookResponse>()
  }

  /**
   * Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository).".
   */
  @aiFunction({
    name: 'repos_update_webhook',
    description: `Updates a webhook configured in a repository. If you previously had a \`secret\` set, you must provide the same \`secret\` or set a new \`secret\` or the secret will be removed. If you are only updating individual webhook \`config\` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository).".`,
    inputSchema: github.ReposUpdateWebhookParamsSchema
  })
  async reposUpdateWebhook(
    params: github.ReposUpdateWebhookParams
  ): Promise<github.ReposUpdateWebhookResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}`,
        {
          json: pick(
            params,
            'config',
            'events',
            'add_events',
            'remove_events',
            'active'
          )
        }
      )
      .json<github.ReposUpdateWebhookResponse>()
  }

  /**
 * Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."

OAuth app tokens and personal access tokens (classic) need the `read:repo_hook` or `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_webhook_config_for_repo',
    description: `Returns the webhook configuration for a repository. To get more information about the webhook, including the \`active\` state and \`events\`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."

OAuth app tokens and personal access tokens (classic) need the \`read:repo_hook\` or \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposGetWebhookConfigForRepoParamsSchema
  })
  async reposGetWebhookConfigForRepo(
    params: github.ReposGetWebhookConfigForRepoParams
  ): Promise<github.ReposGetWebhookConfigForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/config`,
        {}
      )
      .json<github.ReposGetWebhookConfigForRepoResponse>()
  }

  /**
 * Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."

OAuth app tokens and personal access tokens (classic) need the `write:repo_hook` or `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_update_webhook_config_for_repo',
    description: `Updates the webhook configuration for a repository. To update more information about the webhook, including the \`active\` state and \`events\`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."

OAuth app tokens and personal access tokens (classic) need the \`write:repo_hook\` or \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposUpdateWebhookConfigForRepoParamsSchema
  })
  async reposUpdateWebhookConfigForRepo(
    params: github.ReposUpdateWebhookConfigForRepoParams
  ): Promise<github.ReposUpdateWebhookConfigForRepoResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/config`,
        {
          json: pick(params, 'url', 'content_type', 'secret', 'insecure_ssl')
        }
      )
      .json<github.ReposUpdateWebhookConfigForRepoResponse>()
  }

  /**
   * Returns a list of webhook deliveries for a webhook configured in a repository.
   */
  @aiFunction({
    name: 'repos_list_webhook_deliveries',
    description: `Returns a list of webhook deliveries for a webhook configured in a repository.`,
    inputSchema: github.ReposListWebhookDeliveriesParamsSchema
  })
  async reposListWebhookDeliveries(
    params: github.ReposListWebhookDeliveriesParams
  ): Promise<github.ReposListWebhookDeliveriesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/deliveries`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'cursor'))
        }
      )
      .json<github.ReposListWebhookDeliveriesResponse>()
  }

  /**
   * Returns a delivery for a webhook configured in a repository.
   */
  @aiFunction({
    name: 'repos_get_webhook_delivery',
    description: `Returns a delivery for a webhook configured in a repository.`,
    inputSchema: github.ReposGetWebhookDeliveryParamsSchema
  })
  async reposGetWebhookDelivery(
    params: github.ReposGetWebhookDeliveryParams
  ): Promise<github.ReposGetWebhookDeliveryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/deliveries/${params.delivery_id}`,
        {}
      )
      .json<github.ReposGetWebhookDeliveryResponse>()
  }

  /**
   * Redeliver a webhook delivery for a webhook configured in a repository.
   */
  @aiFunction({
    name: 'repos_redeliver_webhook_delivery',
    description: `Redeliver a webhook delivery for a webhook configured in a repository.`,
    inputSchema: github.ReposRedeliverWebhookDeliveryParamsSchema
  })
  async reposRedeliverWebhookDelivery(
    params: github.ReposRedeliverWebhookDeliveryParams
  ): Promise<github.ReposRedeliverWebhookDeliveryResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/deliveries/${params.delivery_id}/attempts`,
        {}
      )
      .json<github.ReposRedeliverWebhookDeliveryResponse>()
  }

  /**
   * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
   */
  @aiFunction({
    name: 'repos_ping_webhook',
    description: `This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.`,
    inputSchema: github.ReposPingWebhookParamsSchema
  })
  async reposPingWebhook(
    params: github.ReposPingWebhookParams
  ): Promise<github.ReposPingWebhookResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/pings`,
        {}
      )
      .json<github.ReposPingWebhookResponse>()
  }

  /**
 * This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.

> [!NOTE]
> Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
 */
  @aiFunction({
    name: 'repos_test_push_webhook',
    description: `This will trigger the hook with the latest push to the current repository if the hook is subscribed to \`push\` events. If the hook is not subscribed to \`push\` events, the server will respond with 204 but no test POST will be generated.

> [!NOTE]
> Previously \`/repos/:owner/:repo/hooks/:hook_id/test\`.`,
    inputSchema: github.ReposTestPushWebhookParamsSchema
  })
  async reposTestPushWebhook(
    params: github.ReposTestPushWebhookParams
  ): Promise<github.ReposTestPushWebhookResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/hooks/${params.hook_id}/tests`,
        {}
      )
      .json<github.ReposTestPushWebhookResponse>()
  }

  /**
 * View the progress of an import.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).

**Import status**

This section includes details about the possible values of the `status` field of the Import Progress response.

An import that does not have errors will progress through these steps:

*   `detecting` - the "detection" step of the import is in progress because the request did not include a `vcs` parameter. The import is identifying the type of source control present at the URL.
*   `importing` - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include `commit_count` (the total number of raw commits that will be imported) and `percent` (0 - 100, the current progress through the import).
*   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.
*   `pushing` - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include `push_percent`, which is the percent value reported by `git push` when it is "Writing objects".
*   `complete` - the import is complete, and the repository is ready on GitHub.

If there are problems, you will see one of these in the `status` field:

*   `auth_failed` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.
*   `error` - the import encountered an error. The import progress response will include the `failed_step` and an error message. Contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information.
*   `detection_needs_auth` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.
*   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/migrations/source-imports#cancel-an-import) and [retry](https://docs.github.com/rest/migrations/source-imports#start-an-import) with the correct URL.
*   `detection_found_multiple` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a `project_choices` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.

**The project_choices field**

When multiple projects are found at the provided URL, the response hash will include a `project_choices` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.

**Git LFS related fields**

This section includes details about Git LFS related fields that may be present in the Import Progress response.

*   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
*   `has_large_files` - the boolean value describing whether files larger than 100MB were found during the `importing` step.
*   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the originating repository.
*   `large_files_count` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a "Get Large Files" request.
 */
  @aiFunction({
    name: 'migrations_get_import_status',
    description: `View the progress of an import.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).

**Import status**

This section includes details about the possible values of the \`status\` field of the Import Progress response.

An import that does not have errors will progress through these steps:

*   \`detecting\` - the "detection" step of the import is in progress because the request did not include a \`vcs\` parameter. The import is identifying the type of source control present at the URL.
*   \`importing\` - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include \`commit_count\` (the total number of raw commits that will be imported) and \`percent\` (0 - 100, the current progress through the import).
*   \`mapping\` - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.
*   \`pushing\` - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include \`push_percent\`, which is the percent value reported by \`git push\` when it is "Writing objects".
*   \`complete\` - the import is complete, and the repository is ready on GitHub.

If there are problems, you will see one of these in the \`status\` field:

*   \`auth_failed\` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.
*   \`error\` - the import encountered an error. The import progress response will include the \`failed_step\` and an error message. Contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information.
*   \`detection_needs_auth\` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.
*   \`detection_found_nothing\` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/migrations/source-imports#cancel-an-import) and [retry](https://docs.github.com/rest/migrations/source-imports#start-an-import) with the correct URL.
*   \`detection_found_multiple\` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a \`project_choices\` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.

**The project_choices field**

When multiple projects are found at the provided URL, the response hash will include a \`project_choices\` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.

**Git LFS related fields**

This section includes details about Git LFS related fields that may be present in the Import Progress response.

*   \`use_lfs\` - describes whether the import has been opted in or out of using Git LFS. The value can be \`opt_in\`, \`opt_out\`, or \`undecided\` if no action has been taken.
*   \`has_large_files\` - the boolean value describing whether files larger than 100MB were found during the \`importing\` step.
*   \`large_files_size\` - the total size in gigabytes of files larger than 100MB found in the originating repository.
*   \`large_files_count\` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a "Get Large Files" request.`,
    inputSchema: github.MigrationsGetImportStatusParamsSchema
  })
  async migrationsGetImportStatus(
    params: github.MigrationsGetImportStatusParams
  ): Promise<github.MigrationsGetImportStatusResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/import`, {})
      .json<github.MigrationsGetImportStatusResponse>()
  }

  /**
 * Start a source import to a GitHub repository using GitHub Importer.
Importing into a GitHub repository with GitHub Actions enabled is not supported and will
return a status `422 Unprocessable Entity` response.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_start_import',
    description: `Start a source import to a GitHub repository using GitHub Importer.
Importing into a GitHub repository with GitHub Actions enabled is not supported and will
return a status \`422 Unprocessable Entity\` response.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsStartImportParamsSchema
  })
  async migrationsStartImport(
    params: github.MigrationsStartImportParams
  ): Promise<github.MigrationsStartImportResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/import`, {
        json: pick(
          params,
          'vcs_url',
          'vcs',
          'vcs_username',
          'vcs_password',
          'tfvc_project'
        )
      })
      .json<github.MigrationsStartImportResponse>()
  }

  /**
 * Stop an import for a repository.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_cancel_import',
    description: `Stop an import for a repository.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsCancelImportParamsSchema
  })
  async migrationsCancelImport(
    params: github.MigrationsCancelImportParams
  ): Promise<github.MigrationsCancelImportResponse> {
    return this.ky
      .delete(`/repos/${params.owner}/${params.repo}/import`, {})
      .json<github.MigrationsCancelImportResponse>()
  }

  /**
 * An import can be updated with credentials or a project choice by passing in the appropriate parameters in this API
request. If no parameters are provided, the import will be restarted.

Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the import progress will
have the status `detection_found_multiple` and the Import Progress response will include a `project_choices` array.
You can select the project to import by providing one of the objects in the `project_choices` array in the update request.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_update_import',
    description: `An import can be updated with credentials or a project choice by passing in the appropriate parameters in this API
request. If no parameters are provided, the import will be restarted.

Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the import progress will
have the status \`detection_found_multiple\` and the Import Progress response will include a \`project_choices\` array.
You can select the project to import by providing one of the objects in the \`project_choices\` array in the update request.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsUpdateImportParamsSchema
  })
  async migrationsUpdateImport(
    params: github.MigrationsUpdateImportParams
  ): Promise<github.MigrationsUpdateImportResponse> {
    return this.ky
      .patch(`/repos/${params.owner}/${params.repo}/import`, {
        json: pick(
          params,
          'vcs_username',
          'vcs_password',
          'vcs',
          'tfvc_project'
        )
      })
      .json<github.MigrationsUpdateImportResponse>()
  }

  /**
 * Each type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username `hubot` into something like `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.

This endpoint and the [Map a commit author](https://docs.github.com/rest/migrations/source-imports#map-a-commit-author) endpoint allow you to provide correct Git author information.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_get_commit_authors',
    description: `Each type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username \`hubot\` into something like \`hubot <hubot@12341234-abab-fefe-8787-fedcba987654>\`.

This endpoint and the [Map a commit author](https://docs.github.com/rest/migrations/source-imports#map-a-commit-author) endpoint allow you to provide correct Git author information.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsGetCommitAuthorsParamsSchema
  })
  async migrationsGetCommitAuthors(
    params: github.MigrationsGetCommitAuthorsParams
  ): Promise<github.MigrationsGetCommitAuthorsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/import/authors`, {
        searchParams: sanitizeSearchParams(pick(params, 'since'))
      })
      .json<github.MigrationsGetCommitAuthorsResponse>()
  }

  /**
 * Update an author's identity for the import. Your application can continue updating authors any time before you push
new commits to the repository.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_map_commit_author',
    description: `Update an author's identity for the import. Your application can continue updating authors any time before you push
new commits to the repository.

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsMapCommitAuthorParamsSchema
  })
  async migrationsMapCommitAuthor(
    params: github.MigrationsMapCommitAuthorParams
  ): Promise<github.MigrationsMapCommitAuthorResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/import/authors/${params.author_id}`,
        {
          json: pick(params, 'email', 'name')
        }
      )
      .json<github.MigrationsMapCommitAuthorResponse>()
  }

  /**
 * List files larger than 100MB found during the import

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_get_large_files',
    description: `List files larger than 100MB found during the import

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsGetLargeFilesParamsSchema
  })
  async migrationsGetLargeFiles(
    params: github.MigrationsGetLargeFilesParams
  ): Promise<github.MigrationsGetLargeFilesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/import/large_files`, {})
      .json<github.MigrationsGetLargeFilesResponse>()
  }

  /**
 * You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability
is powered by [Git LFS](https://git-lfs.com).

You can learn more about our LFS feature and working with large files [on our help
site](https://docs.github.com/repositories/working-with-files/managing-large-files).

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 */
  @aiFunction({
    name: 'migrations_set_lfs_preference',
    description: `You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability
is powered by [Git LFS](https://git-lfs.com).

You can learn more about our LFS feature and working with large files [on our help
site](https://docs.github.com/repositories/working-with-files/managing-large-files).

> [!WARNING]
> **Endpoint closing down notice:** Due to very low levels of usage and available alternatives, this endpoint is closing down and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).`,
    inputSchema: github.MigrationsSetLfsPreferenceParamsSchema
  })
  async migrationsSetLfsPreference(
    params: github.MigrationsSetLfsPreferenceParams
  ): Promise<github.MigrationsSetLfsPreferenceResponse> {
    return this.ky
      .patch(`/repos/${params.owner}/${params.repo}/import/lfs`, {
        json: pick(params, 'use_lfs')
      })
      .json<github.MigrationsSetLfsPreferenceResponse>()
  }

  /**
 * Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_repo_installation',
    description: `Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetRepoInstallationParamsSchema
  })
  async appsGetRepoInstallation(
    params: github.AppsGetRepoInstallationParams
  ): Promise<github.AppsGetRepoInstallationResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/installation`, {})
      .json<github.AppsGetRepoInstallationResponse>()
  }

  /**
   * Shows which type of GitHub user can interact with this repository and when the restriction expires. If there are no restrictions, you will see an empty response.
   */
  @aiFunction({
    name: 'interactions_get_restrictions_for_repo',
    description: `Shows which type of GitHub user can interact with this repository and when the restriction expires. If there are no restrictions, you will see an empty response.`,
    inputSchema: github.InteractionsGetRestrictionsForRepoParamsSchema
  })
  async interactionsGetRestrictionsForRepo(
    params: github.InteractionsGetRestrictionsForRepoParams
  ): Promise<github.InteractionsGetRestrictionsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/interaction-limits`, {})
      .json<github.InteractionsGetRestrictionsForRepoResponse>()
  }

  /**
   * Temporarily restricts interactions to a certain type of GitHub user within the given repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
   */
  @aiFunction({
    name: 'interactions_set_restrictions_for_repo',
    description: `Temporarily restricts interactions to a certain type of GitHub user within the given repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the user or organization that owns this repository, you will receive a \`409 Conflict\` response and will not be able to use this endpoint to change the interaction limit for a single repository.`,
    inputSchema: github.InteractionsSetRestrictionsForRepoParamsSchema
  })
  async interactionsSetRestrictionsForRepo(
    params: github.InteractionsSetRestrictionsForRepoParams
  ): Promise<github.InteractionsSetRestrictionsForRepoResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/interaction-limits`, {
        json: pick(params, 'limit', 'expiry')
      })
      .json<github.InteractionsSetRestrictionsForRepoResponse>()
  }

  /**
   * Removes all interaction restrictions from the given repository. You must have owner or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
   */
  @aiFunction({
    name: 'interactions_remove_restrictions_for_repo',
    description: `Removes all interaction restrictions from the given repository. You must have owner or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this repository, you will receive a \`409 Conflict\` response and will not be able to use this endpoint to change the interaction limit for a single repository.`,
    inputSchema: github.InteractionsRemoveRestrictionsForRepoParamsSchema
  })
  async interactionsRemoveRestrictionsForRepo(
    params: github.InteractionsRemoveRestrictionsForRepoParams
  ): Promise<github.InteractionsRemoveRestrictionsForRepoResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/interaction-limits`,
        {}
      )
      .json<github.InteractionsRemoveRestrictionsForRepoResponse>()
  }

  /**
   * When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
   */
  @aiFunction({
    name: 'repos_list_invitations',
    description: `When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.`,
    inputSchema: github.ReposListInvitationsParamsSchema
  })
  async reposListInvitations(
    params: github.ReposListInvitationsParams
  ): Promise<github.ReposListInvitationsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/invitations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListInvitationsResponse>()
  }

  /**
   * Delete a repository invitation.
   */
  @aiFunction({
    name: 'repos_delete_invitation',
    description: `Delete a repository invitation.`,
    inputSchema: github.ReposDeleteInvitationParamsSchema
  })
  async reposDeleteInvitation(
    params: github.ReposDeleteInvitationParams
  ): Promise<github.ReposDeleteInvitationResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/invitations/${params.invitation_id}`,
        {}
      )
      .json<github.ReposDeleteInvitationResponse>()
  }

  /**
   * Update a repository invitation.
   */
  @aiFunction({
    name: 'repos_update_invitation',
    description: `Update a repository invitation.`,
    inputSchema: github.ReposUpdateInvitationParamsSchema
  })
  async reposUpdateInvitation(
    params: github.ReposUpdateInvitationParams
  ): Promise<github.ReposUpdateInvitationResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/invitations/${params.invitation_id}`,
        {
          json: pick(params, 'permissions')
        }
      )
      .json<github.ReposUpdateInvitationResponse>()
  }

  /**
 * List issues in a repository. Only open issues will be listed.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_for_repo',
    description: `List issues in a repository. Only open issues will be listed.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the \`pull_request\` key. Be aware that the \`id\` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListForRepoParamsSchema
  })
  async issuesListForRepo(
    params: github.IssuesListForRepoParams
  ): Promise<github.IssuesListForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/issues`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'milestone',
            'state',
            'assignee',
            'type',
            'creator',
            'mentioned',
            'labels',
            'sort',
            'direction',
            'since',
            'per_page',
            'page'
          )
        )
      })
      .json<github.IssuesListForRepoResponse>()
  }

  /**
 * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_create',
    description: `Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a \`410 Gone\` status.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesCreateParamsSchema
  })
  async issuesCreate(
    params: github.IssuesCreateParams
  ): Promise<github.IssuesCreateResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/issues`, {
        json: pick(
          params,
          'title',
          'body',
          'assignee',
          'milestone',
          'labels',
          'assignees',
          'type'
        )
      })
      .json<github.IssuesCreateResponse>()
  }

  /**
 * You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.

By default, issue comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_comments_for_repo',
    description: `You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.

By default, issue comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListCommentsForRepoParamsSchema
  })
  async issuesListCommentsForRepo(
    params: github.IssuesListCommentsForRepoParams
  ): Promise<github.IssuesListCommentsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/issues/comments`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'since', 'per_page', 'page')
        )
      })
      .json<github.IssuesListCommentsForRepoResponse>()
  }

  /**
 * You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_get_comment',
    description: `You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesGetCommentParamsSchema
  })
  async issuesGetComment(
    params: github.IssuesGetCommentParams
  ): Promise<github.IssuesGetCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}`,
        {}
      )
      .json<github.IssuesGetCommentResponse>()
  }

  /**
   * You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
   */
  @aiFunction({
    name: 'issues_delete_comment',
    description: `You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.`,
    inputSchema: github.IssuesDeleteCommentParamsSchema
  })
  async issuesDeleteComment(
    params: github.IssuesDeleteCommentParams
  ): Promise<github.IssuesDeleteCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}`,
        {}
      )
      .json<github.IssuesDeleteCommentResponse>()
  }

  /**
 * You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_update_comment',
    description: `You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesUpdateCommentParamsSchema
  })
  async issuesUpdateComment(
    params: github.IssuesUpdateCommentParams
  ): Promise<github.IssuesUpdateCommentResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.IssuesUpdateCommentResponse>()
  }

  /**
   * List the reactions to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
   */
  @aiFunction({
    name: 'reactions_list_for_issue_comment',
    description: `List the reactions to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).`,
    inputSchema: github.ReactionsListForIssueCommentParamsSchema
  })
  async reactionsListForIssueComment(
    params: github.ReactionsListForIssueCommentParams
  ): Promise<github.ReactionsListForIssueCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForIssueCommentResponse>()
  }

  /**
   * Create a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
   */
  @aiFunction({
    name: 'reactions_create_for_issue_comment',
    description: `Create a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment). A response with an HTTP \`200\` status means that you already added the reaction type to this issue comment.`,
    inputSchema: github.ReactionsCreateForIssueCommentParamsSchema
  })
  async reactionsCreateForIssueComment(
    params: github.ReactionsCreateForIssueCommentParams
  ): Promise<github.ReactionsCreateForIssueCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForIssueCommentResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
 */
  @aiFunction({
    name: 'reactions_delete_for_issue_comment',
    description: `> [!NOTE]
> You can also specify a repository by \`repository_id\` using the route \`DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id\`.

Delete a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).`,
    inputSchema: github.ReactionsDeleteForIssueCommentParamsSchema
  })
  async reactionsDeleteForIssueComment(
    params: github.ReactionsDeleteForIssueCommentParams
  ): Promise<github.ReactionsDeleteForIssueCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/comments/${params.comment_id}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForIssueCommentResponse>()
  }

  /**
   * Lists events for a repository.
   */
  @aiFunction({
    name: 'issues_list_events_for_repo',
    description: `Lists events for a repository.`,
    inputSchema: github.IssuesListEventsForRepoParamsSchema
  })
  async issuesListEventsForRepo(
    params: github.IssuesListEventsForRepoParams
  ): Promise<github.IssuesListEventsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/issues/events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.IssuesListEventsForRepoResponse>()
  }

  /**
   * Gets a single event by the event id.
   */
  @aiFunction({
    name: 'issues_get_event',
    description: `Gets a single event by the event id.`,
    inputSchema: github.IssuesGetEventParamsSchema
  })
  async issuesGetEvent(
    params: github.IssuesGetEventParams
  ): Promise<github.IssuesGetEventResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/events/${params.event_id}`,
        {}
      )
      .json<github.IssuesGetEventResponse>()
  }

  /**
 * The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was
[transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_get',
    description: `The API returns a [\`301 Moved Permanently\` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was
[transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
returns a \`404 Not Found\` status. If the issue was deleted from a repository where the authenticated user has read
access, the API returns a \`410 Gone\` status. To receive webhook events for transferred and deleted issues, subscribe
to the [\`issues\`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the \`pull_request\` key. Be aware that the \`id\` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesGetParamsSchema
  })
  async issuesGet(
    params: github.IssuesGetParams
  ): Promise<github.IssuesGetResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}`,
        {}
      )
      .json<github.IssuesGetResponse>()
  }

  /**
 * Issue owners and users with push access or Triage role can edit an issue.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_update',
    description: `Issue owners and users with push access or Triage role can edit an issue.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesUpdateParamsSchema
  })
  async issuesUpdate(
    params: github.IssuesUpdateParams
  ): Promise<github.IssuesUpdateResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}`,
        {
          json: pick(
            params,
            'title',
            'body',
            'assignee',
            'state',
            'state_reason',
            'milestone',
            'labels',
            'assignees',
            'type'
          )
        }
      )
      .json<github.IssuesUpdateResponse>()
  }

  /**
   * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
   */
  @aiFunction({
    name: 'issues_add_assignees',
    description: `Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.`,
    inputSchema: github.IssuesAddAssigneesParamsSchema
  })
  async issuesAddAssignees(
    params: github.IssuesAddAssigneesParams
  ): Promise<github.IssuesAddAssigneesResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/assignees`,
        {
          json: pick(params, 'assignees')
        }
      )
      .json<github.IssuesAddAssigneesResponse>()
  }

  /**
   * Removes one or more assignees from an issue.
   */
  @aiFunction({
    name: 'issues_remove_assignees',
    description: `Removes one or more assignees from an issue.`,
    inputSchema: github.IssuesRemoveAssigneesParamsSchema
  })
  async issuesRemoveAssignees(
    params: github.IssuesRemoveAssigneesParams
  ): Promise<github.IssuesRemoveAssigneesResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/assignees`,
        {
          json: pick(params, 'assignees')
        }
      )
      .json<github.IssuesRemoveAssigneesResponse>()
  }

  /**
 * Checks if a user has permission to be assigned to a specific issue.

If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.

Otherwise a `404` status code is returned.
 */
  @aiFunction({
    name: 'issues_check_user_can_be_assigned_to_issue',
    description: `Checks if a user has permission to be assigned to a specific issue.

If the \`assignee\` can be assigned to this issue, a \`204\` status code with no content is returned.

Otherwise a \`404\` status code is returned.`,
    inputSchema: github.IssuesCheckUserCanBeAssignedToIssueParamsSchema
  })
  async issuesCheckUserCanBeAssignedToIssue(
    params: github.IssuesCheckUserCanBeAssignedToIssueParams
  ): Promise<github.IssuesCheckUserCanBeAssignedToIssueResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/assignees/${params.assignee}`,
        {}
      )
      .json<github.IssuesCheckUserCanBeAssignedToIssueResponse>()
  }

  /**
 * You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

Issue comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_comments',
    description: `You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

Issue comments are ordered by ascending ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListCommentsParamsSchema
  })
  async issuesListComments(
    params: github.IssuesListCommentsParams
  ): Promise<github.IssuesListCommentsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/comments`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'since', 'per_page', 'page')
          )
        }
      )
      .json<github.IssuesListCommentsResponse>()
  }

  /**
 * You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
Creating content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_create_comment',
    description: `You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
Creating content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesCreateCommentParamsSchema
  })
  async issuesCreateComment(
    params: github.IssuesCreateCommentParams
  ): Promise<github.IssuesCreateCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/comments`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.IssuesCreateCommentResponse>()
  }

  /**
   * Lists all events for an issue.
   */
  @aiFunction({
    name: 'issues_list_events',
    description: `Lists all events for an issue.`,
    inputSchema: github.IssuesListEventsParamsSchema
  })
  async issuesListEvents(
    params: github.IssuesListEventsParams
  ): Promise<github.IssuesListEventsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/events`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.IssuesListEventsResponse>()
  }

  /**
   * Lists all labels for an issue.
   */
  @aiFunction({
    name: 'issues_list_labels_on_issue',
    description: `Lists all labels for an issue.`,
    inputSchema: github.IssuesListLabelsOnIssueParamsSchema
  })
  async issuesListLabelsOnIssue(
    params: github.IssuesListLabelsOnIssueParams
  ): Promise<github.IssuesListLabelsOnIssueResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/labels`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.IssuesListLabelsOnIssueResponse>()
  }

  /**
   * Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue. .
   */
  @aiFunction({
    name: 'issues_add_labels',
    description: `Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue. .`,
    // TODO: Improve handling of union params
    inputSchema: github.IssuesAddLabelsParamsSchema as any
  })
  async issuesAddLabels(
    params: github.IssuesAddLabelsParams
  ): Promise<github.IssuesAddLabelsResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/labels`,
        {
          json: params
        }
      )
      .json<github.IssuesAddLabelsResponse>()
  }

  /**
   * Removes any previous labels and sets the new labels for an issue.
   */
  @aiFunction({
    name: 'issues_set_labels',
    description: `Removes any previous labels and sets the new labels for an issue.`,
    // TODO: Improve handling of union params
    inputSchema: github.IssuesSetLabelsParamsSchema as any
  })
  async issuesSetLabels(
    params: github.IssuesSetLabelsParams
  ): Promise<github.IssuesSetLabelsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/labels`,
        {
          json: params
        }
      )
      .json<github.IssuesSetLabelsResponse>()
  }

  /**
   * Removes all labels from an issue.
   */
  @aiFunction({
    name: 'issues_remove_all_labels',
    description: `Removes all labels from an issue.`,
    inputSchema: github.IssuesRemoveAllLabelsParamsSchema
  })
  async issuesRemoveAllLabels(
    params: github.IssuesRemoveAllLabelsParams
  ): Promise<github.IssuesRemoveAllLabelsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/labels`,
        {}
      )
      .json<github.IssuesRemoveAllLabelsResponse>()
  }

  /**
   * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
   */
  @aiFunction({
    name: 'issues_remove_label',
    description: `Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a \`404 Not Found\` status if the label does not exist.`,
    inputSchema: github.IssuesRemoveLabelParamsSchema
  })
  async issuesRemoveLabel(
    params: github.IssuesRemoveLabelParams
  ): Promise<github.IssuesRemoveLabelResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/labels/${params.name}`,
        {}
      )
      .json<github.IssuesRemoveLabelResponse>()
  }

  /**
 * Users with push access can lock an issue or pull request's conversation.

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
 */
  @aiFunction({
    name: 'issues_lock',
    description: `Users with push access can lock an issue or pull request's conversation.

Note that, if you choose not to pass any parameters, you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.IssuesLockParamsSchema
  })
  async issuesLock(
    params: github.IssuesLockParams
  ): Promise<github.IssuesLockResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/lock`,
        {
          json: pick(params, 'lock_reason')
        }
      )
      .json<github.IssuesLockResponse>()
  }

  /**
   * Users with push access can unlock an issue's conversation.
   */
  @aiFunction({
    name: 'issues_unlock',
    description: `Users with push access can unlock an issue's conversation.`,
    inputSchema: github.IssuesUnlockParamsSchema
  })
  async issuesUnlock(
    params: github.IssuesUnlockParams
  ): Promise<github.IssuesUnlockResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/lock`,
        {}
      )
      .json<github.IssuesUnlockResponse>()
  }

  /**
   * List the reactions to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
   */
  @aiFunction({
    name: 'reactions_list_for_issue',
    description: `List the reactions to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).`,
    inputSchema: github.ReactionsListForIssueParamsSchema
  })
  async reactionsListForIssue(
    params: github.ReactionsListForIssueParams
  ): Promise<github.ReactionsListForIssueResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForIssueResponse>()
  }

  /**
   * Create a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue). A response with an HTTP `200` status means that you already added the reaction type to this issue.
   */
  @aiFunction({
    name: 'reactions_create_for_issue',
    description: `Create a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue). A response with an HTTP \`200\` status means that you already added the reaction type to this issue.`,
    inputSchema: github.ReactionsCreateForIssueParamsSchema
  })
  async reactionsCreateForIssue(
    params: github.ReactionsCreateForIssueParams
  ): Promise<github.ReactionsCreateForIssueResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForIssueResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.

Delete a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
 */
  @aiFunction({
    name: 'reactions_delete_for_issue',
    description: `> [!NOTE]
> You can also specify a repository by \`repository_id\` using the route \`DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id\`.

Delete a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).`,
    inputSchema: github.ReactionsDeleteForIssueParamsSchema
  })
  async reactionsDeleteForIssue(
    params: github.ReactionsDeleteForIssueParams
  ): Promise<github.ReactionsDeleteForIssueResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForIssueResponse>()
  }

  /**
 * You can use the REST API to remove a sub-issue from an issue.
Removing content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass a specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_remove_sub_issue',
    description: `You can use the REST API to remove a sub-issue from an issue.
Removing content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass a specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesRemoveSubIssueParamsSchema
  })
  async issuesRemoveSubIssue(
    params: github.IssuesRemoveSubIssueParams
  ): Promise<github.IssuesRemoveSubIssueResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/sub_issue`,
        {
          json: pick(params, 'sub_issue_id')
        }
      )
      .json<github.IssuesRemoveSubIssueResponse>()
  }

  /**
 * You can use the REST API to list the sub-issues on an issue.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_sub_issues',
    description: `You can use the REST API to list the sub-issues on an issue.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListSubIssuesParamsSchema
  })
  async issuesListSubIssues(
    params: github.IssuesListSubIssuesParams
  ): Promise<github.IssuesListSubIssuesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/sub_issues`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.IssuesListSubIssuesResponse>()
  }

  /**
 * You can use the REST API to add sub-issues to issues.

Creating content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_add_sub_issue',
    description: `You can use the REST API to add sub-issues to issues.

Creating content too quickly using this endpoint may result in secondary rate limiting.
For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesAddSubIssueParamsSchema
  })
  async issuesAddSubIssue(
    params: github.IssuesAddSubIssueParams
  ): Promise<github.IssuesAddSubIssueResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/sub_issues`,
        {
          json: pick(params, 'sub_issue_id', 'replace_parent')
        }
      )
      .json<github.IssuesAddSubIssueResponse>()
  }

  /**
   * You can use the REST API to reprioritize a sub-issue to a different position in the parent list.
   */
  @aiFunction({
    name: 'issues_reprioritize_sub_issue',
    description: `You can use the REST API to reprioritize a sub-issue to a different position in the parent list.`,
    inputSchema: github.IssuesReprioritizeSubIssueParamsSchema
  })
  async issuesReprioritizeSubIssue(
    params: github.IssuesReprioritizeSubIssueParams
  ): Promise<github.IssuesReprioritizeSubIssueResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/sub_issues/priority`,
        {
          json: pick(params, 'sub_issue_id', 'after_id', 'before_id')
        }
      )
      .json<github.IssuesReprioritizeSubIssueResponse>()
  }

  /**
   * List all timeline events for an issue.
   */
  @aiFunction({
    name: 'issues_list_events_for_timeline',
    description: `List all timeline events for an issue.`,
    inputSchema: github.IssuesListEventsForTimelineParamsSchema
  })
  async issuesListEventsForTimeline(
    params: github.IssuesListEventsForTimelineParams
  ): Promise<github.IssuesListEventsForTimelineResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/issues/${params.issue_number}/timeline`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.IssuesListEventsForTimelineResponse>()
  }

  /**
   * List deploy keys.
   */
  @aiFunction({
    name: 'repos_list_deploy_keys',
    description: `List deploy keys.`,
    inputSchema: github.ReposListDeployKeysParamsSchema
  })
  async reposListDeployKeys(
    params: github.ReposListDeployKeysParams
  ): Promise<github.ReposListDeployKeysResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/keys`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListDeployKeysResponse>()
  }

  /**
   * You can create a read-only deploy key.
   */
  @aiFunction({
    name: 'repos_create_deploy_key',
    description: `You can create a read-only deploy key.`,
    inputSchema: github.ReposCreateDeployKeyParamsSchema
  })
  async reposCreateDeployKey(
    params: github.ReposCreateDeployKeyParams
  ): Promise<github.ReposCreateDeployKeyResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/keys`, {
        json: pick(params, 'title', 'key', 'read_only')
      })
      .json<github.ReposCreateDeployKeyResponse>()
  }

  /**
   * Get a deploy key.
   */
  @aiFunction({
    name: 'repos_get_deploy_key',
    description: `Get a deploy key.`,
    inputSchema: github.ReposGetDeployKeyParamsSchema
  })
  async reposGetDeployKey(
    params: github.ReposGetDeployKeyParams
  ): Promise<github.ReposGetDeployKeyResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/keys/${params.key_id}`,
        {}
      )
      .json<github.ReposGetDeployKeyResponse>()
  }

  /**
   * Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
   */
  @aiFunction({
    name: 'repos_delete_deploy_key',
    description: `Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.`,
    inputSchema: github.ReposDeleteDeployKeyParamsSchema
  })
  async reposDeleteDeployKey(
    params: github.ReposDeleteDeployKeyParams
  ): Promise<github.ReposDeleteDeployKeyResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/keys/${params.key_id}`,
        {}
      )
      .json<github.ReposDeleteDeployKeyResponse>()
  }

  /**
   * Lists all labels for a repository.
   */
  @aiFunction({
    name: 'issues_list_labels_for_repo',
    description: `Lists all labels for a repository.`,
    inputSchema: github.IssuesListLabelsForRepoParamsSchema
  })
  async issuesListLabelsForRepo(
    params: github.IssuesListLabelsForRepoParams
  ): Promise<github.IssuesListLabelsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/labels`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.IssuesListLabelsForRepoResponse>()
  }

  /**
   * Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).
   */
  @aiFunction({
    name: 'issues_create_label',
    description: `Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).`,
    inputSchema: github.IssuesCreateLabelParamsSchema
  })
  async issuesCreateLabel(
    params: github.IssuesCreateLabelParams
  ): Promise<github.IssuesCreateLabelResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/labels`, {
        json: pick(params, 'name', 'color', 'description')
      })
      .json<github.IssuesCreateLabelResponse>()
  }

  /**
   * Gets a label using the given name.
   */
  @aiFunction({
    name: 'issues_get_label',
    description: `Gets a label using the given name.`,
    inputSchema: github.IssuesGetLabelParamsSchema
  })
  async issuesGetLabel(
    params: github.IssuesGetLabelParams
  ): Promise<github.IssuesGetLabelResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/labels/${params.name}`,
        {}
      )
      .json<github.IssuesGetLabelResponse>()
  }

  /**
   * Deletes a label using the given label name.
   */
  @aiFunction({
    name: 'issues_delete_label',
    description: `Deletes a label using the given label name.`,
    inputSchema: github.IssuesDeleteLabelParamsSchema
  })
  async issuesDeleteLabel(
    params: github.IssuesDeleteLabelParams
  ): Promise<github.IssuesDeleteLabelResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/labels/${params.name}`,
        {}
      )
      .json<github.IssuesDeleteLabelResponse>()
  }

  /**
   * Updates a label using the given label name.
   */
  @aiFunction({
    name: 'issues_update_label',
    description: `Updates a label using the given label name.`,
    inputSchema: github.IssuesUpdateLabelParamsSchema
  })
  async issuesUpdateLabel(
    params: github.IssuesUpdateLabelParams
  ): Promise<github.IssuesUpdateLabelResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/labels/${params.name}`,
        {
          json: pick(params, 'new_name', 'color', 'description')
        }
      )
      .json<github.IssuesUpdateLabelResponse>()
  }

  /**
   * Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
   */
  @aiFunction({
    name: 'repos_list_languages',
    description: `Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.`,
    inputSchema: github.ReposListLanguagesParamsSchema
  })
  async reposListLanguages(
    params: github.ReposListLanguagesParams
  ): Promise<github.ReposListLanguagesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/languages`, {})
      .json<github.ReposListLanguagesResponse>()
  }

  /**
 * This method returns the contents of the repository's license file, if one is detected.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw contents of the license.
- **`application/vnd.github.html+json`**: Returns the license contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
 */
  @aiFunction({
    name: 'licenses_get_for_repo',
    description: `This method returns the contents of the repository's license file, if one is detected.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw contents of the license.
- **\`application/vnd.github.html+json\`**: Returns the license contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).`,
    inputSchema: github.LicensesGetForRepoParamsSchema
  })
  async licensesGetForRepo(
    params: github.LicensesGetForRepoParams
  ): Promise<github.LicensesGetForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/license`, {
        searchParams: sanitizeSearchParams(pick(params, 'ref'))
      })
      .json<github.LicensesGetForRepoResponse>()
  }

  /**
   * Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
   */
  @aiFunction({
    name: 'repos_merge_upstream',
    description: `Sync a branch of a forked repository to keep it up-to-date with the upstream repository.`,
    inputSchema: github.ReposMergeUpstreamParamsSchema
  })
  async reposMergeUpstream(
    params: github.ReposMergeUpstreamParams
  ): Promise<github.ReposMergeUpstreamResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/merge-upstream`, {
        json: pick(params, 'branch')
      })
      .json<github.ReposMergeUpstreamResponse>()
  }

  /**
   * Merge a branch.
   */
  @aiFunction({
    name: 'repos_merge',
    description: `Merge a branch.`,
    inputSchema: github.ReposMergeParamsSchema
  })
  async reposMerge(
    params: github.ReposMergeParams
  ): Promise<github.ReposMergeResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/merges`, {
        json: pick(params, 'base', 'head', 'commit_message')
      })
      .json<github.ReposMergeResponse>()
  }

  /**
   * Lists milestones for a repository.
   */
  @aiFunction({
    name: 'issues_list_milestones',
    description: `Lists milestones for a repository.`,
    inputSchema: github.IssuesListMilestonesParamsSchema
  })
  async issuesListMilestones(
    params: github.IssuesListMilestonesParams
  ): Promise<github.IssuesListMilestonesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/milestones`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'state', 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.IssuesListMilestonesResponse>()
  }

  /**
   * Creates a milestone.
   */
  @aiFunction({
    name: 'issues_create_milestone',
    description: `Creates a milestone.`,
    inputSchema: github.IssuesCreateMilestoneParamsSchema
  })
  async issuesCreateMilestone(
    params: github.IssuesCreateMilestoneParams
  ): Promise<github.IssuesCreateMilestoneResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/milestones`, {
        json: pick(params, 'title', 'state', 'description', 'due_on')
      })
      .json<github.IssuesCreateMilestoneResponse>()
  }

  /**
   * Gets a milestone using the given milestone number.
   */
  @aiFunction({
    name: 'issues_get_milestone',
    description: `Gets a milestone using the given milestone number.`,
    inputSchema: github.IssuesGetMilestoneParamsSchema
  })
  async issuesGetMilestone(
    params: github.IssuesGetMilestoneParams
  ): Promise<github.IssuesGetMilestoneResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/milestones/${params.milestone_number}`,
        {}
      )
      .json<github.IssuesGetMilestoneResponse>()
  }

  /**
   * Deletes a milestone using the given milestone number.
   */
  @aiFunction({
    name: 'issues_delete_milestone',
    description: `Deletes a milestone using the given milestone number.`,
    inputSchema: github.IssuesDeleteMilestoneParamsSchema
  })
  async issuesDeleteMilestone(
    params: github.IssuesDeleteMilestoneParams
  ): Promise<github.IssuesDeleteMilestoneResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/milestones/${params.milestone_number}`,
        {}
      )
      .json<github.IssuesDeleteMilestoneResponse>()
  }

  /**
   * Update a milestone.
   */
  @aiFunction({
    name: 'issues_update_milestone',
    description: `Update a milestone.`,
    inputSchema: github.IssuesUpdateMilestoneParamsSchema
  })
  async issuesUpdateMilestone(
    params: github.IssuesUpdateMilestoneParams
  ): Promise<github.IssuesUpdateMilestoneResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/milestones/${params.milestone_number}`,
        {
          json: pick(params, 'title', 'state', 'description', 'due_on')
        }
      )
      .json<github.IssuesUpdateMilestoneResponse>()
  }

  /**
   * Lists labels for issues in a milestone.
   */
  @aiFunction({
    name: 'issues_list_labels_for_milestone',
    description: `Lists labels for issues in a milestone.`,
    inputSchema: github.IssuesListLabelsForMilestoneParamsSchema
  })
  async issuesListLabelsForMilestone(
    params: github.IssuesListLabelsForMilestoneParams
  ): Promise<github.IssuesListLabelsForMilestoneResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/milestones/${params.milestone_number}/labels`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.IssuesListLabelsForMilestoneResponse>()
  }

  /**
   * Lists all notifications for the current user in the specified repository.
   */
  @aiFunction({
    name: 'activity_list_repo_notifications_for_authenticated_user',
    description: `Lists all notifications for the current user in the specified repository.`,
    inputSchema:
      github.ActivityListRepoNotificationsForAuthenticatedUserParamsSchema
  })
  async activityListRepoNotificationsForAuthenticatedUser(
    params: github.ActivityListRepoNotificationsForAuthenticatedUserParams
  ): Promise<github.ActivityListRepoNotificationsForAuthenticatedUserResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/notifications`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'all',
            'participating',
            'since',
            'before',
            'per_page',
            'page'
          )
        )
      })
      .json<github.ActivityListRepoNotificationsForAuthenticatedUserResponse>()
  }

  /**
   * Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
   */
  @aiFunction({
    name: 'activity_mark_repo_notifications_as_read',
    description: `Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a \`202 Accepted\` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter \`all=false\`.`,
    inputSchema: github.ActivityMarkRepoNotificationsAsReadParamsSchema
  })
  async activityMarkRepoNotificationsAsRead(
    params: github.ActivityMarkRepoNotificationsAsReadParams
  ): Promise<github.ActivityMarkRepoNotificationsAsReadResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/notifications`, {
        json: pick(params, 'last_read_at')
      })
      .json<github.ActivityMarkRepoNotificationsAsReadResponse>()
  }

  /**
 * Gets information about a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_pages',
    description: `Gets information about a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposGetPagesParamsSchema
  })
  async reposGetPages(
    params: github.ReposGetPagesParams
  ): Promise<github.ReposGetPagesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/pages`, {})
      .json<github.ReposGetPagesResponse>()
  }

  /**
 * Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_pages_site',
    description: `Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposCreatePagesSiteParamsSchema as any
  })
  async reposCreatePagesSite(
    params: github.ReposCreatePagesSiteParams
  ): Promise<github.ReposCreatePagesSiteResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/pages`, {
        json: params
      })
      .json<github.ReposCreatePagesSiteResponse>()
  }

  /**
 * Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_update_information_about_pages_site',
    description: `Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.ReposUpdateInformationAboutPagesSiteParamsSchema as any
  })
  async reposUpdateInformationAboutPagesSite(
    params: github.ReposUpdateInformationAboutPagesSiteParams
  ): Promise<github.ReposUpdateInformationAboutPagesSiteResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/pages`, {
        json: params
      })
      .json<github.ReposUpdateInformationAboutPagesSiteResponse>()
  }

  /**
 * Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_delete_pages_site',
    description: `Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposDeletePagesSiteParamsSchema
  })
  async reposDeletePagesSite(
    params: github.ReposDeletePagesSiteParams
  ): Promise<github.ReposDeletePagesSiteResponse> {
    return this.ky
      .delete(`/repos/${params.owner}/${params.repo}/pages`, {})
      .json<github.ReposDeletePagesSiteResponse>()
  }

  /**
 * Lists builts of a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_list_pages_builds',
    description: `Lists builts of a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposListPagesBuildsParamsSchema
  })
  async reposListPagesBuilds(
    params: github.ReposListPagesBuildsParams
  ): Promise<github.ReposListPagesBuildsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/pages/builds`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListPagesBuildsResponse>()
  }

  /**
 * You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.

Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
 */
  @aiFunction({
    name: 'repos_request_pages_build',
    description: `You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.

Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.`,
    inputSchema: github.ReposRequestPagesBuildParamsSchema
  })
  async reposRequestPagesBuild(
    params: github.ReposRequestPagesBuildParams
  ): Promise<github.ReposRequestPagesBuildResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/pages/builds`, {})
      .json<github.ReposRequestPagesBuildResponse>()
  }

  /**
 * Gets information about the single most recent build of a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_latest_pages_build',
    description: `Gets information about the single most recent build of a GitHub Pages site.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposGetLatestPagesBuildParamsSchema
  })
  async reposGetLatestPagesBuild(
    params: github.ReposGetLatestPagesBuildParams
  ): Promise<github.ReposGetLatestPagesBuildResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pages/builds/latest`,
        {}
      )
      .json<github.ReposGetLatestPagesBuildResponse>()
  }

  /**
 * Gets information about a GitHub Pages build.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_pages_build',
    description: `Gets information about a GitHub Pages build.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposGetPagesBuildParamsSchema
  })
  async reposGetPagesBuild(
    params: github.ReposGetPagesBuildParams
  ): Promise<github.ReposGetPagesBuildResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pages/builds/${params.build_id}`,
        {}
      )
      .json<github.ReposGetPagesBuildResponse>()
  }

  /**
 * Create a GitHub Pages deployment for a repository.

The authenticated user must have write permission to the repository.
 */
  @aiFunction({
    name: 'repos_create_pages_deployment',
    description: `Create a GitHub Pages deployment for a repository.

The authenticated user must have write permission to the repository.`,
    inputSchema: github.ReposCreatePagesDeploymentParamsSchema
  })
  async reposCreatePagesDeployment(
    params: github.ReposCreatePagesDeploymentParams
  ): Promise<github.ReposCreatePagesDeploymentResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/pages/deployments`, {
        json: pick(
          params,
          'artifact_id',
          'artifact_url',
          'environment',
          'pages_build_version',
          'oidc_token'
        )
      })
      .json<github.ReposCreatePagesDeploymentResponse>()
  }

  /**
 * Gets the current status of a GitHub Pages deployment.

The authenticated user must have read permission for the GitHub Pages site.
 */
  @aiFunction({
    name: 'repos_get_pages_deployment',
    description: `Gets the current status of a GitHub Pages deployment.

The authenticated user must have read permission for the GitHub Pages site.`,
    inputSchema: github.ReposGetPagesDeploymentParamsSchema
  })
  async reposGetPagesDeployment(
    params: github.ReposGetPagesDeploymentParams
  ): Promise<github.ReposGetPagesDeploymentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pages/deployments/${params.pages_deployment_id}`,
        {}
      )
      .json<github.ReposGetPagesDeploymentResponse>()
  }

  /**
 * Cancels a GitHub Pages deployment.

The authenticated user must have write permissions for the GitHub Pages site.
 */
  @aiFunction({
    name: 'repos_cancel_pages_deployment',
    description: `Cancels a GitHub Pages deployment.

The authenticated user must have write permissions for the GitHub Pages site.`,
    inputSchema: github.ReposCancelPagesDeploymentParamsSchema
  })
  async reposCancelPagesDeployment(
    params: github.ReposCancelPagesDeploymentParams
  ): Promise<github.ReposCancelPagesDeploymentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pages/deployments/${params.pages_deployment_id}/cancel`,
        {}
      )
      .json<github.ReposCancelPagesDeploymentResponse>()
  }

  /**
 * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.

The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_pages_health_check',
    description: `Gets a health check of the DNS settings for the \`CNAME\` record configured for a repository's GitHub Pages.

The first request to this endpoint returns a \`202 Accepted\` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a \`200 OK\` status with the health check results in the response.

The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.ReposGetPagesHealthCheckParamsSchema
  })
  async reposGetPagesHealthCheck(
    params: github.ReposGetPagesHealthCheckParams
  ): Promise<github.ReposGetPagesHealthCheckResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/pages/health`, {})
      .json<github.ReposGetPagesHealthCheckResponse>()
  }

  /**
   * Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".
   */
  @aiFunction({
    name: 'repos_check_private_vulnerability_reporting',
    description: `Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".`,
    inputSchema: github.ReposCheckPrivateVulnerabilityReportingParamsSchema
  })
  async reposCheckPrivateVulnerabilityReporting(
    params: github.ReposCheckPrivateVulnerabilityReportingParams
  ): Promise<github.ReposCheckPrivateVulnerabilityReportingResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/private-vulnerability-reporting`,
        {}
      )
      .json<github.ReposCheckPrivateVulnerabilityReportingResponse>()
  }

  /**
   * Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability).".
   */
  @aiFunction({
    name: 'repos_enable_private_vulnerability_reporting',
    description: `Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability).".`,
    inputSchema: github.ReposEnablePrivateVulnerabilityReportingParamsSchema
  })
  async reposEnablePrivateVulnerabilityReporting(
    params: github.ReposEnablePrivateVulnerabilityReportingParams
  ): Promise<github.ReposEnablePrivateVulnerabilityReportingResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/private-vulnerability-reporting`,
        {}
      )
      .json<github.ReposEnablePrivateVulnerabilityReportingResponse>()
  }

  /**
   * Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".
   */
  @aiFunction({
    name: 'repos_disable_private_vulnerability_reporting',
    description: `Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".`,
    inputSchema: github.ReposDisablePrivateVulnerabilityReportingParamsSchema
  })
  async reposDisablePrivateVulnerabilityReporting(
    params: github.ReposDisablePrivateVulnerabilityReportingParams
  ): Promise<github.ReposDisablePrivateVulnerabilityReportingResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/private-vulnerability-reporting`,
        {}
      )
      .json<github.ReposDisablePrivateVulnerabilityReportingResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_for_repo',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListForRepoParamsSchema
  })
  async projectsListForRepo(
    params: github.ProjectsListForRepoParams
  ): Promise<github.ProjectsListForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/projects`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'state', 'per_page', 'page')
        )
      })
      .json<github.ProjectsListForRepoResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_create_for_repo',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsCreateForRepoParamsSchema
  })
  async projectsCreateForRepo(
    params: github.ProjectsCreateForRepoParams
  ): Promise<github.ProjectsCreateForRepoResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/projects`, {
        json: pick(params, 'name', 'body')
      })
      .json<github.ProjectsCreateForRepoResponse>()
  }

  /**
 * Gets all custom property values that are set for a repository.
Users with read access to the repository can use this endpoint.
 */
  @aiFunction({
    name: 'repos_get_custom_properties_values',
    description: `Gets all custom property values that are set for a repository.
Users with read access to the repository can use this endpoint.`,
    inputSchema: github.ReposGetCustomPropertiesValuesParamsSchema
  })
  async reposGetCustomPropertiesValues(
    params: github.ReposGetCustomPropertiesValuesParams
  ): Promise<github.ReposGetCustomPropertiesValuesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/properties/values`, {})
      .json<github.ReposGetCustomPropertiesValuesResponse>()
  }

  /**
 * Create new or update existing custom property values for a repository.
Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.

Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.
 */
  @aiFunction({
    name: 'repos_create_or_update_custom_properties_values',
    description: `Create new or update existing custom property values for a repository.
Using a value of \`null\` for a custom property will remove or 'unset' the property value from the repository.

Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.`,
    inputSchema: github.ReposCreateOrUpdateCustomPropertiesValuesParamsSchema
  })
  async reposCreateOrUpdateCustomPropertiesValues(
    params: github.ReposCreateOrUpdateCustomPropertiesValuesParams
  ): Promise<github.ReposCreateOrUpdateCustomPropertiesValuesResponse> {
    return this.ky
      .patch(`/repos/${params.owner}/${params.repo}/properties/values`, {
        json: pick(params, 'properties')
      })
      .json<github.ReposCreateOrUpdateCustomPropertiesValuesResponse>()
  }

  /**
 * Lists pull requests in a specified repository.

Draft pull requests are available in public repositories with GitHub
Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing
plans, and in public and private repositories with GitHub Team and GitHub Enterprise
Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)
in the GitHub Help documentation.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list',
    description: `Lists pull requests in a specified repository.

Draft pull requests are available in public repositories with GitHub
Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing
plans, and in public and private repositories with GitHub Team and GitHub Enterprise
Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)
in the GitHub Help documentation.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListParamsSchema
  })
  async pullsList(
    params: github.PullsListParams
  ): Promise<github.PullsListResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/pulls`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'state',
            'head',
            'base',
            'sort',
            'direction',
            'per_page',
            'page'
          )
        )
      })
      .json<github.PullsListResponse>()
  }

  /**
 * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_create',
    description: `Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsCreateParamsSchema
  })
  async pullsCreate(
    params: github.PullsCreateParams
  ): Promise<github.PullsCreateResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/pulls`, {
        json: pick(
          params,
          'title',
          'head',
          'head_repo',
          'base',
          'body',
          'maintainer_can_modify',
          'draft',
          'issue'
        )
      })
      .json<github.PullsCreateResponse>()
  }

  /**
 * Lists review comments for all pull requests in a repository. By default,
review comments are in ascending order by ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_review_comments_for_repo',
    description: `Lists review comments for all pull requests in a repository. By default,
review comments are in ascending order by ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListReviewCommentsForRepoParamsSchema
  })
  async pullsListReviewCommentsForRepo(
    params: github.PullsListReviewCommentsForRepoParams
  ): Promise<github.PullsListReviewCommentsForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/pulls/comments`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'since', 'per_page', 'page')
        )
      })
      .json<github.PullsListReviewCommentsForRepoResponse>()
  }

  /**
 * Provides details for a specified review comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_get_review_comment',
    description: `Provides details for a specified review comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsGetReviewCommentParamsSchema
  })
  async pullsGetReviewComment(
    params: github.PullsGetReviewCommentParams
  ): Promise<github.PullsGetReviewCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}`,
        {}
      )
      .json<github.PullsGetReviewCommentResponse>()
  }

  /**
   * Deletes a review comment.
   */
  @aiFunction({
    name: 'pulls_delete_review_comment',
    description: `Deletes a review comment.`,
    inputSchema: github.PullsDeleteReviewCommentParamsSchema
  })
  async pullsDeleteReviewComment(
    params: github.PullsDeleteReviewCommentParams
  ): Promise<github.PullsDeleteReviewCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}`,
        {}
      )
      .json<github.PullsDeleteReviewCommentResponse>()
  }

  /**
 * Edits the content of a specified review comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_update_review_comment',
    description: `Edits the content of a specified review comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsUpdateReviewCommentParamsSchema
  })
  async pullsUpdateReviewComment(
    params: github.PullsUpdateReviewCommentParams
  ): Promise<github.PullsUpdateReviewCommentResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.PullsUpdateReviewCommentResponse>()
  }

  /**
   * List the reactions to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
   */
  @aiFunction({
    name: 'reactions_list_for_pull_request_review_comment',
    description: `List the reactions to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).`,
    inputSchema: github.ReactionsListForPullRequestReviewCommentParamsSchema
  })
  async reactionsListForPullRequestReviewComment(
    params: github.ReactionsListForPullRequestReviewCommentParams
  ): Promise<github.ReactionsListForPullRequestReviewCommentResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForPullRequestReviewCommentResponse>()
  }

  /**
   * Create a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
   */
  @aiFunction({
    name: 'reactions_create_for_pull_request_review_comment',
    description: `Create a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request). A response with an HTTP \`200\` status means that you already added the reaction type to this pull request review comment.`,
    inputSchema: github.ReactionsCreateForPullRequestReviewCommentParamsSchema
  })
  async reactionsCreateForPullRequestReviewComment(
    params: github.ReactionsCreateForPullRequestReviewCommentParams
  ): Promise<github.ReactionsCreateForPullRequestReviewCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForPullRequestReviewCommentResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`

Delete a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
 */
  @aiFunction({
    name: 'reactions_delete_for_pull_request_comment',
    description: `> [!NOTE]
> You can also specify a repository by \`repository_id\` using the route \`DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.\`

Delete a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).`,
    inputSchema: github.ReactionsDeleteForPullRequestCommentParamsSchema
  })
  async reactionsDeleteForPullRequestComment(
    params: github.ReactionsDeleteForPullRequestCommentParams
  ): Promise<github.ReactionsDeleteForPullRequestCommentResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/pulls/comments/${params.comment_id}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForPullRequestCommentResponse>()
  }

  /**
 * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists details of a pull request by providing its number.

When you get, [create](https://docs.github.com/rest/pulls/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/pulls/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.

The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:

*   If merged as a [merge commit](https://docs.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
*   If merged via a [squash](https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
*   If [rebased](https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.

Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
- **`application/vnd.github.diff`**: For more information, see "[git-diff](https://git-scm.com/docs/git-diff)" in the Git documentation. If a diff is corrupt, contact us through the [GitHub Support portal](https://support.github.com/). Include the repository name and pull request ID in your message.
 */
  @aiFunction({
    name: 'pulls_get',
    description: `Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists details of a pull request by providing its number.

When you get, [create](https://docs.github.com/rest/pulls/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/pulls/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the \`mergeable\` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

The value of the \`mergeable\` attribute can be \`true\`, \`false\`, or \`null\`. If the value is \`null\`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-\`null\` value for the \`mergeable\` attribute in the response. If \`mergeable\` is \`true\`, then \`merge_commit_sha\` will be the SHA of the _test_ merge commit.

The value of the \`merge_commit_sha\` attribute changes depending on the state of the pull request. Before merging a pull request, the \`merge_commit_sha\` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the \`merge_commit_sha\` attribute changes depending on how you merged the pull request:

*   If merged as a [merge commit](https://docs.github.com/articles/about-merge-methods-on-github/), \`merge_commit_sha\` represents the SHA of the merge commit.
*   If merged via a [squash](https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), \`merge_commit_sha\` represents the SHA of the squashed commit on the base branch.
*   If [rebased](https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), \`merge_commit_sha\` represents the commit that the base branch was updated to.

Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.
- **\`application/vnd.github.diff\`**: For more information, see "[git-diff](https://git-scm.com/docs/git-diff)" in the Git documentation. If a diff is corrupt, contact us through the [GitHub Support portal](https://support.github.com/). Include the repository name and pull request ID in your message.`,
    inputSchema: github.PullsGetParamsSchema
  })
  async pullsGet(
    params: github.PullsGetParams
  ): Promise<github.PullsGetResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}`,
        {}
      )
      .json<github.PullsGetResponse>()
  }

  /**
 * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_update',
    description: `Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsUpdateParamsSchema
  })
  async pullsUpdate(
    params: github.PullsUpdateParams
  ): Promise<github.PullsUpdateResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}`,
        {
          json: pick(
            params,
            'title',
            'body',
            'state',
            'base',
            'maintainer_can_modify'
          )
        }
      )
      .json<github.PullsUpdateResponse>()
  }

  /**
 * Creates a codespace owned by the authenticated user for the specified pull request.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_create_with_pr_for_authenticated_user',
    description: `Creates a codespace owned by the authenticated user for the specified pull request.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesCreateWithPrForAuthenticatedUserParamsSchema
  })
  async codespacesCreateWithPrForAuthenticatedUser(
    params: github.CodespacesCreateWithPrForAuthenticatedUserParams
  ): Promise<github.CodespacesCreateWithPrForAuthenticatedUserResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/codespaces`,
        {
          json: pick(
            params,
            'location',
            'geo',
            'client_ip',
            'machine',
            'devcontainer_path',
            'multi_repo_permissions_opt_out',
            'working_directory',
            'idle_timeout_minutes',
            'display_name',
            'retention_period_minutes'
          )
        }
      )
      .json<github.CodespacesCreateWithPrForAuthenticatedUserResponse>()
  }

  /**
 * Lists all review comments for a specified pull request. By default, review comments
are in ascending order by ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_review_comments',
    description: `Lists all review comments for a specified pull request. By default, review comments
are in ascending order by ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListReviewCommentsParamsSchema
  })
  async pullsListReviewComments(
    params: github.PullsListReviewCommentsParams
  ): Promise<github.PullsListReviewCommentsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/comments`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'sort', 'direction', 'since', 'per_page', 'page')
          )
        }
      )
      .json<github.PullsListReviewCommentsResponse>()
  }

  /**
 * Creates a review comment on the diff of a specified pull request. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/issues/comments#create-an-issue-comment)."

If your comment applies to more than one line in the pull request diff, you should use the parameters `line`, `side`, and optionally `start_line` and `start_side` in your request.

The `position` parameter is closing down. If you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_create_review_comment',
    description: `Creates a review comment on the diff of a specified pull request. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/issues/comments#create-an-issue-comment)."

If your comment applies to more than one line in the pull request diff, you should use the parameters \`line\`, \`side\`, and optionally \`start_line\` and \`start_side\` in your request.

The \`position\` parameter is closing down. If you use \`position\`, the \`line\`, \`side\`, \`start_line\`, and \`start_side\` parameters are not required.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsCreateReviewCommentParamsSchema
  })
  async pullsCreateReviewComment(
    params: github.PullsCreateReviewCommentParams
  ): Promise<github.PullsCreateReviewCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/comments`,
        {
          json: pick(
            params,
            'body',
            'commit_id',
            'path',
            'position',
            'side',
            'line',
            'start_line',
            'start_side',
            'in_reply_to',
            'subject_type'
          )
        }
      )
      .json<github.PullsCreateReviewCommentResponse>()
  }

  /**
 * Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_create_reply_for_review_comment',
    description: `Creates a reply to a review comment for a pull request. For the \`comment_id\`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsCreateReplyForReviewCommentParamsSchema
  })
  async pullsCreateReplyForReviewComment(
    params: github.PullsCreateReplyForReviewCommentParams
  ): Promise<github.PullsCreateReplyForReviewCommentResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/comments/${params.comment_id}/replies`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.PullsCreateReplyForReviewCommentResponse>()
  }

  /**
 * Lists a maximum of 250 commits for a pull request. To receive a complete
commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/commits/commits#list-commits)
endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_commits',
    description: `Lists a maximum of 250 commits for a pull request. To receive a complete
commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/commits/commits#list-commits)
endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListCommitsParamsSchema
  })
  async pullsListCommits(
    params: github.PullsListCommitsParams
  ): Promise<github.PullsListCommitsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/commits`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.PullsListCommitsResponse>()
  }

  /**
 * Lists the files in a specified pull request.

> [!NOTE]
> Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_files',
    description: `Lists the files in a specified pull request.

> [!NOTE]
> Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListFilesParamsSchema
  })
  async pullsListFiles(
    params: github.PullsListFilesParams
  ): Promise<github.PullsListFilesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/files`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.PullsListFilesResponse>()
  }

  /**
   * Checks if a pull request has been merged into the base branch. The HTTP status of the response indicates whether or not the pull request has been merged; the response body is empty.
   */
  @aiFunction({
    name: 'pulls_check_if_merged',
    description: `Checks if a pull request has been merged into the base branch. The HTTP status of the response indicates whether or not the pull request has been merged; the response body is empty.`,
    inputSchema: github.PullsCheckIfMergedParamsSchema
  })
  async pullsCheckIfMerged(
    params: github.PullsCheckIfMergedParams
  ): Promise<github.PullsCheckIfMergedResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/merge`,
        {}
      )
      .json<github.PullsCheckIfMergedResponse>()
  }

  /**
 * Merges a pull request into the base branch.
This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".
 */
  @aiFunction({
    name: 'pulls_merge',
    description: `Merges a pull request into the base branch.
This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".`,
    inputSchema: github.PullsMergeParamsSchema
  })
  async pullsMerge(
    params: github.PullsMergeParams
  ): Promise<github.PullsMergeResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/merge`,
        {
          json: pick(
            params,
            'commit_title',
            'commit_message',
            'sha',
            'merge_method'
          )
        }
      )
      .json<github.PullsMergeResponse>()
  }

  /**
   * Gets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request) operation.
   */
  @aiFunction({
    name: 'pulls_list_requested_reviewers',
    description: `Gets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request) operation.`,
    inputSchema: github.PullsListRequestedReviewersParamsSchema
  })
  async pullsListRequestedReviewers(
    params: github.PullsListRequestedReviewersParams
  ): Promise<github.PullsListRequestedReviewersResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/requested_reviewers`,
        {}
      )
      .json<github.PullsListRequestedReviewersResponse>()
  }

  /**
 * Requests reviews for a pull request from a given set of users and/or teams.
This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".
 */
  @aiFunction({
    name: 'pulls_request_reviewers',
    description: `Requests reviews for a pull request from a given set of users and/or teams.
This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".`,
    // TODO: Improve handling of union params
    inputSchema: github.PullsRequestReviewersParamsSchema as any
  })
  async pullsRequestReviewers(
    params: github.PullsRequestReviewersParams
  ): Promise<github.PullsRequestReviewersResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/requested_reviewers`,
        {
          json: params
        }
      )
      .json<github.PullsRequestReviewersResponse>()
  }

  /**
   * Removes review requests from a pull request for a given set of users and/or teams.
   */
  @aiFunction({
    name: 'pulls_remove_requested_reviewers',
    description: `Removes review requests from a pull request for a given set of users and/or teams.`,
    inputSchema: github.PullsRemoveRequestedReviewersParamsSchema
  })
  async pullsRemoveRequestedReviewers(
    params: github.PullsRemoveRequestedReviewersParams
  ): Promise<github.PullsRemoveRequestedReviewersResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/requested_reviewers`,
        {
          json: pick(params, 'reviewers', 'team_reviewers')
        }
      )
      .json<github.PullsRemoveRequestedReviewersResponse>()
  }

  /**
 * Lists all reviews for a specified pull request. The list of reviews returns in chronological order.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_reviews',
    description: `Lists all reviews for a specified pull request. The list of reviews returns in chronological order.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListReviewsParamsSchema
  })
  async pullsListReviews(
    params: github.PullsListReviewsParams
  ): Promise<github.PullsListReviewsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.PullsListReviewsResponse>()
  }

  /**
 * Creates a review on a specified pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

Pull request reviews created in the `PENDING` state are not submitted and therefore do not include the `submitted_at` property in the response. To create a pending review for a pull request, leave the `event` parameter blank. For more information about submitting a `PENDING` review, see "[Submit a review for a pull request](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request)."

> [!NOTE]
> To comment on a specific line in a file, you need to first determine the position of that line in the diff. To see a pull request diff, add the `application/vnd.github.v3.diff` media type to the `Accept` header of a call to the [Get a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) endpoint.

The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_create_review',
    description: `Creates a review on a specified pull request.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

Pull request reviews created in the \`PENDING\` state are not submitted and therefore do not include the \`submitted_at\` property in the response. To create a pending review for a pull request, leave the \`event\` parameter blank. For more information about submitting a \`PENDING\` review, see "[Submit a review for a pull request](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request)."

> [!NOTE]
> To comment on a specific line in a file, you need to first determine the position of that line in the diff. To see a pull request diff, add the \`application/vnd.github.v3.diff\` media type to the \`Accept\` header of a call to the [Get a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) endpoint.

The \`position\` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsCreateReviewParamsSchema
  })
  async pullsCreateReview(
    params: github.PullsCreateReviewParams
  ): Promise<github.PullsCreateReviewResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews`,
        {
          json: pick(params, 'commit_id', 'body', 'event', 'comments')
        }
      )
      .json<github.PullsCreateReviewResponse>()
  }

  /**
 * Retrieves a pull request review by its ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_get_review',
    description: `Retrieves a pull request review by its ID.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsGetReviewParamsSchema
  })
  async pullsGetReview(
    params: github.PullsGetReviewParams
  ): Promise<github.PullsGetReviewResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}`,
        {}
      )
      .json<github.PullsGetReviewResponse>()
  }

  /**
 * Updates the contents of a specified review summary comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_update_review',
    description: `Updates the contents of a specified review summary comment.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsUpdateReviewParamsSchema
  })
  async pullsUpdateReview(
    params: github.PullsUpdateReviewParams
  ): Promise<github.PullsUpdateReviewResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.PullsUpdateReviewResponse>()
  }

  /**
 * Deletes a pull request review that has not been submitted. Submitted reviews cannot be deleted.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_delete_pending_review',
    description: `Deletes a pull request review that has not been submitted. Submitted reviews cannot be deleted.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsDeletePendingReviewParamsSchema
  })
  async pullsDeletePendingReview(
    params: github.PullsDeletePendingReviewParams
  ): Promise<github.PullsDeletePendingReviewResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}`,
        {}
      )
      .json<github.PullsDeletePendingReviewResponse>()
  }

  /**
 * Lists comments for a specific pull request review.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_list_comments_for_review',
    description: `Lists comments for a specific pull request review.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsListCommentsForReviewParamsSchema
  })
  async pullsListCommentsForReview(
    params: github.PullsListCommentsForReviewParams
  ): Promise<github.PullsListCommentsForReviewResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}/comments`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.PullsListCommentsForReviewResponse>()
  }

  /**
 * Dismisses a specified review on a pull request.

> [!NOTE]
> To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/branches/branch-protection), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_dismiss_review',
    description: `Dismisses a specified review on a pull request.

> [!NOTE]
> To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/branches/branch-protection), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsDismissReviewParamsSchema
  })
  async pullsDismissReview(
    params: github.PullsDismissReviewParams
  ): Promise<github.PullsDismissReviewResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}/dismissals`,
        {
          json: pick(params, 'message', 'event')
        }
      )
      .json<github.PullsDismissReviewResponse>()
  }

  /**
 * Submits a pending review for a pull request. For more information about creating a pending review for a pull request, see "[Create a review for a pull request](https://docs.github.com/rest/pulls/reviews#create-a-review-for-a-pull-request)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'pulls_submit_review',
    description: `Submits a pending review for a pull request. For more information about creating a pending review for a pull request, see "[Create a review for a pull request](https://docs.github.com/rest/pulls/reviews#create-a-review-for-a-pull-request)."

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github-commitcomment.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github-commitcomment.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github-commitcomment.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github-commitcomment.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.PullsSubmitReviewParamsSchema
  })
  async pullsSubmitReview(
    params: github.PullsSubmitReviewParams
  ): Promise<github.PullsSubmitReviewResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/reviews/${params.review_id}/events`,
        {
          json: pick(params, 'body', 'event')
        }
      )
      .json<github.PullsSubmitReviewResponse>()
  }

  /**
 * Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
Note: If making a request on behalf of a GitHub App you must also have permissions to write the contents of the head repository.
 */
  @aiFunction({
    name: 'pulls_update_branch',
    description: `Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
Note: If making a request on behalf of a GitHub App you must also have permissions to write the contents of the head repository.`,
    inputSchema: github.PullsUpdateBranchParamsSchema
  })
  async pullsUpdateBranch(
    params: github.PullsUpdateBranchParams
  ): Promise<github.PullsUpdateBranchResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/pulls/${params.pull_number}/update-branch`,
        {
          json: pick(params, 'expected_head_sha')
        }
      )
      .json<github.PullsUpdateBranchResponse>()
  }

  /**
 * Gets the preferred README for a repository.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
- **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
 */
  @aiFunction({
    name: 'repos_get_readme',
    description: `Gets the preferred README for a repository.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw file contents. This is the default if you do not specify a media type.
- **\`application/vnd.github.html+json\`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).`,
    inputSchema: github.ReposGetReadmeParamsSchema
  })
  async reposGetReadme(
    params: github.ReposGetReadmeParams
  ): Promise<github.ReposGetReadmeResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/readme`, {
        searchParams: sanitizeSearchParams(pick(params, 'ref'))
      })
      .json<github.ReposGetReadmeResponse>()
  }

  /**
 * Gets the README from a repository directory.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
- **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
 */
  @aiFunction({
    name: 'repos_get_readme_in_directory',
    description: `Gets the README from a repository directory.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw file contents. This is the default if you do not specify a media type.
- **\`application/vnd.github.html+json\`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).`,
    inputSchema: github.ReposGetReadmeInDirectoryParamsSchema
  })
  async reposGetReadmeInDirectory(
    params: github.ReposGetReadmeInDirectoryParams
  ): Promise<github.ReposGetReadmeInDirectoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/readme/${params.dir}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'ref'))
        }
      )
      .json<github.ReposGetReadmeInDirectoryResponse>()
  }

  /**
 * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).

Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
 */
  @aiFunction({
    name: 'repos_list_releases',
    description: `This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).

Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.`,
    inputSchema: github.ReposListReleasesParamsSchema
  })
  async reposListReleases(
    params: github.ReposListReleasesParams
  ): Promise<github.ReposListReleasesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/releases`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListReleasesResponse>()
  }

  /**
 * Users with push access to the repository can create a release.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".
 */
  @aiFunction({
    name: 'repos_create_release',
    description: `Users with push access to the repository can create a release.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).".`,
    inputSchema: github.ReposCreateReleaseParamsSchema
  })
  async reposCreateRelease(
    params: github.ReposCreateReleaseParams
  ): Promise<github.ReposCreateReleaseResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/releases`, {
        json: pick(
          params,
          'tag_name',
          'target_commitish',
          'name',
          'body',
          'draft',
          'prerelease',
          'discussion_category_name',
          'generate_release_notes',
          'make_latest'
        )
      })
      .json<github.ReposCreateReleaseResponse>()
  }

  /**
 * To download the asset's binary content:

- If within a browser, fetch the location specified in the `browser_download_url` key provided in the response.
- Alternatively, set the `Accept` header of the request to
  [`application/octet-stream`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
  The API will either redirect the client to the location, or stream it directly if possible.
  API clients should handle both a `200` or `302` response.
 */
  @aiFunction({
    name: 'repos_get_release_asset',
    description: `To download the asset's binary content:

- If within a browser, fetch the location specified in the \`browser_download_url\` key provided in the response.
- Alternatively, set the \`Accept\` header of the request to
  [\`application/octet-stream\`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
  The API will either redirect the client to the location, or stream it directly if possible.
  API clients should handle both a \`200\` or \`302\` response.`,
    inputSchema: github.ReposGetReleaseAssetParamsSchema
  })
  async reposGetReleaseAsset(
    params: github.ReposGetReleaseAssetParams
  ): Promise<github.ReposGetReleaseAssetResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/releases/assets/${params.asset_id}`,
        {}
      )
      .json<github.ReposGetReleaseAssetResponse>()
  }

  /**
   * Delete a release asset.
   */
  @aiFunction({
    name: 'repos_delete_release_asset',
    description: `Delete a release asset.`,
    inputSchema: github.ReposDeleteReleaseAssetParamsSchema
  })
  async reposDeleteReleaseAsset(
    params: github.ReposDeleteReleaseAssetParams
  ): Promise<github.ReposDeleteReleaseAssetResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/releases/assets/${params.asset_id}`,
        {}
      )
      .json<github.ReposDeleteReleaseAssetResponse>()
  }

  /**
   * Users with push access to the repository can edit a release asset.
   */
  @aiFunction({
    name: 'repos_update_release_asset',
    description: `Users with push access to the repository can edit a release asset.`,
    inputSchema: github.ReposUpdateReleaseAssetParamsSchema
  })
  async reposUpdateReleaseAsset(
    params: github.ReposUpdateReleaseAssetParams
  ): Promise<github.ReposUpdateReleaseAssetResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/releases/assets/${params.asset_id}`,
        {
          json: pick(params, 'name', 'label', 'state')
        }
      )
      .json<github.ReposUpdateReleaseAssetResponse>()
  }

  /**
   * Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
   */
  @aiFunction({
    name: 'repos_generate_release_notes',
    description: `Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.`,
    inputSchema: github.ReposGenerateReleaseNotesParamsSchema
  })
  async reposGenerateReleaseNotes(
    params: github.ReposGenerateReleaseNotesParams
  ): Promise<github.ReposGenerateReleaseNotesResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/releases/generate-notes`,
        {
          json: pick(
            params,
            'tag_name',
            'target_commitish',
            'previous_tag_name',
            'configuration_file_path'
          )
        }
      )
      .json<github.ReposGenerateReleaseNotesResponse>()
  }

  /**
 * View the latest published full release for the repository.

The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
 */
  @aiFunction({
    name: 'repos_get_latest_release',
    description: `View the latest published full release for the repository.

The latest release is the most recent non-prerelease, non-draft release, sorted by the \`created_at\` attribute. The \`created_at\` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.`,
    inputSchema: github.ReposGetLatestReleaseParamsSchema
  })
  async reposGetLatestRelease(
    params: github.ReposGetLatestReleaseParams
  ): Promise<github.ReposGetLatestReleaseResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/releases/latest`, {})
      .json<github.ReposGetLatestReleaseResponse>()
  }

  /**
   * Get a published release with the specified tag.
   */
  @aiFunction({
    name: 'repos_get_release_by_tag',
    description: `Get a published release with the specified tag.`,
    inputSchema: github.ReposGetReleaseByTagParamsSchema
  })
  async reposGetReleaseByTag(
    params: github.ReposGetReleaseByTagParams
  ): Promise<github.ReposGetReleaseByTagResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/releases/tags/${params.tag}`,
        {}
      )
      .json<github.ReposGetReleaseByTagResponse>()
  }

  /**
 * Gets a public release with the specified release ID.

> [!NOTE]
> This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia).".
 */
  @aiFunction({
    name: 'repos_get_release',
    description: `Gets a public release with the specified release ID.

> [!NOTE]
> This returns an \`upload_url\` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia).".`,
    inputSchema: github.ReposGetReleaseParamsSchema
  })
  async reposGetRelease(
    params: github.ReposGetReleaseParams
  ): Promise<github.ReposGetReleaseResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}`,
        {}
      )
      .json<github.ReposGetReleaseResponse>()
  }

  /**
   * Users with push access to the repository can delete a release.
   */
  @aiFunction({
    name: 'repos_delete_release',
    description: `Users with push access to the repository can delete a release.`,
    inputSchema: github.ReposDeleteReleaseParamsSchema
  })
  async reposDeleteRelease(
    params: github.ReposDeleteReleaseParams
  ): Promise<github.ReposDeleteReleaseResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}`,
        {}
      )
      .json<github.ReposDeleteReleaseResponse>()
  }

  /**
   * Users with push access to the repository can edit a release.
   */
  @aiFunction({
    name: 'repos_update_release',
    description: `Users with push access to the repository can edit a release.`,
    inputSchema: github.ReposUpdateReleaseParamsSchema
  })
  async reposUpdateRelease(
    params: github.ReposUpdateReleaseParams
  ): Promise<github.ReposUpdateReleaseResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}`,
        {
          json: pick(
            params,
            'tag_name',
            'target_commitish',
            'name',
            'body',
            'draft',
            'prerelease',
            'make_latest',
            'discussion_category_name'
          )
        }
      )
      .json<github.ReposUpdateReleaseResponse>()
  }

  /**
   * List release assets.
   */
  @aiFunction({
    name: 'repos_list_release_assets',
    description: `List release assets.`,
    inputSchema: github.ReposListReleaseAssetsParamsSchema
  })
  async reposListReleaseAssets(
    params: github.ReposListReleaseAssetsParams
  ): Promise<github.ReposListReleaseAssetsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}/assets`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposListReleaseAssetsResponse>()
  }

  /**
 * This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.

You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.

Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:

`application/zip`

GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
you'll still need to pass your authentication to be able to upload an asset.

When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.

**Notes:**
*   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
*   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release).
*   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
 */
  @aiFunction({
    name: 'repos_upload_release_asset',
    description: `This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the \`upload_url\` returned in
the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.

You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.

Most libraries will set the required \`Content-Length\` header automatically. Use the required \`Content-Type\` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:

\`application/zip\`

GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
you'll still need to pass your authentication to be able to upload an asset.

When an upstream failure occurs, you will receive a \`502 Bad Gateway\` status. This may leave an empty asset with a state of \`starter\`. It can be safely deleted.

**Notes:**
*   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
*   To find the \`release_id\` query the [\`GET /repos/{owner}/{repo}/releases/latest\` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release).
*   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.`,
    inputSchema: github.ReposUploadReleaseAssetParamsSchema
  })
  async reposUploadReleaseAsset(
    params: github.ReposUploadReleaseAssetParams
  ): Promise<github.ReposUploadReleaseAssetResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}/assets`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'name', 'label'))
        }
      )
      .json<github.ReposUploadReleaseAssetResponse>()
  }

  /**
   * List the reactions to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
   */
  @aiFunction({
    name: 'reactions_list_for_release',
    description: `List the reactions to a [release](https://docs.github.com/rest/releases/releases#get-a-release).`,
    inputSchema: github.ReactionsListForReleaseParamsSchema
  })
  async reactionsListForRelease(
    params: github.ReactionsListForReleaseParams
  ): Promise<github.ReactionsListForReleaseResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForReleaseResponse>()
  }

  /**
   * Create a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
   */
  @aiFunction({
    name: 'reactions_create_for_release',
    description: `Create a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release). A response with a \`Status: 200 OK\` means that you already added the reaction type to this release.`,
    inputSchema: github.ReactionsCreateForReleaseParamsSchema
  })
  async reactionsCreateForRelease(
    params: github.ReactionsCreateForReleaseParams
  ): Promise<github.ReactionsCreateForReleaseResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForReleaseResponse>()
  }

  /**
 * > [!NOTE]
> You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.

Delete a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
 */
  @aiFunction({
    name: 'reactions_delete_for_release',
    description: `> [!NOTE]
> You can also specify a repository by \`repository_id\` using the route \`DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id\`.

Delete a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release).`,
    inputSchema: github.ReactionsDeleteForReleaseParamsSchema
  })
  async reactionsDeleteForRelease(
    params: github.ReactionsDeleteForReleaseParams
  ): Promise<github.ReactionsDeleteForReleaseResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/releases/${params.release_id}/reactions/${params.reaction_id}`,
        {}
      )
      .json<github.ReactionsDeleteForReleaseResponse>()
  }

  /**
 * Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
enforcement statuses are not returned.
 */
  @aiFunction({
    name: 'repos_get_branch_rules',
    description: `Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
enforcement statuses are not returned.`,
    inputSchema: github.ReposGetBranchRulesParamsSchema
  })
  async reposGetBranchRules(
    params: github.ReposGetBranchRulesParams
  ): Promise<github.ReposGetBranchRulesResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/rules/branches/${params.branch}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposGetBranchRulesResponse>()
  }

  /**
   * Get all the rulesets for a repository.
   */
  @aiFunction({
    name: 'repos_get_repo_rulesets',
    description: `Get all the rulesets for a repository.`,
    inputSchema: github.ReposGetRepoRulesetsParamsSchema
  })
  async reposGetRepoRulesets(
    params: github.ReposGetRepoRulesetsParams
  ): Promise<github.ReposGetRepoRulesetsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/rulesets`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'includes_parents', 'targets')
        )
      })
      .json<github.ReposGetRepoRulesetsResponse>()
  }

  /**
   * Create a ruleset for a repository.
   */
  @aiFunction({
    name: 'repos_create_repo_ruleset',
    description: `Create a ruleset for a repository.`,
    inputSchema: github.ReposCreateRepoRulesetParamsSchema
  })
  async reposCreateRepoRuleset(
    params: github.ReposCreateRepoRulesetParams
  ): Promise<github.ReposCreateRepoRulesetResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/rulesets`, {
        json: pick(
          params,
          'name',
          'target',
          'enforcement',
          'bypass_actors',
          'conditions',
          'rules'
        )
      })
      .json<github.ReposCreateRepoRulesetResponse>()
  }

  /**
 * Lists suites of rule evaluations at the repository level.
For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets).".
 */
  @aiFunction({
    name: 'repos_get_repo_rule_suites',
    description: `Lists suites of rule evaluations at the repository level.
For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets).".`,
    inputSchema: github.ReposGetRepoRuleSuitesParamsSchema
  })
  async reposGetRepoRuleSuites(
    params: github.ReposGetRepoRuleSuitesParams
  ): Promise<github.ReposGetRepoRuleSuitesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/rulesets/rule-suites`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'ref',
            'time_period',
            'actor_name',
            'rule_suite_result',
            'per_page',
            'page'
          )
        )
      })
      .json<github.ReposGetRepoRuleSuitesResponse>()
  }

  /**
 * Gets information about a suite of rule evaluations from within a repository.
For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets).".
 */
  @aiFunction({
    name: 'repos_get_repo_rule_suite',
    description: `Gets information about a suite of rule evaluations from within a repository.
For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets).".`,
    inputSchema: github.ReposGetRepoRuleSuiteParamsSchema
  })
  async reposGetRepoRuleSuite(
    params: github.ReposGetRepoRuleSuiteParams
  ): Promise<github.ReposGetRepoRuleSuiteResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/rulesets/rule-suites/${params.rule_suite_id}`,
        {}
      )
      .json<github.ReposGetRepoRuleSuiteResponse>()
  }

  /**
 * Get a ruleset for a repository.

**Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
making the API request has write access to the ruleset.
 */
  @aiFunction({
    name: 'repos_get_repo_ruleset',
    description: `Get a ruleset for a repository.

**Note:** To prevent leaking sensitive information, the \`bypass_actors\` property is only returned if the user
making the API request has write access to the ruleset.`,
    inputSchema: github.ReposGetRepoRulesetParamsSchema
  })
  async reposGetRepoRuleset(
    params: github.ReposGetRepoRulesetParams
  ): Promise<github.ReposGetRepoRulesetResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/rulesets/${params.ruleset_id}`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'includes_parents'))
        }
      )
      .json<github.ReposGetRepoRulesetResponse>()
  }

  /**
   * Update a ruleset for a repository.
   */
  @aiFunction({
    name: 'repos_update_repo_ruleset',
    description: `Update a ruleset for a repository.`,
    inputSchema: github.ReposUpdateRepoRulesetParamsSchema
  })
  async reposUpdateRepoRuleset(
    params: github.ReposUpdateRepoRulesetParams
  ): Promise<github.ReposUpdateRepoRulesetResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/rulesets/${params.ruleset_id}`,
        {
          json: pick(
            params,
            'name',
            'target',
            'enforcement',
            'bypass_actors',
            'conditions',
            'rules'
          )
        }
      )
      .json<github.ReposUpdateRepoRulesetResponse>()
  }

  /**
   * Delete a ruleset for a repository.
   */
  @aiFunction({
    name: 'repos_delete_repo_ruleset',
    description: `Delete a ruleset for a repository.`,
    inputSchema: github.ReposDeleteRepoRulesetParamsSchema
  })
  async reposDeleteRepoRuleset(
    params: github.ReposDeleteRepoRulesetParams
  ): Promise<github.ReposDeleteRepoRulesetResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/rulesets/${params.ruleset_id}`,
        {}
      )
      .json<github.ReposDeleteRepoRulesetResponse>()
  }

  /**
   * Get the history of a repository ruleset.
   */
  @aiFunction({
    name: 'repos_get_repo_ruleset_history',
    description: `Get the history of a repository ruleset.`,
    inputSchema: github.ReposGetRepoRulesetHistoryParamsSchema
  })
  async reposGetRepoRulesetHistory(
    params: github.ReposGetRepoRulesetHistoryParams
  ): Promise<github.ReposGetRepoRulesetHistoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/rulesets/${params.ruleset_id}/history`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
        }
      )
      .json<github.ReposGetRepoRulesetHistoryResponse>()
  }

  /**
   * Get a version of a repository ruleset.
   */
  @aiFunction({
    name: 'repos_get_repo_ruleset_version',
    description: `Get a version of a repository ruleset.`,
    inputSchema: github.ReposGetRepoRulesetVersionParamsSchema
  })
  async reposGetRepoRulesetVersion(
    params: github.ReposGetRepoRulesetVersionParams
  ): Promise<github.ReposGetRepoRulesetVersionResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/rulesets/${params.ruleset_id}/history/${params.version_id}`,
        {}
      )
      .json<github.ReposGetRepoRulesetVersionResponse>()
  }

  /**
 * Lists secret scanning alerts for an eligible repository, from newest to oldest.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_list_alerts_for_repo',
    description: `Lists secret scanning alerts for an eligible repository, from newest to oldest.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningListAlertsForRepoParamsSchema
  })
  async secretScanningListAlertsForRepo(
    params: github.SecretScanningListAlertsForRepoParams
  ): Promise<github.SecretScanningListAlertsForRepoResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/secret-scanning/alerts`,
        {
          searchParams: sanitizeSearchParams(
            pick(
              params,
              'state',
              'secret_type',
              'resolution',
              'sort',
              'direction',
              'page',
              'per_page',
              'before',
              'after',
              'validity',
              'is_publicly_leaked',
              'is_multi_repo'
            )
          )
        }
      )
      .json<github.SecretScanningListAlertsForRepoResponse>()
  }

  /**
 * Gets a single secret scanning alert detected in an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_get_alert',
    description: `Gets a single secret scanning alert detected in an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningGetAlertParamsSchema
  })
  async secretScanningGetAlert(
    params: github.SecretScanningGetAlertParams
  ): Promise<github.SecretScanningGetAlertResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/secret-scanning/alerts/${params.alert_number}`,
        {}
      )
      .json<github.SecretScanningGetAlertResponse>()
  }

  /**
 * Updates the status of a secret scanning alert in an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_update_alert',
    description: `Updates the status of a secret scanning alert in an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningUpdateAlertParamsSchema
  })
  async secretScanningUpdateAlert(
    params: github.SecretScanningUpdateAlertParams
  ): Promise<github.SecretScanningUpdateAlertResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/secret-scanning/alerts/${params.alert_number}`,
        {
          json: pick(params, 'state', 'resolution', 'resolution_comment')
        }
      )
      .json<github.SecretScanningUpdateAlertResponse>()
  }

  /**
 * Lists all locations for a given secret scanning alert for an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_list_locations_for_alert',
    description: `Lists all locations for a given secret scanning alert for an eligible repository.

The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningListLocationsForAlertParamsSchema
  })
  async secretScanningListLocationsForAlert(
    params: github.SecretScanningListLocationsForAlertParams
  ): Promise<github.SecretScanningListLocationsForAlertResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/secret-scanning/alerts/${params.alert_number}/locations`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
        }
      )
      .json<github.SecretScanningListLocationsForAlertResponse>()
  }

  /**
 * Creates a bypass for a previously push protected secret.

The authenticated user must be the original author of the committed secret.

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'secret_scanning_create_push_protection_bypass',
    description: `Creates a bypass for a previously push protected secret.

The authenticated user must be the original author of the committed secret.

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.SecretScanningCreatePushProtectionBypassParamsSchema
  })
  async secretScanningCreatePushProtectionBypass(
    params: github.SecretScanningCreatePushProtectionBypassParams
  ): Promise<github.SecretScanningCreatePushProtectionBypassResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/secret-scanning/push-protection-bypasses`,
        {
          json: pick(params, 'reason', 'placeholder_id')
        }
      )
      .json<github.SecretScanningCreatePushProtectionBypassResponse>()
  }

  /**
 * Lists the latest default incremental and backfill scans by type for a repository. Scans from Copilot Secret Scanning are not included.

OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
 */
  @aiFunction({
    name: 'secret_scanning_get_scan_history',
    description: `Lists the latest default incremental and backfill scans by type for a repository. Scans from Copilot Secret Scanning are not included.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`security_events\` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the \`public_repo\` scope instead.`,
    inputSchema: github.SecretScanningGetScanHistoryParamsSchema
  })
  async secretScanningGetScanHistory(
    params: github.SecretScanningGetScanHistoryParams
  ): Promise<github.SecretScanningGetScanHistoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/secret-scanning/scan-history`,
        {}
      )
      .json<github.SecretScanningGetScanHistoryResponse>()
  }

  /**
 * Lists security advisories in a repository.

The authenticated user can access unpublished security advisories from a repository if they are a security manager or administrator of that repository, or if they are a collaborator on any security advisory.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
 */
  @aiFunction({
    name: 'security_advisories_list_repository_advisories',
    description: `Lists security advisories in a repository.

The authenticated user can access unpublished security advisories from a repository if they are a security manager or administrator of that repository, or if they are a collaborator on any security advisory.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:read\` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.`,
    inputSchema: github.SecurityAdvisoriesListRepositoryAdvisoriesParamsSchema
  })
  async securityAdvisoriesListRepositoryAdvisories(
    params: github.SecurityAdvisoriesListRepositoryAdvisoriesParams
  ): Promise<github.SecurityAdvisoriesListRepositoryAdvisoriesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/security-advisories`, {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'direction',
            'sort',
            'before',
            'after',
            'per_page',
            'state'
          )
        )
      })
      .json<github.SecurityAdvisoriesListRepositoryAdvisoriesResponse>()
  }

  /**
 * Creates a new repository security advisory.

In order to create a draft repository security advisory, the authenticated user must be a security manager or administrator of that repository.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
 */
  @aiFunction({
    name: 'security_advisories_create_repository_advisory',
    description: `Creates a new repository security advisory.

In order to create a draft repository security advisory, the authenticated user must be a security manager or administrator of that repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:write\` scope to use this endpoint.`,
    inputSchema: github.SecurityAdvisoriesCreateRepositoryAdvisoryParamsSchema
  })
  async securityAdvisoriesCreateRepositoryAdvisory(
    params: github.SecurityAdvisoriesCreateRepositoryAdvisoryParams
  ): Promise<github.SecurityAdvisoriesCreateRepositoryAdvisoryResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/security-advisories`, {
        json: pick(
          params,
          'summary',
          'description',
          'cve_id',
          'vulnerabilities',
          'cwe_ids',
          'credits',
          'severity',
          'cvss_vector_string',
          'start_private_fork'
        )
      })
      .json<github.SecurityAdvisoriesCreateRepositoryAdvisoryResponse>()
  }

  /**
 * Report a security vulnerability to the maintainers of the repository.
See "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)" for more information about private vulnerability reporting.
 */
  @aiFunction({
    name: 'security_advisories_create_private_vulnerability_report',
    description: `Report a security vulnerability to the maintainers of the repository.
See "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)" for more information about private vulnerability reporting.`,
    inputSchema:
      github.SecurityAdvisoriesCreatePrivateVulnerabilityReportParamsSchema
  })
  async securityAdvisoriesCreatePrivateVulnerabilityReport(
    params: github.SecurityAdvisoriesCreatePrivateVulnerabilityReportParams
  ): Promise<github.SecurityAdvisoriesCreatePrivateVulnerabilityReportResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/security-advisories/reports`,
        {
          json: pick(
            params,
            'summary',
            'description',
            'vulnerabilities',
            'cwe_ids',
            'severity',
            'cvss_vector_string',
            'start_private_fork'
          )
        }
      )
      .json<github.SecurityAdvisoriesCreatePrivateVulnerabilityReportResponse>()
  }

  /**
 * Get a repository security advisory using its GitHub Security Advisory (GHSA) identifier.

Anyone can access any published security advisory on a public repository.

The authenticated user can access an unpublished security advisory from a repository if they are a security manager or administrator of that repository, or if they are a
collaborator on the security advisory.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
 */
  @aiFunction({
    name: 'security_advisories_get_repository_advisory',
    description: `Get a repository security advisory using its GitHub Security Advisory (GHSA) identifier.

Anyone can access any published security advisory on a public repository.

The authenticated user can access an unpublished security advisory from a repository if they are a security manager or administrator of that repository, or if they are a
collaborator on the security advisory.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:read\` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.`,
    inputSchema: github.SecurityAdvisoriesGetRepositoryAdvisoryParamsSchema
  })
  async securityAdvisoriesGetRepositoryAdvisory(
    params: github.SecurityAdvisoriesGetRepositoryAdvisoryParams
  ): Promise<github.SecurityAdvisoriesGetRepositoryAdvisoryResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/security-advisories/${params.ghsa_id}`,
        {}
      )
      .json<github.SecurityAdvisoriesGetRepositoryAdvisoryResponse>()
  }

  /**
 * Update a repository security advisory using its GitHub Security Advisory (GHSA) identifier.

In order to update any security advisory, the authenticated user must be a security manager or administrator of that repository,
or a collaborator on the repository security advisory.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
 */
  @aiFunction({
    name: 'security_advisories_update_repository_advisory',
    description: `Update a repository security advisory using its GitHub Security Advisory (GHSA) identifier.

In order to update any security advisory, the authenticated user must be a security manager or administrator of that repository,
or a collaborator on the repository security advisory.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:write\` scope to use this endpoint.`,
    inputSchema: github.SecurityAdvisoriesUpdateRepositoryAdvisoryParamsSchema
  })
  async securityAdvisoriesUpdateRepositoryAdvisory(
    params: github.SecurityAdvisoriesUpdateRepositoryAdvisoryParams
  ): Promise<github.SecurityAdvisoriesUpdateRepositoryAdvisoryResponse> {
    return this.ky
      .patch(
        `/repos/${params.owner}/${params.repo}/security-advisories/${params.ghsa_id}`,
        {
          json: pick(
            params,
            'summary',
            'description',
            'cve_id',
            'vulnerabilities',
            'cwe_ids',
            'credits',
            'severity',
            'cvss_vector_string',
            'state',
            'collaborating_users',
            'collaborating_teams'
          )
        }
      )
      .json<github.SecurityAdvisoriesUpdateRepositoryAdvisoryResponse>()
  }

  /**
 * If you want a CVE identification number for the security vulnerability in your project, and don't already have one, you can request a CVE identification number from GitHub. For more information see "[Requesting a CVE identification number](https://docs.github.com/code-security/security-advisories/repository-security-advisories/publishing-a-repository-security-advisory#requesting-a-cve-identification-number-optional)."

You may request a CVE for public repositories, but cannot do so for private repositories.

In order to request a CVE for a repository security advisory, the authenticated user must be a security manager or administrator of that repository.

OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
 */
  @aiFunction({
    name: 'security_advisories_create_repository_advisory_cve_request',
    description: `If you want a CVE identification number for the security vulnerability in your project, and don't already have one, you can request a CVE identification number from GitHub. For more information see "[Requesting a CVE identification number](https://docs.github.com/code-security/security-advisories/repository-security-advisories/publishing-a-repository-security-advisory#requesting-a-cve-identification-number-optional)."

You may request a CVE for public repositories, but cannot do so for private repositories.

In order to request a CVE for a repository security advisory, the authenticated user must be a security manager or administrator of that repository.

OAuth app tokens and personal access tokens (classic) need the \`repo\` or \`repository_advisories:write\` scope to use this endpoint.`,
    inputSchema:
      github.SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamsSchema
  })
  async securityAdvisoriesCreateRepositoryAdvisoryCveRequest(
    params: github.SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParams
  ): Promise<github.SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/security-advisories/${params.ghsa_id}/cve`,
        {}
      )
      .json<github.SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponse>()
  }

  /**
 * Create a temporary private fork to collaborate on fixing a security vulnerability in your repository.

> [!NOTE]
> Forking a repository happens asynchronously. You may have to wait up to 5 minutes before you can access the fork.
 */
  @aiFunction({
    name: 'security_advisories_create_fork',
    description: `Create a temporary private fork to collaborate on fixing a security vulnerability in your repository.

> [!NOTE]
> Forking a repository happens asynchronously. You may have to wait up to 5 minutes before you can access the fork.`,
    inputSchema: github.SecurityAdvisoriesCreateForkParamsSchema
  })
  async securityAdvisoriesCreateFork(
    params: github.SecurityAdvisoriesCreateForkParams
  ): Promise<github.SecurityAdvisoriesCreateForkResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/security-advisories/${params.ghsa_id}/forks`,
        {}
      )
      .json<github.SecurityAdvisoriesCreateForkResponse>()
  }

  /**
 * Lists the people that have starred the repository.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
 */
  @aiFunction({
    name: 'activity_list_stargazers_for_repo',
    description: `Lists the people that have starred the repository.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.star+json\`**: Includes a timestamp of when the star was created.`,
    inputSchema: github.ActivityListStargazersForRepoParamsSchema
  })
  async activityListStargazersForRepo(
    params: github.ActivityListStargazersForRepoParams
  ): Promise<github.ActivityListStargazersForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/stargazers`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListStargazersForRepoResponse>()
  }

  /**
 * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.

> [!NOTE]
> This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.
 */
  @aiFunction({
    name: 'repos_get_code_frequency_stats',
    description: `Returns a weekly aggregate of the number of additions and deletions pushed to a repository.

> [!NOTE]
> This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.`,
    inputSchema: github.ReposGetCodeFrequencyStatsParamsSchema
  })
  async reposGetCodeFrequencyStats(
    params: github.ReposGetCodeFrequencyStatsParams
  ): Promise<github.ReposGetCodeFrequencyStatsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/stats/code_frequency`,
        {}
      )
      .json<github.ReposGetCodeFrequencyStatsResponse>()
  }

  /**
   * Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
   */
  @aiFunction({
    name: 'repos_get_commit_activity_stats',
    description: `Returns the last year of commit activity grouped by week. The \`days\` array is a group of commits per day, starting on \`Sunday\`.`,
    inputSchema: github.ReposGetCommitActivityStatsParamsSchema
  })
  async reposGetCommitActivityStats(
    params: github.ReposGetCommitActivityStatsParams
  ): Promise<github.ReposGetCommitActivityStatsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/stats/commit_activity`,
        {}
      )
      .json<github.ReposGetCommitActivityStatsResponse>()
  }

  /**
 *
Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:

*   `w` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
*   `a` - Number of additions
*   `d` - Number of deletions
*   `c` - Number of commits

> [!NOTE]
> This endpoint will return `0` values for all addition and deletion counts in repositories with 10,000 or more commits.
 */
  @aiFunction({
    name: 'repos_get_contributors_stats',
    description: `
Returns the \`total\` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (\`weeks\` array) with the following information:

*   \`w\` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
*   \`a\` - Number of additions
*   \`d\` - Number of deletions
*   \`c\` - Number of commits

> [!NOTE]
> This endpoint will return \`0\` values for all addition and deletion counts in repositories with 10,000 or more commits.`,
    inputSchema: github.ReposGetContributorsStatsParamsSchema
  })
  async reposGetContributorsStats(
    params: github.ReposGetContributorsStatsParams
  ): Promise<github.ReposGetContributorsStatsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/stats/contributors`, {})
      .json<github.ReposGetContributorsStatsResponse>()
  }

  /**
 * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.

The array order is oldest week (index 0) to most recent week.

The most recent week is seven days ago at UTC midnight to today at UTC midnight.
 */
  @aiFunction({
    name: 'repos_get_participation_stats',
    description: `Returns the total commit counts for the \`owner\` and total commit counts in \`all\`. \`all\` is everyone combined, including the \`owner\` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract \`owner\` from \`all\`.

The array order is oldest week (index 0) to most recent week.

The most recent week is seven days ago at UTC midnight to today at UTC midnight.`,
    inputSchema: github.ReposGetParticipationStatsParamsSchema
  })
  async reposGetParticipationStats(
    params: github.ReposGetParticipationStatsParams
  ): Promise<github.ReposGetParticipationStatsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/stats/participation`,
        {}
      )
      .json<github.ReposGetParticipationStatsResponse>()
  }

  /**
 * Each array contains the day number, hour number, and number of commits:

*   `0-6`: Sunday - Saturday
*   `0-23`: Hour of day
*   Number of commits

For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
 */
  @aiFunction({
    name: 'repos_get_punch_card_stats',
    description: `Each array contains the day number, hour number, and number of commits:

*   \`0-6\`: Sunday - Saturday
*   \`0-23\`: Hour of day
*   Number of commits

For example, \`[2, 14, 25]\` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.`,
    inputSchema: github.ReposGetPunchCardStatsParamsSchema
  })
  async reposGetPunchCardStats(
    params: github.ReposGetPunchCardStatsParams
  ): Promise<github.ReposGetPunchCardStatsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/stats/punch_card`, {})
      .json<github.ReposGetPunchCardStatsResponse>()
  }

  /**
 * Users with push access in a repository can create commit statuses for a given SHA.

Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
 */
  @aiFunction({
    name: 'repos_create_commit_status',
    description: `Users with push access in a repository can create commit statuses for a given SHA.

Note: there is a limit of 1000 statuses per \`sha\` and \`context\` within a repository. Attempts to create more than 1000 statuses will result in a validation error.`,
    inputSchema: github.ReposCreateCommitStatusParamsSchema
  })
  async reposCreateCommitStatus(
    params: github.ReposCreateCommitStatusParams
  ): Promise<github.ReposCreateCommitStatusResponse> {
    return this.ky
      .post(
        `/repos/${params.owner}/${params.repo}/statuses/${params.sha}`,
        {
          json: pick(params, 'state', 'target_url', 'description', 'context')
        }
      )
      .json<github.ReposCreateCommitStatusResponse>()
  }

  /**
   * Lists the people watching the specified repository.
   */
  @aiFunction({
    name: 'activity_list_watchers_for_repo',
    description: `Lists the people watching the specified repository.`,
    inputSchema: github.ActivityListWatchersForRepoParamsSchema
  })
  async activityListWatchersForRepo(
    params: github.ActivityListWatchersForRepoParams
  ): Promise<github.ActivityListWatchersForRepoResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/subscribers`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListWatchersForRepoResponse>()
  }

  /**
   * Gets information about whether the authenticated user is subscribed to the repository.
   */
  @aiFunction({
    name: 'activity_get_repo_subscription',
    description: `Gets information about whether the authenticated user is subscribed to the repository.`,
    inputSchema: github.ActivityGetRepoSubscriptionParamsSchema
  })
  async activityGetRepoSubscription(
    params: github.ActivityGetRepoSubscriptionParams
  ): Promise<github.ActivityGetRepoSubscriptionResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/subscription`, {})
      .json<github.ActivityGetRepoSubscriptionResponse>()
  }

  /**
   * If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.
   */
  @aiFunction({
    name: 'activity_set_repo_subscription',
    description: `If you would like to watch a repository, set \`subscribed\` to \`true\`. If you would like to ignore notifications made within a repository, set \`ignored\` to \`true\`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.`,
    inputSchema: github.ActivitySetRepoSubscriptionParamsSchema
  })
  async activitySetRepoSubscription(
    params: github.ActivitySetRepoSubscriptionParams
  ): Promise<github.ActivitySetRepoSubscriptionResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/subscription`, {
        json: pick(params, 'subscribed', 'ignored')
      })
      .json<github.ActivitySetRepoSubscriptionResponse>()
  }

  /**
   * This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).
   */
  @aiFunction({
    name: 'activity_delete_repo_subscription',
    description: `This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).`,
    inputSchema: github.ActivityDeleteRepoSubscriptionParamsSchema
  })
  async activityDeleteRepoSubscription(
    params: github.ActivityDeleteRepoSubscriptionParams
  ): Promise<github.ActivityDeleteRepoSubscriptionResponse> {
    return this.ky
      .delete(`/repos/${params.owner}/${params.repo}/subscription`, {})
      .json<github.ActivityDeleteRepoSubscriptionResponse>()
  }

  /**
   * List repository tags.
   */
  @aiFunction({
    name: 'repos_list_tags',
    description: `List repository tags.`,
    inputSchema: github.ReposListTagsParamsSchema
  })
  async reposListTags(
    params: github.ReposListTagsParams
  ): Promise<github.ReposListTagsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/tags`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListTagsResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.

This returns the tag protection states of a repository.

This information is only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_list_tag_protection',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.

This returns the tag protection states of a repository.

This information is only available to repository administrators.`,
    inputSchema: github.ReposListTagProtectionParamsSchema
  })
  async reposListTagProtection(
    params: github.ReposListTagProtectionParams
  ): Promise<github.ReposListTagProtectionResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/tags/protection`, {})
      .json<github.ReposListTagProtectionResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.

This creates a tag protection state for a repository.
This endpoint is only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_create_tag_protection',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.

This creates a tag protection state for a repository.
This endpoint is only available to repository administrators.`,
    inputSchema: github.ReposCreateTagProtectionParamsSchema
  })
  async reposCreateTagProtection(
    params: github.ReposCreateTagProtectionParams
  ): Promise<github.ReposCreateTagProtectionResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/tags/protection`, {
        json: pick(params, 'pattern')
      })
      .json<github.ReposCreateTagProtectionResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.

This deletes a tag protection state for a repository.
This endpoint is only available to repository administrators.
 */
  @aiFunction({
    name: 'repos_delete_tag_protection',
    description: `> [!WARNING]
> **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.

This deletes a tag protection state for a repository.
This endpoint is only available to repository administrators.`,
    inputSchema: github.ReposDeleteTagProtectionParamsSchema
  })
  async reposDeleteTagProtection(
    params: github.ReposDeleteTagProtectionParams
  ): Promise<github.ReposDeleteTagProtectionResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/tags/protection/${params.tag_protection_id}`,
        {}
      )
      .json<github.ReposDeleteTagProtectionResponse>()
  }

  /**
 * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
`main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
the `Location` header to make a second `GET` request.

> [!NOTE]
> For private repositories, these links are temporary and expire after five minutes.
 */
  @aiFunction({
    name: 'repos_download_tarball_archive',
    description: `Gets a redirect URL to download a tar archive for a repository. If you omit \`:ref\`, the repositorys default branch (usually
\`main\`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
the \`Location\` header to make a second \`GET\` request.

> [!NOTE]
> For private repositories, these links are temporary and expire after five minutes.`,
    inputSchema: github.ReposDownloadTarballArchiveParamsSchema
  })
  async reposDownloadTarballArchive(
    params: github.ReposDownloadTarballArchiveParams
  ): Promise<github.ReposDownloadTarballArchiveResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/tarball/${params.ref}`,
        {}
      )
      .json<github.ReposDownloadTarballArchiveResponse>()
  }

  /**
 * Lists the teams that have access to the specified repository and that are also visible to the authenticated user.

For a public repository, a team is listed only if that team added the public repository explicitly.

OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to use this endpoint with a public repository, and `repo` scope to use this endpoint with a private repository.
 */
  @aiFunction({
    name: 'repos_list_teams',
    description: `Lists the teams that have access to the specified repository and that are also visible to the authenticated user.

For a public repository, a team is listed only if that team added the public repository explicitly.

OAuth app tokens and personal access tokens (classic) need the \`public_repo\` or \`repo\` scope to use this endpoint with a public repository, and \`repo\` scope to use this endpoint with a private repository.`,
    inputSchema: github.ReposListTeamsParamsSchema
  })
  async reposListTeams(
    params: github.ReposListTeamsParams
  ): Promise<github.ReposListTeamsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/teams`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListTeamsResponse>()
  }

  /**
   * Get all repository topics.
   */
  @aiFunction({
    name: 'repos_get_all_topics',
    description: `Get all repository topics.`,
    inputSchema: github.ReposGetAllTopicsParamsSchema
  })
  async reposGetAllTopics(
    params: github.ReposGetAllTopicsParams
  ): Promise<github.ReposGetAllTopicsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/topics`, {
        searchParams: sanitizeSearchParams(pick(params, 'page', 'per_page'))
      })
      .json<github.ReposGetAllTopicsResponse>()
  }

  /**
   * Replace all repository topics.
   */
  @aiFunction({
    name: 'repos_replace_all_topics',
    description: `Replace all repository topics.`,
    inputSchema: github.ReposReplaceAllTopicsParamsSchema
  })
  async reposReplaceAllTopics(
    params: github.ReposReplaceAllTopicsParams
  ): Promise<github.ReposReplaceAllTopicsResponse> {
    return this.ky
      .put(`/repos/${params.owner}/${params.repo}/topics`, {
        json: pick(params, 'names')
      })
      .json<github.ReposReplaceAllTopicsResponse>()
  }

  /**
   * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
   */
  @aiFunction({
    name: 'repos_get_clones',
    description: `Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.`,
    inputSchema: github.ReposGetClonesParamsSchema
  })
  async reposGetClones(
    params: github.ReposGetClonesParams
  ): Promise<github.ReposGetClonesResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/traffic/clones`, {
        searchParams: sanitizeSearchParams(pick(params, 'per'))
      })
      .json<github.ReposGetClonesResponse>()
  }

  /**
   * Get the top 10 popular contents over the last 14 days.
   */
  @aiFunction({
    name: 'repos_get_top_paths',
    description: `Get the top 10 popular contents over the last 14 days.`,
    inputSchema: github.ReposGetTopPathsParamsSchema
  })
  async reposGetTopPaths(
    params: github.ReposGetTopPathsParams
  ): Promise<github.ReposGetTopPathsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/traffic/popular/paths`,
        {}
      )
      .json<github.ReposGetTopPathsResponse>()
  }

  /**
   * Get the top 10 referrers over the last 14 days.
   */
  @aiFunction({
    name: 'repos_get_top_referrers',
    description: `Get the top 10 referrers over the last 14 days.`,
    inputSchema: github.ReposGetTopReferrersParamsSchema
  })
  async reposGetTopReferrers(
    params: github.ReposGetTopReferrersParams
  ): Promise<github.ReposGetTopReferrersResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/traffic/popular/referrers`,
        {}
      )
      .json<github.ReposGetTopReferrersResponse>()
  }

  /**
   * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
   */
  @aiFunction({
    name: 'repos_get_views',
    description: `Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.`,
    inputSchema: github.ReposGetViewsParamsSchema
  })
  async reposGetViews(
    params: github.ReposGetViewsParams
  ): Promise<github.ReposGetViewsResponse> {
    return this.ky
      .get(`/repos/${params.owner}/${params.repo}/traffic/views`, {
        searchParams: sanitizeSearchParams(pick(params, 'per'))
      })
      .json<github.ReposGetViewsResponse>()
  }

  /**
   * A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
   */
  @aiFunction({
    name: 'repos_transfer',
    description: `A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original \`owner\`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).`,
    inputSchema: github.ReposTransferParamsSchema
  })
  async reposTransfer(
    params: github.ReposTransferParams
  ): Promise<github.ReposTransferResponse> {
    return this.ky
      .post(`/repos/${params.owner}/${params.repo}/transfer`, {
        json: pick(params, 'new_owner', 'new_name', 'team_ids')
      })
      .json<github.ReposTransferResponse>()
  }

  /**
   * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
   */
  @aiFunction({
    name: 'repos_check_vulnerability_alerts',
    description: `Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".`,
    inputSchema: github.ReposCheckVulnerabilityAlertsParamsSchema
  })
  async reposCheckVulnerabilityAlerts(
    params: github.ReposCheckVulnerabilityAlertsParams
  ): Promise<github.ReposCheckVulnerabilityAlertsResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/vulnerability-alerts`,
        {}
      )
      .json<github.ReposCheckVulnerabilityAlertsResponse>()
  }

  /**
   * Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
   */
  @aiFunction({
    name: 'repos_enable_vulnerability_alerts',
    description: `Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".`,
    inputSchema: github.ReposEnableVulnerabilityAlertsParamsSchema
  })
  async reposEnableVulnerabilityAlerts(
    params: github.ReposEnableVulnerabilityAlertsParams
  ): Promise<github.ReposEnableVulnerabilityAlertsResponse> {
    return this.ky
      .put(
        `/repos/${params.owner}/${params.repo}/vulnerability-alerts`,
        {}
      )
      .json<github.ReposEnableVulnerabilityAlertsResponse>()
  }

  /**
 * Disables dependency alerts and the dependency graph for a repository.
The authenticated user must have admin access to the repository. For more information,
see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
 */
  @aiFunction({
    name: 'repos_disable_vulnerability_alerts',
    description: `Disables dependency alerts and the dependency graph for a repository.
The authenticated user must have admin access to the repository. For more information,
see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".`,
    inputSchema: github.ReposDisableVulnerabilityAlertsParamsSchema
  })
  async reposDisableVulnerabilityAlerts(
    params: github.ReposDisableVulnerabilityAlertsParams
  ): Promise<github.ReposDisableVulnerabilityAlertsResponse> {
    return this.ky
      .delete(
        `/repos/${params.owner}/${params.repo}/vulnerability-alerts`,
        {}
      )
      .json<github.ReposDisableVulnerabilityAlertsResponse>()
  }

  /**
 * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
`main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
the `Location` header to make a second `GET` request.

> [!NOTE]
> For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
 */
  @aiFunction({
    name: 'repos_download_zipball_archive',
    description: `Gets a redirect URL to download a zip archive for a repository. If you omit \`:ref\`, the repositorys default branch (usually
\`main\`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
the \`Location\` header to make a second \`GET\` request.

> [!NOTE]
> For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.`,
    inputSchema: github.ReposDownloadZipballArchiveParamsSchema
  })
  async reposDownloadZipballArchive(
    params: github.ReposDownloadZipballArchiveParams
  ): Promise<github.ReposDownloadZipballArchiveResponse> {
    return this.ky
      .get(
        `/repos/${params.owner}/${params.repo}/zipball/${params.ref}`,
        {}
      )
      .json<github.ReposDownloadZipballArchiveResponse>()
  }

  /**
 * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.

OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
 */
  @aiFunction({
    name: 'repos_create_using_template',
    description: `Creates a new repository using a repository template. Use the \`template_owner\` and \`template_repo\` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the \`is_template\` key is \`true\`.

OAuth app tokens and personal access tokens (classic) need the \`public_repo\` or \`repo\` scope to create a public repository, and \`repo\` scope to create a private repository.`,
    inputSchema: github.ReposCreateUsingTemplateParamsSchema
  })
  async reposCreateUsingTemplate(
    params: github.ReposCreateUsingTemplateParams
  ): Promise<github.ReposCreateUsingTemplateResponse> {
    return this.ky
      .post(
        `/repos/${params.template_owner}/${params.template_repo}/generate`,
        {
          json: pick(
            params,
            'owner',
            'name',
            'description',
            'include_all_branches',
            'private'
          )
        }
      )
      .json<github.ReposCreateUsingTemplateResponse>()
  }

  /**
 * Lists all public repositories in the order that they were created.

Note:
- For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
- Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.
 */
  @aiFunction({
    name: 'repos_list_public',
    description: `Lists all public repositories in the order that they were created.

Note:
- For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
- Pagination is powered exclusively by the \`since\` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.`,
    inputSchema: github.ReposListPublicParamsSchema
  })
  async reposListPublic(
    params: github.ReposListPublicParams
  ): Promise<github.ReposListPublicResponse> {
    return this.ky
      .get('/repositories', {
        searchParams: sanitizeSearchParams(params)
      })
      .json<github.ReposListPublicResponse>()
  }

  /**
 * Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:

`q=addClass+in:file+language:js+repo:jquery/jquery`

This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.

Considerations for code search:

Due to the complexity of searching code, there are a few restrictions on how searches are performed:

*   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
*   Only files smaller than 384 KB are searchable.
*   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.

This endpoint requires you to authenticate and limits you to 10 requests per minute.
 */
  @aiFunction({
    name: 'search_code',
    description: `Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the \`text-match\` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find the definition of the \`addClass\` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:

\`q=addClass+in:file+language:js+repo:jquery/jquery\`

This query searches for the keyword \`addClass\` within a file's contents. The query limits the search to files where the language is JavaScript in the \`jquery/jquery\` repository.

Considerations for code search:

Due to the complexity of searching code, there are a few restrictions on how searches are performed:

*   Only the _default branch_ is considered. In most cases, this will be the \`master\` branch.
*   Only files smaller than 384 KB are searchable.
*   You must always include at least one search term when searching source code. For example, searching for [\`language:go\`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [\`amazing
language:go\`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.

This endpoint requires you to authenticate and limits you to 10 requests per minute.`,
    inputSchema: github.SearchCodeParamsSchema
  })
  async searchCode(
    params: github.SearchCodeParams
  ): Promise<github.SearchCodeResponse> {
    return this.ky
      .get('/search/code', {
        searchParams: sanitizeSearchParams(
          pick(params, 'q', 'sort', 'order', 'per_page', 'page')
        )
      })
      .json<github.SearchCodeResponse>()
  }

  /**
 * Find commits via various criteria on the default branch (usually `main`). This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:

`q=repo:octocat/Spoon-Knife+css`.
 */
  @aiFunction({
    name: 'search_commits',
    description: `Find commits via various criteria on the default branch (usually \`main\`). This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for commits, you can get text match metadata for the **message** field when you provide the \`text-match\` media type. For more details about how to receive highlighted search results, see [Text match
metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:

\`q=repo:octocat/Spoon-Knife+css\`.`,
    inputSchema: github.SearchCommitsParamsSchema
  })
  async searchCommits(
    params: github.SearchCommitsParams
  ): Promise<github.SearchCommitsResponse> {
    return this.ky
      .get('/search/commits', {
        searchParams: sanitizeSearchParams(
          pick(params, 'q', 'sort', 'order', 'per_page', 'page')
        )
      })
      .json<github.SearchCommitsResponse>()
  }

  /**
 * > [!WARNING]
> **Notice:** Search for issues and pull requests will be overridden by advanced search on September 4, 2025.
> You can read more about this change on [the GitHub blog](https://github.blog/changelog/2025-03-06-github-issues-projects-api-support-for-issues-advanced-search-and-more/).
 */
  @aiFunction({
    name: 'search_issues_and_pull_requests',
    description: `> [!WARNING]
> **Notice:** Search for issues and pull requests will be overridden by advanced search on September 4, 2025.
> You can read more about this change on [the GitHub blog](https://github.blog/changelog/2025-03-06-github-issues-projects-api-support-for-issues-advanced-search-and-more/).`,
    inputSchema: github.SearchIssuesAndPullRequestsParamsSchema
  })
  async searchIssuesAndPullRequests(
    params: github.SearchIssuesAndPullRequestsParams
  ): Promise<github.SearchIssuesAndPullRequestsResponse> {
    return this.ky
      .get('/search/issues', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'q',
            'sort',
            'order',
            'per_page',
            'page',
            'advanced_search'
          )
        )
      })
      .json<github.SearchIssuesAndPullRequestsResponse>()
  }

  /**
 * Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:

`q=bug+defect+enhancement&repository_id=64778136`

The labels that best match the query appear first in the search results.
 */
  @aiFunction({
    name: 'search_labels',
    description: `Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the \`text-match\` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to find labels in the \`linguist\` repository that match \`bug\`, \`defect\`, or \`enhancement\`. Your query might look like this:

\`q=bug+defect+enhancement&repository_id=64778136\`

The labels that best match the query appear first in the search results.`,
    inputSchema: github.SearchLabelsParamsSchema
  })
  async searchLabels(
    params: github.SearchLabelsParams
  ): Promise<github.SearchLabelsResponse> {
    return this.ky
      .get('/search/labels', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'repository_id',
            'q',
            'sort',
            'order',
            'per_page',
            'page'
          )
        )
      })
      .json<github.SearchLabelsResponse>()
  }

  /**
 * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:

`q=tetris+language:assembly&sort=stars&order=desc`

This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
 */
  @aiFunction({
    name: 'search_repos',
    description: `Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the \`text-match\` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:

\`q=tetris+language:assembly&sort=stars&order=desc\`

This query searches for repositories with the word \`tetris\` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.`,
    inputSchema: github.SearchReposParamsSchema
  })
  async searchRepos(
    params: github.SearchReposParams
  ): Promise<github.SearchReposResponse> {
    return this.ky
      .get('/search/repositories', {
        searchParams: sanitizeSearchParams(
          pick(params, 'q', 'sort', 'order', 'per_page', 'page')
        )
      })
      .json<github.SearchReposResponse>()
  }

  /**
 * Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api). See "[Searching topics](https://docs.github.com/articles/searching-topics/)" for a detailed list of qualifiers.

When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:

`q=ruby+is:featured`

This query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.
 */
  @aiFunction({
    name: 'search_topics',
    description: `Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api). See "[Searching topics](https://docs.github.com/articles/searching-topics/)" for a detailed list of qualifiers.

When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the \`text-match\` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:

\`q=ruby+is:featured\`

This query searches for topics with the keyword \`ruby\` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.`,
    inputSchema: github.SearchTopicsParamsSchema
  })
  async searchTopics(
    params: github.SearchTopicsParams
  ): Promise<github.SearchTopicsResponse> {
    return this.ky
      .get('/search/topics', {
        searchParams: sanitizeSearchParams(
          pick(params, 'q', 'per_page', 'page')
        )
      })
      .json<github.SearchTopicsResponse>()
  }

  /**
 * Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for users, you can get text match metadata for the issue **login**, public **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you're looking for a list of popular users, you might try this query:

`q=tom+repos:%3E42+followers:%3E1000`

This query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.

This endpoint does not accept authentication and will only include publicly visible users. As an alternative, you can use the GraphQL API. The GraphQL API requires authentication and will return private users, including Enterprise Managed Users (EMUs), that you are authorized to view. For more information, see "[GraphQL Queries](https://docs.github.com/graphql/reference/queries#search).".
 */
  @aiFunction({
    name: 'search_users',
    description: `Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).

When searching for users, you can get text match metadata for the issue **login**, public **email**, and **name** fields when you pass the \`text-match\` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/search/search#text-match-metadata).

For example, if you're looking for a list of popular users, you might try this query:

\`q=tom+repos:%3E42+followers:%3E1000\`

This query searches for users with the name \`tom\`. The results are restricted to users with more than 42 repositories and over 1,000 followers.

This endpoint does not accept authentication and will only include publicly visible users. As an alternative, you can use the GraphQL API. The GraphQL API requires authentication and will return private users, including Enterprise Managed Users (EMUs), that you are authorized to view. For more information, see "[GraphQL Queries](https://docs.github.com/graphql/reference/queries#search).".`,
    inputSchema: github.SearchUsersParamsSchema
  })
  async searchUsers(
    params: github.SearchUsersParams
  ): Promise<github.SearchUsersResponse> {
    return this.ky
      .get('/search/users', {
        searchParams: sanitizeSearchParams(
          pick(params, 'q', 'sort', 'order', 'per_page', 'page')
        )
      })
      .json<github.SearchUsersResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/teams/teams#get-a-team-by-name) endpoint.
 */
  @aiFunction({
    name: 'teams_get_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/teams/teams#get-a-team-by-name) endpoint.`,
    inputSchema: github.TeamsGetLegacyParamsSchema
  })
  async teamsGetLegacy(
    params: github.TeamsGetLegacyParams
  ): Promise<github.TeamsGetLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}`)
      .json<github.TeamsGetLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/teams/teams#delete-a-team) endpoint.

To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.
 */
  @aiFunction({
    name: 'teams_delete_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/teams/teams#delete-a-team) endpoint.

To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.`,
    inputSchema: github.TeamsDeleteLegacyParamsSchema
  })
  async teamsDeleteLegacy(
    params: github.TeamsDeleteLegacyParams
  ): Promise<github.TeamsDeleteLegacyResponse> {
    return this.ky
      .delete(`/teams/${params.team_id}`)
      .json<github.TeamsDeleteLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/teams/teams#update-a-team) endpoint.

To edit a team, the authenticated user must either be an organization owner or a team maintainer.

> [!NOTE]
> With nested teams, the `privacy` for parent teams cannot be `secret`.
 */
  @aiFunction({
    name: 'teams_update_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/teams/teams#update-a-team) endpoint.

To edit a team, the authenticated user must either be an organization owner or a team maintainer.

> [!NOTE]
> With nested teams, the \`privacy\` for parent teams cannot be \`secret\`.`,
    inputSchema: github.TeamsUpdateLegacyParamsSchema
  })
  async teamsUpdateLegacy(
    params: github.TeamsUpdateLegacyParams
  ): Promise<github.TeamsUpdateLegacyResponse> {
    return this.ky
      .patch(`/teams/${params.team_id}`, {
        json: pick(
          params,
          'name',
          'description',
          'privacy',
          'notification_setting',
          'permission',
          'parent_team_id'
        )
      })
      .json<github.TeamsUpdateLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/teams/discussions#list-discussions) endpoint.

List all discussions on a team's page.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_list_discussions_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List discussions\`](https://docs.github.com/rest/teams/discussions#list-discussions) endpoint.

List all discussions on a team's page.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsListDiscussionsLegacyParamsSchema
  })
  async teamsListDiscussionsLegacy(
    params: github.TeamsListDiscussionsLegacyParams
  ): Promise<github.TeamsListDiscussionsLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/discussions`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'direction', 'per_page', 'page')
        )
      })
      .json<github.TeamsListDiscussionsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/teams/discussions#create-a-discussion) endpoint.

Creates a new discussion post on a team's page.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_create_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`Create a discussion\`](https://docs.github.com/rest/teams/discussions#create-a-discussion) endpoint.

Creates a new discussion post on a team's page.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsCreateDiscussionLegacyParamsSchema
  })
  async teamsCreateDiscussionLegacy(
    params: github.TeamsCreateDiscussionLegacyParams
  ): Promise<github.TeamsCreateDiscussionLegacyResponse> {
    return this.ky
      .post(`/teams/${params.team_id}/discussions`, {
        json: pick(params, 'title', 'body', 'private')
      })
      .json<github.TeamsCreateDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion) endpoint.

Get a specific discussion on a team's page.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_get_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion) endpoint.

Get a specific discussion on a team's page.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsGetDiscussionLegacyParamsSchema
  })
  async teamsGetDiscussionLegacy(
    params: github.TeamsGetDiscussionLegacyParams
  ): Promise<github.TeamsGetDiscussionLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/discussions/${params.discussion_number}`,
        {}
      )
      .json<github.TeamsGetDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/teams/discussions#delete-a-discussion) endpoint.

Delete a discussion from a team's page.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_delete_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`Delete a discussion\`](https://docs.github.com/rest/teams/discussions#delete-a-discussion) endpoint.

Delete a discussion from a team's page.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsDeleteDiscussionLegacyParamsSchema
  })
  async teamsDeleteDiscussionLegacy(
    params: github.TeamsDeleteDiscussionLegacyParams
  ): Promise<github.TeamsDeleteDiscussionLegacyResponse> {
    return this.ky
      .delete(
        `/teams/${params.team_id}/discussions/${params.discussion_number}`,
        {}
      )
      .json<github.TeamsDeleteDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/teams/discussions#update-a-discussion) endpoint.

Edits the title and body text of a discussion post. Only the parameters you provide are updated.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_update_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/teams/discussions#update-a-discussion) endpoint.

Edits the title and body text of a discussion post. Only the parameters you provide are updated.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsUpdateDiscussionLegacyParamsSchema
  })
  async teamsUpdateDiscussionLegacy(
    params: github.TeamsUpdateDiscussionLegacyParams
  ): Promise<github.TeamsUpdateDiscussionLegacyResponse> {
    return this.ky
      .patch(
        `/teams/${params.team_id}/discussions/${params.discussion_number}`,
        {
          json: pick(params, 'title', 'body')
        }
      )
      .json<github.TeamsUpdateDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/teams/discussion-comments#list-discussion-comments) endpoint.

List all comments on a team discussion.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_list_discussion_comments_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/teams/discussion-comments#list-discussion-comments) endpoint.

List all comments on a team discussion.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsListDiscussionCommentsLegacyParamsSchema
  })
  async teamsListDiscussionCommentsLegacy(
    params: github.TeamsListDiscussionCommentsLegacyParams
  ): Promise<github.TeamsListDiscussionCommentsLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'direction', 'per_page', 'page')
          )
        }
      )
      .json<github.TeamsListDiscussionCommentsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/teams/discussion-comments#create-a-discussion-comment) endpoint.

Creates a new comment on a team discussion.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_create_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/teams/discussion-comments#create-a-discussion-comment) endpoint.

Creates a new comment on a team discussion.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsCreateDiscussionCommentLegacyParamsSchema
  })
  async teamsCreateDiscussionCommentLegacy(
    params: github.TeamsCreateDiscussionCommentLegacyParams
  ): Promise<github.TeamsCreateDiscussionCommentLegacyResponse> {
    return this.ky
      .post(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.TeamsCreateDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment) endpoint.

Get a specific comment on a team discussion.

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_get_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment) endpoint.

Get a specific comment on a team discussion.

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsGetDiscussionCommentLegacyParamsSchema
  })
  async teamsGetDiscussionCommentLegacy(
    params: github.TeamsGetDiscussionCommentLegacyParams
  ): Promise<github.TeamsGetDiscussionCommentLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {}
      )
      .json<github.TeamsGetDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/teams/discussion-comments#delete-a-discussion-comment) endpoint.

Deletes a comment on a team discussion.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_delete_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/teams/discussion-comments#delete-a-discussion-comment) endpoint.

Deletes a comment on a team discussion.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsDeleteDiscussionCommentLegacyParamsSchema
  })
  async teamsDeleteDiscussionCommentLegacy(
    params: github.TeamsDeleteDiscussionCommentLegacyParams
  ): Promise<github.TeamsDeleteDiscussionCommentLegacyResponse> {
    return this.ky
      .delete(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {}
      )
      .json<github.TeamsDeleteDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/teams/discussion-comments#update-a-discussion-comment) endpoint.

Edits the body text of a discussion comment.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'teams_update_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/teams/discussion-comments#update-a-discussion-comment) endpoint.

Edits the body text of a discussion comment.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.TeamsUpdateDiscussionCommentLegacyParamsSchema
  })
  async teamsUpdateDiscussionCommentLegacy(
    params: github.TeamsUpdateDiscussionCommentLegacyParams
  ): Promise<github.TeamsUpdateDiscussionCommentLegacyResponse> {
    return this.ky
      .patch(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments/${params.comment_number}`,
        {
          json: pick(params, 'body')
        }
      )
      .json<github.TeamsUpdateDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment) endpoint.

List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_list_for_team_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List reactions for a team discussion comment\`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment) endpoint.

List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsListForTeamDiscussionCommentLegacyParamsSchema
  })
  async reactionsListForTeamDiscussionCommentLegacy(
    params: github.ReactionsListForTeamDiscussionCommentLegacyParams
  ): Promise<github.ReactionsListForTeamDiscussionCommentLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments/${params.comment_number}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForTeamDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.

Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_create_for_team_discussion_comment_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.

Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).

A response with an HTTP \`200\` status means that you already added the reaction type to this team discussion comment.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema:
      github.ReactionsCreateForTeamDiscussionCommentLegacyParamsSchema
  })
  async reactionsCreateForTeamDiscussionCommentLegacy(
    params: github.ReactionsCreateForTeamDiscussionCommentLegacyParams
  ): Promise<github.ReactionsCreateForTeamDiscussionCommentLegacyResponse> {
    return this.ky
      .post(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/comments/${params.comment_number}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForTeamDiscussionCommentLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion) endpoint.

List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_list_for_team_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List reactions for a team discussion\`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion) endpoint.

List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

OAuth app tokens and personal access tokens (classic) need the \`read:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsListForTeamDiscussionLegacyParamsSchema
  })
  async reactionsListForTeamDiscussionLegacy(
    params: github.ReactionsListForTeamDiscussionLegacyParams
  ): Promise<github.ReactionsListForTeamDiscussionLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/reactions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'content', 'per_page', 'page')
          )
        }
      )
      .json<github.ReactionsListForTeamDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion) endpoint.

Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

A response with an HTTP `200` status means that you already added the reaction type to this team discussion.

OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
 */
  @aiFunction({
    name: 'reactions_create_for_team_discussion_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`Create reaction for a team discussion\`](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion) endpoint.

Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).

A response with an HTTP \`200\` status means that you already added the reaction type to this team discussion.

OAuth app tokens and personal access tokens (classic) need the \`write:discussion\` scope to use this endpoint.`,
    inputSchema: github.ReactionsCreateForTeamDiscussionLegacyParamsSchema
  })
  async reactionsCreateForTeamDiscussionLegacy(
    params: github.ReactionsCreateForTeamDiscussionLegacyParams
  ): Promise<github.ReactionsCreateForTeamDiscussionLegacyResponse> {
    return this.ky
      .post(
        `/teams/${params.team_id}/discussions/${params.discussion_number}/reactions`,
        {
          json: pick(params, 'content')
        }
      )
      .json<github.ReactionsCreateForTeamDiscussionLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/teams/members#list-pending-team-invitations) endpoint.

The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
 */
  @aiFunction({
    name: 'teams_list_pending_invitations_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List pending team invitations\`](https://docs.github.com/rest/teams/members#list-pending-team-invitations) endpoint.

The return hash contains a \`role\` field which refers to the Organization Invitation role and will be one of the following values: \`direct_member\`, \`admin\`, \`billing_manager\`, \`hiring_manager\`, or \`reinstate\`. If the invitee is not a GitHub member, the \`login\` field in the return hash will be \`null\`.`,
    inputSchema: github.TeamsListPendingInvitationsLegacyParamsSchema
  })
  async teamsListPendingInvitationsLegacy(
    params: github.TeamsListPendingInvitationsLegacyParams
  ): Promise<github.TeamsListPendingInvitationsLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/invitations`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListPendingInvitationsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/teams/members#list-team-members) endpoint.

Team members will include the members of child teams.
 */
  @aiFunction({
    name: 'teams_list_members_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List team members\`](https://docs.github.com/rest/teams/members#list-team-members) endpoint.

Team members will include the members of child teams.`,
    inputSchema: github.TeamsListMembersLegacyParamsSchema
  })
  async teamsListMembersLegacy(
    params: github.TeamsListMembersLegacyParams
  ): Promise<github.TeamsListMembersLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/members`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'role', 'per_page', 'page')
        )
      })
      .json<github.TeamsListMembersLegacyResponse>()
  }

  /**
 * The "Get team member" endpoint (described below) is closing down.

We recommend using the [Get team membership for a user](https://docs.github.com/rest/teams/members#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.

To list members in a team, the team must be visible to the authenticated user.
 */
  @aiFunction({
    name: 'teams_get_member_legacy',
    description: `The "Get team member" endpoint (described below) is closing down.

We recommend using the [Get team membership for a user](https://docs.github.com/rest/teams/members#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.

To list members in a team, the team must be visible to the authenticated user.`,
    inputSchema: github.TeamsGetMemberLegacyParamsSchema
  })
  async teamsGetMemberLegacy(
    params: github.TeamsGetMemberLegacyParams
  ): Promise<github.TeamsGetMemberLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/members/${params.username}`, {})
      .json<github.TeamsGetMemberLegacyResponse>()
  }

  /**
 * The "Add team member" endpoint (described below) is closing down.

We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/teams/members#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
 */
  @aiFunction({
    name: 'teams_add_member_legacy',
    description: `The "Add team member" endpoint (described below) is closing down.

We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/teams/members#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

Note that you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.TeamsAddMemberLegacyParamsSchema
  })
  async teamsAddMemberLegacy(
    params: github.TeamsAddMemberLegacyParams
  ): Promise<github.TeamsAddMemberLegacyResponse> {
    return this.ky
      .put(`/teams/${params.team_id}/members/${params.username}`, {})
      .json<github.TeamsAddMemberLegacyResponse>()
  }

  /**
 * The "Remove team member" endpoint (described below) is closing down.

We recommend using the [Remove team membership for a user](https://docs.github.com/rest/teams/members#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
 */
  @aiFunction({
    name: 'teams_remove_member_legacy',
    description: `The "Remove team member" endpoint (described below) is closing down.

We recommend using the [Remove team membership for a user](https://docs.github.com/rest/teams/members#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".`,
    inputSchema: github.TeamsRemoveMemberLegacyParamsSchema
  })
  async teamsRemoveMemberLegacy(
    params: github.TeamsRemoveMemberLegacyParams
  ): Promise<github.TeamsRemoveMemberLegacyResponse> {
    return this.ky
      .delete(`/teams/${params.team_id}/members/${params.username}`, {})
      .json<github.TeamsRemoveMemberLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/teams/members#get-team-membership-for-a-user) endpoint.

Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:**
The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/teams/teams#create-a-team).
 */
  @aiFunction({
    name: 'teams_get_membership_for_user_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/teams/members#get-team-membership-for-a-user) endpoint.

Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:**
The response contains the \`state\` of the membership and the member's \`role\`.

The \`role\` for organization owners is set to \`maintainer\`. For more information about \`maintainer\` roles, see [Create a team](https://docs.github.com/rest/teams/teams#create-a-team).`,
    inputSchema: github.TeamsGetMembershipForUserLegacyParamsSchema
  })
  async teamsGetMembershipForUserLegacy(
    params: github.TeamsGetMembershipForUserLegacyParams
  ): Promise<github.TeamsGetMembershipForUserLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/memberships/${params.username}`, {})
      .json<github.TeamsGetMembershipForUserLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/teams/members#add-or-update-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
 */
  @aiFunction({
    name: 'teams_add_or_update_membership_for_user_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/teams/members#add-or-update-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.`,
    inputSchema: github.TeamsAddOrUpdateMembershipForUserLegacyParamsSchema
  })
  async teamsAddOrUpdateMembershipForUserLegacy(
    params: github.TeamsAddOrUpdateMembershipForUserLegacyParams
  ): Promise<github.TeamsAddOrUpdateMembershipForUserLegacyResponse> {
    return this.ky
      .put(`/teams/${params.team_id}/memberships/${params.username}`, {
        json: pick(params, 'role')
      })
      .json<github.TeamsAddOrUpdateMembershipForUserLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/teams/members#remove-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
 */
  @aiFunction({
    name: 'teams_remove_membership_for_user_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/teams/members#remove-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

> [!NOTE]
> When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".`,
    inputSchema: github.TeamsRemoveMembershipForUserLegacyParamsSchema
  })
  async teamsRemoveMembershipForUserLegacy(
    params: github.TeamsRemoveMembershipForUserLegacyParams
  ): Promise<github.TeamsRemoveMembershipForUserLegacyResponse> {
    return this.ky
      .delete(
        `/teams/${params.team_id}/memberships/${params.username}`,
        {}
      )
      .json<github.TeamsRemoveMembershipForUserLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_list_projects_legacy',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsListProjectsLegacyParamsSchema
  })
  async teamsListProjectsLegacy(
    params: github.TeamsListProjectsLegacyParams
  ): Promise<github.TeamsListProjectsLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/projects`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListProjectsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_check_permissions_for_project_legacy',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsCheckPermissionsForProjectLegacyParamsSchema
  })
  async teamsCheckPermissionsForProjectLegacy(
    params: github.TeamsCheckPermissionsForProjectLegacyParams
  ): Promise<github.TeamsCheckPermissionsForProjectLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/projects/${params.project_id}`, {})
      .json<github.TeamsCheckPermissionsForProjectLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_add_or_update_project_permissions_legacy',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsAddOrUpdateProjectPermissionsLegacyParamsSchema
  })
  async teamsAddOrUpdateProjectPermissionsLegacy(
    params: github.TeamsAddOrUpdateProjectPermissionsLegacyParams
  ): Promise<github.TeamsAddOrUpdateProjectPermissionsLegacyResponse> {
    return this.ky
      .put(`/teams/${params.team_id}/projects/${params.project_id}`, {
        json: pick(params, 'permission')
      })
      .json<github.TeamsAddOrUpdateProjectPermissionsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'teams_remove_project_legacy',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.TeamsRemoveProjectLegacyParamsSchema
  })
  async teamsRemoveProjectLegacy(
    params: github.TeamsRemoveProjectLegacyParams
  ): Promise<github.TeamsRemoveProjectLegacyResponse> {
    return this.ky
      .delete(
        `/teams/${params.team_id}/projects/${params.project_id}`,
        {}
      )
      .json<github.TeamsRemoveProjectLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/teams/teams#list-team-repositories) endpoint.
 */
  @aiFunction({
    name: 'teams_list_repos_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/teams/teams#list-team-repositories) endpoint.`,
    inputSchema: github.TeamsListReposLegacyParamsSchema
  })
  async teamsListReposLegacy(
    params: github.TeamsListReposLegacyParams
  ): Promise<github.TeamsListReposLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/repos`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListReposLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-repository) endpoint.

> [!NOTE]
> Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types/) via the `Accept` header:.
 */
  @aiFunction({
    name: 'teams_check_permissions_for_repo_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-repository) endpoint.

> [!NOTE]
> Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types/) via the \`Accept\` header:.`,
    inputSchema: github.TeamsCheckPermissionsForRepoLegacyParamsSchema
  })
  async teamsCheckPermissionsForRepoLegacy(
    params: github.TeamsCheckPermissionsForRepoLegacyParams
  ): Promise<github.TeamsCheckPermissionsForRepoLegacyResponse> {
    return this.ky
      .get(
        `/teams/${params.team_id}/repos/${params.owner}/${params.repo}`,
        {}
      )
      .json<github.TeamsCheckPermissionsForRepoLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/teams/teams#add-or-update-team-repository-permissions)" endpoint.

To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
 */
  @aiFunction({
    name: 'teams_add_or_update_repo_permissions_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/teams/teams#add-or-update-team-repository-permissions)" endpoint.

To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a \`422 Unprocessable Entity\` status if you attempt to add a repository to a team that is not owned by the organization.

Note that, if you choose not to pass any parameters, you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.TeamsAddOrUpdateRepoPermissionsLegacyParamsSchema
  })
  async teamsAddOrUpdateRepoPermissionsLegacy(
    params: github.TeamsAddOrUpdateRepoPermissionsLegacyParams
  ): Promise<github.TeamsAddOrUpdateRepoPermissionsLegacyResponse> {
    return this.ky
      .put(
        `/teams/${params.team_id}/repos/${params.owner}/${params.repo}`,
        {
          json: pick(params, 'permission')
        }
      )
      .json<github.TeamsAddOrUpdateRepoPermissionsLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/teams/teams#remove-a-repository-from-a-team) endpoint.

If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.
 */
  @aiFunction({
    name: 'teams_remove_repo_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/teams/teams#remove-a-repository-from-a-team) endpoint.

If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.`,
    inputSchema: github.TeamsRemoveRepoLegacyParamsSchema
  })
  async teamsRemoveRepoLegacy(
    params: github.TeamsRemoveRepoLegacyParams
  ): Promise<github.TeamsRemoveRepoLegacyResponse> {
    return this.ky
      .delete(
        `/teams/${params.team_id}/repos/${params.owner}/${params.repo}`,
        {}
      )
      .json<github.TeamsRemoveRepoLegacyResponse>()
  }

  /**
 * > [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/teams/teams#list-child-teams) endpoint.
 */
  @aiFunction({
    name: 'teams_list_child_legacy',
    description: `> [!WARNING]
> **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [\`List child teams\`](https://docs.github.com/rest/teams/teams#list-child-teams) endpoint.`,
    inputSchema: github.TeamsListChildLegacyParamsSchema
  })
  async teamsListChildLegacy(
    params: github.TeamsListChildLegacyParams
  ): Promise<github.TeamsListChildLegacyResponse> {
    return this.ky
      .get(`/teams/${params.team_id}/teams`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListChildLegacyResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
   */
  @aiFunction({
    name: 'users_get_authenticated',
    description: `OAuth app tokens and personal access tokens (classic) need the \`user\` scope in order for the response to include private profile information.`,
    inputSchema: github.UsersGetAuthenticatedParamsSchema
  })
  async usersGetAuthenticated(
    _params: github.UsersGetAuthenticatedParams
  ): Promise<github.UsersGetAuthenticatedResponse> {
    return this.ky.get('/user').json<github.UsersGetAuthenticatedResponse>()
  }

  /**
   * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
   */
  @aiFunction({
    name: 'users_update_authenticated',
    description: `**Note:** If your email is set to private and you send an \`email\` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.`,
    inputSchema: github.UsersUpdateAuthenticatedParamsSchema
  })
  async usersUpdateAuthenticated(
    params: github.UsersUpdateAuthenticatedParams
  ): Promise<github.UsersUpdateAuthenticatedResponse> {
    return this.ky
      .patch('/user', {
        json: pick(
          params,
          'name',
          'email',
          'blog',
          'twitter_username',
          'company',
          'location',
          'hireable',
          'bio'
        )
      })
      .json<github.UsersUpdateAuthenticatedResponse>()
  }

  /**
   * List the users you've blocked on your personal account.
   */
  @aiFunction({
    name: 'users_list_blocked_by_authenticated_user',
    description: `List the users you've blocked on your personal account.`,
    inputSchema: github.UsersListBlockedByAuthenticatedUserParamsSchema
  })
  async usersListBlockedByAuthenticatedUser(
    params: github.UsersListBlockedByAuthenticatedUserParams
  ): Promise<github.UsersListBlockedByAuthenticatedUserResponse> {
    return this.ky
      .get('/user/blocks', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListBlockedByAuthenticatedUserResponse>()
  }

  /**
   * Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.
   */
  @aiFunction({
    name: 'users_check_blocked',
    description: `Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.`,
    inputSchema: github.UsersCheckBlockedParamsSchema
  })
  async usersCheckBlocked(
    params: github.UsersCheckBlockedParams
  ): Promise<github.UsersCheckBlockedResponse> {
    return this.ky
      .get(`/user/blocks/${params.username}`)
      .json<github.UsersCheckBlockedResponse>()
  }

  /**
   * Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.
   */
  @aiFunction({
    name: 'users_block',
    description: `Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.`,
    inputSchema: github.UsersBlockParamsSchema
  })
  async usersBlock(
    params: github.UsersBlockParams
  ): Promise<github.UsersBlockResponse> {
    return this.ky
      .put(`/user/blocks/${params.username}`)
      .json<github.UsersBlockResponse>()
  }

  /**
   * Unblocks the given user and returns a 204.
   */
  @aiFunction({
    name: 'users_unblock',
    description: `Unblocks the given user and returns a 204.`,
    inputSchema: github.UsersUnblockParamsSchema
  })
  async usersUnblock(
    params: github.UsersUnblockParams
  ): Promise<github.UsersUnblockResponse> {
    return this.ky
      .delete(`/user/blocks/${params.username}`)
      .json<github.UsersUnblockResponse>()
  }

  /**
 * Lists the authenticated user's codespaces.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_for_authenticated_user',
    description: `Lists the authenticated user's codespaces.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListForAuthenticatedUserParamsSchema
  })
  async codespacesListForAuthenticatedUser(
    params: github.CodespacesListForAuthenticatedUserParams
  ): Promise<github.CodespacesListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/codespaces', {
        searchParams: sanitizeSearchParams(
          pick(params, 'per_page', 'page', 'repository_id')
        )
      })
      .json<github.CodespacesListForAuthenticatedUserResponse>()
  }

  /**
 * Creates a new codespace, owned by the authenticated user.

This endpoint requires either a `repository_id` OR a `pull_request` but not both.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_create_for_authenticated_user',
    description: `Creates a new codespace, owned by the authenticated user.

This endpoint requires either a \`repository_id\` OR a \`pull_request\` but not both.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.CodespacesCreateForAuthenticatedUserParamsSchema as any
  })
  async codespacesCreateForAuthenticatedUser(
    params: github.CodespacesCreateForAuthenticatedUserParams
  ): Promise<github.CodespacesCreateForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/codespaces', {
        json: params
      })
      .json<github.CodespacesCreateForAuthenticatedUserResponse>()
  }

  /**
 * Lists all development environment secrets available for a user's codespaces without revealing their
encrypted values.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_secrets_for_authenticated_user',
    description: `Lists all development environment secrets available for a user's codespaces without revealing their
encrypted values.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema: github.CodespacesListSecretsForAuthenticatedUserParamsSchema
  })
  async codespacesListSecretsForAuthenticatedUser(
    params: github.CodespacesListSecretsForAuthenticatedUserParams
  ): Promise<github.CodespacesListSecretsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/codespaces/secrets', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.CodespacesListSecretsForAuthenticatedUserResponse>()
  }

  /**
 * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_public_key_for_authenticated_user',
    description: `Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetPublicKeyForAuthenticatedUserParamsSchema
  })
  async codespacesGetPublicKeyForAuthenticatedUser(
    _params: github.CodespacesGetPublicKeyForAuthenticatedUserParams
  ): Promise<github.CodespacesGetPublicKeyForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/codespaces/secrets/public-key')
      .json<github.CodespacesGetPublicKeyForAuthenticatedUserResponse>()
  }

  /**
 * Gets a development environment secret available to a user's codespaces without revealing its encrypted value.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_secret_for_authenticated_user',
    description: `Gets a development environment secret available to a user's codespaces without revealing its encrypted value.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetSecretForAuthenticatedUserParamsSchema
  })
  async codespacesGetSecretForAuthenticatedUser(
    params: github.CodespacesGetSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesGetSecretForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/codespaces/secrets/${params.secret_name}`)
      .json<github.CodespacesGetSecretForAuthenticatedUserResponse>()
  }

  /**
 * Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_create_or_update_secret_for_authenticated_user',
    description: `Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesCreateOrUpdateSecretForAuthenticatedUserParamsSchema
  })
  async codespacesCreateOrUpdateSecretForAuthenticatedUser(
    params: github.CodespacesCreateOrUpdateSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse> {
    return this.ky
      .put(`/user/codespaces/secrets/${params.secret_name}`, {
        json: pick(
          params,
          'encrypted_value',
          'key_id',
          'selected_repository_ids'
        )
      })
      .json<github.CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse>()
  }

  /**
 * Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_delete_secret_for_authenticated_user',
    description: `Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema: github.CodespacesDeleteSecretForAuthenticatedUserParamsSchema
  })
  async codespacesDeleteSecretForAuthenticatedUser(
    params: github.CodespacesDeleteSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesDeleteSecretForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/codespaces/secrets/${params.secret_name}`)
      .json<github.CodespacesDeleteSecretForAuthenticatedUserResponse>()
  }

  /**
 * List the repositories that have been granted the ability to use a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_list_repositories_for_secret_for_authenticated_user',
    description: `List the repositories that have been granted the ability to use a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesListRepositoriesForSecretForAuthenticatedUserParamsSchema
  })
  async codespacesListRepositoriesForSecretForAuthenticatedUser(
    params: github.CodespacesListRepositoriesForSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesListRepositoriesForSecretForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/codespaces/secrets/${params.secret_name}/repositories`)
      .json<github.CodespacesListRepositoriesForSecretForAuthenticatedUserResponse>()
  }

  /**
 * Select the repositories that will use a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_set_repositories_for_secret_for_authenticated_user',
    description: `Select the repositories that will use a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesSetRepositoriesForSecretForAuthenticatedUserParamsSchema
  })
  async codespacesSetRepositoriesForSecretForAuthenticatedUser(
    params: github.CodespacesSetRepositoriesForSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse> {
    return this.ky
      .put(`/user/codespaces/secrets/${params.secret_name}/repositories`, {
        json: pick(params, 'selected_repository_ids')
      })
      .json<github.CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse>()
  }

  /**
 * Adds a repository to the selected repositories for a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_add_repository_for_secret_for_authenticated_user',
    description: `Adds a repository to the selected repositories for a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesAddRepositoryForSecretForAuthenticatedUserParamsSchema
  })
  async codespacesAddRepositoryForSecretForAuthenticatedUser(
    params: github.CodespacesAddRepositoryForSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesAddRepositoryForSecretForAuthenticatedUserResponse> {
    return this.ky
      .put(
        `/user/codespaces/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.CodespacesAddRepositoryForSecretForAuthenticatedUserResponse>()
  }

  /**
 * Removes a repository from the selected repositories for a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_remove_repository_for_secret_for_authenticated_user',
    description: `Removes a repository from the selected repositories for a user's development environment secret.

The authenticated user must have Codespaces access to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` or \`codespace:secrets\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamsSchema
  })
  async codespacesRemoveRepositoryForSecretForAuthenticatedUser(
    params: github.CodespacesRemoveRepositoryForSecretForAuthenticatedUserParams
  ): Promise<github.CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse> {
    return this.ky
      .delete(
        `/user/codespaces/secrets/${params.secret_name}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse>()
  }

  /**
 * Gets information about a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_for_authenticated_user',
    description: `Gets information about a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesGetForAuthenticatedUserParamsSchema
  })
  async codespacesGetForAuthenticatedUser(
    params: github.CodespacesGetForAuthenticatedUserParams
  ): Promise<github.CodespacesGetForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/codespaces/${params.codespace_name}`)
      .json<github.CodespacesGetForAuthenticatedUserResponse>()
  }

  /**
 * Deletes a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_delete_for_authenticated_user',
    description: `Deletes a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesDeleteForAuthenticatedUserParamsSchema
  })
  async codespacesDeleteForAuthenticatedUser(
    params: github.CodespacesDeleteForAuthenticatedUserParams
  ): Promise<github.CodespacesDeleteForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/codespaces/${params.codespace_name}`)
      .json<github.CodespacesDeleteForAuthenticatedUserResponse>()
  }

  /**
 * Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.

If you specify a new machine type it will be applied the next time your codespace is started.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_update_for_authenticated_user',
    description: `Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.

If you specify a new machine type it will be applied the next time your codespace is started.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesUpdateForAuthenticatedUserParamsSchema
  })
  async codespacesUpdateForAuthenticatedUser(
    params: github.CodespacesUpdateForAuthenticatedUserParams
  ): Promise<github.CodespacesUpdateForAuthenticatedUserResponse> {
    return this.ky
      .patch(`/user/codespaces/${params.codespace_name}`, {
        json: pick(params, 'machine', 'display_name', 'recent_folders')
      })
      .json<github.CodespacesUpdateForAuthenticatedUserResponse>()
  }

  /**
 * Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.

If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_export_for_authenticated_user',
    description: `Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.

If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesExportForAuthenticatedUserParamsSchema
  })
  async codespacesExportForAuthenticatedUser(
    params: github.CodespacesExportForAuthenticatedUserParams
  ): Promise<github.CodespacesExportForAuthenticatedUserResponse> {
    return this.ky
      .post(`/user/codespaces/${params.codespace_name}/exports`)
      .json<github.CodespacesExportForAuthenticatedUserResponse>()
  }

  /**
 * Gets information about an export of a codespace.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_get_export_details_for_authenticated_user',
    description: `Gets information about an export of a codespace.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesGetExportDetailsForAuthenticatedUserParamsSchema
  })
  async codespacesGetExportDetailsForAuthenticatedUser(
    params: github.CodespacesGetExportDetailsForAuthenticatedUserParams
  ): Promise<github.CodespacesGetExportDetailsForAuthenticatedUserResponse> {
    return this.ky
      .get(
        `/user/codespaces/${params.codespace_name}/exports/${params.export_id}`,
        {}
      )
      .json<github.CodespacesGetExportDetailsForAuthenticatedUserResponse>()
  }

  /**
 * List the machine types a codespace can transition to use.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_codespace_machines_for_authenticated_user',
    description: `List the machine types a codespace can transition to use.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema:
      github.CodespacesCodespaceMachinesForAuthenticatedUserParamsSchema
  })
  async codespacesCodespaceMachinesForAuthenticatedUser(
    params: github.CodespacesCodespaceMachinesForAuthenticatedUserParams
  ): Promise<github.CodespacesCodespaceMachinesForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/codespaces/${params.codespace_name}/machines`)
      .json<github.CodespacesCodespaceMachinesForAuthenticatedUserResponse>()
  }

  /**
 * Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.

The codespace's token is granted write permissions to the repository, allowing the user to push their changes.

This will fail for a codespace that is already published, meaning it has an associated repository.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_publish_for_authenticated_user',
    description: `Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.

The codespace's token is granted write permissions to the repository, allowing the user to push their changes.

This will fail for a codespace that is already published, meaning it has an associated repository.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesPublishForAuthenticatedUserParamsSchema
  })
  async codespacesPublishForAuthenticatedUser(
    params: github.CodespacesPublishForAuthenticatedUserParams
  ): Promise<github.CodespacesPublishForAuthenticatedUserResponse> {
    return this.ky
      .post(`/user/codespaces/${params.codespace_name}/publish`, {
        json: pick(params, 'name', 'private')
      })
      .json<github.CodespacesPublishForAuthenticatedUserResponse>()
  }

  /**
 * Starts a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_start_for_authenticated_user',
    description: `Starts a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesStartForAuthenticatedUserParamsSchema
  })
  async codespacesStartForAuthenticatedUser(
    params: github.CodespacesStartForAuthenticatedUserParams
  ): Promise<github.CodespacesStartForAuthenticatedUserResponse> {
    return this.ky
      .post(`/user/codespaces/${params.codespace_name}/start`)
      .json<github.CodespacesStartForAuthenticatedUserResponse>()
  }

  /**
 * Stops a user's codespace.

OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
 */
  @aiFunction({
    name: 'codespaces_stop_for_authenticated_user',
    description: `Stops a user's codespace.

OAuth app tokens and personal access tokens (classic) need the \`codespace\` scope to use this endpoint.`,
    inputSchema: github.CodespacesStopForAuthenticatedUserParamsSchema
  })
  async codespacesStopForAuthenticatedUser(
    params: github.CodespacesStopForAuthenticatedUserParams
  ): Promise<github.CodespacesStopForAuthenticatedUserResponse> {
    return this.ky
      .post(`/user/codespaces/${params.codespace_name}/stop`)
      .json<github.CodespacesStopForAuthenticatedUserResponse>()
  }

  /**
 * Lists all packages that are owned by the authenticated user within the user's namespace, and that encountered a conflict during a Docker migration.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
 */
  @aiFunction({
    name: 'packages_list_docker_migration_conflicting_packages_for_authenticated_user',
    description: `Lists all packages that are owned by the authenticated user within the user's namespace, and that encountered a conflict during a Docker migration.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint.`,
    inputSchema:
      github.PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParamsSchema
  })
  async packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(
    _params: github.PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserParams
  ): Promise<github.PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/docker/conflicts')
      .json<github.PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponse>()
  }

  /**
   * Sets the visibility for your primary email addresses.
   */
  @aiFunction({
    name: 'users_set_primary_email_visibility_for_authenticated_user',
    description: `Sets the visibility for your primary email addresses.`,
    inputSchema:
      github.UsersSetPrimaryEmailVisibilityForAuthenticatedUserParamsSchema
  })
  async usersSetPrimaryEmailVisibilityForAuthenticatedUser(
    params: github.UsersSetPrimaryEmailVisibilityForAuthenticatedUserParams
  ): Promise<github.UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse> {
    return this.ky
      .patch('/user/email/visibility', {
        json: params
      })
      .json<github.UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse>()
  }

  /**
 * Lists all of your email addresses, and specifies which one is visible
to the public.

OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_list_emails_for_authenticated_user',
    description: `Lists all of your email addresses, and specifies which one is visible
to the public.

OAuth app tokens and personal access tokens (classic) need the \`user:email\` scope to use this endpoint.`,
    inputSchema: github.UsersListEmailsForAuthenticatedUserParamsSchema
  })
  async usersListEmailsForAuthenticatedUser(
    params: github.UsersListEmailsForAuthenticatedUserParams
  ): Promise<github.UsersListEmailsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/emails', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListEmailsForAuthenticatedUserResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
   */
  @aiFunction({
    name: 'users_add_email_for_authenticated_user',
    description: `OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.UsersAddEmailForAuthenticatedUserParamsSchema as any
  })
  async usersAddEmailForAuthenticatedUser(
    params: github.UsersAddEmailForAuthenticatedUserParams
  ): Promise<github.UsersAddEmailForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/emails', {
        json: params
      })
      .json<github.UsersAddEmailForAuthenticatedUserResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
   */
  @aiFunction({
    name: 'users_delete_email_for_authenticated_user',
    description: `OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    // TODO: Improve handling of union params
    inputSchema: github.UsersDeleteEmailForAuthenticatedUserParamsSchema as any
  })
  async usersDeleteEmailForAuthenticatedUser(
    params: github.UsersDeleteEmailForAuthenticatedUserParams
  ): Promise<github.UsersDeleteEmailForAuthenticatedUserResponse> {
    return this.ky
      .delete('/user/emails', {
        json: params
      })
      .json<github.UsersDeleteEmailForAuthenticatedUserResponse>()
  }

  /**
   * Lists the people following the authenticated user.
   */
  @aiFunction({
    name: 'users_list_followers_for_authenticated_user',
    description: `Lists the people following the authenticated user.`,
    inputSchema: github.UsersListFollowersForAuthenticatedUserParamsSchema
  })
  async usersListFollowersForAuthenticatedUser(
    params: github.UsersListFollowersForAuthenticatedUserParams
  ): Promise<github.UsersListFollowersForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/followers', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListFollowersForAuthenticatedUserResponse>()
  }

  /**
   * Lists the people who the authenticated user follows.
   */
  @aiFunction({
    name: 'users_list_followed_by_authenticated_user',
    description: `Lists the people who the authenticated user follows.`,
    inputSchema: github.UsersListFollowedByAuthenticatedUserParamsSchema
  })
  async usersListFollowedByAuthenticatedUser(
    params: github.UsersListFollowedByAuthenticatedUserParams
  ): Promise<github.UsersListFollowedByAuthenticatedUserResponse> {
    return this.ky
      .get('/user/following', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListFollowedByAuthenticatedUserResponse>()
  }

  /**
   * Check if a person is followed by the authenticated user.
   */
  @aiFunction({
    name: 'users_check_person_is_followed_by_authenticated',
    description: `Check if a person is followed by the authenticated user.`,
    inputSchema: github.UsersCheckPersonIsFollowedByAuthenticatedParamsSchema
  })
  async usersCheckPersonIsFollowedByAuthenticated(
    params: github.UsersCheckPersonIsFollowedByAuthenticatedParams
  ): Promise<github.UsersCheckPersonIsFollowedByAuthenticatedResponse> {
    return this.ky
      .get(`/user/following/${params.username}`)
      .json<github.UsersCheckPersonIsFollowedByAuthenticatedResponse>()
  }

  /**
 * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_follow',
    description: `Note that you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."

OAuth app tokens and personal access tokens (classic) need the \`user:follow\` scope to use this endpoint.`,
    inputSchema: github.UsersFollowParamsSchema
  })
  async usersFollow(
    params: github.UsersFollowParams
  ): Promise<github.UsersFollowResponse> {
    return this.ky
      .put(`/user/following/${params.username}`)
      .json<github.UsersFollowResponse>()
  }

  /**
   * OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
   */
  @aiFunction({
    name: 'users_unfollow',
    description: `OAuth app tokens and personal access tokens (classic) need the \`user:follow\` scope to use this endpoint.`,
    inputSchema: github.UsersUnfollowParamsSchema
  })
  async usersUnfollow(
    params: github.UsersUnfollowParams
  ): Promise<github.UsersUnfollowResponse> {
    return this.ky
      .delete(`/user/following/${params.username}`)
      .json<github.UsersUnfollowResponse>()
  }

  /**
 * Lists the current user's GPG keys.

OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_list_gpg_keys_for_authenticated_user',
    description: `Lists the current user's GPG keys.

OAuth app tokens and personal access tokens (classic) need the \`read:gpg_key\` scope to use this endpoint.`,
    inputSchema: github.UsersListGpgKeysForAuthenticatedUserParamsSchema
  })
  async usersListGpgKeysForAuthenticatedUser(
    params: github.UsersListGpgKeysForAuthenticatedUserParams
  ): Promise<github.UsersListGpgKeysForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/gpg_keys', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListGpgKeysForAuthenticatedUserResponse>()
  }

  /**
 * Adds a GPG key to the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_create_gpg_key_for_authenticated_user',
    description: `Adds a GPG key to the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`write:gpg_key\` scope to use this endpoint.`,
    inputSchema: github.UsersCreateGpgKeyForAuthenticatedUserParamsSchema
  })
  async usersCreateGpgKeyForAuthenticatedUser(
    params: github.UsersCreateGpgKeyForAuthenticatedUserParams
  ): Promise<github.UsersCreateGpgKeyForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/gpg_keys', {
        json: pick(params, 'name', 'armored_public_key')
      })
      .json<github.UsersCreateGpgKeyForAuthenticatedUserResponse>()
  }

  /**
 * View extended details for a single GPG key.

OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_get_gpg_key_for_authenticated_user',
    description: `View extended details for a single GPG key.

OAuth app tokens and personal access tokens (classic) need the \`read:gpg_key\` scope to use this endpoint.`,
    inputSchema: github.UsersGetGpgKeyForAuthenticatedUserParamsSchema
  })
  async usersGetGpgKeyForAuthenticatedUser(
    params: github.UsersGetGpgKeyForAuthenticatedUserParams
  ): Promise<github.UsersGetGpgKeyForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/gpg_keys/${params.gpg_key_id}`)
      .json<github.UsersGetGpgKeyForAuthenticatedUserResponse>()
  }

  /**
 * Removes a GPG key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `admin:gpg_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_delete_gpg_key_for_authenticated_user',
    description: `Removes a GPG key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`admin:gpg_key\` scope to use this endpoint.`,
    inputSchema: github.UsersDeleteGpgKeyForAuthenticatedUserParamsSchema
  })
  async usersDeleteGpgKeyForAuthenticatedUser(
    params: github.UsersDeleteGpgKeyForAuthenticatedUserParams
  ): Promise<github.UsersDeleteGpgKeyForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/gpg_keys/${params.gpg_key_id}`)
      .json<github.UsersDeleteGpgKeyForAuthenticatedUserResponse>()
  }

  /**
 * Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

You can find the permissions for the installation under the `permissions` key.
 */
  @aiFunction({
    name: 'apps_list_installations_for_authenticated_user',
    description: `Lists installations of your GitHub App that the authenticated user has explicit permission (\`:read\`, \`:write\`, or \`:admin\`) to access.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

You can find the permissions for the installation under the \`permissions\` key.`,
    inputSchema: github.AppsListInstallationsForAuthenticatedUserParamsSchema
  })
  async appsListInstallationsForAuthenticatedUser(
    params: github.AppsListInstallationsForAuthenticatedUserParams
  ): Promise<github.AppsListInstallationsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/installations', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListInstallationsForAuthenticatedUserResponse>()
  }

  /**
 * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

The access the user has to each repository is included in the hash under the `permissions` key.
 */
  @aiFunction({
    name: 'apps_list_installation_repos_for_authenticated_user',
    description: `List repositories that the authenticated user has explicit permission (\`:read\`, \`:write\`, or \`:admin\`) to access for an installation.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

The access the user has to each repository is included in the hash under the \`permissions\` key.`,
    inputSchema:
      github.AppsListInstallationReposForAuthenticatedUserParamsSchema
  })
  async appsListInstallationReposForAuthenticatedUser(
    params: github.AppsListInstallationReposForAuthenticatedUserParams
  ): Promise<github.AppsListInstallationReposForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/installations/${params.installation_id}/repositories`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListInstallationReposForAuthenticatedUserResponse>()
  }

  /**
 * Add a single repository to an installation. The authenticated user must have admin access to the repository.

This endpoint only works for PATs (classic) with the `repo` scope.
 */
  @aiFunction({
    name: 'apps_add_repo_to_installation_for_authenticated_user',
    description: `Add a single repository to an installation. The authenticated user must have admin access to the repository.

This endpoint only works for PATs (classic) with the \`repo\` scope.`,
    inputSchema:
      github.AppsAddRepoToInstallationForAuthenticatedUserParamsSchema
  })
  async appsAddRepoToInstallationForAuthenticatedUser(
    params: github.AppsAddRepoToInstallationForAuthenticatedUserParams
  ): Promise<github.AppsAddRepoToInstallationForAuthenticatedUserResponse> {
    return this.ky
      .put(
        `/user/installations/${params.installation_id}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.AppsAddRepoToInstallationForAuthenticatedUserResponse>()
  }

  /**
 * Remove a single repository from an installation. The authenticated user must have admin access to the repository. The installation must have the `repository_selection` of `selected`.

This endpoint only works for PATs (classic) with the `repo` scope.
 */
  @aiFunction({
    name: 'apps_remove_repo_from_installation_for_authenticated_user',
    description: `Remove a single repository from an installation. The authenticated user must have admin access to the repository. The installation must have the \`repository_selection\` of \`selected\`.

This endpoint only works for PATs (classic) with the \`repo\` scope.`,
    inputSchema:
      github.AppsRemoveRepoFromInstallationForAuthenticatedUserParamsSchema
  })
  async appsRemoveRepoFromInstallationForAuthenticatedUser(
    params: github.AppsRemoveRepoFromInstallationForAuthenticatedUserParams
  ): Promise<github.AppsRemoveRepoFromInstallationForAuthenticatedUserResponse> {
    return this.ky
      .delete(
        `/user/installations/${params.installation_id}/repositories/${params.repository_id}`,
        {}
      )
      .json<github.AppsRemoveRepoFromInstallationForAuthenticatedUserResponse>()
  }

  /**
   * Shows which type of GitHub user can interact with your public repositories and when the restriction expires.
   */
  @aiFunction({
    name: 'interactions_get_restrictions_for_authenticated_user',
    description: `Shows which type of GitHub user can interact with your public repositories and when the restriction expires.`,
    inputSchema:
      github.InteractionsGetRestrictionsForAuthenticatedUserParamsSchema
  })
  async interactionsGetRestrictionsForAuthenticatedUser(
    _params: github.InteractionsGetRestrictionsForAuthenticatedUserParams
  ): Promise<github.InteractionsGetRestrictionsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/interaction-limits')
      .json<github.InteractionsGetRestrictionsForAuthenticatedUserResponse>()
  }

  /**
   * Temporarily restricts which type of GitHub user can interact with your public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set for individual repositories owned by the user.
   */
  @aiFunction({
    name: 'interactions_set_restrictions_for_authenticated_user',
    description: `Temporarily restricts which type of GitHub user can interact with your public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set for individual repositories owned by the user.`,
    inputSchema:
      github.InteractionsSetRestrictionsForAuthenticatedUserParamsSchema
  })
  async interactionsSetRestrictionsForAuthenticatedUser(
    params: github.InteractionsSetRestrictionsForAuthenticatedUserParams
  ): Promise<github.InteractionsSetRestrictionsForAuthenticatedUserResponse> {
    return this.ky
      .put('/user/interaction-limits', {
        json: pick(params, 'limit', 'expiry')
      })
      .json<github.InteractionsSetRestrictionsForAuthenticatedUserResponse>()
  }

  /**
   * Removes any interaction restrictions from your public repositories.
   */
  @aiFunction({
    name: 'interactions_remove_restrictions_for_authenticated_user',
    description: `Removes any interaction restrictions from your public repositories.`,
    inputSchema:
      github.InteractionsRemoveRestrictionsForAuthenticatedUserParamsSchema
  })
  async interactionsRemoveRestrictionsForAuthenticatedUser(
    _params: github.InteractionsRemoveRestrictionsForAuthenticatedUserParams
  ): Promise<github.InteractionsRemoveRestrictionsForAuthenticatedUserResponse> {
    return this.ky
      .delete('/user/interaction-limits')
      .json<github.InteractionsRemoveRestrictionsForAuthenticatedUserResponse>()
  }

  /**
 * List issues across owned and member repositories assigned to the authenticated user.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
 */
  @aiFunction({
    name: 'issues_list_for_authenticated_user',
    description: `List issues across owned and member repositories assigned to the authenticated user.

> [!NOTE]
> GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the \`pull_request\` key. Be aware that the \`id\` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.raw+json\`**: Returns the raw markdown body. Response will include \`body\`. This is the default if you do not pass any specific media type.
- **\`application/vnd.github.text+json\`**: Returns a text only representation of the markdown body. Response will include \`body_text\`.
- **\`application/vnd.github.html+json\`**: Returns HTML rendered from the body's markdown. Response will include \`body_html\`.
- **\`application/vnd.github.full+json\`**: Returns raw, text, and HTML representations. Response will include \`body\`, \`body_text\`, and \`body_html\`.`,
    inputSchema: github.IssuesListForAuthenticatedUserParamsSchema
  })
  async issuesListForAuthenticatedUser(
    params: github.IssuesListForAuthenticatedUserParams
  ): Promise<github.IssuesListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/issues', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'filter',
            'state',
            'labels',
            'sort',
            'direction',
            'since',
            'per_page',
            'page'
          )
        )
      })
      .json<github.IssuesListForAuthenticatedUserResponse>()
  }

  /**
 * Lists the public SSH keys for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_list_public_ssh_keys_for_authenticated_user',
    description: `Lists the public SSH keys for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`read:public_key\` scope to use this endpoint.`,
    inputSchema: github.UsersListPublicSshKeysForAuthenticatedUserParamsSchema
  })
  async usersListPublicSshKeysForAuthenticatedUser(
    params: github.UsersListPublicSshKeysForAuthenticatedUserParams
  ): Promise<github.UsersListPublicSshKeysForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/keys', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListPublicSshKeysForAuthenticatedUserResponse>()
  }

  /**
 * Adds a public SSH key to the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_create_public_ssh_key_for_authenticated_user',
    description: `Adds a public SSH key to the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`write:gpg_key\` scope to use this endpoint.`,
    inputSchema: github.UsersCreatePublicSshKeyForAuthenticatedUserParamsSchema
  })
  async usersCreatePublicSshKeyForAuthenticatedUser(
    params: github.UsersCreatePublicSshKeyForAuthenticatedUserParams
  ): Promise<github.UsersCreatePublicSshKeyForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/keys', {
        json: pick(params, 'title', 'key')
      })
      .json<github.UsersCreatePublicSshKeyForAuthenticatedUserResponse>()
  }

  /**
 * View extended details for a single public SSH key.

OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_get_public_ssh_key_for_authenticated_user',
    description: `View extended details for a single public SSH key.

OAuth app tokens and personal access tokens (classic) need the \`read:public_key\` scope to use this endpoint.`,
    inputSchema: github.UsersGetPublicSshKeyForAuthenticatedUserParamsSchema
  })
  async usersGetPublicSshKeyForAuthenticatedUser(
    params: github.UsersGetPublicSshKeyForAuthenticatedUserParams
  ): Promise<github.UsersGetPublicSshKeyForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/keys/${params.key_id}`)
      .json<github.UsersGetPublicSshKeyForAuthenticatedUserResponse>()
  }

  /**
 * Removes a public SSH key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `admin:public_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_delete_public_ssh_key_for_authenticated_user',
    description: `Removes a public SSH key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`admin:public_key\` scope to use this endpoint.`,
    inputSchema: github.UsersDeletePublicSshKeyForAuthenticatedUserParamsSchema
  })
  async usersDeletePublicSshKeyForAuthenticatedUser(
    params: github.UsersDeletePublicSshKeyForAuthenticatedUserParams
  ): Promise<github.UsersDeletePublicSshKeyForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/keys/${params.key_id}`)
      .json<github.UsersDeletePublicSshKeyForAuthenticatedUserResponse>()
  }

  /**
   * Lists the active subscriptions for the authenticated user.
   */
  @aiFunction({
    name: 'apps_list_subscriptions_for_authenticated_user',
    description: `Lists the active subscriptions for the authenticated user.`,
    inputSchema: github.AppsListSubscriptionsForAuthenticatedUserParamsSchema
  })
  async appsListSubscriptionsForAuthenticatedUser(
    params: github.AppsListSubscriptionsForAuthenticatedUserParams
  ): Promise<github.AppsListSubscriptionsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/marketplace_purchases', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListSubscriptionsForAuthenticatedUserResponse>()
  }

  /**
   * Lists the active subscriptions for the authenticated user.
   */
  @aiFunction({
    name: 'apps_list_subscriptions_for_authenticated_user_stubbed',
    description: `Lists the active subscriptions for the authenticated user.`,
    inputSchema:
      github.AppsListSubscriptionsForAuthenticatedUserStubbedParamsSchema
  })
  async appsListSubscriptionsForAuthenticatedUserStubbed(
    params: github.AppsListSubscriptionsForAuthenticatedUserStubbedParams
  ): Promise<github.AppsListSubscriptionsForAuthenticatedUserStubbedResponse> {
    return this.ky
      .get('/user/marketplace_purchases/stubbed', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.AppsListSubscriptionsForAuthenticatedUserStubbedResponse>()
  }

  /**
   * Lists all of the authenticated user's organization memberships.
   */
  @aiFunction({
    name: 'orgs_list_memberships_for_authenticated_user',
    description: `Lists all of the authenticated user's organization memberships.`,
    inputSchema: github.OrgsListMembershipsForAuthenticatedUserParamsSchema
  })
  async orgsListMembershipsForAuthenticatedUser(
    params: github.OrgsListMembershipsForAuthenticatedUserParams
  ): Promise<github.OrgsListMembershipsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/memberships/orgs', {
        searchParams: sanitizeSearchParams(
          pick(params, 'state', 'per_page', 'page')
        )
      })
      .json<github.OrgsListMembershipsForAuthenticatedUserResponse>()
  }

  /**
   * If the authenticated user is an active or pending member of the organization, this endpoint will return the user's membership. If the authenticated user is not affiliated with the organization, a `404` is returned. This endpoint will return a `403` if the request is made by a GitHub App that is blocked by the organization.
   */
  @aiFunction({
    name: 'orgs_get_membership_for_authenticated_user',
    description: `If the authenticated user is an active or pending member of the organization, this endpoint will return the user's membership. If the authenticated user is not affiliated with the organization, a \`404\` is returned. This endpoint will return a \`403\` if the request is made by a GitHub App that is blocked by the organization.`,
    inputSchema: github.OrgsGetMembershipForAuthenticatedUserParamsSchema
  })
  async orgsGetMembershipForAuthenticatedUser(
    params: github.OrgsGetMembershipForAuthenticatedUserParams
  ): Promise<github.OrgsGetMembershipForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/memberships/orgs/${params.org}`)
      .json<github.OrgsGetMembershipForAuthenticatedUserResponse>()
  }

  /**
   * Converts the authenticated user to an active member of the organization, if that user has a pending invitation from the organization.
   */
  @aiFunction({
    name: 'orgs_update_membership_for_authenticated_user',
    description: `Converts the authenticated user to an active member of the organization, if that user has a pending invitation from the organization.`,
    inputSchema: github.OrgsUpdateMembershipForAuthenticatedUserParamsSchema
  })
  async orgsUpdateMembershipForAuthenticatedUser(
    params: github.OrgsUpdateMembershipForAuthenticatedUserParams
  ): Promise<github.OrgsUpdateMembershipForAuthenticatedUserResponse> {
    return this.ky
      .patch(`/user/memberships/orgs/${params.org}`, {
        json: pick(params, 'state')
      })
      .json<github.OrgsUpdateMembershipForAuthenticatedUserResponse>()
  }

  /**
   * Lists all migrations a user has started.
   */
  @aiFunction({
    name: 'migrations_list_for_authenticated_user',
    description: `Lists all migrations a user has started.`,
    inputSchema: github.MigrationsListForAuthenticatedUserParamsSchema
  })
  async migrationsListForAuthenticatedUser(
    params: github.MigrationsListForAuthenticatedUserParams
  ): Promise<github.MigrationsListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/migrations', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.MigrationsListForAuthenticatedUserResponse>()
  }

  /**
   * Initiates the generation of a user migration archive.
   */
  @aiFunction({
    name: 'migrations_start_for_authenticated_user',
    description: `Initiates the generation of a user migration archive.`,
    inputSchema: github.MigrationsStartForAuthenticatedUserParamsSchema
  })
  async migrationsStartForAuthenticatedUser(
    params: github.MigrationsStartForAuthenticatedUserParams
  ): Promise<github.MigrationsStartForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/migrations', {
        json: pick(
          params,
          'lock_repositories',
          'exclude_metadata',
          'exclude_git_data',
          'exclude_attachments',
          'exclude_releases',
          'exclude_owner_projects',
          'org_metadata_only',
          'exclude',
          'repositories'
        )
      })
      .json<github.MigrationsStartForAuthenticatedUserResponse>()
  }

  /**
 * Fetches a single user migration. The response includes the `state` of the migration, which can be one of the following values:

*   `pending` - the migration hasn't started yet.
*   `exporting` - the migration is in progress.
*   `exported` - the migration finished successfully.
*   `failed` - the migration failed.

Once the migration has been `exported` you can [download the migration archive](https://docs.github.com/rest/migrations/users#download-a-user-migration-archive).
 */
  @aiFunction({
    name: 'migrations_get_status_for_authenticated_user',
    description: `Fetches a single user migration. The response includes the \`state\` of the migration, which can be one of the following values:

*   \`pending\` - the migration hasn't started yet.
*   \`exporting\` - the migration is in progress.
*   \`exported\` - the migration finished successfully.
*   \`failed\` - the migration failed.

Once the migration has been \`exported\` you can [download the migration archive](https://docs.github.com/rest/migrations/users#download-a-user-migration-archive).`,
    inputSchema: github.MigrationsGetStatusForAuthenticatedUserParamsSchema
  })
  async migrationsGetStatusForAuthenticatedUser(
    params: github.MigrationsGetStatusForAuthenticatedUserParams
  ): Promise<github.MigrationsGetStatusForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/migrations/${params.migration_id}`, {
        searchParams: sanitizeSearchParams(pick(params, 'exclude'))
      })
      .json<github.MigrationsGetStatusForAuthenticatedUserResponse>()
  }

  /**
 * Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources your repository uses, the migration archive can contain JSON files with data for these objects:

*   attachments
*   bases
*   commit\_comments
*   issue\_comments
*   issue\_events
*   issues
*   milestones
*   organizations
*   projects
*   protected\_branches
*   pull\_request\_reviews
*   pull\_requests
*   releases
*   repositories
*   review\_comments
*   schema
*   users

The archive will also contain an `attachments` directory that includes all attachment files uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
 */
  @aiFunction({
    name: 'migrations_get_archive_for_authenticated_user',
    description: `Fetches the URL to download the migration archive as a \`tar.gz\` file. Depending on the resources your repository uses, the migration archive can contain JSON files with data for these objects:

*   attachments
*   bases
*   commit\_comments
*   issue\_comments
*   issue\_events
*   issues
*   milestones
*   organizations
*   projects
*   protected\_branches
*   pull\_request\_reviews
*   pull\_requests
*   releases
*   repositories
*   review\_comments
*   schema
*   users

The archive will also contain an \`attachments\` directory that includes all attachment files uploaded to GitHub.com and a \`repositories\` directory that contains the repository's Git data.`,
    inputSchema: github.MigrationsGetArchiveForAuthenticatedUserParamsSchema
  })
  async migrationsGetArchiveForAuthenticatedUser(
    params: github.MigrationsGetArchiveForAuthenticatedUserParams
  ): Promise<github.MigrationsGetArchiveForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/migrations/${params.migration_id}/archive`)
      .json<github.MigrationsGetArchiveForAuthenticatedUserResponse>()
  }

  /**
   * Deletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/migrations/users#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/migrations/users#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted.
   */
  @aiFunction({
    name: 'migrations_delete_archive_for_authenticated_user',
    description: `Deletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/migrations/users#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/migrations/users#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted.`,
    inputSchema: github.MigrationsDeleteArchiveForAuthenticatedUserParamsSchema
  })
  async migrationsDeleteArchiveForAuthenticatedUser(
    params: github.MigrationsDeleteArchiveForAuthenticatedUserParams
  ): Promise<github.MigrationsDeleteArchiveForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/migrations/${params.migration_id}/archive`)
      .json<github.MigrationsDeleteArchiveForAuthenticatedUserResponse>()
  }

  /**
   * Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/migrations/users#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/repos/repos#delete-a-repository) if you no longer need the source data. Returns a status of `404 Not Found` if the repository is not locked.
   */
  @aiFunction({
    name: 'migrations_unlock_repo_for_authenticated_user',
    description: `Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/migrations/users#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/repos/repos#delete-a-repository) if you no longer need the source data. Returns a status of \`404 Not Found\` if the repository is not locked.`,
    inputSchema: github.MigrationsUnlockRepoForAuthenticatedUserParamsSchema
  })
  async migrationsUnlockRepoForAuthenticatedUser(
    params: github.MigrationsUnlockRepoForAuthenticatedUserParams
  ): Promise<github.MigrationsUnlockRepoForAuthenticatedUserResponse> {
    return this.ky
      .delete(
        `/user/migrations/${params.migration_id}/repos/${params.repo_name}/lock`,
        {}
      )
      .json<github.MigrationsUnlockRepoForAuthenticatedUserResponse>()
  }

  /**
   * Lists all the repositories for this user migration.
   */
  @aiFunction({
    name: 'migrations_list_repos_for_authenticated_user',
    description: `Lists all the repositories for this user migration.`,
    inputSchema: github.MigrationsListReposForAuthenticatedUserParamsSchema
  })
  async migrationsListReposForAuthenticatedUser(
    params: github.MigrationsListReposForAuthenticatedUserParams
  ): Promise<github.MigrationsListReposForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/migrations/${params.migration_id}/repositories`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.MigrationsListReposForAuthenticatedUserResponse>()
  }

  /**
 * List organizations for the authenticated user.

For OAuth app tokens and personal access tokens (classic), this endpoint only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope for OAuth app tokens and personal access tokens (classic). Requests with insufficient scope will receive a `403 Forbidden` response.

> [!NOTE]
> Requests using a fine-grained access token will receive a `200 Success` response with an empty list.
 */
  @aiFunction({
    name: 'orgs_list_for_authenticated_user',
    description: `List organizations for the authenticated user.

For OAuth app tokens and personal access tokens (classic), this endpoint only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with \`read:org\` scope, you can publicize your organization membership with \`user\` scope, etc.). Therefore, this API requires at least \`user\` or \`read:org\` scope for OAuth app tokens and personal access tokens (classic). Requests with insufficient scope will receive a \`403 Forbidden\` response.

> [!NOTE]
> Requests using a fine-grained access token will receive a \`200 Success\` response with an empty list.`,
    inputSchema: github.OrgsListForAuthenticatedUserParamsSchema
  })
  async orgsListForAuthenticatedUser(
    params: github.OrgsListForAuthenticatedUserParams
  ): Promise<github.OrgsListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/orgs', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListForAuthenticatedUserResponse>()
  }

  /**
 * Lists packages owned by the authenticated user within the user's namespace.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_list_packages_for_authenticated_user',
    description: `Lists packages owned by the authenticated user within the user's namespace.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesListPackagesForAuthenticatedUserParamsSchema
  })
  async packagesListPackagesForAuthenticatedUser(
    params: github.PackagesListPackagesForAuthenticatedUserParams
  ): Promise<github.PackagesListPackagesForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/packages', {
        searchParams: sanitizeSearchParams(
          pick(params, 'package_type', 'visibility', 'page', 'per_page')
        )
      })
      .json<github.PackagesListPackagesForAuthenticatedUserResponse>()
  }

  /**
 * Gets a specific package for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_for_authenticated_user',
    description: `Gets a specific package for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesGetPackageForAuthenticatedUserParamsSchema
  })
  async packagesGetPackageForAuthenticatedUser(
    params: github.PackagesGetPackageForAuthenticatedUserParams
  ): Promise<github.PackagesGetPackageForAuthenticatedUserResponse> {
    return this.ky
      .get(
        `/user/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesGetPackageForAuthenticatedUserResponse>()
  }

  /**
 * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_for_authenticated_user',
    description: `Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesDeletePackageForAuthenticatedUserParamsSchema
  })
  async packagesDeletePackageForAuthenticatedUser(
    params: github.PackagesDeletePackageForAuthenticatedUserParams
  ): Promise<github.PackagesDeletePackageForAuthenticatedUserResponse> {
    return this.ky
      .delete(
        `/user/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesDeletePackageForAuthenticatedUserResponse>()
  }

  /**
 * Restores a package owned by the authenticated user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_for_authenticated_user',
    description: `Restores a package owned by the authenticated user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesRestorePackageForAuthenticatedUserParamsSchema
  })
  async packagesRestorePackageForAuthenticatedUser(
    params: github.PackagesRestorePackageForAuthenticatedUserParams
  ): Promise<github.PackagesRestorePackageForAuthenticatedUserResponse> {
    return this.ky
      .post(
        `/user/packages/${params.package_type}/${params.package_name}/restore`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'token'))
        }
      )
      .json<github.PackagesRestorePackageForAuthenticatedUserResponse>()
  }

  /**
 * Lists package versions for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_all_package_versions_for_package_owned_by_authenticated_user',
    description: `Lists package versions for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsSchema
  })
  async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
    params: github.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
  ): Promise<github.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse> {
    return this.ky
      .get(
        `/user/packages/${params.package_type}/${params.package_name}/versions`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'page', 'per_page', 'state')
          )
        }
      )
      .json<github.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse>()
  }

  /**
 * Gets a specific package version for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_version_for_authenticated_user',
    description: `Gets a specific package version for a package owned by the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesGetPackageVersionForAuthenticatedUserParamsSchema
  })
  async packagesGetPackageVersionForAuthenticatedUser(
    params: github.PackagesGetPackageVersionForAuthenticatedUserParams
  ): Promise<github.PackagesGetPackageVersionForAuthenticatedUserResponse> {
    return this.ky
      .get(
        `/user/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesGetPackageVersionForAuthenticatedUserResponse>()
  }

  /**
 * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_version_for_authenticated_user',
    description: `Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

The authenticated user must have admin permissions in the organization to use this endpoint.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesDeletePackageVersionForAuthenticatedUserParamsSchema
  })
  async packagesDeletePackageVersionForAuthenticatedUser(
    params: github.PackagesDeletePackageVersionForAuthenticatedUserParams
  ): Promise<github.PackagesDeletePackageVersionForAuthenticatedUserResponse> {
    return this.ky
      .delete(
        `/user/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesDeletePackageVersionForAuthenticatedUserResponse>()
  }

  /**
 * Restores a package version owned by the authenticated user.

You can restore a deleted package version under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_version_for_authenticated_user',
    description: `Restores a package version owned by the authenticated user.

You can restore a deleted package version under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesRestorePackageVersionForAuthenticatedUserParamsSchema
  })
  async packagesRestorePackageVersionForAuthenticatedUser(
    params: github.PackagesRestorePackageVersionForAuthenticatedUserParams
  ): Promise<github.PackagesRestorePackageVersionForAuthenticatedUserResponse> {
    return this.ky
      .post(
        `/user/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}/restore`,
        {}
      )
      .json<github.PackagesRestorePackageVersionForAuthenticatedUserResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_create_for_authenticated_user',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsCreateForAuthenticatedUserParamsSchema
  })
  async projectsCreateForAuthenticatedUser(
    params: github.ProjectsCreateForAuthenticatedUserParams
  ): Promise<github.ProjectsCreateForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/projects', {
        json: pick(params, 'name', 'body')
      })
      .json<github.ProjectsCreateForAuthenticatedUserResponse>()
  }

  /**
 * Lists your publicly visible email address, which you can set with the
[Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
endpoint.

OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_list_public_emails_for_authenticated_user',
    description: `Lists your publicly visible email address, which you can set with the
[Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
endpoint.

OAuth app tokens and personal access tokens (classic) need the \`user:email\` scope to use this endpoint.`,
    inputSchema: github.UsersListPublicEmailsForAuthenticatedUserParamsSchema
  })
  async usersListPublicEmailsForAuthenticatedUser(
    params: github.UsersListPublicEmailsForAuthenticatedUserParams
  ): Promise<github.UsersListPublicEmailsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/public_emails', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListPublicEmailsForAuthenticatedUserResponse>()
  }

  /**
 * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
 */
  @aiFunction({
    name: 'repos_list_for_authenticated_user',
    description: `Lists repositories that the authenticated user has explicit permission (\`:read\`, \`:write\`, or \`:admin\`) to access.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.`,
    inputSchema: github.ReposListForAuthenticatedUserParamsSchema
  })
  async reposListForAuthenticatedUser(
    params: github.ReposListForAuthenticatedUserParams
  ): Promise<github.ReposListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/repos', {
        searchParams: sanitizeSearchParams(
          pick(
            params,
            'visibility',
            'affiliation',
            'type',
            'sort',
            'direction',
            'per_page',
            'page',
            'since',
            'before'
          )
        )
      })
      .json<github.ReposListForAuthenticatedUserResponse>()
  }

  /**
 * Creates a new repository for the authenticated user.

OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
 */
  @aiFunction({
    name: 'repos_create_for_authenticated_user',
    description: `Creates a new repository for the authenticated user.

OAuth app tokens and personal access tokens (classic) need the \`public_repo\` or \`repo\` scope to create a public repository, and \`repo\` scope to create a private repository.`,
    inputSchema: github.ReposCreateForAuthenticatedUserParamsSchema
  })
  async reposCreateForAuthenticatedUser(
    params: github.ReposCreateForAuthenticatedUserParams
  ): Promise<github.ReposCreateForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/repos', {
        json: pick(
          params,
          'name',
          'description',
          'homepage',
          'private',
          'has_issues',
          'has_projects',
          'has_wiki',
          'has_discussions',
          'team_id',
          'auto_init',
          'gitignore_template',
          'license_template',
          'allow_squash_merge',
          'allow_merge_commit',
          'allow_rebase_merge',
          'allow_auto_merge',
          'delete_branch_on_merge',
          'squash_merge_commit_title',
          'squash_merge_commit_message',
          'merge_commit_title',
          'merge_commit_message',
          'has_downloads',
          'is_template'
        )
      })
      .json<github.ReposCreateForAuthenticatedUserResponse>()
  }

  /**
   * When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
   */
  @aiFunction({
    name: 'repos_list_invitations_for_authenticated_user',
    description: `When authenticating as a user, this endpoint will list all currently open repository invitations for that user.`,
    inputSchema: github.ReposListInvitationsForAuthenticatedUserParamsSchema
  })
  async reposListInvitationsForAuthenticatedUser(
    params: github.ReposListInvitationsForAuthenticatedUserParams
  ): Promise<github.ReposListInvitationsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/repository_invitations', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ReposListInvitationsForAuthenticatedUserResponse>()
  }

  /**
   * Decline a repository invitation.
   */
  @aiFunction({
    name: 'repos_decline_invitation_for_authenticated_user',
    description: `Decline a repository invitation.`,
    inputSchema: github.ReposDeclineInvitationForAuthenticatedUserParamsSchema
  })
  async reposDeclineInvitationForAuthenticatedUser(
    params: github.ReposDeclineInvitationForAuthenticatedUserParams
  ): Promise<github.ReposDeclineInvitationForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/repository_invitations/${params.invitation_id}`)
      .json<github.ReposDeclineInvitationForAuthenticatedUserResponse>()
  }

  /**
   * Accept a repository invitation.
   */
  @aiFunction({
    name: 'repos_accept_invitation_for_authenticated_user',
    description: `Accept a repository invitation.`,
    inputSchema: github.ReposAcceptInvitationForAuthenticatedUserParamsSchema
  })
  async reposAcceptInvitationForAuthenticatedUser(
    params: github.ReposAcceptInvitationForAuthenticatedUserParams
  ): Promise<github.ReposAcceptInvitationForAuthenticatedUserResponse> {
    return this.ky
      .patch(`/user/repository_invitations/${params.invitation_id}`)
      .json<github.ReposAcceptInvitationForAuthenticatedUserResponse>()
  }

  /**
   * Lists all of your social accounts.
   */
  @aiFunction({
    name: 'users_list_social_accounts_for_authenticated_user',
    description: `Lists all of your social accounts.`,
    inputSchema: github.UsersListSocialAccountsForAuthenticatedUserParamsSchema
  })
  async usersListSocialAccountsForAuthenticatedUser(
    params: github.UsersListSocialAccountsForAuthenticatedUserParams
  ): Promise<github.UsersListSocialAccountsForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/social_accounts', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListSocialAccountsForAuthenticatedUserResponse>()
  }

  /**
 * Add one or more social accounts to the authenticated user's profile.

OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_add_social_account_for_authenticated_user',
    description: `Add one or more social accounts to the authenticated user's profile.

OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    inputSchema: github.UsersAddSocialAccountForAuthenticatedUserParamsSchema
  })
  async usersAddSocialAccountForAuthenticatedUser(
    params: github.UsersAddSocialAccountForAuthenticatedUserParams
  ): Promise<github.UsersAddSocialAccountForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/social_accounts', {
        json: params
      })
      .json<github.UsersAddSocialAccountForAuthenticatedUserResponse>()
  }

  /**
 * Deletes one or more social accounts from the authenticated user's profile.

OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_delete_social_account_for_authenticated_user',
    description: `Deletes one or more social accounts from the authenticated user's profile.

OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    inputSchema: github.UsersDeleteSocialAccountForAuthenticatedUserParamsSchema
  })
  async usersDeleteSocialAccountForAuthenticatedUser(
    params: github.UsersDeleteSocialAccountForAuthenticatedUserParams
  ): Promise<github.UsersDeleteSocialAccountForAuthenticatedUserResponse> {
    return this.ky
      .delete('/user/social_accounts', {
        json: params
      })
      .json<github.UsersDeleteSocialAccountForAuthenticatedUserResponse>()
  }

  /**
 * Lists the SSH signing keys for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_list_ssh_signing_keys_for_authenticated_user',
    description: `Lists the SSH signing keys for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`read:ssh_signing_key\` scope to use this endpoint.`,
    inputSchema: github.UsersListSshSigningKeysForAuthenticatedUserParamsSchema
  })
  async usersListSshSigningKeysForAuthenticatedUser(
    params: github.UsersListSshSigningKeysForAuthenticatedUserParams
  ): Promise<github.UsersListSshSigningKeysForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/ssh_signing_keys', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListSshSigningKeysForAuthenticatedUserResponse>()
  }

  /**
 * Creates an SSH signing key for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `write:ssh_signing_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_create_ssh_signing_key_for_authenticated_user',
    description: `Creates an SSH signing key for the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`write:ssh_signing_key\` scope to use this endpoint.`,
    inputSchema: github.UsersCreateSshSigningKeyForAuthenticatedUserParamsSchema
  })
  async usersCreateSshSigningKeyForAuthenticatedUser(
    params: github.UsersCreateSshSigningKeyForAuthenticatedUserParams
  ): Promise<github.UsersCreateSshSigningKeyForAuthenticatedUserResponse> {
    return this.ky
      .post('/user/ssh_signing_keys', {
        json: pick(params, 'title', 'key')
      })
      .json<github.UsersCreateSshSigningKeyForAuthenticatedUserResponse>()
  }

  /**
 * Gets extended details for an SSH signing key.

OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_get_ssh_signing_key_for_authenticated_user',
    description: `Gets extended details for an SSH signing key.

OAuth app tokens and personal access tokens (classic) need the \`read:ssh_signing_key\` scope to use this endpoint.`,
    inputSchema: github.UsersGetSshSigningKeyForAuthenticatedUserParamsSchema
  })
  async usersGetSshSigningKeyForAuthenticatedUser(
    params: github.UsersGetSshSigningKeyForAuthenticatedUserParams
  ): Promise<github.UsersGetSshSigningKeyForAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/ssh_signing_keys/${params.ssh_signing_key_id}`)
      .json<github.UsersGetSshSigningKeyForAuthenticatedUserResponse>()
  }

  /**
 * Deletes an SSH signing key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the `admin:ssh_signing_key` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_delete_ssh_signing_key_for_authenticated_user',
    description: `Deletes an SSH signing key from the authenticated user's GitHub account.

OAuth app tokens and personal access tokens (classic) need the \`admin:ssh_signing_key\` scope to use this endpoint.`,
    inputSchema: github.UsersDeleteSshSigningKeyForAuthenticatedUserParamsSchema
  })
  async usersDeleteSshSigningKeyForAuthenticatedUser(
    params: github.UsersDeleteSshSigningKeyForAuthenticatedUserParams
  ): Promise<github.UsersDeleteSshSigningKeyForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/ssh_signing_keys/${params.ssh_signing_key_id}`)
      .json<github.UsersDeleteSshSigningKeyForAuthenticatedUserResponse>()
  }

  /**
 * Lists repositories the authenticated user has starred.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
 */
  @aiFunction({
    name: 'activity_list_repos_starred_by_authenticated_user',
    description: `Lists repositories the authenticated user has starred.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.star+json\`**: Includes a timestamp of when the star was created.`,
    inputSchema: github.ActivityListReposStarredByAuthenticatedUserParamsSchema
  })
  async activityListReposStarredByAuthenticatedUser(
    params: github.ActivityListReposStarredByAuthenticatedUserParams
  ): Promise<github.ActivityListReposStarredByAuthenticatedUserResponse> {
    return this.ky
      .get('/user/starred', {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.ActivityListReposStarredByAuthenticatedUserResponse>()
  }

  /**
   * Whether the authenticated user has starred the repository.
   */
  @aiFunction({
    name: 'activity_check_repo_is_starred_by_authenticated_user',
    description: `Whether the authenticated user has starred the repository.`,
    inputSchema:
      github.ActivityCheckRepoIsStarredByAuthenticatedUserParamsSchema
  })
  async activityCheckRepoIsStarredByAuthenticatedUser(
    params: github.ActivityCheckRepoIsStarredByAuthenticatedUserParams
  ): Promise<github.ActivityCheckRepoIsStarredByAuthenticatedUserResponse> {
    return this.ky
      .get(`/user/starred/${params.owner}/${params.repo}`, {})
      .json<github.ActivityCheckRepoIsStarredByAuthenticatedUserResponse>()
  }

  /**
   * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".
   */
  @aiFunction({
    name: 'activity_star_repo_for_authenticated_user',
    description: `Note that you'll need to set \`Content-Length\` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).".`,
    inputSchema: github.ActivityStarRepoForAuthenticatedUserParamsSchema
  })
  async activityStarRepoForAuthenticatedUser(
    params: github.ActivityStarRepoForAuthenticatedUserParams
  ): Promise<github.ActivityStarRepoForAuthenticatedUserResponse> {
    return this.ky
      .put(`/user/starred/${params.owner}/${params.repo}`, {})
      .json<github.ActivityStarRepoForAuthenticatedUserResponse>()
  }

  /**
   * Unstar a repository that the authenticated user has previously starred.
   */
  @aiFunction({
    name: 'activity_unstar_repo_for_authenticated_user',
    description: `Unstar a repository that the authenticated user has previously starred.`,
    inputSchema: github.ActivityUnstarRepoForAuthenticatedUserParamsSchema
  })
  async activityUnstarRepoForAuthenticatedUser(
    params: github.ActivityUnstarRepoForAuthenticatedUserParams
  ): Promise<github.ActivityUnstarRepoForAuthenticatedUserResponse> {
    return this.ky
      .delete(`/user/starred/${params.owner}/${params.repo}`, {})
      .json<github.ActivityUnstarRepoForAuthenticatedUserResponse>()
  }

  /**
   * Lists repositories the authenticated user is watching.
   */
  @aiFunction({
    name: 'activity_list_watched_repos_for_authenticated_user',
    description: `Lists repositories the authenticated user is watching.`,
    inputSchema: github.ActivityListWatchedReposForAuthenticatedUserParamsSchema
  })
  async activityListWatchedReposForAuthenticatedUser(
    params: github.ActivityListWatchedReposForAuthenticatedUserParams
  ): Promise<github.ActivityListWatchedReposForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/subscriptions', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListWatchedReposForAuthenticatedUserResponse>()
  }

  /**
 * List all of the teams across all of the organizations to which the authenticated
user belongs.

OAuth app tokens and personal access tokens (classic) need the `user`, `repo`, or `read:org` scope to use this endpoint.

When using a fine-grained personal access token, the resource owner of the token must be a single organization, and the response will only include the teams from that organization.
 */
  @aiFunction({
    name: 'teams_list_for_authenticated_user',
    description: `List all of the teams across all of the organizations to which the authenticated
user belongs.

OAuth app tokens and personal access tokens (classic) need the \`user\`, \`repo\`, or \`read:org\` scope to use this endpoint.

When using a fine-grained personal access token, the resource owner of the token must be a single organization, and the response will only include the teams from that organization.`,
    inputSchema: github.TeamsListForAuthenticatedUserParamsSchema
  })
  async teamsListForAuthenticatedUser(
    params: github.TeamsListForAuthenticatedUserParams
  ): Promise<github.TeamsListForAuthenticatedUserResponse> {
    return this.ky
      .get('/user/teams', {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.TeamsListForAuthenticatedUserResponse>()
  }

  /**
 * Provides publicly available information about someone with a GitHub account. This method takes their durable user `ID` instead of their `login`, which can change over time.

If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.

The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).

The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
 */
  @aiFunction({
    name: 'users_get_by_id',
    description: `Provides publicly available information about someone with a GitHub account. This method takes their durable user \`ID\` instead of their \`login\`, which can change over time.

If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a \`404 Not Found\` status.

The \`email\` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for \`email\`, then it will have a value of \`null\`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).

The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).`,
    inputSchema: github.UsersGetByIdParamsSchema
  })
  async usersGetById(
    params: github.UsersGetByIdParams
  ): Promise<github.UsersGetByIdResponse> {
    return this.ky
      .get(`/user/${params.account_id}`)
      .json<github.UsersGetByIdResponse>()
  }

  /**
 * Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.

Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.
 */
  @aiFunction({
    name: 'users_list',
    description: `Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.

Note: Pagination is powered exclusively by the \`since\` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.`,
    inputSchema: github.UsersListParamsSchema
  })
  async usersList(
    params: github.UsersListParams
  ): Promise<github.UsersListResponse> {
    return this.ky
      .get('/users', {
        searchParams: sanitizeSearchParams(pick(params, 'since', 'per_page'))
      })
      .json<github.UsersListResponse>()
  }

  /**
 * Provides publicly available information about someone with a GitHub account.

If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.

The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).

The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
 */
  @aiFunction({
    name: 'users_get_by_username',
    description: `Provides publicly available information about someone with a GitHub account.

If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a \`404 Not Found\` status.

The \`email\` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for \`email\`, then it will have a value of \`null\`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).

The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).`,
    inputSchema: github.UsersGetByUsernameParamsSchema
  })
  async usersGetByUsername(
    params: github.UsersGetByUsernameParams
  ): Promise<github.UsersGetByUsernameResponse> {
    return this.ky
      .get(`/users/${params.username}`)
      .json<github.UsersGetByUsernameResponse>()
  }

  /**
 * List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.

The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
 */
  @aiFunction({
    name: 'users_list_attestations',
    description: `List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.

The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the \`attestations:read\` permission is required.

**Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI \`attestation verify\` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).`,
    inputSchema: github.UsersListAttestationsParamsSchema
  })
  async usersListAttestations(
    params: github.UsersListAttestationsParams
  ): Promise<github.UsersListAttestationsResponse> {
    return this.ky
      .get(
        `/users/${params.username}/attestations/${params.subject_digest}`,
        {
          searchParams: sanitizeSearchParams(
            pick(params, 'per_page', 'before', 'after', 'predicate_type')
          )
        }
      )
      .json<github.UsersListAttestationsResponse>()
  }

  /**
 * Lists all packages that are in a specific user's namespace, that the requesting user has access to, and that encountered a conflict during Docker migration.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
 */
  @aiFunction({
    name: 'packages_list_docker_migration_conflicting_packages_for_user',
    description: `Lists all packages that are in a specific user's namespace, that the requesting user has access to, and that encountered a conflict during Docker migration.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint.`,
    inputSchema:
      github.PackagesListDockerMigrationConflictingPackagesForUserParamsSchema
  })
  async packagesListDockerMigrationConflictingPackagesForUser(
    params: github.PackagesListDockerMigrationConflictingPackagesForUserParams
  ): Promise<github.PackagesListDockerMigrationConflictingPackagesForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/docker/conflicts`)
      .json<github.PackagesListDockerMigrationConflictingPackagesForUserResponse>()
  }

  /**
 * If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. _Optional_: use the fine-grained token with following permission set to view private events: "Events" user permissions (read).

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_events_for_authenticated_user',
    description: `If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. _Optional_: use the fine-grained token with following permission set to view private events: "Events" user permissions (read).

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListEventsForAuthenticatedUserParamsSchema
  })
  async activityListEventsForAuthenticatedUser(
    params: github.ActivityListEventsForAuthenticatedUserParams
  ): Promise<github.ActivityListEventsForAuthenticatedUserResponse> {
    return this.ky
      .get(`/users/${params.username}/events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListEventsForAuthenticatedUserResponse>()
  }

  /**
 * This is the user's organization dashboard. You must be authenticated as the user to view this.

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_org_events_for_authenticated_user',
    description: `This is the user's organization dashboard. You must be authenticated as the user to view this.

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListOrgEventsForAuthenticatedUserParamsSchema
  })
  async activityListOrgEventsForAuthenticatedUser(
    params: github.ActivityListOrgEventsForAuthenticatedUserParams
  ): Promise<github.ActivityListOrgEventsForAuthenticatedUserResponse> {
    return this.ky
      .get(`/users/${params.username}/events/orgs/${params.org}`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListOrgEventsForAuthenticatedUserResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_public_events_for_user',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListPublicEventsForUserParamsSchema
  })
  async activityListPublicEventsForUser(
    params: github.ActivityListPublicEventsForUserParams
  ): Promise<github.ActivityListPublicEventsForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/events/public`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListPublicEventsForUserResponse>()
  }

  /**
   * Lists the people following the specified user.
   */
  @aiFunction({
    name: 'users_list_followers_for_user',
    description: `Lists the people following the specified user.`,
    inputSchema: github.UsersListFollowersForUserParamsSchema
  })
  async usersListFollowersForUser(
    params: github.UsersListFollowersForUserParams
  ): Promise<github.UsersListFollowersForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/followers`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListFollowersForUserResponse>()
  }

  /**
   * Lists the people who the specified user follows.
   */
  @aiFunction({
    name: 'users_list_following_for_user',
    description: `Lists the people who the specified user follows.`,
    inputSchema: github.UsersListFollowingForUserParamsSchema
  })
  async usersListFollowingForUser(
    params: github.UsersListFollowingForUserParams
  ): Promise<github.UsersListFollowingForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/following`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListFollowingForUserResponse>()
  }

  /**
   * Check if a user follows another user.
   */
  @aiFunction({
    name: 'users_check_following_for_user',
    description: `Check if a user follows another user.`,
    inputSchema: github.UsersCheckFollowingForUserParamsSchema
  })
  async usersCheckFollowingForUser(
    params: github.UsersCheckFollowingForUserParams
  ): Promise<github.UsersCheckFollowingForUserResponse> {
    return this.ky
      .get(
        `/users/${params.username}/following/${params.target_user}`,
        {}
      )
      .json<github.UsersCheckFollowingForUserResponse>()
  }

  /**
   * Lists public gists for the specified user:.
   */
  @aiFunction({
    name: 'gists_list_for_user',
    description: `Lists public gists for the specified user:.`,
    inputSchema: github.GistsListForUserParamsSchema
  })
  async gistsListForUser(
    params: github.GistsListForUserParams
  ): Promise<github.GistsListForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/gists`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'since', 'per_page', 'page')
        )
      })
      .json<github.GistsListForUserResponse>()
  }

  /**
   * Lists the GPG keys for a user. This information is accessible by anyone.
   */
  @aiFunction({
    name: 'users_list_gpg_keys_for_user',
    description: `Lists the GPG keys for a user. This information is accessible by anyone.`,
    inputSchema: github.UsersListGpgKeysForUserParamsSchema
  })
  async usersListGpgKeysForUser(
    params: github.UsersListGpgKeysForUserParams
  ): Promise<github.UsersListGpgKeysForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/gpg_keys`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListGpgKeysForUserResponse>()
  }

  /**
 * Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.

  The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository, you would use a `subject_type` value of `repository` and a `subject_id` value of `1300192` (the ID of the `Spoon-Knife` repository).

OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
 */
  @aiFunction({
    name: 'users_get_context_for_user',
    description: `Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.

  The \`subject_type\` and \`subject_id\` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about \`octocat\` who owns the \`Spoon-Knife\` repository, you would use a \`subject_type\` value of \`repository\` and a \`subject_id\` value of \`1300192\` (the ID of the \`Spoon-Knife\` repository).

OAuth app tokens and personal access tokens (classic) need the \`repo\` scope to use this endpoint.`,
    inputSchema: github.UsersGetContextForUserParamsSchema
  })
  async usersGetContextForUser(
    params: github.UsersGetContextForUserParams
  ): Promise<github.UsersGetContextForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/hovercard`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'subject_type', 'subject_id')
        )
      })
      .json<github.UsersGetContextForUserResponse>()
  }

  /**
 * Enables an authenticated GitHub App to find the users installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
 */
  @aiFunction({
    name: 'apps_get_user_installation',
    description: `Enables an authenticated GitHub App to find the users installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.`,
    inputSchema: github.AppsGetUserInstallationParamsSchema
  })
  async appsGetUserInstallation(
    params: github.AppsGetUserInstallationParams
  ): Promise<github.AppsGetUserInstallationResponse> {
    return this.ky
      .get(`/users/${params.username}/installation`)
      .json<github.AppsGetUserInstallationResponse>()
  }

  /**
   * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
   */
  @aiFunction({
    name: 'users_list_public_keys_for_user',
    description: `Lists the _verified_ public SSH keys for a user. This is accessible by anyone.`,
    inputSchema: github.UsersListPublicKeysForUserParamsSchema
  })
  async usersListPublicKeysForUser(
    params: github.UsersListPublicKeysForUserParams
  ): Promise<github.UsersListPublicKeysForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/keys`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListPublicKeysForUserResponse>()
  }

  /**
 * List [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.

This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/orgs/orgs#list-organizations-for-the-authenticated-user) API instead.
 */
  @aiFunction({
    name: 'orgs_list_for_user',
    description: `List [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.

This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/orgs/orgs#list-organizations-for-the-authenticated-user) API instead.`,
    inputSchema: github.OrgsListForUserParamsSchema
  })
  async orgsListForUser(
    params: github.OrgsListForUserParams
  ): Promise<github.OrgsListForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/orgs`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.OrgsListForUserResponse>()
  }

  /**
 * Lists all packages in a user's namespace for which the requesting user has access.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_list_packages_for_user',
    description: `Lists all packages in a user's namespace for which the requesting user has access.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesListPackagesForUserParamsSchema
  })
  async packagesListPackagesForUser(
    params: github.PackagesListPackagesForUserParams
  ): Promise<github.PackagesListPackagesForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/packages`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'package_type', 'visibility', 'page', 'per_page')
        )
      })
      .json<github.PackagesListPackagesForUserResponse>()
  }

  /**
 * Gets a specific package metadata for a public package owned by a user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_for_user',
    description: `Gets a specific package metadata for a public package owned by a user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesGetPackageForUserParamsSchema
  })
  async packagesGetPackageForUser(
    params: github.PackagesGetPackageForUserParams
  ): Promise<github.PackagesGetPackageForUserResponse> {
    return this.ky
      .get(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesGetPackageForUserResponse>()
  }

  /**
 * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_for_user',
    description: `Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesDeletePackageForUserParamsSchema
  })
  async packagesDeletePackageForUser(
    params: github.PackagesDeletePackageForUserParams
  ): Promise<github.PackagesDeletePackageForUserResponse> {
    return this.ky
      .delete(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}`,
        {}
      )
      .json<github.PackagesDeletePackageForUserResponse>()
  }

  /**
 * Restores an entire package for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_for_user',
    description: `Restores an entire package for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesRestorePackageForUserParamsSchema
  })
  async packagesRestorePackageForUser(
    params: github.PackagesRestorePackageForUserParams
  ): Promise<github.PackagesRestorePackageForUserResponse> {
    return this.ky
      .post(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}/restore`,
        {
          searchParams: sanitizeSearchParams(pick(params, 'token'))
        }
      )
      .json<github.PackagesRestorePackageForUserResponse>()
  }

  /**
 * Lists package versions for a public package owned by a specified user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_all_package_versions_for_package_owned_by_user',
    description: `Lists package versions for a public package owned by a specified user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema:
      github.PackagesGetAllPackageVersionsForPackageOwnedByUserParamsSchema
  })
  async packagesGetAllPackageVersionsForPackageOwnedByUser(
    params: github.PackagesGetAllPackageVersionsForPackageOwnedByUserParams
  ): Promise<github.PackagesGetAllPackageVersionsForPackageOwnedByUserResponse> {
    return this.ky
      .get(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}/versions`,
        {}
      )
      .json<github.PackagesGetAllPackageVersionsForPackageOwnedByUserResponse>()
  }

  /**
 * Gets a specific package version for a public package owned by a specified user.

OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_get_package_version_for_user',
    description: `Gets a specific package version for a public package owned by a specified user.

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` scope to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesGetPackageVersionForUserParamsSchema
  })
  async packagesGetPackageVersionForUser(
    params: github.PackagesGetPackageVersionForUserParams
  ): Promise<github.PackagesGetPackageVersionForUserResponse> {
    return this.ky
      .get(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesGetPackageVersionForUserResponse>()
  }

  /**
 * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_delete_package_version_for_user',
    description: `Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`delete:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesDeletePackageVersionForUserParamsSchema
  })
  async packagesDeletePackageVersionForUser(
    params: github.PackagesDeletePackageVersionForUserParams
  ): Promise<github.PackagesDeletePackageVersionForUserResponse> {
    return this.ky
      .delete(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}`,
        {}
      )
      .json<github.PackagesDeletePackageVersionForUserResponse>()
  }

  /**
 * Restores a specific package version for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
 */
  @aiFunction({
    name: 'packages_restore_package_version_for_user',
    description: `Restores a specific package version for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

If the \`package_type\` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."

OAuth app tokens and personal access tokens (classic) need the \`read:packages\` and \`write:packages\` scopes to use this endpoint. For more information, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".`,
    inputSchema: github.PackagesRestorePackageVersionForUserParamsSchema
  })
  async packagesRestorePackageVersionForUser(
    params: github.PackagesRestorePackageVersionForUserParams
  ): Promise<github.PackagesRestorePackageVersionForUserResponse> {
    return this.ky
      .post(
        `/users/${params.username}/packages/${params.package_type}/${params.package_name}/versions/${params.package_version_id}/restore`,
        {}
      )
      .json<github.PackagesRestorePackageVersionForUserResponse>()
  }

  /**
 * > [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
 */
  @aiFunction({
    name: 'projects_list_for_user',
    description: `> [!WARNING]
> **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience.
> See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.`,
    inputSchema: github.ProjectsListForUserParamsSchema
  })
  async projectsListForUser(
    params: github.ProjectsListForUserParams
  ): Promise<github.ProjectsListForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/projects`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'state', 'per_page', 'page')
        )
      })
      .json<github.ProjectsListForUserResponse>()
  }

  /**
 * These are events that you've received by watching repositories and following users. If you are authenticated as the
given user, you will see private events. Otherwise, you'll only see public events.

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_received_events_for_user',
    description: `These are events that you've received by watching repositories and following users. If you are authenticated as the
given user, you will see private events. Otherwise, you'll only see public events.

> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListReceivedEventsForUserParamsSchema
  })
  async activityListReceivedEventsForUser(
    params: github.ActivityListReceivedEventsForUserParams
  ): Promise<github.ActivityListReceivedEventsForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/received_events`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListReceivedEventsForUserResponse>()
  }

  /**
 * > [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
 */
  @aiFunction({
    name: 'activity_list_received_public_events_for_user',
    description: `> [!NOTE]
> This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.`,
    inputSchema: github.ActivityListReceivedPublicEventsForUserParamsSchema
  })
  async activityListReceivedPublicEventsForUser(
    params: github.ActivityListReceivedPublicEventsForUserParams
  ): Promise<github.ActivityListReceivedPublicEventsForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/received_events/public`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListReceivedPublicEventsForUserResponse>()
  }

  /**
   * Lists public repositories for the specified user.
   */
  @aiFunction({
    name: 'repos_list_for_user',
    description: `Lists public repositories for the specified user.`,
    inputSchema: github.ReposListForUserParamsSchema
  })
  async reposListForUser(
    params: github.ReposListForUserParams
  ): Promise<github.ReposListForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/repos`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'type', 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.ReposListForUserResponse>()
  }

  /**
 * Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_github_actions_billing_user',
    description: `Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    inputSchema: github.BillingGetGithubActionsBillingUserParamsSchema
  })
  async billingGetGithubActionsBillingUser(
    params: github.BillingGetGithubActionsBillingUserParams
  ): Promise<github.BillingGetGithubActionsBillingUserResponse> {
    return this.ky
      .get(`/users/${params.username}/settings/billing/actions`)
      .json<github.BillingGetGithubActionsBillingUserResponse>()
  }

  /**
 * Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_github_packages_billing_user',
    description: `Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    inputSchema: github.BillingGetGithubPackagesBillingUserParamsSchema
  })
  async billingGetGithubPackagesBillingUser(
    params: github.BillingGetGithubPackagesBillingUserParams
  ): Promise<github.BillingGetGithubPackagesBillingUserResponse> {
    return this.ky
      .get(`/users/${params.username}/settings/billing/packages`)
      .json<github.BillingGetGithubPackagesBillingUserResponse>()
  }

  /**
 * Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
 */
  @aiFunction({
    name: 'billing_get_shared_storage_billing_user',
    description: `Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

OAuth app tokens and personal access tokens (classic) need the \`user\` scope to use this endpoint.`,
    inputSchema: github.BillingGetSharedStorageBillingUserParamsSchema
  })
  async billingGetSharedStorageBillingUser(
    params: github.BillingGetSharedStorageBillingUserParams
  ): Promise<github.BillingGetSharedStorageBillingUserResponse> {
    return this.ky
      .get(`/users/${params.username}/settings/billing/shared-storage`)
      .json<github.BillingGetSharedStorageBillingUserResponse>()
  }

  /**
   * Lists social media accounts for a user. This endpoint is accessible by anyone.
   */
  @aiFunction({
    name: 'users_list_social_accounts_for_user',
    description: `Lists social media accounts for a user. This endpoint is accessible by anyone.`,
    inputSchema: github.UsersListSocialAccountsForUserParamsSchema
  })
  async usersListSocialAccountsForUser(
    params: github.UsersListSocialAccountsForUserParams
  ): Promise<github.UsersListSocialAccountsForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/social_accounts`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListSocialAccountsForUserResponse>()
  }

  /**
   * Lists the SSH signing keys for a user. This operation is accessible by anyone.
   */
  @aiFunction({
    name: 'users_list_ssh_signing_keys_for_user',
    description: `Lists the SSH signing keys for a user. This operation is accessible by anyone.`,
    inputSchema: github.UsersListSshSigningKeysForUserParamsSchema
  })
  async usersListSshSigningKeysForUser(
    params: github.UsersListSshSigningKeysForUserParams
  ): Promise<github.UsersListSshSigningKeysForUserResponse> {
    return this.ky
      .get(`/users/${params.username}/ssh_signing_keys`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.UsersListSshSigningKeysForUserResponse>()
  }

  /**
 * Lists repositories a user has starred.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
 */
  @aiFunction({
    name: 'activity_list_repos_starred_by_user',
    description: `Lists repositories a user has starred.

This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."

- **\`application/vnd.github.star+json\`**: Includes a timestamp of when the star was created.`,
    inputSchema: github.ActivityListReposStarredByUserParamsSchema
  })
  async activityListReposStarredByUser(
    params: github.ActivityListReposStarredByUserParams
  ): Promise<github.ActivityListReposStarredByUserResponse> {
    return this.ky
      .get(`/users/${params.username}/starred`, {
        searchParams: sanitizeSearchParams(
          pick(params, 'sort', 'direction', 'per_page', 'page')
        )
      })
      .json<github.ActivityListReposStarredByUserResponse>()
  }

  /**
   * Lists repositories a user is watching.
   */
  @aiFunction({
    name: 'activity_list_repos_watched_by_user',
    description: `Lists repositories a user is watching.`,
    inputSchema: github.ActivityListReposWatchedByUserParamsSchema
  })
  async activityListReposWatchedByUser(
    params: github.ActivityListReposWatchedByUserParams
  ): Promise<github.ActivityListReposWatchedByUserResponse> {
    return this.ky
      .get(`/users/${params.username}/subscriptions`, {
        searchParams: sanitizeSearchParams(pick(params, 'per_page', 'page'))
      })
      .json<github.ActivityListReposWatchedByUserResponse>()
  }

  /**
   * Get all supported GitHub API versions.
   */
  @aiFunction({
    name: 'meta_get_all_versions',
    description: `Get all supported GitHub API versions.`,
    inputSchema: github.MetaGetAllVersionsParamsSchema
  })
  async metaGetAllVersions(
    _params: github.MetaGetAllVersionsParams
  ): Promise<github.MetaGetAllVersionsResponse> {
    return this.ky.get('/versions').json<github.MetaGetAllVersionsResponse>()
  }

  /**
   * Get a random sentence from the Zen of GitHub.
   */
  @aiFunction({
    name: 'meta_get_zen',
    description: `Get a random sentence from the Zen of GitHub.`,
    inputSchema: github.MetaGetZenParamsSchema
  })
  async metaGetZen(
    _params: github.MetaGetZenParams
  ): Promise<github.MetaGetZenResponse> {
    return this.ky.get('/zen').json<github.MetaGetZenResponse>()
  }
}
